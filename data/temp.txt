

#version 330

uniform sampler3D Texture0; // pal fbo
uniform sampler2D Texture1; // hmFBO
uniform sampler2D Texture2; // cityFBO;
uniform sampler2D Texture3; // hmFBOLinear
//varying vec2 TexCoord0;

uniform vec4 blitCoords;
uniform float curTime;
uniform float cameraZoom;
//uniform float mapTrans;

uniform vec4 mapFreqs;
uniform vec4 mapAmps;

uniform float seaLevel;
uniform vec3 cameraPos;
uniform vec3 lookAtVec;
uniform vec2 bufferDim;
uniform vec2 mapDimInPixels;

uniform float mapPitch;
uniform float heightMapMaxInCells;
uniform vec3 worldSizeInCells;


const float TEX_NULL=0.0/255.0;
const float TEX_DEBUG=1.0/255.0;
const float TEX_UNUSED=2.0/255.0;
const float TEX_SAND=3.0/255.0;
const float TEX_STONE=4.0/255.0;
const float TEX_SNOW=5.0/255.0;
const float TEX_GRASS=6.0/255.0;
const float TEX_MORTAR=7.0/255.0;
const float TEX_WOOD=8.0/255.0;
const float TEX_BRICK=9.0/255.0;
const float TEX_SHINGLE=10.0/255.0;
const float TEX_PLASTER=11.0/255.0;
const float TEX_EARTH=12.0/255.0;
const float TEX_BARK=13.0/255.0;
const float TEX_TREEWOOD=14.0/255.0;
const float TEX_LEAF=15.0/255.0;
const float TEX_GOLD=16.0/255.0;
const float TEX_WATER=17.0/255.0;
const float TEX_METAL=18.0/255.0;
const float TEX_GLASS=19.0/255.0;
const float TEX_MAPLAND=20.0/255.0;
const float TEX_MAPWATER=21.0/255.0;
const float TEX_SKY=22.0/255.0;
const float TEX_SKIN=23.0/255.0;
const float TEX_LEATHER=24.0/255.0;
const float TEX_EXPLOSION=25.0/255.0;







in vec4 TexCoord0;
layout(location = 0) out vec4 FragColor0;

/*

vec3 COLOR_MASKS[16] = vec3[](
    vec3(  1.0,  0.0,  0.0  ),
    vec3(  1.0,  1.0,  0.0  ),
    vec3(  0.0,  1.0,  0.0  ),
    vec3(  0.0,  1.0,  1.0  ),
    vec3(  0.0,  0.0,  1.0  ),
    vec3(  1.0,  0.0,  1.0  ),

    vec3(  0.7,  0.0,  0.0  ),
    vec3(  0.7,  0.7,  0.0  ),
    vec3(  0.0,  0.7,  0.0  ),
    vec3(  0.0,  0.7,  0.7  ),
    vec3(  0.0,  0.0,  0.7  ),
    vec3(  0.7,  0.0,  0.7  ),
   
    vec3(  0.3,  0.0,  0.0  ),
    vec3(  0.3,  0.3,  0.0  ),
    vec3(  0.0,  0.3,  0.0  ),
    vec3(  0.0,  0.3,  0.3  )

);
*/

int intMod(int lhs, int rhs) {
    return lhs - ( (lhs/rhs)*rhs );
}

float getGrid(int val, vec2 gridVecBase, float thickness) {

    int testVal = val;

    int hasDown = testVal / 8;
    testVal -= hasDown * 8;
    
    int hasUp = testVal / 4;
    testVal -= hasUp*4;
    
    int hasRight = testVal/2;
    testVal -= hasRight*2;

    int hasLeft = testVal;

    float maxT = 1.0-thickness;
    float minT = thickness;

    return float(
        ( (gridVecBase.x >= maxT) && (hasLeft > 0) ) ||
        ( (gridVecBase.x <= minT) && (hasRight > 0)  ) ||
        ( (gridVecBase.y >= maxT) && (hasUp > 0)  ) ||
        ( (gridVecBase.y <= minT) && (hasDown > 0) )
    );
}

// Tricubic interpolated texture lookup, using unnormalized coordinates.
// Fast implementation, using 8 trilinear lookups.
// uniform vec3 nrOfVoxels;

// todo: add license:
// https://github.com/DannyRuijters/CubicInterpolationCUDA/blob/master/examples/glCubicRayCast/tricubic.shader

vec4 tricubic(sampler3D mySampler, vec3 coord, vec3 nrOfVoxels)
{
		// shift the coordinate from [0,1] to [-0.5, nrOfVoxels-0.5]
		//vec3 nrOfVoxels = vec3(textureSize3D(tex, 0));
		vec3 coord_grid = coord * nrOfVoxels - 0.5;
		vec3 index = floor(coord_grid);
		vec3 fraction = coord_grid - index;
		vec3 one_frac = 1.0 - fraction;

		vec3 w0 = 1.0/6.0 * one_frac*one_frac*one_frac;
		vec3 w1 = 2.0/3.0 - 0.5 * fraction*fraction*(2.0-fraction);
		vec3 w2 = 2.0/3.0 - 0.5 * one_frac*one_frac*(2.0-one_frac);
		vec3 w3 = 1.0/6.0 * fraction*fraction*fraction;

		vec3 g0 = w0 + w1;
		vec3 g1 = w2 + w3;
		vec3 mult = 1.0 / nrOfVoxels;
		vec3 h0 = mult * ((w1 / g0) - 0.5 + index);  //h0 = w1/g0 - 1, move from [-0.5, nrOfVoxels-0.5] to [0,1]
		vec3 h1 = mult * ((w3 / g1) + 1.5 + index);  //h1 = w3/g1 + 1, move from [-0.5, nrOfVoxels-0.5] to [0,1]

		// fetch the eight linear interpolations
		// weighting and fetching is interleaved for performance and stability reasons
		vec4 tex000 = texture(mySampler, h0);
		vec4 tex100 = texture(mySampler, vec3(h1.x, h0.y, h0.z));
		tex000 = mix(tex100, tex000, g0.x);  //weigh along the x-direction
		vec4 tex010 = texture(mySampler, vec3(h0.x, h1.y, h0.z));
		vec4 tex110 = texture(mySampler, vec3(h1.x, h1.y, h0.z));
		tex010 = mix(tex110, tex010, g0.x);  //weigh along the x-direction
		tex000 = mix(tex010, tex000, g0.y);  //weigh along the y-direction
		vec4 tex001 = texture(mySampler, vec3(h0.x, h0.y, h1.z));
		vec4 tex101 = texture(mySampler, vec3(h1.x, h0.y, h1.z));
		tex001 = mix(tex101, tex001, g0.x);  //weigh along the x-direction
		vec4 tex011 = texture(mySampler, vec3(h0.x, h1.y, h1.z));
		vec4 tex111 = texture(mySampler, h1);
		tex011 = mix(tex111, tex011, g0.x);  //weigh along the x-direction
		tex001 = mix(tex011, tex001, g0.y);  //weigh along the y-direction

		return mix(tex001, tex000, g0.z);  //weigh along the z-direction
};

vec4 cubic(float v)
{
		vec4 n = vec4(1.0, 2.0, 3.0, 4.0) - v;
		vec4 s = n * n * n;
		vec4 res;
		res.x = s.x;
		res.y = s.y - 4.0 * s.x;
		res.z = s.z - 4.0 * s.y + 6.0 * s.x;
		res.w = 6.0 - res.x - res.y - res.z;
		return res;
}

// vec4 bilin(sampler2D mySampler, vec2 texcoord, vec2 texscale) {
// 	return texture(mySampler,texcoord);
// }


// from CodeProject.com
// float CatMullRom( float x )
// {
//     const float B = 0.0;
//     const float C = 0.5;
//     float f = x;
//     if( f < 0.0 )
//     {
//         f = -f;
//     }
//     if( f < 1.0 )
//     {
//         return ( ( 12 - 9 * B - 6 * C ) * ( f * f * f ) +
//             ( -18 + 12 * B + 6 *C ) * ( f * f ) +
//             ( 6 - 2 * B ) ) / 6.0;
//     }
//     else if( f >= 1.0 && f < 2.0 )
//     {
//         return ( ( -B - 6 * C ) * ( f * f * f )
//             + ( 6 * B + 30 * C ) * ( f *f ) +
//             ( - ( 12 * B ) - 48 * C  ) * f +
//             8 * B + 24 * C)/ 6.0;
//     }
//     else
//     {
//         return 0.0;
//     }
// } 

vec4 bilin(in sampler2D t, in vec2 uvIn, in vec2 textureSize, in vec2 texelSize)
{
    vec2 f = fract( uvIn * textureSize );
    vec2 uv = floor(uvIn * textureSize)/textureSize;
    // f.x = CatMullRom(1.0-f.x);
    // f.y = CatMullRom(1.0-f.y);
    
    vec3 newTX = vec3(texelSize.xy,0.0);
    
    //uv += texelSize*0.06;    // <--- precision hack (anything higher breaks it)
    vec4 tl = texture2D(t, uv);
    vec4 tr = texture2D(t, uv + newTX.xz);
    vec4 bl = texture2D(t, uv + newTX.zy);
    vec4 br = texture2D(t, uv + newTX.xy);
    vec4 tA = mix( tl, tr, f.x );
    vec4 tB = mix( bl, br, f.x );
    return mix( tA, tB, f.y );
}

vec4 trilin(in sampler3D t, in vec3 uvIn, in vec3 textureSize, in vec3 texelSize)
{
    vec3 f = fract( uvIn * textureSize );
    vec3 uv = floor(uvIn * textureSize)/textureSize;
    
    // f.x = CatMullRom(1.0-f.x);
    // f.y = CatMullRom(1.0-f.y);
    
    vec4 newTX = vec4(texelSize.xyz,0.0);
    
    //uv += texelSize*0.06;    // <--- precision hack (anything higher breaks it)
    vec4 tl = texture(t, uv + newTX.www);
    vec4 tr = texture(t, uv + newTX.xww);
    vec4 bl = texture(t, uv + newTX.wyw);
    vec4 br = texture(t, uv + newTX.xyw);
    vec4 tA = mix( tl, tr, f.x );
    vec4 tB = mix( bl, br, f.x );
    vec4 tC = mix( tA, tB, f.y );
    
    tl = texture(t, uv + newTX.wwz);
    tr = texture(t, uv + newTX.xwz);
    bl = texture(t, uv + newTX.wyz);
    br = texture(t, uv + newTX.xyz);
    tA = mix( tl, tr, f.x );
    tB = mix( bl, br, f.x );
    vec4 tC2 = mix( tA, tB, f.y );
    
    return mix(tC,tC2,f.z);
    
}


vec4 bicubic(sampler2D mySampler, vec2 texcoord, vec2 texscale) {
		float fx = fract(texcoord.x);
		float fy = fract(texcoord.y);
		texcoord.x -= fx;
		texcoord.y -= fy;

		vec4 xcubic = cubic(fx);
		vec4 ycubic = cubic(fy);

		vec4 c = vec4(texcoord.x - 0.5, texcoord.x + 1.5, texcoord.y - 0.5, texcoord.y + 1.5);
		vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);
		vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;

		vec4 sample0 = texture(mySampler, vec2(offset.x, offset.z) * texscale);
		vec4 sample1 = texture(mySampler, vec2(offset.y, offset.z) * texscale);
		vec4 sample2 = texture(mySampler, vec2(offset.x, offset.w) * texscale);
		vec4 sample3 = texture(mySampler, vec2(offset.y, offset.w) * texscale);

		float sx = s.x / (s.x + s.y);
		float sy = s.z / (s.z + s.w);

		return mix(
				mix(sample3, sample2, sx),
				mix(sample1, sample0, sx), sy
		);
}

vec4 getTexCubic(sampler3D mySampler, vec3 pos, float vs) {
	return tricubic(mySampler,(pos)/vs, vec3(vs) );
}

vec4 getTexLin(sampler3D mySampler, vec3 pos, float vs) {
	return texture(mySampler, (pos)/vs );
}



vec2 getTerHeight(sampler2D mySampler, vec2 newTC, float zval) { // , float camDis

	

	vec2 mp = vec2(1.0/mapPitch);
	vec2 mp2 = vec2(mapPitch);
	// vec4 texHM = vec4(
	// 	bicubic(mySampler, newTC.xy*mapFreqs.x*mapPitch, mp).r,
	// 	bicubic(mySampler, newTC.xy*mapFreqs.y*mapPitch, mp).r,
	// 	bicubic(mySampler, newTC.xy*mapFreqs.z*mapPitch, mp).r,
	// 	bicubic(mySampler, newTC.xy*mapFreqs.w*mapPitch, mp).r
	// );

	vec4 texHM = vec4(
		bilin(mySampler, newTC.xy*mapFreqs.x, mp2, mp).r,
		bilin(mySampler, newTC.xy*mapFreqs.y, mp2, mp).r,
		bilin(mySampler, newTC.xy*mapFreqs.z, mp2, mp).r,
		bilin(mySampler, newTC.xy*mapFreqs.w, mp2, mp).r
	);

	float dotVal = dot(texHM,mapAmps);
	//dotVal = mix(dotVal,min(dotVal,0.6),0.25);
	
	//float dotVal = bilin(mySampler, newTC.xy, vec2(mapPitch), mp).r;
	

	return vec2(zval-(dotVal*heightMapMaxInCells),dotVal); //-128.0*(1.0-camDis)
}





vec2 opRotate( vec2 p, float theta )
{
    mat2 m = mat2(
        cos(theta),
        -sin(theta),
        sin(theta),
        cos(theta)
    );
    
    return m*p;
}

void main() {

    float newTime = curTime/100.0;

    vec2 camPosZO = cameraPos.xy/worldSizeInCells.xy;

    vec2 tcFlip = TexCoord0.xy;
    tcFlip.y = 1.0-tcFlip.y;

    vec2 baseTC = (tcFlip.xy - 0.5);
    
    
    float M_PI = 3.14159265359;    

    baseTC = opRotate(baseTC,M_PI*0.5+2.0*M_PI-atan(lookAtVec.y,lookAtVec.x));

    vec2 newTC = 
        (baseTC + camPosZO*cameraZoom )/cameraZoom
        
        
        ;//(TexCoord0.xy + camPosZO*cameraZoom - 0.5)/cameraZoom;

    //vec2 newTC = ( (TexCoord0.xy - 0.5)-(camPosZO))/cameraZoom + 0.5;

    vec2 newLA = vec2(0.0,-1.0);//normalize(lookAtVec.xy);

    float posDis2 = distance(vec2(0.0), TexCoord0.xy - 0.5);
    float posDis = posDis2*distance(vec2(0.0) + newLA*0.2, TexCoord0.xy - 0.5);
    
    if (posDis2 > 0.1) {
        posDis = 1.0;
    }
    
    

    vec4 tex1 = texture( Texture1, newTC.xy);
    vec4 tex2 = texture( Texture2, newTC.xy);


    

    float testHeight = getTerHeight(Texture3,newTC,0.0).y;
    float seaHeight = seaLevel;        

    float isAboveWater = float(testHeight > seaHeight);
    vec4 landRes = texture( Texture0, vec3(
            (testHeight-seaHeight)*2.0/(1.0-seaHeight),
            0.0,
            TEX_MAPLAND + 0.5/255.0
        )
    );
    vec4 seaRes = texture( Texture0, vec3(
            testHeight/seaHeight,
            0.0,
            TEX_MAPWATER + 0.5/255.0
        )
    );
    vec4 topoRes = mix(seaRes,landRes,isAboveWater);

    vec4 tex0 = topoRes;
    tex0.a = 1.0;


    float offsetAmount = (1.0)/mapDimInPixels.x;

    vec4 tex1u = texture(Texture1, vec2(newTC.x, newTC.y + offsetAmount) );
    vec4 tex1d = texture(Texture1, vec2(newTC.x, newTC.y - offsetAmount) );
    vec4 tex1l = texture(Texture1, vec2(newTC.x - offsetAmount, newTC.y) );
    vec4 tex1r = texture(Texture1, vec2(newTC.x + offsetAmount, newTC.y) );

    vec4 tex2u = texture(Texture2, vec2(newTC.x, newTC.y + offsetAmount) );
    vec4 tex2d = texture(Texture2, vec2(newTC.x, newTC.y - offsetAmount) );
    vec4 tex2l = texture(Texture2, vec2(newTC.x - offsetAmount, newTC.y) );
    vec4 tex2r = texture(Texture2, vec2(newTC.x + offsetAmount, newTC.y) );

    /*
    vec4 tex1ul = texture(Texture1, vec2(newTC.x - offsetAmount, newTC.y + offsetAmount) );
    vec4 tex1ur = texture(Texture1, vec2(newTC.x + offsetAmount, newTC.y + offsetAmount) );
    vec4 tex1dl = texture(Texture1, vec2(newTC.x - offsetAmount, newTC.y - offsetAmount) );
    vec4 tex1dr = texture(Texture1, vec2(newTC.x + offsetAmount, newTC.y - offsetAmount) );
    */

    float mod1 = 1.0;
    if (
        tex1u.g != tex1.g ||
        tex1d.g != tex1.g ||
        tex1l.g != tex1.g ||
        tex1r.g != tex1.g /*||

        tex1ul.g < tex1.g ||
        tex1ur.g < tex1.g ||
        tex1dl.g < tex1.g ||
        tex1dr.g < tex1.g*/

    ) {
        mod1 = 1.0;
    }


    // float mod2 = 0.0;
    // if (
    //     tex2u.b != tex2.b ||
    //     tex2d.b != tex2.b ||
    //     tex2l.b != tex2.b ||
    //     tex2r.b != tex2.b

    // ) {
    //     mod2 = 0.6;
    // }

    

    //float isBridge = float( abs(testHeight - seaHeight) < 10.0/255.0 );

    vec2 gridVecBase = ( (newTC.xy*mapDimInPixels.xy) - floor(newTC.xy*mapDimInPixels.xy) );
    vec2 gridVec = abs( gridVecBase - 0.5)*2.0;
    float gridTest = float( (gridVec.x >= 0.9) || (gridVec.y >= 0.9) )*0.5;

    
    float gv3 = getGrid( int(tex2.b*255.0), gridVecBase, 0.4 );
    float gv2 = getGrid( int(tex2.r*255.0), gridVecBase, 0.2 ); //stchannel
    float gv1 = getGrid( int(tex2.g*255.0), gridVecBase, 0.1 )*0.5; //btchannel
    
    float gridMod = mix( max(gv1,gv2), 0.0, 1.0-clamp(cameraZoom*0.01,0.0,1.0) );

    vec3 resCol = tex0.rgb;//(tex0.rgb + gridMod)*mod1;

    // resCol = mix(
    //     resCol,
        
    //     mix(
    //         resCol+vec3(0.0,0.125,0.25),
    //         resCol+0.5,//vec3(1.0,1.0,1.0),//vec3(0.3,0.1,0.0),
    //         isAboveWater
    //     ),
        
    //     gv3
    // );

    // if (tex2.a > 0.0) {
    //     resCol.rgb = resCol.rgb*0.75 + (mod(tex2.a*255.0,16.0)/15.0)*0.25;
    // }

    // float othick = 0.01;
    // vec2 fracVal = vec2( fract(newTC.x),fract(newTC.y) );
    // if (
    //     ((fracVal.x >= -othick)&&(fracVal.x <= othick)) ||
    //     ((fracVal.y >= -othick)&&(fracVal.y <= othick))
    // ) {
    //     resCol += 0.2;
    // }

    

    //gl_FragData[0] = vec4(tex0.rgb,mapTrans);

    // + tex2.a * 8.0;
    
    bool mapMod = (posDis < 0.01)&&(posDis2>0.03);
    bool mapMod2 = (posDis < 0.01)&&(posDis2>0.025);
    
    
    //resCol = mix(vec3(0.0,0.0,1.0),vec3(0.0,1.0,0.0),isAboveWater);
    
    if (mapMod) {
        resCol.r += 1.0;
    }
    else {
        if (mapMod2) {
            resCol.rgb += 1.0;
        }
    }
    
    

    FragColor0 = vec4(
    
        
    
        resCol//vec3(testHeight);
        , 1.0 );// + float(tex1.a > 0.0)*0.2;// + tex2.a*0.5;// + float(tex1.r < seaHeight);//*mod;// + vec4( float(clamp(1.0-tex1.b,0.0,1.0) > 0.6) ,0.0,0.0,0.0);//tex0*mod;//1.0-tex1.bbbb;//tex0*mod;//tex0;//1.0-tex1.bbbb;////1.0-tex1.bbbb;//(tex0)*mod; // + colMod

}


