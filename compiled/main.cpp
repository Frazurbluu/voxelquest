
#if !defined(WIN32_LEAN_AND_MEAN)
#define WIN32_LEAN_AND_MEAN
#endif


int RUN_COUNT;

bool ND_TRACE_OFF = false;


#define DEFAULT_BUFLEN 512
#define DEFAULT_PORT "27015"

const static int MAX_LIMB_DATA_IN_BYTES = 65536;


const static bool POLY_COLLISION = false;
const static bool VOXEL_COLLISION = true;

const static bool GEN_DEBRIS = false;
const static int  MAX_DEBRIS = 0;
const static bool GEN_COLLISION = false;
const static bool GEN_POLYS_WORLD = true;

const static bool SINGLE_THREADED = false;
const static bool DO_RANDOMIZE = false;

// no greater than 8 unless shader changed (primIdList[8])
const static int MAX_PRIM_IDS = 16;
const static int MAX_PRIMTEST = 8;

const static int MAX_DEPTH_PEELS = 4;

double STEP_TIME_IN_SEC;

const static float OFFSET_X[4] = {-0.5,0.5,0.5,-0.5};
const static float OFFSET_Y[4] = {-0.5,-0.5,0.5,0.5};

const static int MAX_SPLASHES = 8;
const static int MAX_EXPLODES = 8;

//const static bool DO_CONNECT = true;
const static bool DO_SHADER_DUMP = false;
bool EDIT_POSE = false;

// warning: changing this changes the size of saved poses
// should be a one time change, then revereted to 1.0 after save
const static float ORG_SCALE_DELTA = 1.0f;

// base scale applied to base org generation
// only change this after changing ORG_SCALE_DELTA from 1.0
const static float ORG_SCALE_BASE = 0.5f;





// const static int DEF_WIN_W = 1440;
// const static int DEF_WIN_H = 720;


//#define STREAM_RES 1

#ifdef STREAM_RES
	const static int DEF_WIN_W = 1920; //2048;//
	const static int DEF_WIN_H = 1080; //1024;//
#else
	const static int DEF_WIN_W = 1440;//1536;
	const static int DEF_WIN_H = 720;//768;
#endif



const static int DEF_SCALE_FACTOR = 8;
const static int RENDER_SCALE_FACTOR = 1;
const static float SPHEREMAP_SCALE_FACTOR = 0.5f; // lower is faster

const static int DEF_VOL_SIZE = 128;

const static bool USE_SPHERE_MAP = false;

const static float TIME_DELTA = 1.0f/60.0f;

const static int THREAD_DATA_COUNT = 16;

const static float MASS_PER_LIMB = 0.1f;

// #define DEBUG_BOUNDS 1

const static float explodeRad = 5.0f;

float RAND_COUNTER = 25.0f;
float RAND_COUNTER2 = 25.0f;


const static int GROUP_ID_NONEXISTENT = -3;
const static int GROUP_ID_UNMARKED = -2;
const static int GROUP_ID_UNMARKED_IDEAL = -1;

const static int FLUID_UNIT_MIN = -1;
const static int FLUID_UNIT_MAX = 16384;

const static int MAX_LAYERS = 2;
const static int MAX_MIP_LEV = 1; // min of 1

const static bool DO_POINTS = true;


const static int MAX_KEYS = 256;

//const static int NUM_PRIM_LAYERS = 1;

const static int MAX_LIGHTS = 24;
const static int MAX_EVAL_LIGHTS = 128;
const static int FLOATS_PER_LIGHT = 12;



const static float UI_SCALE_FACTOR = 1.0f;

const static int MAX_PLANT_GEN = 16;

const static int MAX_TER_TEX = 9;

const static bool RT_TRANSFORM = false;



const static int MAX_NODE_DIRS = 6;
const static int MAX_NODE_VALS = 4;
const static int TOT_NODE_VALS =
	MAX_NODE_DIRS * MAX_NODE_VALS;

const static int TOT_MAP_DIRS = 4;

const static int MAX_BLOCK_STACK = 10;
const static int MAX_UI_LAYERS = 4;

// solid, water, air
const static float CUBE_POINTS[42] = {
		0,0,0,
		1,0,1,
		0,0,1,
		0,1,1,
		0,1,0,
		1,1,0,
		1,0,0,
		
		
		1,1,1,
		1,0,0,
		1,1,0,
		0,1,0,
		0,1,1,
		0,0,1,
		1,0,1
		
		
		
};




// solid, water, air
const static bool PROC_MATRIX[3][3] = {
		{false, true, true},
		{false, false, true},
		{false, false, false}
};

bool TEMP_DEBUG;

const static int MAX_OBJ_TYPES = 1673;
const static int ITEMS_PER_COL = 48;
const static int ITEMS_PER_ROW = 36;
const static int MAX_ICON_ID = ITEMS_PER_COL*ITEMS_PER_ROW;
const static int EMPTY_OBJECT_TYPE = 1672;
const static int EMPTY_OBJECT_ID = 1;

enum E_DIR_SPECS_SIGN {
	E_DIR_XP,
	E_DIR_XM,
	E_DIR_YP,
	E_DIR_YM,
	E_DIR_ZP,
	E_DIR_ZM,
	E_DIR_MP_LENGTH
};


const static int NUM_ORIENTATIONS = 6;
const static float DIR_VECS[NUM_ORIENTATIONS][3] = {
	{1.0f, 0.0f, 0.0f},
	{-1.0f, 0.0f, 0.0f},
	{0.0f, 1.0f, 0.0f},
	{0.0f, -1.0f, 0.0f},
	{0.0f, 0.0f, 1.0f},
	{0.0f, 0.0f, -1.0f}
};
const static int DIR_VECS_I[NUM_ORIENTATIONS][3] = {
	{1, 0, 0},
	{-1, 0, 0},
	{0, 1, 0},
	{0, -1, 0},
	{0, 0, 1},
	{0, 0, -1}
};


const static int NUM_PLANAR_ORIENTATIONS = 4;
const static int BASE_MOVEABLE_Z = 2;
const static int MAX_MOVEABLE_Z = BASE_MOVEABLE_Z*2 + 1;
const static int NUM_MOVEABLE_DIRS_ONE_AWAY = NUM_PLANAR_ORIENTATIONS*3;

const static int NUM_MOVEABLE_DIRS = MAX_MOVEABLE_Z*NUM_PLANAR_ORIENTATIONS;// 12 20 24
const static int DIR_VECS_MOVE[NUM_MOVEABLE_DIRS][3] = {
	
	{ 1,  0,  -2},
	{-1,  0,  -2},
	{ 0,  1,  -2},
	{ 0, -1,  -2},
	
	{ 1,  0, -1},
	{-1,  0, -1},
	{ 0,  1, -1},
	{ 0, -1, -1},
	
	
	{ 1,  0,  0},
	{-1,  0,  0},
	{ 0,  1,  0},
	{ 0, -1,  0},
	
	
	
	
	{ 1,  0,  1},
	{-1,  0,  1},
	{ 0,  1,  1},
	{ 0, -1,  1},
		
	{ 1,  0,  2},
	{-1,  0,  2},
	{ 0,  1,  2},
	{ 0, -1,  2}
	
	
	
	
	
	// ,
	// { 1,  0,  -3},
	// {-1,  0,  -3},
	// { 0,  1,  -3},
	// { 0, -1,  -3},
	
	// { 1,  0,  3},
	// {-1,  0,  3},
	// { 0,  1,  3},
	// { 0, -1,  3}
	
	
	
	// ,{ 1,  1,  1},
	// { 1, -1,  1},
	// {-1,  1,  1},
	// {-1, -1,  1},
	
	// { 1,  1,  0},
	// { 1, -1,  0},
	// {-1,  1,  0},
	// {-1, -1,  0},
	
	// { 1,  1, -1},
	// { 1, -1, -1},
	// {-1,  1, -1},
	// {-1, -1, -1}
	
	
};


float ALL_ROT[16*NUM_ORIENTATIONS*NUM_ORIENTATIONS*NUM_ORIENTATIONS];
const static int ROT_MAP[36] = {
	
	// x, inc theta
	//-------------
	E_DIR_XP,// x+ -> x+
	E_DIR_XM,// x- -> x-
	E_DIR_ZP,// y+ -> z+
	E_DIR_ZM,// y- -> z-
	E_DIR_YM,// z+ -> y-
	E_DIR_YP,// z- -> y+
	
	// x, dec theta
	//-------------
	E_DIR_XP,// x+ -> x+
	E_DIR_XM,// x- -> x-
	E_DIR_ZM,// y+ -> z-
	E_DIR_ZP,// y- -> z+
	E_DIR_YP,// z+ -> y+
	E_DIR_YM,// z- -> y-
	
	// y, inc theta
	//-------------
	E_DIR_ZP,// x+ -> z+
	E_DIR_ZM,// x- -> z-
	E_DIR_YP,// y+ -> y+
	E_DIR_YM,// y- -> y-
	E_DIR_XM,// z+ -> x-
	E_DIR_XP,// z- -> x+
	
	// y, dec theta
	//-------------
	E_DIR_ZM,// x+ -> z-
	E_DIR_ZP,// x- -> z+
	E_DIR_YP,// y+ -> y+
	E_DIR_YM,// y- -> y-
	E_DIR_XP,// z+ -> x+
	E_DIR_XM,// z- -> x-
	
	// z, inc theta
	//-------------
	E_DIR_YP,// x+ -> y+
	E_DIR_YM,// x- -> y-
	E_DIR_XM,// y+ -> x-
	E_DIR_XP,// y- -> x+
	E_DIR_ZP,// z+ -> z+
	E_DIR_ZM,// z- -> z-
	
	// z, dec theta
	//-------------
	E_DIR_YM,// x+ -> y-
	E_DIR_YP,// x- -> y+
	E_DIR_XP,// y+ -> x+
	E_DIR_XM,// y- -> x-
	E_DIR_ZP,// z+ -> z+
	E_DIR_ZM// z- -> z-
	
};

int totalPointCount;


bool LAST_COMPILE_ERROR = false;

char *BUF_NAMES[] =
{
	"ublock0",
	"ublock1",
	"ublock2",
	"ublock3",
	"ublock4",
	"ublock5",
	"ublock6",
	"ublock7",
	"ublock8",
	"ublock9",
	"ublock10",
	"ublock11",
	"ublock12",
	"ublock13"
};

const static int R_CHANNEL = 0;
const static int G_CHANNEL = 1;
const static int B_CHANNEL = 2;
const static int A_CHANNEL = 3;

const static int MAX_VG_FBOS = 2;
int CUR_VG_FBO = 0;

const static int MAX_VGT_FBOS = 2;
int CUR_VGT_FBO = 0;

const static float M_PI = 3.14159265359;

const static float TBDIR_ARR[] = {
	0.0f,
	M_PI*0.5f,
	M_PI,
	M_PI*1.5f
};


int PAGE_COUNT = 0;
// set to 0 to disable
int MAX_HOLDERS = 2048;


float MAX_GPU_MEM = 2560.0f;
float TOT_GPU_MEM_USAGE = 0.0f;

float MAX_CPU_MEM = 4096.0f;
float TOT_CPU_MEM_USAGE = 0.0f;

long long ENT_COUNTER = 0;

bool TRACE_ON = false;
//#define DEBUG_MODE 1







#include <SDKDDKVer.h>


#include <cmath>
#include <fstream>
#include <sstream>
#include <stdexcept>
#include <string>
#include <cstring>
#include <vector>
#include <deque>
#include <list>
#include <cstddef>
#include <cassert>
#include <cstdarg>
#include <cstdio>
#include <iostream>
#include <ios>
#include <algorithm>
#include <cstdlib>
#include <thread>
#include <mutex>
//#include <atomic>

#include <iomanip>
#include <map>
//#include <ctime>


#include <stdlib.h>
#include <math.h>
#include <tchar.h>
#include <fcntl.h>
#include <stdio.h>
#include <assert.h>
#include <io.h>
#include <conio.h>

#include <SFML/Audio/SoundBuffer.hpp>
#include <SFML/Audio/Sound.hpp>
#include <SFML/Audio/Music.hpp>

#include <gl/glew.h>
#include <gl/gl.h>
#include <gl/glu.h>
#include <gl/freeglut.h>
#pragma comment(lib, "glew32.lib")










// note - check deprecated source folder
// make sure to put it back in source
// if using poco or web services

// #ifdef USE_POCO

// #include "Poco/Net/HTTPServer.h"
// #include "Poco/Net/HTTPRequestHandler.h"
// #include "Poco/Net/HTTPRequestHandlerFactory.h"
// #include "Poco/Net/HTTPServerParams.h"
// #include "Poco/Net/HTTPServerRequest.h"
// #include "Poco/Net/HTTPServerResponse.h"
// #include "Poco/Net/HTTPServerParams.h"
// #include "Poco/Net/ServerSocket.h"
// #include "Poco/Net/WebSocket.h"
// #include "Poco/Net/NetException.h"
// #include "Poco/Util/ServerApplication.h"
// #include "Poco/Util/Option.h"
// #include "Poco/Util/OptionSet.h"
// #include "Poco/Util/HelpFormatter.h"
// #include "Poco/Format.h"
// #include "Poco/Runnable.h"
// #include "Poco/ThreadPool.h"





// using Poco::Net::ServerSocket;
// using Poco::Net::WebSocket;
// using Poco::Net::WebSocketException;
// using Poco::SystemException;
// using Poco::Net::HTTPRequestHandler;
// using Poco::Net::HTTPRequestHandlerFactory;
// using Poco::Net::HTTPServer;
// using Poco::Net::HTTPServerRequest;
// using Poco::Net::HTTPResponse;
// using Poco::Net::HTTPServerResponse;
// using Poco::Net::HTTPServerParams;
// using Poco::Timestamp;
// using Poco::Runnable;
// using Poco::ThreadPool;
// using Poco::Util::ServerApplication;
// using Poco::Util::Application;
// using Poco::Util::Option;
// using Poco::Util::OptionSet;
// using Poco::Util::HelpFormatter;



// #endif

//#include "Poco/Base64Decoder.h"
//using Poco::Base64Decoder;






class HPClock
{
public:
	HPClock();

	HPClock(const HPClock& other);
	HPClock& operator=(const HPClock& other);

	~HPClock();

	/// Resets the initial reference time.
	void reset();

	/// Returns the time in ms since the last call to reset or since 
	/// the HPClock was created.
	unsigned long int getTimeMilliseconds();

	/// Returns the time in us since the last call to reset or since 
	/// the Clock was created.
	unsigned long int getTimeMicroseconds();
private:
	struct HPClockData* m_data;
};



template <class T>
const T& HPClockMin(const T& a, const T& b) 
{
  return a < b ? a : b ;
}


#ifdef __CELLOS_LV2__
#include <sys/sys_time.h>
#include <sys/time_util.h>
#include <stdio.h>
#endif

#if defined (SUNOS) || defined (__SUNOS__) 
#include <stdio.h> 
#endif

#if defined(WIN32) || defined(_WIN32)

#define B3_USE_WINDOWS_TIMERS
#define WIN32_LEAN_AND_MEAN
#define NOWINRES
#define NOMCX
#define NOIME 

#ifdef _XBOX
	#include <Xtl.h>
#else //_XBOX
	#include <windows.h>
#endif //_XBOX

#include <time.h>


#else //_WIN32
#include <sys/time.h>
#endif //_WIN32



struct HPClockData
{

#ifdef B3_USE_WINDOWS_TIMERS
	LARGE_INTEGER mClockFrequency;
	DWORD mStartTick;
	LONGLONG mPrevElapsedTime;
	LARGE_INTEGER mStartTime;
#else
#ifdef __CELLOS_LV2__
	uint64_t	mStartTime;
#else
	struct timeval mStartTime;
#endif
#endif //__CELLOS_LV2__

};

///The HPClock is a portable basic clock that measures accurate time in seconds, use for profiling.
HPClock::HPClock()
{
	m_data = new HPClockData;
#ifdef B3_USE_WINDOWS_TIMERS
	QueryPerformanceFrequency(&m_data->mClockFrequency);
#endif
	reset();
}

HPClock::~HPClock()
{
	delete m_data;
}

HPClock::HPClock(const HPClock& other)
{
	m_data = new HPClockData;
	*m_data = *other.m_data;
}

HPClock& HPClock::operator=(const HPClock& other)
{
	*m_data = *other.m_data;
	return *this;
}


	/// Resets the initial reference time.
void HPClock::reset()
{
#ifdef B3_USE_WINDOWS_TIMERS
	QueryPerformanceCounter(&m_data->mStartTime);
	m_data->mStartTick = GetTickCount();
	m_data->mPrevElapsedTime = 0;
#else
#ifdef __CELLOS_LV2__

	typedef uint64_t  ClockSize;
	ClockSize newTime;
	//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
	SYS_TIMEBASE_GET( newTime );
	m_data->mStartTime = newTime;
#else
	gettimeofday(&m_data->mStartTime, 0);
#endif
#endif
}

/// Returns the time in ms since the last call to reset or since 
/// the HPClock was created.
unsigned long int HPClock::getTimeMilliseconds()
{
#ifdef B3_USE_WINDOWS_TIMERS
	LARGE_INTEGER currentTime;
	QueryPerformanceCounter(&currentTime);
	LONGLONG elapsedTime = currentTime.QuadPart - 
		m_data->mStartTime.QuadPart;
		// Compute the number of millisecond ticks elapsed.
	unsigned long msecTicks = (unsigned long)(1000 * elapsedTime / 
		m_data->mClockFrequency.QuadPart);
		// Check for unexpected leaps in the Win32 performance counter.  
	// (This is caused by unexpected data across the PCI to ISA 
		// bridge, aka south bridge.  See Microsoft KB274323.)
		unsigned long elapsedTicks = GetTickCount() - m_data->mStartTick;
		signed long msecOff = (signed long)(msecTicks - elapsedTicks);
		if (msecOff < -100 || msecOff > 100)
		{
			// Adjust the starting time forwards.
			LONGLONG msecAdjustment = HPClockMin(msecOff * 
				m_data->mClockFrequency.QuadPart / 1000, elapsedTime - 
				m_data->mPrevElapsedTime);
			m_data->mStartTime.QuadPart += msecAdjustment;
			elapsedTime -= msecAdjustment;

			// Recompute the number of millisecond ticks elapsed.
			msecTicks = (unsigned long)(1000 * elapsedTime / 
				m_data->mClockFrequency.QuadPart);
		}

		// Store the current elapsed time for adjustments next time.
		m_data->mPrevElapsedTime = elapsedTime;

		return msecTicks;
#else

#ifdef __CELLOS_LV2__
		uint64_t freq=sys_time_get_timebase_frequency();
		double dFreq=((double) freq) / 1000.0;
		typedef uint64_t  ClockSize;
		ClockSize newTime;
		SYS_TIMEBASE_GET( newTime );
		//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");

		return (unsigned long int)((double(newTime-m_data->mStartTime)) / dFreq);
#else

		struct timeval currentTime;
		gettimeofday(&currentTime, 0);
		return (currentTime.tv_sec - m_data->mStartTime.tv_sec) * 1000 + 
			(currentTime.tv_usec - m_data->mStartTime.tv_usec) / 1000;
#endif //__CELLOS_LV2__
#endif
}

	/// Returns the time in us since the last call to reset or since 
	/// the Clock was created.
unsigned long int HPClock::getTimeMicroseconds()
{
#ifdef B3_USE_WINDOWS_TIMERS
		LARGE_INTEGER currentTime;
		QueryPerformanceCounter(&currentTime);
		LONGLONG elapsedTime = currentTime.QuadPart - 
			m_data->mStartTime.QuadPart;

		// Compute the number of millisecond ticks elapsed.
		unsigned long msecTicks = (unsigned long)(1000 * elapsedTime / 
			m_data->mClockFrequency.QuadPart);

		// Check for unexpected leaps in the Win32 performance counter.  
		// (This is caused by unexpected data across the PCI to ISA 
		// bridge, aka south bridge.  See Microsoft KB274323.)
		unsigned long elapsedTicks = GetTickCount() - m_data->mStartTick;
		signed long msecOff = (signed long)(msecTicks - elapsedTicks);
		if (msecOff < -100 || msecOff > 100)
		{
			// Adjust the starting time forwards.
			LONGLONG msecAdjustment = HPClockMin(msecOff * 
				m_data->mClockFrequency.QuadPart / 1000, elapsedTime - 
				m_data->mPrevElapsedTime);
			m_data->mStartTime.QuadPart += msecAdjustment;
			elapsedTime -= msecAdjustment;
		}

		// Store the current elapsed time for adjustments next time.
		m_data->mPrevElapsedTime = elapsedTime;

		// Convert to microseconds.
		unsigned long usecTicks = (unsigned long)(1000000 * elapsedTime / 
			m_data->mClockFrequency.QuadPart);

		return usecTicks;
#else

#ifdef __CELLOS_LV2__
		uint64_t freq=sys_time_get_timebase_frequency();
		double dFreq=((double) freq)/ 1000000.0;
		typedef uint64_t  ClockSize;
		ClockSize newTime;
		//__asm __volatile__( "mftb %0" : "=r" (newTime) : : "memory");
		SYS_TIMEBASE_GET( newTime );

		return (unsigned long int)((double(newTime-m_data->mStartTime)) / dFreq);
#else

		struct timeval currentTime;
		gettimeofday(&currentTime, 0);
		return (currentTime.tv_sec - m_data->mStartTime.tv_sec) * 1000000 + 
			(currentTime.tv_usec - m_data->mStartTime.tv_usec);
#endif//__CELLOS_LV2__
#endif 
}







struct charArr {
	long size;
	char *data;
};

#ifdef WIN32
//#include <windows.h>

#include <winsock2.h>
#include <ws2tcpip.h>
// Need to link with Ws2_32.lib, Mswsock.lib, and Advapi32.lib
#pragma comment (lib, "Ws2_32.lib")
#pragma comment (lib, "Mswsock.lib")
#pragma comment (lib, "AdvApi32.lib")

#else
// #include <sys/time.h>
#endif


// #if defined(_DEBUG)
// #include <crtdbg.h>
// #endif





// #include "q3.h"

// #include <chrono>

// typedef std::chrono::high_resolution_clock hr_clock;
// typedef std::chrono::nanoseconds clock_freq;
// const float kClockDivisor = 1.0f / (float)std::chrono::duration_cast<clock_freq>( std::chrono::seconds( 1 ) ).count( );

// class Clock {
// public:
// 	Clock( ) {
// 		m_start = hr_clock::now( );
// 		m_stop = hr_clock::now( );
// 	}

// 	float Start( ) {
// 		m_start = hr_clock::now( );
// 		return std::chrono::duration_cast<clock_freq>( m_start - m_stop ).count( ) * kClockDivisor;
// 	}
// 	void Stop( ) {
// 		m_stop = hr_clock::now( );
// 	}

// private:
//   hr_clock::time_point m_start;
//   hr_clock::time_point m_stop;
// };




using namespace std;


#define _USE_MATH_DEFINES

typedef unsigned int uint;


static inline int newcasecmp(const char *s1, const char *s2, size_t n)
{
	int lc1  = 0;
	int lc2  = 0;

	while (n--)
	{
		lc1 = towlower (*s1);
		lc2 = towlower (*s2);

		if (lc1 != lc2)
			return (lc1 - lc2);

		if (!lc1)
			return 0;

		++s1;
		++s2;
	}

	return 0;
}

// todo: this define of wcsncasecmp should not be here

//Win32 incompatibilities
#if defined(WIN32) && !defined(__GNUC__)
static inline bool isnan(double x) {
	return x != x;
}
static inline bool isinf(double x) {
	return !isnan(x) && isnan(x - x);
}
#endif

// Linux compile fix - from quaker66
#ifdef __GNUC__
// #include <cstring>
// #include <cstdlib>
#endif

// Mac compile fixes - from quaker66, Lion fix by dabrahams
#if defined(__APPLE__) && __DARWIN_C_LEVEL < 200809L || (defined(WIN32) && defined(__GNUC__))
#include <wctype.h>
#include <wchar.h>

#endif

// Simple function to check a string 's' has at least 'n' characters
static inline bool simplejson_wcsnlen(const char *s, size_t n) {
	if (s == 0)
		return false;

	const char *save = s;
	while (n-- > 0)
	{
		if (*(save++) == 0) return false;
	}

	return true;
}

struct membuf : std::streambuf
{
	membuf(char *begin, char *end) {
		this->setg(begin, begin, end);
	}
};



bool PROG_ACTIVE = true;

string SPACE_BUFFER[] = {" ", "  ", "   ", "    ", "     ", "      ", "       ", "        ", "         ", "          ", "           ", "            ", "             ", "              ", "               ", "                ", "                 ", "                  ", "                   ", "                    ", "                     ", "                      ", "                       ", "                        ", "                         ", "                          ", "                           ", "                            ", "                             ", "                              ", "                               ", "                                ", "                                 ", "                                  ", "                                   ", "                                    ", "                                     ", "                                      ", "                                       ", "                                        ", "                                         ", "                                          ", "                                           ", "                                            ", "                                             ", "                                              ", "                                               ", "                                                ", "                                                 ", "                                                  ", "                                                   ", "                                                    ", "                                                     ", "                                                      ", "                                                       ", "                                                        ", "                                                         ", "                                                          ", "                                                           ", "                                                            ", "                                                             ", "                                                              ", "                                                               ", "                                                                ", "                                                                 ", "                                                                  ", "                                                                   ", "                                                                    ", "                                                                     ", "                                                                      ", "                                                                       ", "                                                                        ", "                                                                         ", "                                                                          ", "                                                                           ", "                                                                            ", "                                                                             ", "                                                                              ", "                                                                               ", "                                                                                ", "                                                                                 ", "                                                                                  ", "                                                                                   ", "                                                                                    ", "                                                                                     ", "                                                                                      ", "                                                                                       ", "                                                                                        ", "                                                                                         ", "                                                                                          ", "                                                                                           ", "                                                                                            ", "                                                                                             ", "                                                                                              ", "                                                                                               ", "                                                                                                ", "                                                                                                 ", "                                                                                                  ", "                                                                                                   ", "                                                                                                    "};

#define glError() { \
		GLenum err = glGetError(); \
		while (err != GL_NO_ERROR) { \
			printf("glError: %s caught at %s:%u", \
						 (char*)gluErrorString(err), __FILE__, __LINE__); \
			err = glGetError(); \
			exit(-1); \
		} \
	}























// ########
	



// struct variable to store OpenGL info
struct glInfo
{
    std::string vendor;
    std::string renderer;
    std::string version;
    std::string glslVersion;
    std::vector <std::string> extensions;
    int redBits;
    int greenBits;
    int blueBits;
    int alphaBits;
    int depthBits;
    int stencilBits;
    int maxTextureSize;
    int maxLights;
    int maxAttribStacks;
    int maxModelViewStacks;
    int maxProjectionStacks;
    int maxClipPlanes;
    int maxTextureStacks;

    // ctor, init all members
    glInfo() : redBits(0), greenBits(0), blueBits(0), alphaBits(0), depthBits(0),
               stencilBits(0), maxTextureSize(0), maxLights(0), maxAttribStacks(0),
               maxModelViewStacks(0), maxClipPlanes(0), maxTextureStacks(0) {}

    void getInfo(unsigned int param=0);         // extract info
    void printSelf();                           // print itself
    bool isExtensionSupported(const std::string& ext); // check if a extension is supported
};



// WGL specific extensions for v3.0+ //////////////////////////////////////////
#ifdef _WIN32
//#include <windows.h>
#ifndef WGLGETEXTENSIONSSTRINGARB_DEF
#define WGLGETEXTENSIONSSTRINGARB_DEF
typedef const char* (WINAPI * PFNWGLGETEXTENSIONSSTRINGARBPROC)(HDC hdc);
PFNWGLGETEXTENSIONSSTRINGARBPROC    pwglGetExtensionsStringARB = 0;
#define wglGetExtensionsStringARB  pwglGetExtensionsStringARB
#endif
#endif

// version 2.0 or greater
#define GL_SHADING_LANGUAGE_VERSION       0x8B8C



///////////////////////////////////////////////////////////////////////////////
// extract openGL info
// This function must be called after GL rendering context opened.
///////////////////////////////////////////////////////////////////////////////
void glInfo::getInfo(unsigned int param)
{
    std::string str;

    // get vendor string
    str = (const char*)glGetString(GL_VENDOR);
    this->vendor = str;             // check NULL return value

    // get renderer string
    str = (const char*)glGetString(GL_RENDERER);
    this->renderer = str;           // check NULL return value

    // get version string
    str = (const char*)glGetString(GL_VERSION);
    this->version = str;            // check NULL return value

    // get all extensions as a string
    str = (const char*)glGetString(GL_EXTENSIONS);

    // split extensions
    if(str.size() > 0)
    {
        char* str2 = new char[str.size() + 1];
        strcpy(str2, str.c_str());
        char* tok = strtok(str2, " ");
        while(tok)
        {
            this->extensions.push_back(tok);    // put a extension into struct
            tok = strtok(0, " ");               // next token
        }
        delete [] str2;
    }

    // get GLSL version string (v2.0+)
    str = (const char*)glGetString(GL_SHADING_LANGUAGE_VERSION);
    if(str.size() > 0)
        this->glslVersion = str;
    else
    {
        // "GL_SHADING_LANGUAGE_VERSION" token is added later (v2.0) after the
        // first GLSL included in OpenGL (v1.5). If "GL_SHADING_LANGUAGE_VERSION"
        // is invalid token but "GL_ARB_shading_language_100" is supported, then
        // the GLSL version should be 1.0.rev.51
        if(isExtensionSupported("GL_ARB_shading_language_100"))
            glslVersion = "1.0.51"; // the first GLSL version
        else
            glslVersion = "";
    }

    // get WGL specific extensions for v3.0+
#ifdef _WIN32 //===========================================
    wglGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)wglGetProcAddress("wglGetExtensionsStringARB");
    if(wglGetExtensionsStringARB && param)
    {
        str = (const char*)wglGetExtensionsStringARB((HDC)param);
        if(str.size() > 0)
        {
            char* str2 = new char[str.size() + 1];
            strcpy(str2, str.c_str());
            char* tok = strtok(str2, " ");
            while(tok)
            {
                this->extensions.push_back(tok);    // put a extension into struct
                tok = strtok(0, " ");               // next token
            }
            delete [] str2;
        }
    }
#endif //==================================================

    // sort extension by alphabetical order
    std::sort(this->extensions.begin(), this->extensions.end());

    // get number of color bits
    glGetIntegerv(GL_RED_BITS, &this->redBits);
    glGetIntegerv(GL_GREEN_BITS, &this->greenBits);
    glGetIntegerv(GL_BLUE_BITS, &this->blueBits);
    glGetIntegerv(GL_ALPHA_BITS, &this->alphaBits);

    // get depth bits
    glGetIntegerv(GL_DEPTH_BITS, &this->depthBits);

    // get stecil bits
    glGetIntegerv(GL_STENCIL_BITS, &this->stencilBits);

    // get max number of lights allowed
    glGetIntegerv(GL_MAX_LIGHTS, &this->maxLights);

    // get max texture resolution
    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &this->maxTextureSize);

    // get max number of clipping planes
    glGetIntegerv(GL_MAX_CLIP_PLANES, &this->maxClipPlanes);

    // get max modelview and projection matrix stacks
    glGetIntegerv(GL_MAX_MODELVIEW_STACK_DEPTH, &this->maxModelViewStacks);
    glGetIntegerv(GL_MAX_PROJECTION_STACK_DEPTH, &this->maxProjectionStacks);
    glGetIntegerv(GL_MAX_ATTRIB_STACK_DEPTH, &this->maxAttribStacks);

    // get max texture stacks
    glGetIntegerv(GL_MAX_TEXTURE_STACK_DEPTH, &this->maxTextureStacks);
}



///////////////////////////////////////////////////////////////////////////////
// check if the video card support a certain extension
///////////////////////////////////////////////////////////////////////////////
bool glInfo::isExtensionSupported(const std::string& ext)
{
    // search corresponding extension
    std::vector<std::string>::const_iterator iter = this->extensions.begin();
    std::vector<std::string>::const_iterator endIter = this->extensions.end();

    while(iter != endIter)
    {
        if(ext == *iter)
            return true;
        else
            ++iter;
    }
    return false;
}



///////////////////////////////////////////////////////////////////////////////
// print OpenGL info to screen and save to a file
///////////////////////////////////////////////////////////////////////////////
void glInfo::printSelf()
{
    std::stringstream ss;

    ss << std::endl; // blank line
    ss << "OpenGL Driver Info" << std::endl;
    ss << "==================" << std::endl;
    ss << "Vendor: " << this->vendor << std::endl;
    ss << "Version: " << this->version << std::endl;
    ss << "GLSL Version: " << this->glslVersion << std::endl;
    ss << "Renderer: " << this->renderer << std::endl;

    ss << std::endl;
    ss << "Color Bits(R,G,B,A): (" << this->redBits << ", " << this->greenBits
       << ", " << this->blueBits << ", " << this->alphaBits << ")\n";
    ss << "Depth Bits: " << this->depthBits << std::endl;
    ss << "Stencil Bits: " << this->stencilBits << std::endl;

    ss << std::endl;
    ss << "Max Texture Size: " << this->maxTextureSize << "x" << this->maxTextureSize << std::endl;
    ss << "Max Lights: " << this->maxLights << std::endl;
    ss << "Max Clip Planes: " << this->maxClipPlanes << std::endl;
    ss << "Max Modelview Matrix Stacks: " << this->maxModelViewStacks << std::endl;
    ss << "Max Projection Matrix Stacks: " << this->maxProjectionStacks << std::endl;
    ss << "Max Attribute Stacks: " << this->maxAttribStacks << std::endl;
    ss << "Max Texture Stacks: " << this->maxTextureStacks << std::endl;

    ss << std::endl;
    ss << "Total Number of Extensions: " << this->extensions.size() << std::endl;
    ss << "==============================" << std::endl;
    for(unsigned int i = 0; i < this->extensions.size(); ++i)
        ss << this->extensions.at(i) << std::endl;

    ss << "======================================================================" << std::endl;

    std::cout << ss.str() << std::endl;
}




// function pointers for PBO Extension
// Windows needs to get function pointers from ICD OpenGL drivers,
// because opengl32.dll does not support extensions higher than v1.1.
#ifdef _WIN32
PFNGLGENBUFFERSARBPROC pglGenBuffersARB = 0;                     // VBO Name Generation Procedure
PFNGLBINDBUFFERARBPROC pglBindBufferARB = 0;                     // VBO Bind Procedure
PFNGLBUFFERDATAARBPROC pglBufferDataARB = 0;                     // VBO Data Loading Procedure
PFNGLBUFFERSUBDATAARBPROC pglBufferSubDataARB = 0;               // VBO Sub Data Loading Procedure
PFNGLDELETEBUFFERSARBPROC pglDeleteBuffersARB = 0;               // VBO Deletion Procedure
PFNGLGETBUFFERPARAMETERIVARBPROC pglGetBufferParameterivARB = 0; // return various parameters of VBO
PFNGLMAPBUFFERARBPROC pglMapBufferARB = 0;                       // map VBO procedure
PFNGLUNMAPBUFFERARBPROC pglUnmapBufferARB = 0;                   // unmap VBO procedure
// #define glGenBuffersARB           pglGenBuffersARB
// #define glBindBufferARB           pglBindBufferARB
// #define glBufferDataARB           pglBufferDataARB
// #define glBufferSubDataARB        pglBufferSubDataARB
// #define glDeleteBuffersARB        pglDeleteBuffersARB
// #define glGetBufferParameterivARB pglGetBufferParameterivARB
// #define glMapBufferARB            pglMapBufferARB
// #define glUnmapBufferARB          pglUnmapBufferARB
#endif


// function pointers for WGL_EXT_swap_control
#ifdef _WIN32
typedef BOOL (WINAPI * PFNWGLSWAPINTERVALEXTPROC) (int interval);
typedef int (WINAPI * PFNWGLGETSWAPINTERVALEXTPROC) (void);
PFNWGLSWAPINTERVALEXTPROC pwglSwapIntervalEXT = 0;
PFNWGLGETSWAPINTERVALEXTPROC pwglGetSwapIntervalEXT = 0;
#define wglSwapIntervalEXT      pwglSwapIntervalEXT
#define wglGetSwapIntervalEXT   pwglGetSwapIntervalEXT
#endif




// typedef BOOL (APIENTRY *PFNWGLSWAPINTERVALFARPROC)( int );
// extern PFNWGLSWAPINTERVALFARPROC wglSwapIntervalEXT;

// static inline void init_EXT_Vsync()
// {
// wglSwapIntervalEXT = (PFNWGLSWAPINTERVALFARPROC)extgl_GetProcAddress( "wglSwapIntervalEXT" );
// }





const static GLenum bufNames[] = {
	GL_COLOR_ATTACHMENT0_EXT,
	GL_COLOR_ATTACHMENT1_EXT,
	GL_COLOR_ATTACHMENT2_EXT,
	GL_COLOR_ATTACHMENT3_EXT,
	GL_COLOR_ATTACHMENT4_EXT,
	GL_COLOR_ATTACHMENT5_EXT,
	GL_COLOR_ATTACHMENT6_EXT,
	GL_COLOR_ATTACHMENT7_EXT
};






// data for a fullscreen quad (this time with texture coords)
GLfloat vertexDataQuad[] = {
//  X     Y     Z           U     V     
   1.0f, 1.0f, 0.0f, 1.0f,       1.0f, 1.0f, 0.0f, 0.0f, // vertex 0
  -1.0f, 1.0f, 0.0f, 1.0f,       0.0f, 1.0f, 0.0f, 0.0f, // vertex 1
   1.0f,-1.0f, 0.0f, 1.0f,       1.0f, 0.0f, 0.0f, 0.0f, // vertex 2
  -1.0f,-1.0f, 0.0f, 1.0f,       0.0f, 0.0f, 0.0f, 0.0f  // vertex 3
}; // 4 vertices with 8 components (floats) each
GLuint indexDataQuad[] = {
    0,1,2, // first triangle
    2,1,3  // second triangle
};








// ??????????????????????????????





#define NUMRAYS 500
#define ARRAY_SIZE_Y 5
#define ARRAY_SIZE_X 5
#define ARRAY_SIZE_Z 5

#define COLLISION_RADIUS 0.0f


#define BT_LINE_BATCH_SIZE 512
#if defined(BT_USE_DOUBLE_PRECISION)
#define btglLoadMatrix glLoadMatrixd
#define btglMultMatrix glMultMatrixd
#define btglColor3 glColor3d
#define btglVertex3 glVertex3d
#else
#define btglLoadMatrix glLoadMatrixf
#define btglMultMatrix glMultMatrixf
#define btglColor3 glColor3f
#define btglVertex3 glVertex3d
#endif

// #ifndef M_PI
// #define M_PI       btScalar(3.14159265358979323846)
// #endif

// #ifndef M_PI_2
// #define M_PI_2     btScalar(1.57079632679489661923)
// #endif

// #ifndef M_PI_4
// #define M_PI_4     btScalar(0.785398163397448309616)
// #endif

#ifndef M_PI_8
#define M_PI_8     0.5 * M_PI_4
#endif

//#define NUM_LEGS_GA 6
//#define BODYPART_COUNT_GA 2 * NUM_LEGS_GA + 1
//#define JOINT_COUNT_GA BODYPART_COUNT_GA - 1



class btConvexShape;
class btCollisionShape;
class btShapeHull;
class btDiscreteDynamicsWorld;
class MyShapeDrawer;
class btDynamicsWorld;
class btRigidBody;
class btBroadphaseInterface;
class btOverlappingPairCache;
class btCollisionDispatcher;
class btConstraintSolver;
struct btCollisionAlgorithmCreateFunc;
class btDefaultCollisionConfiguration;





#include "../CommonInterfaces/CommonGraphicsAppInterface.h"
#include "../CommonInterfaces/CommonRenderInterface.h"
#include "../CommonInterfaces/CommonExampleInterface.h"
#include "../CommonInterfaces/CommonGUIHelperInterface.h"
#include "../CommonInterfaces/CommonRigidBodyBase.h"


#include "btBulletDynamicsCommon.h"

// #include "Bullet3Common/b3Vector3.h"
// #include "Bullet3Common/b3Scalar.h"

// #include "LinearMath/btVector3.h"
// #include "LinearMath/btAlignedObjectArray.h"
// #include "LinearMath/btTransformUtil.h"



#include "BulletCollision/CollisionShapes/btShapeHull.h"
#include "BulletCollision/CollisionShapes/btPolyhedralConvexShape.h"
#include "BulletCollision/CollisionShapes/btConvexPolyhedron.h"
#include "BulletCollision/CollisionDispatch/btSimulationIslandManager.h"

// included within btBulletDynamicsCommon.h
// #include "LinearMath/btIDebugDraw.h"
// #include "LinearMath/btDefaultMotionState.h"
// #include "LinearMath/btTransform.h"
// #include "BulletCollision/CollisionShapes/btTriangleMeshShape.h"
// #include "BulletCollision/CollisionShapes/btBoxShape.h"
// #include "BulletCollision/CollisionShapes/btSphereShape.h"
// #include "BulletCollision/CollisionShapes/btConeShape.h"
// #include "BulletCollision/CollisionShapes/btCylinderShape.h"
// #include "BulletCollision/CollisionShapes/btTetrahedronShape.h"
// #include "BulletCollision/CollisionShapes/btCompoundShape.h"
// #include "BulletCollision/CollisionShapes/btCapsuleShape.h"
// #include "BulletCollision/CollisionShapes/btConvexTriangleMeshShape.h"
// #include "BulletCollision/CollisionShapes/btUniformScalingShape.h"
// #include "BulletCollision/CollisionShapes/btStaticPlaneShape.h"
// #include "BulletCollision/CollisionShapes/btMultiSphereShape.h"
// #include "BulletCollision/BroadphaseCollision/btDbvtBroadphase.h"
// #include "BulletDynamics/Dynamics/btDiscreteDynamicsWorld.h"
// #include "BulletDynamics/Dynamics/btRigidBody.h"

#include "../OpenGLWindow/OpenGL2Include.h"
#include "../OpenGLWindow/SimpleCamera.h"
#include "../OpenGLWindow/GLInstanceGraphicsShape.h"

#include "../Benchmarks/TaruData.h"
//#include "../Benchmarks/landscapeData.h"






/////







// ??????????????????????????????






/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/









struct ShapeCache
{
	struct Edge { btVector3 n[2];int v[2]; };
	ShapeCache(btConvexShape* s) : m_shapehull(s) {}
	btShapeHull					m_shapehull;
	btAlignedObjectArray<Edge>	m_edges;
};

void OGL_displaylist_register_shape(btCollisionShape * shape);
void OGL_displaylist_clean();



///










class GlDrawcallback : public btTriangleCallback
{

public:

	bool	m_wireframe;

	GlDrawcallback()
		:m_wireframe(false)
	{
	}

	virtual void processTriangle(btVector3* triangle, int partId, int triangleIndex)
	{

		// (void)triangleIndex;
		// (void)partId;


		if (m_wireframe)
		{
			// glBegin(GL_LINES);
			// //glColor3f(1, 0, 0);
			// glVertex3d(triangle[0].getX(), triangle[0].getY(), triangle[0].getZ());
			// glVertex3d(triangle[1].getX(), triangle[1].getY(), triangle[1].getZ());
			// //glColor3f(0, 1, 0);
			// glVertex3d(triangle[2].getX(), triangle[2].getY(), triangle[2].getZ());
			// glVertex3d(triangle[1].getX(), triangle[1].getY(), triangle[1].getZ());
			// // /glColor3f(0, 0, 1);
			// glVertex3d(triangle[2].getX(), triangle[2].getY(), triangle[2].getZ());
			// glVertex3d(triangle[0].getX(), triangle[0].getY(), triangle[0].getZ());
			// glEnd();
		} else
		{
			//glBegin(GL_TRIANGLES);
			//glColor3f(1, 1, 1);
			
			//cout << "f\n";
			
			
			btVector3 normal = (triangle[2]-triangle[0]).cross(triangle[1]-triangle[0]);
			normal.normalize();
			glNormal3f(normal.getX(),normal.getY(),normal.getZ());
			
			glVertex3f(triangle[0].getX(), triangle[0].getY(), triangle[0].getZ());
			glVertex3f(triangle[1].getX(), triangle[1].getY(), triangle[1].getZ());
			glVertex3f(triangle[2].getX(), triangle[2].getY(), triangle[2].getZ());
			
			// cout << triangle[0].getX() << " " << triangle[0].getY() << " " << triangle[0].getZ() << "\n";
			// cout << triangle[1].getX() << " " << triangle[1].getY() << " " << triangle[1].getZ() << "\n";
			// cout << triangle[2].getX() << " " << triangle[2].getY() << " " << triangle[2].getZ() << "\n";
			// cout << normal.getX() << " " << normal.getY() << " " << normal.getZ() << "\n";
			// cout << "\n";
			
			// normal = (triangle[0]-triangle[2]).cross(triangle[1]-triangle[2]);
			// normal.normalize();
			// glNormal3f(normal.getX(),normal.getY(),normal.getZ());
			
			// glVertex3d(triangle[2].getX(), triangle[2].getY(), triangle[2].getZ());
			// glVertex3d(triangle[1].getX(), triangle[1].getY(), triangle[1].getZ());
			// glVertex3d(triangle[0].getX(), triangle[0].getY(), triangle[0].getZ());
			//glEnd();
		}
	}
};

class TriangleGlDrawcallback : public btInternalTriangleIndexCallback
{
public:
	virtual void internalProcessTriangleIndex(btVector3* triangle,int partId,int  triangleIndex)
	{
		(void)triangleIndex;
		(void)partId;



		//glBegin(GL_TRIANGLES);//LINES);
		//glColor3f(1, 0, 0);
		glVertex3d(triangle[0].getX(), triangle[0].getY(), triangle[0].getZ());
		glVertex3d(triangle[1].getX(), triangle[1].getY(), triangle[1].getZ());
		//glColor3f(0, 1, 0);
		glVertex3d(triangle[2].getX(), triangle[2].getY(), triangle[2].getZ());
		glVertex3d(triangle[1].getX(), triangle[1].getY(), triangle[1].getZ());
		// /glColor3f(0, 0, 1);
		glVertex3d(triangle[2].getX(), triangle[2].getY(), triangle[2].getZ());
		glVertex3d(triangle[0].getX(), triangle[0].getY(), triangle[0].getZ());
		//glEnd();
	}
};


// ???????????








struct OGLRenderer : public CommonRenderInterface
{
    int m_width;
    int m_height;
    SimpleCamera	m_camera;
    
    OGLRenderer(int width, int height);
    
    virtual void init();
    
    virtual void updateCamera(int upAxis);
    
	virtual const CommonCameraInterface* getActiveCamera() const;
	virtual CommonCameraInterface* getActiveCamera();
	virtual void setActiveCamera(CommonCameraInterface* cam);

	virtual void resize(int width, int height)
	{
		m_width = width;
		m_height = height;
	}

    virtual void removeAllInstances();
    
    
    virtual void writeSingleInstanceColorToCPU(float* color, int srcIndex);
    virtual void writeSingleInstanceColorToCPU(double* color, int srcIndex);
    virtual void getCameraViewMatrix(float viewMat[16]) const;
    virtual void getCameraProjectionMatrix(float projMat[16]) const;

    
    virtual void renderScene();
    
    virtual int getScreenWidth()
    {
        return m_width;
    }
    virtual int getScreenHeight()
    {
        return m_height;
    }
	virtual int	registerTexture(const unsigned char* texels, int width, int height)
	{
		return -1;
	}
    virtual int registerGraphicsInstance(int shapeIndex, const double* position, const double* quaternion, const double* color, const double* scaling);
    
    virtual int registerGraphicsInstance(int shapeIndex, const float* position, const float* quaternion, const float* color, const float* scaling);
    
    virtual void drawLines(const float* positions, const float color[4], int numPoints, int pointStrideInBytes, const unsigned int* indices, int numIndices, float pointDrawSize);
    
    virtual void drawLine(const float from[4], const float to[4], const float color[4], float lineWidth);
    
    virtual int registerShape(const float* vertices, int numvertices, const int* indices, int numIndices,int primitiveType=B3_GL_TRIANGLES, int textureIndex=-1);
    
    virtual void writeSingleInstanceTransformToCPU(const float* position, const float* orientation, int srcIndex);
    
    virtual void writeSingleInstanceTransformToCPU(const double* position, const double* orientation, int srcIndex);
    
    virtual void writeTransforms();
    
    virtual void drawLine(const double from[4], const double to[4], const double color[4], double lineWidth);
    
    virtual void drawPoint(const float* position, const float color[4], float pointDrawSize);
    
    virtual void drawPoint(const double* position, const double color[4], double pointDrawSize);
    
    virtual void updateShape(int shapeIndex, const float* vertices);
    
    virtual void enableBlend(bool blend);

	virtual struct	GLInstanceRendererInternalData* getInternalData()
	{
		return 0;
	}
    
};







OGLRenderer::OGLRenderer(int width, int height)
 :m_width(width),
 m_height(height)
{
    
}

void OGLRenderer::init()
{
}

const CommonCameraInterface* OGLRenderer::getActiveCamera() const
{
	return &m_camera;
}
CommonCameraInterface* OGLRenderer::getActiveCamera()
{
	return &m_camera;
}
void OGLRenderer::setActiveCamera(CommonCameraInterface* cam)
{
	b3Assert(0);//not supported yet
}

void OGLRenderer::updateCamera(int upAxis)
{
    float projection[16];
    float view[16];
    m_camera.setAspectRatio((float)m_width/(float)m_height);
    m_camera.update();
    m_camera.getCameraProjectionMatrix(projection);
    m_camera.getCameraViewMatrix(view);
    GLfloat projMat[16];
    GLfloat viewMat[16];
    for (int i=0;i<16;i++)
    {
        viewMat[i] = view[i];
        projMat[i] = projection[i];
    }
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glMultMatrixf(projMat);
    
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glMultMatrixf(viewMat);
}

void OGLRenderer::removeAllInstances()
{
}


void OGLRenderer::writeSingleInstanceColorToCPU(float* color, int srcIndex)
{
}
void OGLRenderer::writeSingleInstanceColorToCPU(double* color, int srcIndex)
{
    
}
void OGLRenderer::getCameraViewMatrix(float viewMat[16]) const
{
    b3Assert(0);
}
void OGLRenderer::getCameraProjectionMatrix(float projMat[16]) const
{
    b3Assert(0);
    
}


void OGLRenderer::renderScene()
{
    //cout << "asdfasdf\n";
}
    
    


int OGLRenderer::registerGraphicsInstance(int shapeIndex, const double* position, const double* quaternion, const double* color, const double* scaling)
{
    return 0;
}

int OGLRenderer::registerGraphicsInstance(int shapeIndex, const float* position, const float* quaternion, const float* color, const float* scaling)
{
    return 0;
}

void OGLRenderer::drawLines(const float* positions, const float color[4], int numPoints, int pointStrideInBytes, const unsigned int* indices, int numIndices, float pointDrawSize)
{
    int pointStrideInFloats = pointStrideInBytes/4;
    for (int i=0;i<numIndices;i+=2)
    {
        int index0 = indices[i];
        int index1 = indices[i+1];
        
        b3Vector3 fromColor = b3MakeVector3(color[0],color[1],color[2]);
        b3Vector3 toColor = b3MakeVector3(color[0],color[1],color[2]);
        
        b3Vector3 from= b3MakeVector3(positions[index0*pointStrideInFloats],positions[index0*pointStrideInFloats+1],positions[index0*pointStrideInFloats+2]);
        b3Vector3 to= b3MakeVector3(positions[index1*pointStrideInFloats],positions[index1*pointStrideInFloats+1],positions[index1*pointStrideInFloats+2]);
        
        // glBegin(GL_LINES);
        // glColor3f(fromColor.getX(), fromColor.getY(), fromColor.getZ());
        // glVertex3d(from.getX(), from.getY(), from.getZ());
        // glColor3f(toColor.getX(), toColor.getY(), toColor.getZ());
        // glVertex3d(to.getX(), to.getY(), to.getZ());
        // glEnd();
        
    }
}

void OGLRenderer::drawLine(const float from[4], const float to[4], const float color[4], float lineWidth)
{
        // glBegin(GL_LINES);
        // glColor3f(color[0],color[1],color[2]);
        // glVertex3d(from[0],from[1],from[2]);
        // glVertex3d(to[0],to[1],to[2]);
        // glEnd();
}
int OGLRenderer::registerShape(const float* vertices, int numvertices, const int* indices, int numIndices,int primitiveType, int textureIndex)
{
    return 0;
}

void OGLRenderer::writeSingleInstanceTransformToCPU(const float* position, const float* orientation, int srcIndex)
{
}
void OGLRenderer::writeSingleInstanceTransformToCPU(const double* position, const double* orientation, int srcIndex)
{
}
void OGLRenderer::writeTransforms()
{
}


void OGLRenderer::drawLine(const double from[4], const double to[4], const double color[4], double lineWidth)
{
    
}
void OGLRenderer::drawPoint(const float* position, const float color[4], float pointDrawSize)
{
}
void OGLRenderer::drawPoint(const double* position, const double color[4], double pointDrawSize)
{
}

void OGLRenderer::updateShape(int shapeIndex, const float* vertices)
{
}

void OGLRenderer::enableBlend(bool blend)
{
}




// ??????????????

struct MyOGLAppInternalData
{
	GLuint m_fontTextureId;
	GLuint m_largeFontTextureId;
	
};

struct MyOGLApp : public CommonGraphicsApp
{
protected:
	struct MyOGLAppInternalData*	m_data;

public:
	MyOGLApp(const char* title, int width, int height) {
		m_renderer = new OGLRenderer(width,height);		
	}
	virtual ~MyOGLApp() {}

	virtual void drawGrid(DrawGridData data=DrawGridData()) {}
	virtual void setUpAxis(int axis) {}
	virtual int getUpAxis() const {return 2;}
	
	virtual void swapBuffer() {}
	virtual void drawText( const char* txt, int posX, int posY) {}
	virtual void setBackgroundColor(float red, float green, float blue) {}
	virtual int	registerCubeShape(float halfExtentsX,float halfExtentsY, float halfExtentsZ, int textureIndex = -1,  float textureScaling = 1)
	{
		cout << "a\n";
		return 0;
	}
	virtual int	registerGraphicsUnitSphereShape(EnumSphereLevelOfDetail lod, int textureId=-1)
	{
		cout << "b\n";
		return 0;
	}
    virtual void drawText3D( const char* txt, float posX, float posZY, float posZ, float size) {}
    virtual void registerGrid(int xres, int yres, float color0[4], float color1[4]) {
    	cout << "c\n";
    }
    
    virtual struct	GLInstanceRendererInternalData* getInternalData()
    {
    	cout << "d\n";
    	return 0;
    }
    
};






static btVector4 sColors[4] =
{
	btVector4(0.3,0.3,1,1),
	btVector4(0.6,0.6,1,1),
	btVector4(0,1,0,1),
	btVector4(0,1,1,1),
	//btVector4(1,1,0,1),
};


struct MyDebugVec3
{
	MyDebugVec3(const btVector3& org)
	:x(org.x()),
	y(org.y()),
	z(org.z())
	{
	}

	float x;
	float y;
	float z;
};
class MyDebugDrawer : public btIDebugDraw
{
	CommonGraphicsApp* m_glApp;
	int m_debugMode;

    btAlignedObjectArray<MyDebugVec3> m_linePoints;
    btAlignedObjectArray<unsigned int> m_lineIndices;
    btVector3 m_currentLineColor;
	DefaultColors m_ourColors;

public:

	MyDebugDrawer(CommonGraphicsApp* app)
		: m_glApp(app)
		,m_debugMode(btIDebugDraw::DBG_DrawWireframe|btIDebugDraw::DBG_DrawAabb),
		m_currentLineColor(-1,-1,-1)
	{
		
		
	}
	virtual DefaultColors	getDefaultColors() const	
	{	
		return m_ourColors;
	}
	///the default implementation for setDefaultColors has no effect. A derived class can implement it and store the colors.
	virtual void setDefaultColors(const DefaultColors& colors) 
	{
		m_ourColors = colors;
	}


	virtual void drawLine(const btVector3& from1,const btVector3& to1,const btVector3& color1)
	{
        //float from[4] = {from1[0],from1[1],from1[2],from1[3]};
        //float to[4] = {to1[0],to1[1],to1[2],to1[3]};
        //float color[4] = {color1[0],color1[1],color1[2],color1[3]};
		//m_glApp->m_instancingRenderer->drawLine(from,to,color);
		if (m_currentLineColor!=color1 || m_linePoints.size() >= BT_LINE_BATCH_SIZE)
        {
            flushLines();
            m_currentLineColor = color1;
        }
		MyDebugVec3 from(from1);
		MyDebugVec3 to(to1);
			
		m_linePoints.push_back(from);
		m_linePoints.push_back(to);

		m_lineIndices.push_back(m_lineIndices.size());
		m_lineIndices.push_back(m_lineIndices.size());

	}

	virtual void drawContactPoint(const btVector3& PointOnB,const btVector3& normalOnB,btScalar distance,int lifeTime,const btVector3& color)
	{
        drawLine(PointOnB,PointOnB+normalOnB,color);
	}
     

	virtual void reportErrorWarning(const char* warningString)
	{
	}

	virtual void draw3dText(const btVector3& location,const char* textString)
	{
	}

	virtual void setDebugMode(int debugMode)
	{
		m_debugMode = debugMode;
	}

	virtual int		getDebugMode() const
	{
		return m_debugMode;
	}

    virtual void flushLines()
	{
	    int sz = m_linePoints.size();
	    if (sz)
        {
			float debugColor[4];
		debugColor[0] = m_currentLineColor.x();
		debugColor[1] = m_currentLineColor.y();
		debugColor[2] = m_currentLineColor.z();
		debugColor[3] = 1.f;
		m_glApp->m_renderer->drawLines(&m_linePoints[0].x,debugColor,
														 m_linePoints.size(),sizeof(MyDebugVec3),
														 &m_lineIndices[0],
														 m_lineIndices.size(),
														 1);
            m_linePoints.clear();
            m_lineIndices.clear();
        }
	}

};




struct MyConvertPointerSizeT
{
	union 
	{
			const void* m_ptr;
			size_t m_int;
	};
};

bool shapePointerCompareFunc(const btCollisionObject* colA, const btCollisionObject* colB)
{
	MyConvertPointerSizeT a,b;
	a.m_ptr = colA->getCollisionShape();
	b.m_ptr = colB->getCollisionShape();
	return (a.m_int<b.m_int);
}

struct MyGLHelperInternalData
{
	struct CommonGraphicsApp* m_glApp;
	class MyDebugDrawer* m_debugDraw;
	MyShapeDrawer* m_gl2ShapeDrawer;
};














// %%%%%%%%%%%%%%%%%%%%%%%%%


/*
Bullet Continuous Collision Detection and Physics Library
Copyright (c) 2003-2006 Erwin Coumans  http://continuousphysics.com/Bullet/

This software is provided 'as-is', without any express or implied warranty.
In no event will the authors be held liable for any damages arising from the use of this software.
Permission is granted to anyone to use this software for any purpose, 
including commercial applications, and to alter it and redistribute it freely, 
subject to the following restrictions:

1. The origin of this software must not be misrepresented; you must not claim that you wrote the original software. If you use this software in a product, an acknowledgment in the product documentation would be appreciated but is not required.
2. Altered source versions must be plainly marked as such, and must not be misrepresented as being the original software.
3. This notice may not be removed or altered from any source distribution.
*/














struct CustFilterCallback : public btOverlapFilterCallback
{
	
	// CustFilterCallback()
	// {
	// }
	// virtual ~CustFilterCallback()
	// {
	// }
	
	// return true when pairs need collision
	virtual bool needBroadphaseCollision(
		btBroadphaseProxy* proxy0,
		btBroadphaseProxy* proxy1) const
	{
		
		if (EDIT_POSE) {
			return false;
		}
		
		bool collides = 
		(
			((proxy0->m_collisionFilterGroup & proxy1->m_collisionFilterMask) != 0) &&
			((proxy1->m_collisionFilterGroup & proxy0->m_collisionFilterMask) != 0)
		);


		
		btCollisionObject* colObj0 = (btCollisionObject*)(proxy0->m_clientObject);
		btCollisionObject* colObj1 = (btCollisionObject*)(proxy1->m_clientObject);
		
		
		
		// if (colObj0->bodyUID != colObj1->bodyUID) {
		// 	cout << colObj0->bodyUID << " " << colObj1->bodyUID << "\n";
		// }
		
		collides = collides && (
			(colObj0->bodyUID != colObj1->bodyUID) &&
			(colObj0->bodyUID > -2) &&
			(colObj1->bodyUID > -2) &&
			(colObj0->heldByUID != colObj1->bodyUID) &&
			(colObj1->heldByUID != colObj0->bodyUID)
		);
		
		
		
		return collides;
	}
};




class BenchmarkDemo : public CommonRigidBodyBase
{

	//keep the collision shapes, for deletion/cleanup

	btAlignedObjectArray<class RagDoll*>	m_ragdolls;
	
	//btOverlapFilterCallback * filterCallback;
	
	btVector3 initOffset;
	
	int	m_benchmark;

	void myinit()
	{
		//??
	}

	void setCameraDistance(btScalar dist)
	{
	}
	void createTest1();
	void createTest2();
	void createTest3();
	void createTest4();
	void createTest5();
	void createTest6();
	void createTest7();
	void createTest8();

	
	void createWall(const btVector3& offsetPosition,int stackSize,const btVector3& boxSize);
	void createPyramid(const btVector3& offsetPosition,int stackSize,const btVector3& boxSize);
	void createTowerCircle(const btVector3& offsetPosition,int stackSize,int rotSize,const btVector3& boxSize);
	//void createLargeMeshBody();


	class SpuBatchRaycaster* m_batchRaycaster;
	class btThreadSupportInterface* m_batchRaycasterThreadSupport;

	void castRays();
	void initRays();

	public:

	
	BenchmarkDemo(struct GUIHelperInterface* helper, int benchmark)
	:CommonRigidBodyBase(helper),
	m_benchmark(benchmark)
	{
	}
	virtual ~BenchmarkDemo()
	{
		exitPhysics();
	}
	
	btDiscreteDynamicsWorld* getWorld();
	
	btRigidBody* createRigidBodyMask(
		btScalar mass, const btTransform& startTransform, btCollisionShape* shape, int maskFrom, int maskTo
	);
	
	void removeRigidBody(btRigidBody* body);
	
	void updateGraphicsObjects();
	
	void beginDrop(float x, float y, float z);
	
	// btRigidBody* bodyPick(const btVector3& rayFromWorld, const btVector3& rayToWorld);
	
	void initPhysics();

	void exitPhysics();

	void stepSimulation(float deltaTime);

	void resetCamera()
	{
		float dist = 120;
		float pitch = 52;
		float yaw = 35;
		float targetPos[3]={0,10.46,0};
		m_guiHelper->resetCamera(dist,pitch,yaw,targetPos[0],targetPos[1],targetPos[2]);
	}
};

// btRigidBody* BenchmarkDemo::bodyPick(const btVector3& rayFromWorld, const btVector3& rayToWorld) {
	
// 	if (m_dynamicsWorld==0) {
// 		cout << "world not ready\n";
// 		return NULL;
// 	}

// 	btCollisionWorld::ClosestRayResultCallback rayCallback(rayFromWorld, rayToWorld);

// 	m_dynamicsWorld->rayTest(rayFromWorld, rayToWorld, rayCallback);
// 	if (rayCallback.hasHit())
// 	{

// 		btVector3 pickPos = rayCallback.m_hitPointWorld;
// 		btRigidBody* body = (btRigidBody*)btRigidBody::upcast(rayCallback.m_collisionObject);
// 		if (body)
// 		{
// 			//other exclusions?
// 			if (!(body->isStaticObject() || body->isKinematicObject()))
// 			{
				
// 				return body;
				
// 				// m_pickedBody = body;
// 				// m_savedState = m_pickedBody->getActivationState();
// 				// m_pickedBody->setActivationState(DISABLE_DEACTIVATION);
// 				// //printf("pickPos=%f,%f,%f\n",pickPos.getX(),pickPos.getY(),pickPos.getZ());
// 				// btVector3 localPivot = body->getCenterOfMassTransform().inverse() * pickPos;
// 				// btPoint2PointConstraint* p2p = new btPoint2PointConstraint(*body, localPivot);
// 				// m_dynamicsWorld->addConstraint(p2p, true);
// 				// m_pickedConstraint = p2p;
// 				// btScalar mousePickClamping = 30.f;
// 				// p2p->m_setting.m_impulseClamp = mousePickClamping;
// 				// //very weak constraint for picking
// 				// p2p->m_setting.m_tau = 0.001f;
// 			}
// 		}
		
		
// 		// m_oldPickingPos = rayToWorld;
// 		// m_hitPos = pickPos;
// 		// m_oldPickingDist = (pickPos - rayFromWorld).length();
// 	}
// 	return NULL;
	
// }


class btRaycastBar2
{
public:
	btVector3 source[NUMRAYS];
	btVector3 dest[NUMRAYS];
	btVector3 direction[NUMRAYS];
	btVector3 hit[NUMRAYS];
	btVector3 normal[NUMRAYS];
	struct GUIHelperInterface* m_guiHelper;
	
	int frame_counter;
	int ms;
	int sum_ms;
	int sum_ms_samples;
	int min_ms;
	int max_ms;

#ifdef USE_BT_CLOCK
	btClock frame_timer;
#endif //USE_BT_CLOCK

	btScalar dx;
	btScalar min_x;
	btScalar max_x;
	btScalar max_y;
	btScalar sign;

	btRaycastBar2 ()
	{
		m_guiHelper = 0;
		ms = 0;
		max_ms = 0;
		min_ms = 9999;
		sum_ms_samples = 0;
		sum_ms = 0;
	}



	btRaycastBar2 (btScalar ray_length, btScalar z,btScalar max_y,struct GUIHelperInterface* guiHelper)
	{
		m_guiHelper = guiHelper;
		frame_counter = 0;
		ms = 0;
		max_ms = 0;
		min_ms = 9999;
		sum_ms_samples = 0;
		sum_ms = 0;
		dx = 10.0;
		min_x = 0;
		max_x = 0;
		this->max_y = max_y;
		sign = 1.0;
		btScalar dalpha = 2*SIMD_2_PI/NUMRAYS;
		for (int i = 0; i < NUMRAYS; i++)
		{
			btScalar alpha = dalpha * i;
			// rotate around by alpha degrees y 
			btQuaternion q(btVector3(0.0, 1.0, 0.0), alpha);
			direction[i] = btVector3(1.0, 0.0, 0.0);
			direction[i] = quatRotate(q , direction[i]);
			direction[i] = direction[i] * ray_length;
			
			
			source[i] = btVector3(min_x, max_y, z);
			dest[i] = source[i] + direction[i];
			dest[i][1]=-1000;
			normal[i] = btVector3(1.0, 0.0, 0.0);
		}
	}

	void move (btScalar dt)
	{
		if (dt > btScalar(1.0/60.0))
			dt = btScalar(1.0/60.0);
		for (int i = 0; i < NUMRAYS; i++)
		{
			source[i][0] += dx * dt * sign;
			dest[i][0] += dx * dt * sign;
		}
		if (source[0][0] < min_x)
			sign = 1.0;
		else if (source[0][0] > max_x)
			sign = -1.0;
	}

	void cast (btCollisionWorld* cw)
	{
#ifdef USE_BT_CLOCK
		frame_timer.reset ();
#endif //USE_BT_CLOCK

#ifdef BATCH_RAYCASTER
		if (!gBatchRaycaster)
			return;

		gBatchRaycaster->clearRays ();
		for (int i = 0; i < NUMRAYS; i++)
		{
			gBatchRaycaster->addRay (source[i], dest[i]);
		}
		gBatchRaycaster->performBatchRaycast ();
		for (int i = 0; i < gBatchRaycaster->getNumRays (); i++)
		{
				const SpuRaycastTaskWorkUnitOut& out = (*gBatchRaycaster)[i];
				hit[i].setInterpolate3(source[i],dest[i],out.hitFraction);
				normal[i] = out.hitNormal;
				normal[i].normalize ();
		}
#else
		for (int i = 0; i < NUMRAYS; i++)
		{
			btCollisionWorld::ClosestRayResultCallback cb(source[i], dest[i]);
			
			cw->rayTest (source[i], dest[i], cb);
			if (cb.hasHit ())
			{
				hit[i] = cb.m_hitPointWorld;
				normal[i] = cb.m_hitNormalWorld;
				normal[i].normalize ();
			} else {
				hit[i] = dest[i];
				normal[i] = btVector3(1.0, 0.0, 0.0);
			}

		}
#ifdef USE_BT_CLOCK
		ms += frame_timer.getTimeMilliseconds ();
#endif //USE_BT_CLOCK
		frame_counter++;
		if (frame_counter > 50)
		{
			min_ms = ms < min_ms ? ms : min_ms;
			max_ms = ms > max_ms ? ms : max_ms;
			sum_ms += ms;
			sum_ms_samples++;
			btScalar mean_ms = (btScalar)sum_ms/(btScalar)sum_ms_samples;
			printf("%d rays in %d ms %d %d %f\n", NUMRAYS * frame_counter, ms, min_ms, max_ms, mean_ms);
			ms = 0;
			frame_counter = 0;
		}
#endif
	}

	void draw ()
	{
		
		if (m_guiHelper)
		{
			btAlignedObjectArray<unsigned int> indices;
			btAlignedObjectArray<btVector3FloatData> points;
			
			
			float lineColor[4]={1,0.4,.4,1};
			
			for (int i = 0; i < NUMRAYS; i++)
			{
				btVector3FloatData s,h;
				for (int w=0;w<4;w++)
				{
					s.m_floats[w] = source[i][w];
					h.m_floats[w] = hit[i][w];
				}
				
				points.push_back(s);
				points.push_back(h);
				indices.push_back(indices.size());
				indices.push_back(indices.size());
			}

			m_guiHelper->getRenderInterface()->drawLines(&points[0].m_floats[0],lineColor,points.size(),sizeof(btVector3),&indices[0],indices.size(),1);
		}
													 
#if 0
		glDisable (GL_LIGHTING);
		glColor3f (0.0, 1.0, 0.0);
		glBegin (GL_LINES);
		int i;

		for (i = 0; i < NUMRAYS; i++)
		{
			glVertex3f (source[i][0], source[i][1], source[i][2]);
			glVertex3f (hit[i][0], hit[i][1], hit[i][2]);
		}
		glEnd ();
		glColor3f (1.0, 1.0, 1.0);
		glBegin (GL_LINES);
		for (i = 0; i < NUMRAYS; i++)
		{
			glVertex3f (hit[i][0], hit[i][1], hit[i][2]);
			glVertex3f (hit[i][0] + normal[i][0], hit[i][1] + normal[i][1], hit[i][2] + normal[i][2]);
		}
		glEnd ();
		glColor3f (0.0, 1.0, 1.0);
		glBegin (GL_POINTS);
		for ( i = 0; i < NUMRAYS; i++)
		{
			glVertex3f (hit[i][0], hit[i][1], hit[i][2]);
		}
		glEnd ();
		glEnable (GL_LIGHTING);
#endif //USE_GRAPHICAL_BENCHMARK

	}
};


static btRaycastBar2 raycastBar;

btDiscreteDynamicsWorld* BenchmarkDemo::getWorld() {
	return m_dynamicsWorld;
}

void BenchmarkDemo::stepSimulation(float deltaTime)
{
	if (m_dynamicsWorld)
	{
		m_dynamicsWorld->stepSimulation(deltaTime);
	}
	
	if (m_benchmark==7)
	{
		castRays();

		raycastBar.draw();
	
	}

}

void BenchmarkDemo::removeRigidBody(btRigidBody* body) {
	m_dynamicsWorld->removeRigidBody(body);
}


btRigidBody* BenchmarkDemo::createRigidBodyMask(
	btScalar mass, const btTransform& startTransform, btCollisionShape* shape, int maskFrom, int maskTo
) {

	//rigidbody is dynamic if and only if mass is non zero, otherwise static
	bool isDynamic = (mass != 0.f);

	btVector3 localInertia(0,0,0);
	if (isDynamic) {
		shape->calculateLocalInertia(mass,localInertia);
	}
		

	//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
	btDefaultMotionState* myMotionState = new btDefaultMotionState(startTransform);
	btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,shape,localInertia);
	btRigidBody* body = new btRigidBody(rbInfo);

	//add the body to the dynamics world 
	m_dynamicsWorld->addRigidBody(body, maskFrom, maskTo); //
	
	return body;
}


void BenchmarkDemo::updateGraphicsObjects() {
	m_guiHelper->autogenerateGraphicsObjects(m_dynamicsWorld);
}


void BenchmarkDemo::beginDrop(float x, float y, float z) {
	initOffset = btVector3(x,y,z);
	createTest5();
	m_guiHelper->autogenerateGraphicsObjects(m_dynamicsWorld);
}

void BenchmarkDemo::initPhysics()
{
	cout << "BenchmarkDemo:initPhysics()\n";
	
	
	m_guiHelper->setUpAxis(2);

	setCameraDistance(btScalar(100.));

	///collision configuration contains default setup for memory, collision setup
	btDefaultCollisionConstructionInfo cci;
	cci.m_defaultMaxPersistentManifoldPoolSize = 32768;
	m_collisionConfiguration = new btDefaultCollisionConfiguration(cci);

	///use the default collision dispatcher. For parallel processing you can use a diffent dispatcher (see Extras/BulletMultiThreaded)
	m_dispatcher = new	btCollisionDispatcher(m_collisionConfiguration);
	
	m_dispatcher->setDispatcherFlags(btCollisionDispatcher::CD_DISABLE_CONTACTPOOL_DYNAMIC_ALLOCATION);



	///the maximum size of the collision world. Make sure objects stay within these boundaries
	///Don't make the world AABB size too large, it will harm simulation quality and performance
	btVector3 worldAabbMin(-16384,-16384,-16384);
	btVector3 worldAabbMax(16384,16384,16384);
	
//	btHashedOverlappingPairCache* pairCache = new btHashedOverlappingPairCache();
//	m_broadphase = new btAxisSweep3(worldAabbMin,worldAabbMax,3500,pairCache);
//	m_broadphase = new btSimpleBroadphase();
	m_broadphase = new btDbvtBroadphase();
	

	///the default constraint solver. For parallel processing you can use a different solver (see Extras/BulletMultiThreaded)
	btSequentialImpulseConstraintSolver* sol = new btSequentialImpulseConstraintSolver;
	
	
	m_solver = sol;

	btDiscreteDynamicsWorld* dynamicsWorld;
	m_dynamicsWorld = dynamicsWorld = new btDiscreteDynamicsWorld(m_dispatcher,m_broadphase,m_solver,m_collisionConfiguration);
	

	///the following 3 lines increase the performance dramatically, with a little bit of loss of quality
	m_dynamicsWorld->getSolverInfo().m_solverMode |=SOLVER_ENABLE_FRICTION_DIRECTION_CACHING; //don't recalculate friction values each frame
	dynamicsWorld->getSolverInfo().m_numIterations = 5; //few solver iterations 
	//m_defaultContactProcessingThreshold = 0.f;//used when creating bodies: body->setContactProcessingThreshold(...);
	m_guiHelper->createPhysicsDebugDrawer(m_dynamicsWorld);
	

	m_dynamicsWorld->setGravity(btVector3(0,0,-10));
	
	
	
	

	// if (m_benchmark<5)
	// {
	// 	///create a few basic rigid bodies
	// 	btCollisionShape* groundShape = new btBoxShape(btVector3(btScalar(250.),btScalar(250.),btScalar(50.)));
	// //	btCollisionShape* groundShape = new btStaticPlaneShape(btVector3(0,1,0),0);
		
	// 	m_collisionShapes.push_back(groundShape);

	// 	btTransform groundTransform;
	// 	groundTransform.setIdentity();
	// 	groundTransform.setOrigin(btVector3(0,0,-50));

	// 	//We can also use DemoApplication::createRigidBody, but for clarity it is provided here:
	// 	{
	// 		btScalar mass(0.);

	// 		//rigidbody is dynamic if and only if mass is non zero, otherwise static
	// 		bool isDynamic = (mass != 0.f);

	// 		btVector3 localInertia(0,0,0);
	// 		if (isDynamic)
	// 			groundShape->calculateLocalInertia(mass,localInertia);

	// 		//using motionstate is recommended, it provides interpolation capabilities, and only synchronizes 'active' objects
	// 		btDefaultMotionState* myMotionState = new btDefaultMotionState(groundTransform);
	// 		btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,groundShape,localInertia);
	// 		btRigidBody* body = new btRigidBody(rbInfo);

	// 		//add the body to the dynamics world
	// 		m_dynamicsWorld->addRigidBody(body);
	// 	}
	// }

	// switch (m_benchmark)
	// {
	// 	case 1:
	// 		{
	// 			createTest1();
	// 			break;
	// 		}
	// 	case 2:
	// 		{
	// 			createTest2();
	// 			break;
	// 		}
	// 	case 3:
	// 		{
	// 			createTest3();
	// 			break;
	// 		}
	// 	case 4:
	// 		{
	// 			createTest4();
	// 			break;
	// 		}
	// 	case 5:
	// 		{
	// 			createTest5();
	// 			break;
	// 		}
	// 	case 6:
	// 	{
	// 		createTest6();
	// 		break;
	// 	}
	// 	case 7:
	// 	{
	// 		createTest7();
	// 		break;
	// 	}
	// 	case 8:
	// 	{
	// 		createTest8();
	// 		break;
	// 	}


	// default:
	// 	{
	// 	}			
	// }

	

}
	

void BenchmarkDemo::createTest1()
{
	// 3000
	int size = 8;
	const float cubeSize = 1.0f;
	float spacing = cubeSize;
	btVector3 pos(0.0f, cubeSize * 2,0.f);
	float offset = -size * (cubeSize * 2.0f + spacing) * 0.5f;

	btBoxShape* blockShape = new btBoxShape(btVector3(cubeSize-COLLISION_RADIUS,cubeSize-COLLISION_RADIUS,cubeSize-COLLISION_RADIUS));
	btVector3 localInertia(0,0,0);
	float mass = 2.f;
	blockShape->calculateLocalInertia(mass,localInertia);
	
	btTransform trans;
	trans.setIdentity();

	for(int k=0;k<47;k++) {
		for(int j=0;j<size;j++) {
			pos[2] = offset + (float)j * (cubeSize * 2.0f + spacing);
			for(int i=0;i<size;i++) {
				pos[0] = offset + (float)i * (cubeSize * 2.0f + spacing);

				trans.setOrigin(pos);
				btRigidBody* cmbody;
				cmbody= createRigidBody(mass,trans,blockShape);
			}
		}
		offset -= 0.05f * spacing * (size-1);
//		spacing *= 1.01f;
		pos[1] += (cubeSize * 2.0f + spacing);
	}
}


///////////////////////////////////////////////////////////////////////////////
// Pyramid 3

void BenchmarkDemo::createWall(const btVector3& offsetPosition,int stackSize,const btVector3& boxSize)
{
	
	btBoxShape* blockShape = new btBoxShape(btVector3(boxSize[0]-COLLISION_RADIUS,boxSize[1]-COLLISION_RADIUS,boxSize[2]-COLLISION_RADIUS));

	float mass = 1.f;
	btVector3 localInertia(0,0,0);
	blockShape->calculateLocalInertia(mass,localInertia);

//	btScalar  diffX = boxSize[0] * 1.0f;
	btScalar  diffY = boxSize[1] * 1.0f;
	btScalar  diffZ = boxSize[2] * 1.0f;

	btScalar  offset = -stackSize * (diffZ * 2.0f) * 0.5f;
	btVector3 pos(0.0f, diffY, 0.0f);

	btTransform trans;
	trans.setIdentity();

	while(stackSize) {
		for(int i=0;i<stackSize;i++) {
			pos[2] = offset + (float)i * (diffZ * 2.0f);

		trans.setOrigin(offsetPosition + pos);
		createRigidBody(mass,trans,blockShape);
		
		}
		offset += diffZ;
		pos[1] += (diffY * 2.0f);
		stackSize--;
	}
}

void BenchmarkDemo::createPyramid(const btVector3& offsetPosition,int stackSize,const btVector3& boxSize)
{
	btScalar space = 0.0001f;
	
	btVector3 pos(0.0f, boxSize[1], 0.0f);

	btBoxShape* blockShape = new btBoxShape(btVector3(boxSize[0]-COLLISION_RADIUS,boxSize[1]-COLLISION_RADIUS,boxSize[2]-COLLISION_RADIUS));
	btTransform trans;
	trans.setIdentity();

	btScalar mass = 1.f;
	btVector3 localInertia(0,0,0);
	blockShape->calculateLocalInertia(mass,localInertia);

	
	btScalar diffX = boxSize[0]*1.02f;
	btScalar diffY = boxSize[1]*1.02f;
	btScalar diffZ = boxSize[2]*1.02f;
	
	btScalar offsetX = -stackSize * (diffX * 2.0f + space) * 0.5f;
	btScalar offsetZ = -stackSize * (diffZ * 2.0f + space) * 0.5f;
	while(stackSize) {
		for(int j=0;j<stackSize;j++) {
			pos[2] = offsetZ + (float)j * (diffZ * 2.0f + space);
			for(int i=0;i<stackSize;i++) {
				pos[0] = offsetX + (float)i * (diffX * 2.0f + space);
				trans.setOrigin(offsetPosition + pos);
				this->createRigidBody(mass,trans,blockShape);


			}
		}
		offsetX += diffX;
		offsetZ += diffZ;
		pos[1] += (diffY * 2.0f + space);
		stackSize--;
	}

}

 const btVector3 rotate( const btQuaternion& quat, const btVector3 & vec ) {
    float tmpX, tmpY, tmpZ, tmpW;
    tmpX = ( ( ( quat.getW() * vec.getX() ) + ( quat.getY() * vec.getZ() ) ) - ( quat.getZ() * vec.getY() ) );
    tmpY = ( ( ( quat.getW() * vec.getY() ) + ( quat.getZ() * vec.getX() ) ) - ( quat.getX() * vec.getZ() ) );
    tmpZ = ( ( ( quat.getW() * vec.getZ() ) + ( quat.getX() * vec.getY() ) ) - ( quat.getY() * vec.getX() ) );
    tmpW = ( ( ( quat.getX() * vec.getX() ) + ( quat.getY() * vec.getY() ) ) + ( quat.getZ() * vec.getZ() ) );
    return btVector3(
        ( ( ( ( tmpW * quat.getX() ) + ( tmpX * quat.getW() ) ) - ( tmpY * quat.getZ() ) ) + ( tmpZ * quat.getY() ) ),
        ( ( ( ( tmpW * quat.getY() ) + ( tmpY * quat.getW() ) ) - ( tmpZ * quat.getX() ) ) + ( tmpX * quat.getZ() ) ),
        ( ( ( ( tmpW * quat.getZ() ) + ( tmpZ * quat.getW() ) ) - ( tmpX * quat.getY() ) ) + ( tmpY * quat.getX() ) )
    );
}

void BenchmarkDemo::createTowerCircle(const btVector3& offsetPosition,int stackSize,int rotSize,const btVector3& boxSize)
{

	btBoxShape* blockShape = new btBoxShape(btVector3(boxSize[0]-COLLISION_RADIUS,boxSize[1]-COLLISION_RADIUS,boxSize[2]-COLLISION_RADIUS));

	btTransform trans;
	trans.setIdentity();

	float mass = 1.f;
	btVector3 localInertia(0,0,0);
	blockShape->calculateLocalInertia(mass,localInertia);


	float radius = 1.3f * rotSize * boxSize[0] / SIMD_PI;

	// create active boxes
	btQuaternion rotY(0,1,0,0);
	float posY = boxSize[1];

	for(int i=0;i<stackSize;i++) {
		for(int j=0;j<rotSize;j++) {
		

			trans.setOrigin(offsetPosition+  rotate(rotY,btVector3(0.0f , posY, radius)));
			trans.setRotation(rotY);
			createRigidBody(mass,trans,blockShape);

			rotY *= btQuaternion(btVector3(0,1,0),SIMD_PI/(rotSize*btScalar(0.5)));
		}

		posY += boxSize[1] * 2.0f;
		rotY *= btQuaternion(btVector3(0,1,0),SIMD_PI/(float)rotSize);
	}
	
}

void BenchmarkDemo::createTest2()
{
	setCameraDistance(btScalar(50.));
	const float cubeSize = 1.0f;

	createPyramid(btVector3(-20.0f,0.0f,0.0f),12,btVector3(cubeSize,cubeSize,cubeSize));
	createWall(btVector3(-2.0f,0.0f,0.0f),12,btVector3(cubeSize,cubeSize,cubeSize));
	createWall(btVector3(4.0f,0.0f,0.0f),12,btVector3(cubeSize,cubeSize,cubeSize));
	createWall(btVector3(10.0f,0.0f,0.0f),12,btVector3(cubeSize,cubeSize,cubeSize));
	createTowerCircle(btVector3(25.0f,0.0f,0.0f),8,24,btVector3(cubeSize,cubeSize,cubeSize));
	
}




class RagDoll
{
	enum
	{
		BODYPART_PELVIS = 0,
		BODYPART_SPINE,
		BODYPART_HEAD,

		BODYPART_LEFT_UPPER_LEG,
		BODYPART_LEFT_LOWER_LEG,

		BODYPART_RIGHT_UPPER_LEG,
		BODYPART_RIGHT_LOWER_LEG,

		BODYPART_LEFT_UPPER_ARM,
		BODYPART_LEFT_LOWER_ARM,

		BODYPART_RIGHT_UPPER_ARM,
		BODYPART_RIGHT_LOWER_ARM,

		BODYPART_COUNT
	};

	enum
	{
		JOINT_PELVIS_SPINE = 0,
		JOINT_SPINE_HEAD,

		JOINT_LEFT_HIP,
		JOINT_LEFT_KNEE,

		JOINT_RIGHT_HIP,
		JOINT_RIGHT_KNEE,

		JOINT_LEFT_SHOULDER,
		JOINT_LEFT_ELBOW,

		JOINT_RIGHT_SHOULDER,
		JOINT_RIGHT_ELBOW,

		JOINT_COUNT
	};

	btDynamicsWorld* m_ownerWorld;
	btCollisionShape* m_shapes[BODYPART_COUNT];
	btRigidBody* m_bodies[BODYPART_COUNT];
	btTypedConstraint* m_joints[JOINT_COUNT];

	btRigidBody* createRigidBody(btScalar mass, const btTransform& startTransform, btCollisionShape* shape)
	{
		bool isDynamic = (mass != 0.f);

		btVector3 localInertia(0,0,0);
		if (isDynamic) {
			shape->calculateLocalInertia(mass,localInertia);
		}
		

		btDefaultMotionState* myMotionState = new btDefaultMotionState(startTransform);
		
		btRigidBody::btRigidBodyConstructionInfo rbInfo(mass,myMotionState,shape,localInertia);
		btRigidBody* body = new btRigidBody(rbInfo);

		m_ownerWorld->addRigidBody(body);

		return body;
	}

public:
	RagDoll (btDynamicsWorld* ownerWorld, const btVector3& positionOffset,btScalar scale)
		: m_ownerWorld (ownerWorld)
	{
		// Setup the geometry
		m_shapes[BODYPART_PELVIS] = new btCapsuleShape(btScalar(0.15)*scale, btScalar(0.20)*scale);
		m_shapes[BODYPART_SPINE] = new btCapsuleShape(btScalar(0.15)*scale, btScalar(0.28)*scale);
		m_shapes[BODYPART_HEAD] = new btCapsuleShape(btScalar(0.10)*scale, btScalar(0.05)*scale);
		m_shapes[BODYPART_LEFT_UPPER_LEG] = new btCapsuleShape(btScalar(0.07)*scale, btScalar(0.45)*scale);
		m_shapes[BODYPART_LEFT_LOWER_LEG] = new btCapsuleShape(btScalar(0.05)*scale, btScalar(0.37)*scale);
		m_shapes[BODYPART_RIGHT_UPPER_LEG] = new btCapsuleShape(btScalar(0.07)*scale, btScalar(0.45)*scale);
		m_shapes[BODYPART_RIGHT_LOWER_LEG] = new btCapsuleShape(btScalar(0.05)*scale, btScalar(0.37)*scale);
		m_shapes[BODYPART_LEFT_UPPER_ARM] = new btCapsuleShape(btScalar(0.05)*scale, btScalar(0.33)*scale);
		m_shapes[BODYPART_LEFT_LOWER_ARM] = new btCapsuleShape(btScalar(0.04)*scale, btScalar(0.25)*scale);
		m_shapes[BODYPART_RIGHT_UPPER_ARM] = new btCapsuleShape(btScalar(0.05)*scale, btScalar(0.33)*scale);
		m_shapes[BODYPART_RIGHT_LOWER_ARM] = new btCapsuleShape(btScalar(0.04)*scale, btScalar(0.25)*scale);

		// Setup all the rigid bodies
		btTransform offset; offset.setIdentity();
		offset.setOrigin(positionOffset);

		btTransform transform;
		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(0.), btScalar(1.), btScalar(0.)));
		m_bodies[BODYPART_PELVIS] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_PELVIS]);

		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(0.), btScalar(1.2), btScalar(0.)));
		m_bodies[BODYPART_SPINE] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_SPINE]);

		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(0.), btScalar(1.6), btScalar(0.)));
		m_bodies[BODYPART_HEAD] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_HEAD]);

		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(-0.18), btScalar(0.65), btScalar(0.)));
		m_bodies[BODYPART_LEFT_UPPER_LEG] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_LEFT_UPPER_LEG]);

		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(-0.18), btScalar(0.2), btScalar(0.)));
		m_bodies[BODYPART_LEFT_LOWER_LEG] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_LEFT_LOWER_LEG]);

		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(0.18), btScalar(0.65), btScalar(0.)));
		m_bodies[BODYPART_RIGHT_UPPER_LEG] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_RIGHT_UPPER_LEG]);

		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(0.18), btScalar(0.2), btScalar(0.)));
		m_bodies[BODYPART_RIGHT_LOWER_LEG] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_RIGHT_LOWER_LEG]);

		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(-0.35), btScalar(1.45), btScalar(0.)));
		transform.getBasis().setEulerZYX(0,0,M_PI_2);
		m_bodies[BODYPART_LEFT_UPPER_ARM] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_LEFT_UPPER_ARM]);

		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(-0.7), btScalar(1.45), btScalar(0.)));
		transform.getBasis().setEulerZYX(0,0,M_PI_2);
		m_bodies[BODYPART_LEFT_LOWER_ARM] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_LEFT_LOWER_ARM]);

		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(0.35), btScalar(1.45), btScalar(0.)));
		transform.getBasis().setEulerZYX(0,0,-M_PI_2);
		m_bodies[BODYPART_RIGHT_UPPER_ARM] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_RIGHT_UPPER_ARM]);

		transform.setIdentity();
		transform.setOrigin(scale*btVector3(btScalar(0.7), btScalar(1.45), btScalar(0.)));
		transform.getBasis().setEulerZYX(0,0,-M_PI_2);
		m_bodies[BODYPART_RIGHT_LOWER_ARM] = createRigidBody(btScalar(1.), offset*transform, m_shapes[BODYPART_RIGHT_LOWER_ARM]);

		// Setup some damping on the m_bodies
		for (int i = 0; i < BODYPART_COUNT; ++i)
		{
			m_bodies[i]->setDamping(btScalar(0.05), btScalar(0.85));
			m_bodies[i]->setDeactivationTime(btScalar(0.8));
			m_bodies[i]->setSleepingThresholds(btScalar(1.6), btScalar(2.5));
		}

		// Now setup the constraints
		btHingeConstraint* hingeC;
		btConeTwistConstraint* coneC;

		btTransform localA, localB;

		localA.setIdentity(); localB.setIdentity();
		localA.getBasis().setEulerZYX(0,M_PI_2,0); localA.setOrigin(scale*btVector3(btScalar(0.), btScalar(0.15), btScalar(0.)));
		localB.getBasis().setEulerZYX(0,M_PI_2,0); localB.setOrigin(scale*btVector3(btScalar(0.), btScalar(-0.15), btScalar(0.)));
		hingeC =  new btHingeConstraint(*m_bodies[BODYPART_PELVIS], *m_bodies[BODYPART_SPINE], localA, localB);
		hingeC->setLimit(btScalar(-M_PI_4), btScalar(M_PI_2));
		m_joints[JOINT_PELVIS_SPINE] = hingeC;
		m_ownerWorld->addConstraint(m_joints[JOINT_PELVIS_SPINE], true);


		localA.setIdentity(); localB.setIdentity();
		localA.getBasis().setEulerZYX(0,0,M_PI_2); localA.setOrigin(scale*btVector3(btScalar(0.), btScalar(0.30), btScalar(0.)));
		localB.getBasis().setEulerZYX(0,0,M_PI_2); localB.setOrigin(scale*btVector3(btScalar(0.), btScalar(-0.14), btScalar(0.)));
		coneC = new btConeTwistConstraint(*m_bodies[BODYPART_SPINE], *m_bodies[BODYPART_HEAD], localA, localB);
		coneC->setLimit(M_PI_4, M_PI_4, M_PI_2);
		m_joints[JOINT_SPINE_HEAD] = coneC;
		m_ownerWorld->addConstraint(m_joints[JOINT_SPINE_HEAD], true);


		localA.setIdentity(); localB.setIdentity();
		localA.getBasis().setEulerZYX(0,0,-M_PI_4*5); localA.setOrigin(scale*btVector3(btScalar(-0.18), btScalar(-0.10), btScalar(0.)));
		localB.getBasis().setEulerZYX(0,0,-M_PI_4*5); localB.setOrigin(scale*btVector3(btScalar(0.), btScalar(0.225), btScalar(0.)));
		coneC = new btConeTwistConstraint(*m_bodies[BODYPART_PELVIS], *m_bodies[BODYPART_LEFT_UPPER_LEG], localA, localB);
		coneC->setLimit(M_PI_4, M_PI_4, 0);
		m_joints[JOINT_LEFT_HIP] = coneC;
		m_ownerWorld->addConstraint(m_joints[JOINT_LEFT_HIP], true);

		localA.setIdentity(); localB.setIdentity();
		localA.getBasis().setEulerZYX(0,M_PI_2,0); localA.setOrigin(scale*btVector3(btScalar(0.), btScalar(-0.225), btScalar(0.)));
		localB.getBasis().setEulerZYX(0,M_PI_2,0); localB.setOrigin(scale*btVector3(btScalar(0.), btScalar(0.185), btScalar(0.)));
		hingeC =  new btHingeConstraint(*m_bodies[BODYPART_LEFT_UPPER_LEG], *m_bodies[BODYPART_LEFT_LOWER_LEG], localA, localB);
		hingeC->setLimit(btScalar(0), btScalar(M_PI_2));
		m_joints[JOINT_LEFT_KNEE] = hingeC;
		m_ownerWorld->addConstraint(m_joints[JOINT_LEFT_KNEE], true);


		localA.setIdentity(); localB.setIdentity();
		localA.getBasis().setEulerZYX(0,0,M_PI_4); localA.setOrigin(scale*btVector3(btScalar(0.18), btScalar(-0.10), btScalar(0.)));
		localB.getBasis().setEulerZYX(0,0,M_PI_4); localB.setOrigin(scale*btVector3(btScalar(0.), btScalar(0.225), btScalar(0.)));
		coneC = new btConeTwistConstraint(*m_bodies[BODYPART_PELVIS], *m_bodies[BODYPART_RIGHT_UPPER_LEG], localA, localB);
		coneC->setLimit(M_PI_4, M_PI_4, 0);
		m_joints[JOINT_RIGHT_HIP] = coneC;
		m_ownerWorld->addConstraint(m_joints[JOINT_RIGHT_HIP], true);

		localA.setIdentity(); localB.setIdentity();
		localA.getBasis().setEulerZYX(0,M_PI_2,0); localA.setOrigin(scale*btVector3(btScalar(0.), btScalar(-0.225), btScalar(0.)));
		localB.getBasis().setEulerZYX(0,M_PI_2,0); localB.setOrigin(scale*btVector3(btScalar(0.), btScalar(0.185), btScalar(0.)));
		hingeC =  new btHingeConstraint(*m_bodies[BODYPART_RIGHT_UPPER_LEG], *m_bodies[BODYPART_RIGHT_LOWER_LEG], localA, localB);
		hingeC->setLimit(btScalar(0), btScalar(M_PI_2));
		m_joints[JOINT_RIGHT_KNEE] = hingeC;
		m_ownerWorld->addConstraint(m_joints[JOINT_RIGHT_KNEE], true);


		localA.setIdentity(); localB.setIdentity();
		localA.getBasis().setEulerZYX(0,0,M_PI); localA.setOrigin(scale*btVector3(btScalar(-0.2), btScalar(0.15), btScalar(0.)));
		localB.getBasis().setEulerZYX(0,0,M_PI_2); localB.setOrigin(scale*btVector3(btScalar(0.), btScalar(-0.18), btScalar(0.)));
		coneC = new btConeTwistConstraint(*m_bodies[BODYPART_SPINE], *m_bodies[BODYPART_LEFT_UPPER_ARM], localA, localB);
		coneC->setLimit(M_PI_2, M_PI_2, 0);
		m_joints[JOINT_LEFT_SHOULDER] = coneC;
		m_ownerWorld->addConstraint(m_joints[JOINT_LEFT_SHOULDER], true);

		localA.setIdentity(); localB.setIdentity();
		localA.getBasis().setEulerZYX(0,M_PI_2,0); localA.setOrigin(scale*btVector3(btScalar(0.), btScalar(0.18), btScalar(0.)));
		localB.getBasis().setEulerZYX(0,M_PI_2,0); localB.setOrigin(scale*btVector3(btScalar(0.), btScalar(-0.14), btScalar(0.)));
		hingeC =  new btHingeConstraint(*m_bodies[BODYPART_LEFT_UPPER_ARM], *m_bodies[BODYPART_LEFT_LOWER_ARM], localA, localB);
		hingeC->setLimit(btScalar(-M_PI_2), btScalar(0));
		m_joints[JOINT_LEFT_ELBOW] = hingeC;
		m_ownerWorld->addConstraint(m_joints[JOINT_LEFT_ELBOW], true);



		localA.setIdentity(); localB.setIdentity();
		localA.getBasis().setEulerZYX(0,0,0); localA.setOrigin(scale*btVector3(btScalar(0.2), btScalar(0.15), btScalar(0.)));
		localB.getBasis().setEulerZYX(0,0,M_PI_2); localB.setOrigin(scale*btVector3(btScalar(0.), btScalar(-0.18), btScalar(0.)));
		coneC = new btConeTwistConstraint(*m_bodies[BODYPART_SPINE], *m_bodies[BODYPART_RIGHT_UPPER_ARM], localA, localB);
		coneC->setLimit(M_PI_2, M_PI_2, 0);
		m_joints[JOINT_RIGHT_SHOULDER] = coneC;
		m_ownerWorld->addConstraint(m_joints[JOINT_RIGHT_SHOULDER], true);

		localA.setIdentity(); localB.setIdentity();
		localA.getBasis().setEulerZYX(0,M_PI_2,0); localA.setOrigin(scale*btVector3(btScalar(0.), btScalar(0.18), btScalar(0.)));
		localB.getBasis().setEulerZYX(0,M_PI_2,0); localB.setOrigin(scale*btVector3(btScalar(0.), btScalar(-0.14), btScalar(0.)));
		hingeC =  new btHingeConstraint(*m_bodies[BODYPART_RIGHT_UPPER_ARM], *m_bodies[BODYPART_RIGHT_LOWER_ARM], localA, localB);
		hingeC->setLimit(btScalar(-M_PI_2), btScalar(0));
		m_joints[JOINT_RIGHT_ELBOW] = hingeC;
		m_ownerWorld->addConstraint(m_joints[JOINT_RIGHT_ELBOW], true);
	}

	virtual	~RagDoll ()
	{
		int i;

		// Remove all constraints
		for ( i = 0; i < JOINT_COUNT; ++i)
		{
			m_ownerWorld->removeConstraint(m_joints[i]);
			delete m_joints[i]; m_joints[i] = 0;
		}

		// Remove all bodies and shapes
		for ( i = 0; i < BODYPART_COUNT; ++i)
		{
			m_ownerWorld->removeRigidBody(m_bodies[i]);
			
			delete m_bodies[i]->getMotionState();

			delete m_bodies[i]; m_bodies[i] = 0;
			delete m_shapes[i]; m_shapes[i] = 0;
		}
	}
};

void BenchmarkDemo::createTest3()
{
	setCameraDistance(btScalar(50.));

	int size = 16;

	float sizeX = 1.f;
	float sizeY = 1.f;

	//int rc=0;

	btScalar scale(3.5);
	btVector3 pos(0.0f, sizeY, 0.0f);
	while(size) {
		float offset = -size * (sizeX * 6.0f) * 0.5f;
		for(int i=0;i<size;i++) {
			pos[0] = offset + (float)i * (sizeX * 6.0f);

				RagDoll* ragDoll = new RagDoll (m_dynamicsWorld,pos,scale);
				m_ragdolls.push_back(ragDoll);
		}

		offset += sizeX;
		pos[1] += (sizeY * 7.0f);
		pos[2] -= sizeX * 2.0f;
		size--;
	}

}
void BenchmarkDemo::createTest4()
{
	setCameraDistance(btScalar(50.));

	int size = 8;
	const float cubeSize = 1.5f;
	float spacing = cubeSize;
	btVector3 pos(0.0f, cubeSize * 2, 0.0f);
	float offset = -size * (cubeSize * 2.0f + spacing) * 0.5f;

	btConvexHullShape* convexHullShape = new btConvexHullShape();

	btScalar scaling(1);

	convexHullShape->setLocalScaling(btVector3(scaling,scaling,scaling));

	for (int i=0;i<TaruVtxCount;i++)
	{
		btVector3 vtx(TaruVtx[i*3],TaruVtx[i*3+1],TaruVtx[i*3+2]);
		convexHullShape->addPoint(vtx*btScalar(1./scaling));
	}

	//this will enable polyhedral contact clipping, better quality, slightly slower
	//convexHullShape->initializePolyhedralFeatures();

	btTransform trans;
	trans.setIdentity();

	float mass = 1.f;
	btVector3 localInertia(0,0,0);
	convexHullShape->calculateLocalInertia(mass,localInertia);

	for(int k=0;k<15;k++) {
		for(int j=0;j<size;j++) {
			pos[2] = offset + (float)j * (cubeSize * 2.0f + spacing);
			for(int i=0;i<size;i++) {
				pos[0] = offset + (float)i * (cubeSize * 2.0f + spacing);
				trans.setOrigin(pos);
				createRigidBody(mass,trans,convexHullShape);		
			}
		}
		offset -= 0.05f * spacing * (size-1);
		spacing *= 1.01f;
		pos[1] += (cubeSize * 2.0f + spacing);
	}
}


///////////////////////////////////////////////////////////////////////////////
// LargeMesh

// int LandscapeVtxCount[] = {
// 	Landscape01VtxCount,
// 	Landscape02VtxCount,
// 	Landscape03VtxCount,
// 	Landscape04VtxCount,
// 	Landscape05VtxCount,
// 	Landscape06VtxCount,
// 	Landscape07VtxCount,
// 	Landscape08VtxCount,
// };

// int LandscapeIdxCount[] = {
// 	Landscape01IdxCount,
// 	Landscape02IdxCount,
// 	Landscape03IdxCount,
// 	Landscape04IdxCount,
// 	Landscape05IdxCount,
// 	Landscape06IdxCount,
// 	Landscape07IdxCount,
// 	Landscape08IdxCount,
// };

// btScalar *LandscapeVtx[] = {
// 	Landscape01Vtx,
// 	Landscape02Vtx,
// 	Landscape03Vtx,
// 	Landscape04Vtx,
// 	Landscape05Vtx,
// 	Landscape06Vtx,
// 	Landscape07Vtx,
// 	Landscape08Vtx,
// };

// btScalar *LandscapeNml[] = {
// 	Landscape01Nml,
// 	Landscape02Nml,
// 	Landscape03Nml,
// 	Landscape04Nml,
// 	Landscape05Nml,
// 	Landscape06Nml,
// 	Landscape07Nml,
// 	Landscape08Nml,
// };

// btScalar* LandscapeTex[] = {
// 	Landscape01Tex,
// 	Landscape02Tex,
// 	Landscape03Tex,
// 	Landscape04Tex,
// 	Landscape05Tex,
// 	Landscape06Tex,
// 	Landscape07Tex,
// 	Landscape08Tex,
// };

// unsigned short  *LandscapeIdx[] = {
// 	Landscape01Idx,
// 	Landscape02Idx,
// 	Landscape03Idx,
// 	Landscape04Idx,
// 	Landscape05Idx,
// 	Landscape06Idx,
// 	Landscape07Idx,
// 	Landscape08Idx,
// };

// void BenchmarkDemo::createLargeMeshBody()
// {
// 	btTransform trans;
// 	trans.setIdentity();

// 	for(int i=0;i<8;i++) {

// 		btTriangleIndexVertexArray* meshInterface = new btTriangleIndexVertexArray();
// 		btIndexedMesh part;

// 		part.m_vertexBase = (const unsigned char*)LandscapeVtx[i];
// 		part.m_vertexStride = sizeof(btScalar) * 3;
// 		part.m_numVertices = LandscapeVtxCount[i];
// 		part.m_triangleIndexBase = (const unsigned char*)LandscapeIdx[i];
// 		part.m_triangleIndexStride = sizeof( short) * 3;
// 		part.m_numTriangles = LandscapeIdxCount[i]/3;
// 		part.m_indexType = PHY_SHORT;

// 		meshInterface->addIndexedMesh(part,PHY_SHORT);

// 		bool	useQuantizedAabbCompression = true;
// 		btBvhTriangleMeshShape* trimeshShape = new btBvhTriangleMeshShape(meshInterface,useQuantizedAabbCompression);
// 		btVector3 localInertia(0,0,0);
// 		trans.setOrigin(btVector3(0,-25,0));

// 		btRigidBody* body = createRigidBody(0,trans,trimeshShape);
// 		body->setFriction (btScalar(0.9));
		
// 	}
	
// }


void BenchmarkDemo::createTest5()
{
	//setCameraDistance(btScalar(250.));
	btVector3 boxSize(1.5f,1.5f,1.5f);
	float boxMass = 1.0f;
	float sphereRadius = 1.5f;
	float sphereMass = 1.0f;
	float capsuleHalf = 2.0f;
	float capsuleRadius = 1.0f;
	float capsuleMass = 1.0f;

	btRigidBody* tempBody = NULL;

	{
		int size = 10;
		int height = 10;

		const float cubeSize = boxSize[0];
		float spacing = 2.0f;
		btVector3 pos(0.0f, 0.0f, 20.0f);
		float offset = -size * (cubeSize * 2.0f + spacing) * 0.5f;
		
		int numBodies = 0;

		for(int k=0;k<height;k++) {
			for(int j=0;j<size;j++) {
				pos[1] = offset + (float)j * (cubeSize * 2.0f + spacing);
				for(int i=0;i<size;i++) {
					pos[0] = offset + (float)i * (cubeSize * 2.0f + spacing);
					btVector3 bpos = btVector3(0,0,300) + btVector3(5.0f,5.0f,1.0f)*pos + initOffset;
					int idx = rand() % 9;
					btTransform trans;
					trans.setIdentity();
					trans.setOrigin(bpos);

					switch(idx) {
						case 0:case 1:case 2:
						{
							float r = 0.5f * (idx+1);
							btBoxShape* boxShape = new btBoxShape(boxSize*r);
							tempBody = createRigidBody(boxMass*r,trans,boxShape);
						}
						break;

						case 3:case 4:case 5:
						{
							float r = 0.5f * (idx-3+1);
							btSphereShape* sphereShape = new btSphereShape(sphereRadius*r);
							tempBody = createRigidBody(sphereMass*r,trans,sphereShape);
						}
						break;

						case 6:case 7:case 8:
						{
							float r = 0.5f * (idx-6+1);
							btCapsuleShape* capsuleShape = new btCapsuleShape(capsuleRadius*r,capsuleHalf*r);
							tempBody = createRigidBody(capsuleMass*r,trans,capsuleShape);
						}
						break;
					}
					
					tempBody->bodyUID = -1;
					tempBody->limbUID = -1;
					
					numBodies++;
				}
			}
			offset -= 0.05f * spacing * (size-1);
			spacing *= 1.1f;
			pos[1] += (cubeSize * 2.0f + spacing);
		}
	}

	//createLargeMeshBody();
}
void BenchmarkDemo::createTest6()
{
	setCameraDistance(btScalar(250.));

	btVector3 boxSize(1.5f,1.5f,1.5f);

	btConvexHullShape* convexHullShape = new btConvexHullShape();

	for (int i=0;i<TaruVtxCount;i++)
	{
		btVector3 vtx(TaruVtx[i*3],TaruVtx[i*3+1],TaruVtx[i*3+2]);
		convexHullShape->addPoint(vtx);
	}

	btTransform trans;
	trans.setIdentity();

	float mass = 1.f;
	btVector3 localInertia(0,0,0);
	convexHullShape->calculateLocalInertia(mass,localInertia);


	{
		int size = 10;
		int height = 10;

		const float cubeSize = boxSize[0];
		float spacing = 2.0f;
		btVector3 pos(0.0f, 20.0f, 0.0f);
		float offset = -size * (cubeSize * 2.0f + spacing) * 0.5f;
		
	
		for(int k=0;k<height;k++) {
			for(int j=0;j<size;j++) {
				pos[2] = offset + (float)j * (cubeSize * 2.0f + spacing);
				for(int i=0;i<size;i++) {
					pos[0] = offset + (float)i * (cubeSize * 2.0f + spacing);
					btVector3 bpos = btVector3(0,25,0) + btVector3(5.0f,1.0f,5.0f)*pos;
					trans.setOrigin(bpos);
					
					createRigidBody(mass,trans,convexHullShape);
				}
			}
			offset -= 0.05f * spacing * (size-1);
			spacing *= 1.1f;
			pos[1] += (cubeSize * 2.0f + spacing);
		}
	}


	//createLargeMeshBody();
}


void BenchmarkDemo::initRays()
{
	raycastBar = btRaycastBar2 (2500.0, 0,50.0,m_guiHelper);
}



void BenchmarkDemo::castRays()
{
	raycastBar.cast (m_dynamicsWorld);
}

void BenchmarkDemo::createTest7()
{
	
	createTest6();
	setCameraDistance(btScalar(150.));
	initRays();
}


void BenchmarkDemo::createTest8()
{
	setCameraDistance(btScalar(250.));
	btVector3 boxSize(1.5f,1.5f,1.5f);
	float boxMass = 1.0f;
	float sphereRadius = 1.5f;
	float sphereMass = 1.0f;
	float capsuleHalf = 2.0f;
	float capsuleRadius = 1.0f;
	float capsuleMass = 1.0f;

	{
		int size = 10;
		int height = 10;

		const float cubeSize = boxSize[0];
		float spacing = 2.0f;
		btVector3 pos(0.0f, 20.0f, 0.0f);
		float offset = -size * (cubeSize * 2.0f + spacing) * 0.5f;
		
		int numBodies = 0;

		for(int k=0;k<height;k++) {
			for(int j=0;j<size;j++) {
				pos[2] = offset + (float)j * (cubeSize * 2.0f + spacing);
				for(int i=0;i<size;i++) {
					pos[0] = offset + (float)i * (cubeSize * 2.0f + spacing);
					btVector3 bpos = btVector3(0,25,0) + btVector3(5.0f,1.0f,5.0f)*pos;
					int idx = rand() % 9;
					btTransform trans;
					trans.setIdentity();
					trans.setOrigin(bpos);

					switch(idx) {
						case 0:case 1:case 2:
						{
							float r = 0.5f * (idx+1);
							btBoxShape* boxShape = new btBoxShape(boxSize*r);
							createRigidBody(boxMass*r,trans,boxShape);
						}
						break;

						case 3:case 4:case 5:
						{
							float r = 0.5f * (idx-3+1);
							btSphereShape* sphereShape = new btSphereShape(sphereRadius*r);
							createRigidBody(sphereMass*r,trans,sphereShape);
						}
						break;

						case 6:case 7:case 8:
						{
							float r = 0.5f * (idx-6+1);
							btCapsuleShape* capsuleShape = new btCapsuleShape(capsuleRadius*r,capsuleHalf*r);
							createRigidBody(capsuleMass*r,trans,capsuleShape);
						}
						break;
					}

					numBodies++;
				}
			}
			offset -= 0.05f * spacing * (size-1);
			spacing *= 1.1f;
			pos[1] += (cubeSize * 2.0f + spacing);
		}
	}

	//createLargeMeshBody();
}


void BenchmarkDemo::exitPhysics()
{
	int i;

	for (i=0;i<m_ragdolls.size();i++)
	{
		RagDoll* doll = m_ragdolls[i];
		delete doll;
	}
	m_ragdolls.clear();

	CommonRigidBodyBase::exitPhysics();

	
}



btVector3 NET_MASKS[256];
void initNetMasks() {
	btVector3 nmDirs[8];
	
	int i;
	int j;
	int k;
	
	int ii;
	int jj;
	int kk;
	
	int tot;
	
	for (i = 0; i < 256; i++) {
		NET_MASKS[i] = btVector3(0.0f,0.0f,0.0f);
	}
	
	
	for (k = -1; k <= 1; k += 2) {
		for (j = -1; j <= 1; j += 2) {
			for (i = -1; i <= 1; i += 2) {
				ii = (i + 1)/2;
				jj = (j + 1)/2;
				kk = (k + 1)/2;
				
				nmDirs[ii+jj*2+kk*4] = btVector3(i,j,k);
				
			}	
		}
	}
	
	for (i = 0; i < 8; i++) {
		nmDirs[i].normalize();
	}
	
	
	for (i = 0; i < 256; i++) {
		tot = 0;
		for (j = 0; j < 8; j++) {
			if ((i&(1<<j)) > 0) {
				NET_MASKS[i] += nmDirs[j];
				tot++;
			}
		}
		
		if (
			(
				abs(NET_MASKS[i].getX()) +
				abs(NET_MASKS[i].getY()) +
				abs(NET_MASKS[i].getZ())		
			) == 0.0
		) {
			NET_MASKS[i] = btVector3(0.0f,0.0f,0.0f);
		}
		else {
			NET_MASKS[i].normalize();
			
			 // sqrt(0.5)/2 //0.35355339059f
			
			switch (tot) {
				
				case 1:
				case 7:
					NET_MASKS[i] = NET_MASKS[i] * (1.0f-0.43301270189f);//1.73205080757f / 4.0f; // sqrt(3)/4
				break;
				case 2:
				case 6:
					NET_MASKS[i] = NET_MASKS[i] * 1.41421356237f / 4.0f; // sqrt(2)/4
				break;
				// case 3:
				// 	NET_MASKS[i] = NET_MASKS[i] * -(1.0f-0.43301270189f);
				// break;
				default:
					NET_MASKS[i] = btVector3(0.0f,0.0f,0.0f);
				break;
				
			}
			
			if (tot > 4) {
				NET_MASKS[i] = -(NET_MASKS[i]);
			}
			
		}
		
		
		
		
		
	}
	
	
}

bool replaceStr(std::string& str, const std::string& from, const std::string& to) {
    size_t start_pos = str.find(from);
    if(start_pos == std::string::npos)
        return false;
    str.replace(start_pos, from.length(), to);
    return true;
}

// struct CommonExampleInterface*    BenchmarkCreateFunc(struct CommonExampleOptions& options)
// {
// 	return new BenchmarkDemo(options.m_guiHelper,options.m_option);
// }







 


#define DO_DESCRIPTION(e)  #e,
#define DO_ENUM(e)  e,


// const static unsigned long int SPEEDUP_FACTOR = 4;
// const static unsigned long int STEP_TIME_IN_MICRO_SEC = 32000;

#define E_CONST(DDD) \
DDD(E_CONST_TURNBASED_TICKS) \
DDD(E_CONST_JUMP_COOLDOWN_MAX) \
DDD(E_CONST_HIT_COOLDOWN_MAX) \
DDD(E_CONST_TBSNAP_MULT) \
DDD(E_CONST_TBSNAP_ZOFFSET) \
DDD(E_CONST_BINDING_MULT) \
DDD(E_CONST_AIRANIM_THRESH) \
DDD(E_CONST_MIN_WALK_ANIM_VEL) \
DDD(E_CONST_WALKANIM_LERP_MOD) \
DDD(E_CONST_WALKANIM_INTERVAL_MOD) \
DDD(E_CONST_VEL_STOP_THRESH) \
DDD(E_CONST_BINDING_POW_MAX) \
DDD(E_CONST_COLDEPTH_WALL_XY) \
DDD(E_CONST_COLDEPTH_WALL_Z) \
DDD(E_CONST_WALL_RESIST) \
DDD(E_CONST_WALKANIM_THRESH) \
DDD(E_CONST_NOR_PUSH) \
DDD(E_CONST_ZDAMP_GROUND) \
DDD(E_CONST_DEFAULT_GRAVITY) \
DDD(E_CONST_PHYS_STEPS_PER_FRAME) \
DDD(E_CONST_STEP_TIME_IN_MICRO_SEC) \
DDD(E_CONST_BINDING_POW_INC) \
DDD(E_CONST_BINDING_POW_ON_HIT) \
DDD(E_CONST_BINDING_POW_ON_DEATH) \
DDD(E_CONST_HALF_OFFSET) \
DDD(E_CONST_CAM_LERP_AMOUNT) \
DDD(E_CONST_REM_DIS_THRESH) \
DDD(E_CONST_THROW_STRENGTHXY) \
DDD(E_CONST_THROW_STRENGTHZ) \
DDD(E_CONST_COL_SOUND_THRESH) \
DDD(E_CONST_SWING_DELAY) \
DDD(E_CONST_TIMEINTERVAL_MULT) \
DDD(E_CONST_ANIMLERP_MULT) \
DDD(E_CONST_AI_SEEK_THRESH) \
DDD(E_CONST_AI_REPEL_THRESH) \
DDD(E_CONST_ANGDAMP) \
DDD(E_CONST_ANTIGRAV) \
DDD(E_CONST_COLDEPTH_LIMB) \
DDD(E_CONST_COLDEPTH_CONT) \
DDD(E_CONST_PUSH_UP_AMOUNT) \
DDD(E_CONST_AIR_RESIST) \
DDD(E_CONST_WALKING_FRIC) \
DDD(E_CONST_STANDING_FRIC) \
DDD(E_CONST_WALKING_GRAV) \
DDD(E_CONST_JUMP_AMOUNT) \
DDD(E_CONST_TURN_AMOUNT) \
DDD(E_CONST_WALK_AMOUNT_AIR) \
DDD(E_CONST_WALK_AMOUNT) \
DDD(E_CONST_WALK_UP_AMOUNT) \
DDD(E_CONST_LIMB_IMPULSE) \
DDD(E_CONST_HIT_STRENGTH) \
DDD(E_CONST_DASH_AMOUNT) \
DDD(E_CONST_DASH_UP_AMOUNT) \
DDD(E_CONST_MAPFREQ0) \
DDD(E_CONST_MAPFREQ1) \
DDD(E_CONST_MAPFREQ2) \
DDD(E_CONST_MAPFREQ3) \
DDD(E_CONST_MAPAMP0) \
DDD(E_CONST_MAPAMP1) \
DDD(E_CONST_MAPAMP2) \
DDD(E_CONST_MAPAMP3) \
DDD(E_CONST_LENGTH)


string E_CONST_STRINGS[] = {
	E_CONST(DO_DESCRIPTION)
};

enum E_CONST_VALS {
	E_CONST(DO_ENUM)
};


enum E_GUI_DATA_STRINGS {
	E_GDS_DATA_SOURCE,
	E_GDS_DATA_FILE,
	//E_GDS_CHILD_TYPE,
	E_GDS_CHILD_NAME,
	E_GDS_MATERIAL,
	E_GDS_LAST_KEY,
	E_GDS_LENGTH
};

enum E_PERFORMANCE_PROFILE {
	E_PP_FAST_LOWRES,
	E_PP_SCROLLING,
	E_PP_HIGHQUALITY,
	E_PP_FAST_MODIFICATION,
	E_PP_TERRAIN_MODIFICATION,
	E_PP_ENTITY,
	E_PP_LENGTH
};



enum E_PRIM_TYPE_TER {
	E_PTT_TER,
	E_PTT_WAT,
	E_PTT_LST,
	E_PTT_EMP,
	E_PTT_LENGTH
};



enum E_PRIM_TYPE_EXT {
	E_PTT_IDE,
	E_PTT_STB,
	E_PTT_BLD,
	E_PTT_RS1,
	E_EXT_LENGTH
};

enum E_THREAD_TYPE {
	E_TT_GENPATHS,
	E_TT_GENLIST,
	E_TT_LENGTH
};

enum E_DRAG_TYPE {
	E_DT_NOTHING, // can drag to, but not from
	E_DT_WORLD_OBJECT,
	E_DT_INV_OBJECT,
	E_DT_INV_OBJECT_PARENT,
	E_DT_LENGTH
};

enum E_VOCAB {
	E_VC_FLOAT,
	E_VC_IFTHEN,
	E_VC_ALL,
	E_VC_ANY,
	E_VC_NONE,
	E_VC_LIST,
	E_VC_EQUAL,
	E_VC_NOTEQUAL,
	E_VC_ISBETWEEN,
	E_VC_LENGTH	
};

enum E_VOCAB_TYPE {
	
	E_VCT_FLOAT, // terminal
	E_VCT_NOUN, // terminal
	E_VCT_OPERATOR,
	E_VCT_VARIABLE,
	E_VCT_PREDICATE,
	E_VCT_LENGTH
};

struct FluidPlane {
	std::vector<int> planeIds;
};

struct FluidStruct {
	int minX;
	int minY;
	int minZ;
	
	int maxX;
	int maxY;
	int maxZ;
	
	int id;
	long long int collectedWater;
	
	bool didCollectWater;
	
	int fidBegInd;
	int fidEndInd;
	
	int iciBegInd;
	int iciEndInd;
	
};

struct VToken
{
	int index;
	int type;
	int maxParam;
	float floatValue;
	string stringValue;
};

enum E_FLUID_IDS {
	//E_FID_SML,
	E_FID_BIG,
	//E_FID_MIP,
	E_FID_LENGTH	
};

string globString;


int NUM_POLY_STRINGS = 0;
string polyFBOStrings[] = {
	"polyFBO0",
	"polyFBO1",
	"polyFBO2",
	"polyFBO3",
	"polyFBO4"
};

string dragStrings[] = {
	"E_DT_NOTHING",
	"E_DT_WORLD_OBJECT",
	"E_DT_INV_OBJECT",
	"E_DT_INV_OBJECT_PARENT",
	"E_DT_LENGTH"
};


const static int NA_SIZE_IN_BYTES = 32;

struct NetworkAction {
	char data[NA_SIZE_IN_BYTES];
};

enum E_NET_OPS {
	E_NO_TERMINAL,
	E_NO_KEY_ACTION,
	E_NO_ADD_ENT,
	E_NO_REM_ENT,
	E_NO_DRAG_ENT,
	E_NO_LENGTH	
};


enum E_ITEM_CLASS {
	E_IC_NONE,
	E_IC_EQ_HEAD,
	E_IC_EQ_NECK,
	E_IC_EQ_BACK,
	E_IC_EQ_TORSO,
	E_IC_WAIST,
	E_IC_EQ_WRISTS,
	E_IC_EQ_HANDS,
	E_IC_EQ_FINGERS,
	E_IC_EQ_HOLDING,
	E_IC_EQ_FEET,
	E_IC_RESOURCE,
	E_IC_CONSUMABLE,
	E_IC_MISC,
	E_IC_LENGTH,
};

// enum E_TOOL_CLASS {
// 	E_TC_NONE,
// 	E_TC_SWORD,
// 	E_TC_AXE,
// 	E_TC_WAND,
// 	E_TC_BOW,
// 	E_TC_,
// 	E_TC_,
// 	E_TC_,
// 	E_TC_,
// 	E_TC_,
// 	E_TC_,
// 	E_TC_,
// 	E_TC_,
// 	E_TC_,
// 	E_IC_LENGTH,
// };

enum E_VOLUME_WRAPPERS {
	//E_VW_TERGEN,
	E_VW_HOLDER,
	E_VW_WORLD,
	E_VW_VORO,
	E_VW_LENGTH
};

// string volumeWrapperStrings[] = {
// 	"E_VW_TERGEN",
// 	"E_VW_HOLDER",
// 	"E_VW_VORO",
// 	"E_VW_LENGTH"
// };



const static int MAX_STAT_VALUE = 10;

#define E_CHAR_STAT(DDD) \
DDD(E_CS_STRENGTH) \
DDD(E_CS_DEXTERITY) \
DDD(E_CS_AGILITY) \
DDD(E_CS_INTELLIGENCE) \
DDD(E_CS_DISCIPLINE) \
DDD(E_CS_CHARISMA) \
DDD(E_CS_LENGTH)

string E_CHAR_STAT_STRINGS[] = {
	E_CHAR_STAT(DO_DESCRIPTION)
};

enum E_CHAR_STAT_VALS {
	E_CHAR_STAT(DO_ENUM)
};

#define E_CHAR_STATUS(DDD) \
DDD(E_STATUS_HEALTH) \
DDD(E_STATUS_STAMINA) \
DDD(E_STATUS_MANA) \
DDD(E_STATUS_FOCUS) \
DDD(E_STATUS_SPIRIT) \
DDD(E_STATUS_LENGTH)

string E_CHAR_STATUS_STRINGS[] = {
	E_CHAR_STATUS(DO_DESCRIPTION)
};

enum E_CHAR_STATUS_VALS {
	E_CHAR_STATUS(DO_ENUM)
};




// #define E_TB_ACTION(DDD) \
// DDD(E_TBA_) \
// DDD(E_TBA_) \
// DDD(E_TBA_) \
// DDD(E_TBA_) \
// DDD(E_TBA_) \
// DDD(E_TBA_)

// string E_TB_ACTION_STRINGS[] = {
// 	E_TB_ACTION(DO_DESCRIPTION)
// };

// enum E_TB_ACTION_VALS {
// 	E_TB_ACTION(DO_ENUM)
// };


#define E_GUI_CHILD_TYPE(DDD) \
DDD(E_GCT_INV_ITEM) \
DDD(E_GCT_SHADER_PARAM) \
DDD(E_GCT_GENERIC) \
DDD(E_GCT_CONTAINER) \
DDD(E_GCT_CONTAINER_PARENT) \
DDD(E_GCT_AUTOMATIC) \
DDD(E_GCT_LENGTH)

string E_GUI_CHILD_TYPE_STRINGS[] = {
	E_GUI_CHILD_TYPE(DO_DESCRIPTION)
};

enum E_GUI_CHILD_TYPE_VALS {
	E_GUI_CHILD_TYPE(DO_ENUM)
};




// // do not reorder
// // childType
// enum E_GUI_CHILD_TYPES {
// 	E_GCT_INV_ITEM,			// 0
// 	E_GCT_SHADER_PARAM,		// 1
// 	E_GCT_GENERIC, 			// 2
// 	E_GCT_CONTAINER,		// 3
// 	E_GCT_CONTAINER_PARENT, // 4
// 	E_GCT_STATS, 			// 6
// 	E_GCT_LENGTH			// 5
// };

enum E_CLOSEST_FLAGS {
	E_CF_NOTGRABBED = 1,
	E_CF_AREENEMIES = 2,
	E_CF_AREFRIENDS = 4,
	E_CF_ISALIVE = 8
	// E_CF_ = 8,
	// E_CF_ = 16,
	// E_CF_ = 32,
	// E_CF_ = 64
	
};

enum E_FONT_WRAPPERS {
	EFW_TEXT,
	EFW_ICONS,
	EFW_LENGTH
};

enum E_MOVE_TYPES {
	E_MT_NONE,
	E_MT_RELATIVE,
	E_MT_TRACKBALL,
	E_MT_LENGTH
};

enum eProgramState {
	E_PS_MENU,
	E_PS_IN_GAME,
	E_PS_SIZE
};

enum eProgramAction {
	E_PA_QUIT,
	E_PA_TOGGLE_FULLSCREEN,
	E_PA_REFRESH,
	E_PA_SIZE
};

enum E_TEX_TYPE {
	E_TEX_TYPE_NOISE
};

enum E_RENDER_METHODS {
	E_RENDER_NONE,
	E_RENDER_VOL,
	E_RENDER_LENGTH
};

enum E_KEYMAP {
	KEYMAP_UP,
	KEYMAP_DOWN,
	KEYMAP_FORWARD,
	KEYMAP_BACKWARD,
	KEYMAP_LEFT,
	KEYMAP_RIGHT,
	KEYMAP_FIRE_PRIMARY,
	KEYMAP_GRAB,
	KEYMAP_THROW,
	KEYMAP_LENGTH
};

// do not rearrange
enum ENT_TYPE {
	E_ENTTYPE_NPC,
	E_ENTTYPE_WEAPON,
	E_ENTTYPE_OBJ,
	E_ENTTYPE_BULLET,
	E_ENTTYPE_TRACE,
	E_ENTTYPE_DEBRIS,
	E_ENTTYPE_LENGTH
};

enum ENT_SUBTYPE {
	
	E_ENTSUB_LENGTH
};

enum E_STATES {
	E_STATE_INIT_LAUNCH,
	E_STATE_INIT_BEG,
	E_STATE_INIT_END,
	E_STATE_CREATESIMPLEXNOISE_LAUNCH,
	E_STATE_CREATESIMPLEXNOISE_BEG,
	E_STATE_CREATESIMPLEXNOISE_END,
	E_STATE_NEIGHBORSREADY_LAUNCH,
	E_STATE_NEIGHBORSREADY_BEG,
	E_STATE_NEIGHBORSREADY_END,
	E_STATE_COPYTOTEXTURE_LAUNCH,
	E_STATE_COPYTOTEXTURE_BEG,
	E_STATE_COPYTOTEXTURE_END,
	E_STATE_GENERATEVOLUME_LAUNCH,
	E_STATE_GENERATEVOLUME_BEG,
	E_STATE_GENERATEVOLUME_END,
	E_STATE_WAIT,
	E_STATE_LENGTH

};

enum EVENT_OPS {
	EV_COLLISION,
	EV_LENGTH	
};

// enum E_UI_LIST {
// 	E_UL_FB_MEM,
// 	E_UL_CHUNK_MEM,
// 	E_UL_TOT_MEM,
// 	E_UL_LENGTH
// };

// enum E_UI_LIST {
// 	E_UL_FB_MEM,
// 	E_UL_CHUNK_MEM,
// 	E_UL_TOT_MEM,
// 	E_UL_LENGTH
// };


// enum E_ENTPOOL {
// 	E_ENTPOOL_BULLET,
// 	E_ENTPOOL_TRACE,
// 	E_ENTPOOL_LENGTH
// };



#define E_PATTERN_TYPE(DDD) \
DDD(E_PAT_1X1SQUARE) \
DDD(E_PAT_3X3SQUARE) \
DDD(E_PAT_5X5SQUARE) \
DDD(E_PAT_1X1DIAMOND) \
DDD(E_PAT_3X3DIAMOND) \
DDD(E_PAT_5X5DIAMOND) \
DDD(E_PAT_LENGTH)

string E_PATTERN_TYPE_STRINGS[] = {
	E_PATTERN_TYPE(DO_DESCRIPTION)
};

enum E_PATTERN_TYPE_VALS {
	E_PATTERN_TYPE(DO_ENUM)
};

enum PATTERN_SHAPES {
	E_PATSHAPE_SQUARE,
	E_PATSHAPE_DIAMOND,
	E_PATSHAPE_LENGTH
};

const static int PATTERN_SIZE = 5;
const static int PATTERN_CENTER = (PATTERN_SIZE/2);

struct PatternStruct {
	int addPat;
	int addX;
	int addY;
	
	int subPat;
	int subX;
	int subY;
	
	float patternVals[PATTERN_SIZE*PATTERN_SIZE];
};

struct DebrisStruct {
	btVector3 pos;
};

struct ExplodeStruct {
	btVector3 pos;
	float radius;
	float power;	
};

struct EntPool {
	int curIndex;
	int maxCount;
	int entType;
	std::vector<int> entIds;
};

struct KeyStackEvent {
	unsigned char key;
	bool keyDown;
	int x;
	int y;
};

enum E_TER_TYPE {
	E_TER_GROUNDLEVEL,
	E_TER_UNDERGROUND,
	E_TER_AIR,
	E_TER_LENGTH
};

enum E_LAYER_TYPE {
	E_LAYER_SOLID,
	E_LAYER_TRANS,
	E_LAYER_NULL, // must be last
	E_LAYER_LENGTH
};


enum E_MOUSE_STATE {
	E_MOUSE_STATE_MOVE,
	E_MOUSE_STATE_BRUSH,
	E_MOUSE_STATE_PICKING,
	E_MOUSE_STATE_LENGTH
};
string mouseStateStrings[] = {
	"E_MOUSE_STATE_MOVE",
	"E_MOUSE_STATE_BRUSH",
	"E_MOUSE_STATE_PICKING",
	"E_MOUSE_STATE_LENGTH"
};

enum E_BRUSH {
	E_BRUSH_ADD,
	E_BRUSH_SUB,
	E_BRUSH_REF,
	E_BRUSH_MOVE,
	E_BRUSH_LENGTH
};

enum E_HOLDER_ACTION {
	E_HOLDER_ACTION_RENDER,
	E_HOLDER_ACTION_REDRAW_CHILDREN,
	E_HOLDER_ACTION_RESET,
	E_HOLDER_ACTION_LENGTH
};

enum E_PLANE_TYPES {
	E_PLANE_XY,
	E_PLANE_YZ,
	E_PLANE_XZ,
	E_PLANE_LENGTH
};

// enum E_GRASS_STATE {
//     E_GRASS_STATE_OFF,
//     E_GRASS_STATE_ON,
//     E_GRASS_STATE_ANIM,
//     E_GRASS_STATE_LENGTH
// };

enum E_FILL_STATE {
	E_FILL_STATE_EMPTY,
	E_FILL_STATE_PARTIAL,
	E_FILL_STATE_FULL,
};

enum E_PLANT_TYPES {
	E_PT_OAK_TRUNK,
	E_PT_OAK_ROOTS,
	E_PT_OAK2_TRUNK,
	E_PT_OAK2_ROOTS,
	E_PT_BARE_OAK_TRUNK,
	E_PT_BARE_OAK_ROOTS,
	E_PT_LENGTH
};

enum E_OBJ {
	E_OBJ_CAMERA,
	//E_OBJ_LIMBTARG0,
	//E_OBJ_FOG,
	//E_OBJ_CUTAWAY,
	//E_OBJ_HUMAN,
	//E_OBJ_P0,
	//E_OBJ_P1,
	//E_OBJ_P2,
	E_OBJ_LIGHT0,
	E_OBJ_LIGHT1,
	E_OBJ_LIGHT2,
	E_OBJ_LIGHT3,
	E_OBJ_LIGHT4,
	E_OBJ_LIGHT5,
	E_OBJ_LENGTH // LIGHTS MUST BE LAST ENTRIES
};

enum E_MAT_SUBPARAM {
	E_MAT_SUBPARAM_NONE,
	E_MAT_SUBPARAM_TUDOR,
	E_MAT_SUBPARAM_DOCK,
	E_MAT_SUBPARAM_BRICK,
	E_MAT_SUBPARAM_BRICK_ARCH,
	E_MAT_SUBPARAM_LENGTH
};


enum E_MAT_PARAM {
	E_MAT_PARAM_FOUNDATION,
	E_MAT_PARAM_ROOF,
	//E_MAT_PARAM_WALKWAY_TOP,
	//E_MAT_PARAM_DOCK,
	E_MAT_PARAM_BUILDING,
	//E_MAT_PARAM_WALKWAY,
	E_MAT_PARAM_LANTERN,
	E_MAT_PARAM_DOORWAY,
	E_MAT_PARAM_DOOR,
	//E_MAT_PARAM_STAIRS,
	E_MAT_PARAM_TREE, // TREES MUST BE LAST ENTRY
	E_MAT_PARAM_LENGTH
};


enum E_ORG_SUBPARAM {
	E_ORG_SUBPARAM_NOT_SEL,
	E_ORG_SUBPARAM_SEL,
	E_ORG_SUBPARAM_LENGTH
};

enum E_ORG_PARAM {
	E_ORG_PARAM_GEOM,
	E_ORG_PARAM_LINES,
	E_ORG_PARAM_LENGTH
};


// enum E_CONNECTION_SUBTYPES {
//     E_CST_NULL,
//     E_CST_TUDOR,
//     E_CST_BRICK,
//     E_CST_LENGTH
// };

enum E_BLOCK_GEN {
	E_BG_ROADS_AND_BUILDINGS,
	//E_BG_STAIRS,
	//E_BG_REMOVE_REDUNDANT_Z_SEGMENTS,
	E_BG_ROOFS,
	//E_BG_BASEMENTS,
	E_BG_WING_TIPS,
	E_BG_DOORS,
	E_BG_FILL_TERRAIN,
	E_BG_LENGTH
};

enum E_CONNECTION_TYPE_CLASSES {
	E_CTC_NOTHING,
	E_CTC_ROAD,
	E_CTC_ROOF,
	E_CTC_ROOM,
	E_CTC_STAIRS,
	E_CTC_LANTERN,
	E_CTC_LENGTH
};

enum E_CONNECTION_TYPES {
	E_CT_NULL,
	E_CT_CONNECTED,
	E_CT_FOUNDATION,
	E_CT_ROAD,
	E_CT_DOCK,
	E_CT_MAINHALL,
	E_CT_WING,
	E_CT_ROOF,
	E_CT_WALKWAY_TOP,
	E_CT_ROOM_BRICK,
	E_CT_ROOM_TUDOR,
	E_CT_WALKWAY,
	E_CT_STAIRS,
	E_CT_LANTERN,
	E_CT_WINDOWFRAME,
	E_CT_WINDOW,
	E_CT_DOORWAY,
	E_CT_DOOR,
	E_CT_OBJECT,
	E_CT_LINES,
	E_CT_TREE,
	E_CT_LENGTH
};


// enum E_HOLDER_STATE {
// 	EHS_INIT_BEG,
// 	EHS_INIT_END,
// 	EHS_
// }

// enum E_BUILDING_TYPE {
// 	E_BT_NULL,
// 	E_BT_ROAD,
// 	E_BT_DOCK,
// 	E_BT_MAINHALL,
// 	E_BT_WING,
// 	// E_BT_BALCONY,
// 	// E_BT_TOWER,
// 	// E_BT_LANTERN,
// 	// E_BT_DOORWAY,
// 	// E_BT_WINDOWFRAME,
// 	// E_BT_DOOR,
// 	// E_BT_WINDOW,
// 	//E_BT_OBJ,
// 	//E_BT_TREE,
// 	E_BT_LENGTH
// };

enum E_BODY_GUIDES {
	E_BDG_CENTER,
	//E_BDG_LFOOT,
	//E_BDG_RFOOT,
	E_BDG_LENGTH
};

// const static int E_BDG_LFOOT = -99;
// const static int E_BDG_RFOOT = -98;


enum E_BONES_HUMAN {
	
	E_BONE_L_BEG, ///////////////
	E_BONE_L_SHOULDER,
	E_BONE_L_UPPERARM,
	E_BONE_L_LOWERARM,
	E_BONE_L_METACARPALS,
	// E_BONE_L_HOLDBASE,
	// E_BONE_L_HOLDEND,
	E_BONE_L_PROXIMAL0, // pinky
	E_BONE_L_PROXIMAL1, // ring
	E_BONE_L_PROXIMAL2, // middle
	E_BONE_L_PROXIMAL3, // index
	E_BONE_L_PROXIMAL4, // thumb
	E_BONE_L_INTER0, // pinky
	E_BONE_L_INTER1, // ring
	E_BONE_L_INTER2, // middle
	E_BONE_L_INTER3, // index
	E_BONE_L_INTER4, // thumb
	E_BONE_L_DISTAL0, // pinky
	E_BONE_L_DISTAL1, // ring
	E_BONE_L_DISTAL2, // middle
	E_BONE_L_DISTAL3, // index
	E_BONE_L_DISTAL4, // thumb
	E_BONE_L_HIP,
	E_BONE_L_UPPERLEG,
	E_BONE_L_LOWERLEG,
	E_BONE_L_TALUS,
	E_BONE_L_PHALANGE,
	E_BONE_L_END, //////////////
	
	E_BONE_R_BEG, //////////////
	E_BONE_R_SHOULDER,
	E_BONE_R_UPPERARM,
	E_BONE_R_LOWERARM,
	E_BONE_R_METACARPALS,
	// E_BONE_R_HOLDBASE,
	// E_BONE_R_HOLDEND,
	E_BONE_R_PROXIMAL0, // pinky
	E_BONE_R_PROXIMAL1, // ring
	E_BONE_R_PROXIMAL2, // middle
	E_BONE_R_PROXIMAL3, // index
	E_BONE_R_PROXIMAL4, // thumb
	E_BONE_R_INTER0, // pinky
	E_BONE_R_INTER1, // ring
	E_BONE_R_INTER2, // middle
	E_BONE_R_INTER3, // index
	E_BONE_R_INTER4, // thumb
	E_BONE_R_DISTAL0, // pinky
	E_BONE_R_DISTAL1, // ring
	E_BONE_R_DISTAL2, // middle
	E_BONE_R_DISTAL3, // index
	E_BONE_R_DISTAL4, // thumb
	E_BONE_R_HIP,
	E_BONE_R_UPPERLEG,
	E_BONE_R_LOWERLEG,
	E_BONE_R_TALUS,
	E_BONE_R_PHALANGE,
	E_BONE_R_END, /////////////////
	E_BONE_C_BEG, /////////////////
	E_BONE_C_BASE,
	E_BONE_C_SPINE0, // tail
	E_BONE_C_SPINE1,
	E_BONE_C_SPINE2,
	E_BONE_C_SPINE3,
	E_BONE_C_SPINE4, // neck
	E_BONE_C_SKULL,
	
	E_BONE_WEAPON_POMMEL,
	E_BONE_WEAPON_HANDLE,
	E_BONE_WEAPON_CENTER,
	E_BONE_WEAPON_CROSSR,
	E_BONE_WEAPON_CROSSL,
	E_BONE_WEAPON_BLADER,
	E_BONE_WEAPON_BLADEL,
	E_BONE_WEAPON_BLADEU,
	
	E_BONE_C_END //////////////////
	
};

enum E_WEAPON_STATES {
	E_WEAPON_STATE_IDLE,
	E_WEAPON_STATE_BEG,
	E_WEAPON_STATE_END,
	E_WEAPON_STATE_LENGTH	
};

enum E_WEAPON_POS {
	E_WEAPON_POS_RELAXED,
	
	E_WEAPON_POS_FORWARD,
	
	E_WEAPON_POS_LEFT,
	E_WEAPON_POS_RIGHT,
	E_WEAPON_POS_UP,
	E_WEAPON_POS_DOWN,
	
	E_WEAPON_POS_UP_LEFT,
	E_WEAPON_POS_UP_RIGHT,
	E_WEAPON_POS_DOWN_LEFT,
	E_WEAPON_POS_DOWN_RIGHT,
	
	E_WEAPON_POS_LENGTH
};

enum E_GUI {
	E_GUI_LENGTH
};

enum eAlignH {
	E_ALIGNH_LEFT,
	E_ALIGNH_CENTER,
	E_ALIGNH_RIGHT,
};

enum eAlignV {
	E_ALIGNV_TOP,
	E_ALIGNV_MIDDLE,
	E_ALIGNV_BOTTOM	
};

enum eFillDir {
	E_FILL_HORIZONTAL,
	E_FILL_VERTICAL
};

// do not reorder
enum E_ORG_VECS {
	E_OV_TANGENT,
	E_OV_BITANGENT,
	E_OV_NORMAL,
	E_OV_TBNRAD0,
	E_OV_TBNRAD1,
	E_OV_THETAPHIRHO,
	E_OV_TPRORIG,
	E_OV_MATPARAMS,
	E_OV_TBNOFFSET,
	E_OV_POWVALS, // x: lerpValP0toP1, y: lerpValBit, z: lerpValTan
	E_OV_LENGTH
};

// TODO: FIX THIS SLOP
// MUST CALL THIS, BONE NAMES GOT REVERSED
int getCorrectedName(int curNodeName) {
	
	if (curNodeName < E_BONE_C_BEG) {
		if (curNodeName <= E_BONE_L_END) {
			return (
				curNodeName+(E_BONE_R_BEG-E_BONE_L_BEG)
			);
		}
		else {
			return (
				curNodeName-(E_BONE_R_BEG-E_BONE_L_BEG)
			);
		}
	}
	else {
		return curNodeName;
	}	
}

string boneStrings[] = {
	
	"E_BONE_L_BEG", ///////////////
	"E_BONE_L_SHOULDER",
	"E_BONE_L_UPPERARM",
	"E_BONE_L_LOWERARM",
	"E_BONE_L_METACARPALS",
	"E_BONE_L_PROXIMAL0", // pinky
	"E_BONE_L_PROXIMAL1", // ring
	"E_BONE_L_PROXIMAL2", // middle
	"E_BONE_L_PROXIMAL3", // index
	"E_BONE_L_PROXIMAL4", // thumb
	"E_BONE_L_INTER0", // pinky
	"E_BONE_L_INTER1", // ring
	"E_BONE_L_INTER2", // middle
	"E_BONE_L_INTER3", // index
	"E_BONE_L_INTER4", // thumb
	"E_BONE_L_DISTAL0", // pinky
	"E_BONE_L_DISTAL1", // ring
	"E_BONE_L_DISTAL2", // middle
	"E_BONE_L_DISTAL3", // index
	"E_BONE_L_DISTAL4", // thumb
	"E_BONE_L_HIP",
	"E_BONE_L_UPPERLEG",
	"E_BONE_L_LOWERLEG",
	"E_BONE_L_TALUS",
	"E_BONE_L_PHALANGE",
	"E_BONE_L_END", //////////////
	"E_BONE_R_BEG", //////////////
	"E_BONE_R_SHOULDER",
	"E_BONE_R_UPPERARM",
	"E_BONE_R_LOWERARM",
	"E_BONE_R_METACARPALS",
	"E_BONE_R_PROXIMAL0", // pinky
	"E_BONE_R_PROXIMAL1", // ring
	"E_BONE_R_PROXIMAL2", // middle
	"E_BONE_R_PROXIMAL3", // index
	"E_BONE_R_PROXIMAL4", // thumb
	"E_BONE_R_INTER0", // pinky
	"E_BONE_R_INTER1", // ring
	"E_BONE_R_INTER2", // middle
	"E_BONE_R_INTER3", // index
	"E_BONE_R_INTER4", // thumb
	"E_BONE_R_DISTAL0", // pinky
	"E_BONE_R_DISTAL1", // ring
	"E_BONE_R_DISTAL2", // middle
	"E_BONE_R_DISTAL3", // index
	"E_BONE_R_DISTAL4", // thumb
	"E_BONE_R_HIP",
	"E_BONE_R_UPPERLEG",
	"E_BONE_R_LOWERLEG",
	"E_BONE_R_TALUS",
	"E_BONE_R_PHALANGE",
	"E_BONE_R_END", /////////////////
	"E_BONE_C_BEG", /////////////////
	"E_BONE_C_BASE",
	"E_BONE_C_SPINE0", // tail
	"E_BONE_C_SPINE1",
	"E_BONE_C_SPINE2",
	"E_BONE_C_SPINE3",
	"E_BONE_C_SPINE4", // neck
	"E_BONE_C_SKULL",
	
	
	"E_BONE_WEAPON_POMMEL",
	"E_BONE_WEAPON_HANDLE",
	"E_BONE_WEAPON_CENTER",
	"E_BONE_WEAPON_CROSSR",
	"E_BONE_WEAPON_CROSSL",
	"E_BONE_WEAPON_BLADER",
	"E_BONE_WEAPON_BLADEL",
	"E_BONE_WEAPON_BLADEU",
	
	"E_BONE_C_END" //////////////////
	
	
	
};



// NEVER REORDER
enum E_EQUIPMENT_SLOTS {
	E_ES_HELMET,	// 0
	E_ES_NECKLACE,	// 1
	E_ES_CLOAK,		// 2
	E_ES_ARMOR,		// 3
	E_ES_GLOVES,	// 4
	E_ES_PRIMARY,	// 5
	E_ES_SECONDARY,	// 6
	E_ES_BOOTS,		// 7
	E_ES_LENGTH 	// 8
};

// // NEVER REORDER

// enum E_ITEM_IDS {
// 	E_II_IRON_LONG_SWORD,
// 	E_II_IRON_KITE_SHIELD,
// 	E_II_IRON_PLATED_MAIL,
// 	E_II_LENGTH
	
// }

enum E_COMMON_PARAMS {
	E_CP_VISMININPIXELST,
	E_CP_VISMAXINPIXELST,
	E_CP_LENGTH
};

// enum E_ACTOR_PARAMS {
// 	E_AC_RESERVED0,
// 	E_AC_RESERVED1,
// 	E_AC_UNUSED00,
// 	E_AC_UNUSED01,
// 	E_AC_UNUSED1,
// 	E_AC_UNUSED2,
// 	E_AC_UNUSED3,
// 	E_AC_UNUSED4,
// 	E_AC_UNUSED5,
// 	E_AC_UNUSED6, // must be last
// 	E_AC_LENGTH
// };

enum E_LIGHT_PARAMS {
	E_LP_RESERVED0,
	E_LP_RESERVED1,
	E_LP_POSITION,
	E_LP_RADIUS,
	E_LP_COLOR,
	E_LP_UNUSED2,
	E_LP_UNUSED3,
	E_LP_UNUSED4,
	E_LP_UNUSED5,
	E_LP_UNUSED6, // must be last
	E_LP_LENGTH
};

enum E_TREE_PARAMS {
	E_TP_RESERVED0,
	E_TP_RESERVED1,
	E_TP_P0,
	E_TP_P1,
	E_TP_P2,
	E_TP_POWERVALS,
	E_TP_POWERVALS2,
	E_TP_THICKVALS,
	E_TP_UNUSED,
	E_TP_MATPARAMS, // must be last
	E_TP_LENGTH
};

enum E_LINES_PARAMS {
	E_AP_RESERVED0,
	E_AP_RESERVED1,
	E_AP_ORG, // origin
	E_AP_TAN, // tangent (not normalized)
	E_AP_BIT, // bitangent (normalized)
	E_AP_NOR, // normal (normalized)
	E_AP_RAD0, // radius
	E_AP_RAD1,
	E_AP_UNUSED1,
	E_AP_MATPARAMS, // must be last
	E_AP_LENGTH
};

enum E_GEOM_PARAMS {
	E_GP_RESERVED0, //visMin
	E_GP_RESERVED1, //visMax
	E_GP_BOUNDSMININPIXELST,
	E_GP_BOUNDSMAXINPIXELST,
	E_GP_CORNERDISINPIXELS,
	E_GP_POWERVALS,
	E_GP_POWERVALS2,
	E_GP_THICKVALS,
	E_GP_UNUSED,
	E_GP_MATPARAMS, // must be last
	E_GP_LENGTH
};

enum E_PRIMTEMP {
	E_PRIMTEMP_VISMIN,
	E_PRIMTEMP_VISMAX,
	E_PRIMTEMP_BOUNDSMIN,
	E_PRIMTEMP_BOUNDSMAX,
	E_PRIMTEMP_CORNERDIS, //E_PRIMTEMP_CORNERDISTHICKNESSPOWER
	E_PRIMTEMP_MATPARAMS,
	E_PRIMTEMP_LENGTH
};

const static int FLOATS_PER_TEMPLATE = ((int)E_PRIMTEMP_LENGTH)*4;
const static float defaultTemplate[FLOATS_PER_TEMPLATE] = {
	-2.0,-2.0,-2.0, 0.0,
	 2.0, 2.0, 2.0, 0.0,
	-2.0,-2.0,-2.0, 0.0,
	 2.0, 2.0, 2.0, 0.0,
	 1.0, 1.0, 1.0, 1.0,
	 0.0, 0.0, 0.0, 0.0
};

string primTempStrings[] = {
	"visMin",
	"visMax",
	"boundsMin",
	"boundsMax",
	"cornerDis",
	"matParams"
};



enum E_GEOM_POINTS {
	E_GEOM_POINTS_ORIGIN,
	E_GEOM_POINTS_RAD_XYZ,
	E_GEOM_POINTS_OFFSET,
	E_GEOM_POINTS_CORNER,
	E_GEOM_POINTS_POWER_VALS,
	E_GEOM_POINTS_NEG_RAD_XY,
	E_GEOM_POINTS_POS_RAD_XY,
	E_GEOM_POINTS_NEG_RAD_Z,
	E_GEOM_POINTS_POS_RAD_Z,
	E_GEOM_POINTS_THICKNESS,
	E_GEOM_POINTS_LENGTH
};

enum E_GEOM_POINTS_TEMP {
	E_GEOM_POINTS_TEMP_ORIGIN,
	E_GEOM_POINTS_TEMP_OFFSET,
	E_GEOM_POINTS_TEMP_LENGTH
};

string E_GEOM_POINTS_STR[] = {
	"E_GEOM_POINTS_ORIGIN",
	"E_GEOM_POINTS_RAD_XYZ",
	"E_GEOM_POINTS_OFFSET",
	"E_GEOM_POINTS_CORNER",
	"E_GEOM_POINTS_POWER_VALS",
	"E_GEOM_POINTS_NEG_RAD_XY",
	"E_GEOM_POINTS_POS_RAD_XY",
	"E_GEOM_POINTS_NEG_RAD_Z",
	"E_GEOM_POINTS_POS_RAD_Z",
	"E_GEOM_POINTS_THICKNESS",
	"E_GEOM_POINTS_LENGTH"
};

enum E_PRIM_LAYERS {
	E_PL_TERRAIN,
	//E_PL_PRIMIDS,
	E_PL_LENGTH
};

enum E_PUSH_MOD {
	E_PM_EXPLODE_BULLET,
	E_PM_MODIFY_UNIT,
	E_PM_PLACE_TEMPLATE,
	E_PM_LENGTH
};



enum E_ENT_TYPES {
	E_ET_GEOM,
	//E_ET_ACTOR,
	E_ET_LIGHT,
	E_ET_LENGTH
	
};

enum E_ENT_PARAM {
	
	E_EP_CURCENTERPOSINPIXELS,
	E_EP_RADIUSINPIXELS,
	E_EP_CURMINVISBOUNDSINPIXELS,
	E_EP_CURMAXVISBOUNDSINPIXELS,
	E_EP_MOVEMINBOUNDSINPIXELS,
	E_EP_MOVEMAXBOUNDSINPIXELS,
	E_EP_LENGTH
};


enum E_NODE_TYPE {
	E_NT_CONNECTIONPROP,
	E_NT_SHORTPROP,
	E_NT_DYNPROP,
	E_NT_CENTERPROP,
	E_NT_LENGTH
};


enum E_ALIGN {
	E_ALIGN_BOTTOM,
	E_ALIGN_MIDDLE,
	E_ALIGN_TOP
};

enum E_MAT_CODE {
	E_MC_DEFAULT,
	E_MC_HSV,
	E_MC_MATERIAL,
	E_MC_LENGTH
};




// enum E_PATH_INDEX_TYPE {
// 	E_PIT_TYPE,
// 	E_PIT_RES1,
// 	E_PIT_RES2,
// 	E_PIT_RES3,
// 	E_PIT_LENGTH
// };

enum E_PATH_VALUE_TYPE {
	E_PVT_INVALID = 1,
	E_PVT_LAND_BELOW = 2,
	E_PVT_LENGTH = 128
};


// enum E_CELL_DATA {
// 	E_CD_EMPTY,
// 	E_CD_WATER,
// 	E_CD_SOLID,
// 	//E_CD_PORTAL, // cost of moving through a door is very high, but less than a wall
// 	E_CD_LENGTH	
// };

// dont use enums, not cast to uint
const static uint E_CD_UNKNOWN = 0;
const static uint E_CD_EMPTY = 1;
const static uint E_CD_WATER = 2;
const static uint E_CD_SOLID = 4;

struct ConnectingNodeStruct {
	
	float dist;
	
	int blockIdFrom;
	int holderIdFrom;
	
	int blockIdTo;
	int holderIdTo;
	
	int groupIdFrom;
	int groupIdTo;
	
	int cellIndFrom;
	int cellIndTo;
	
	int totCost;
};

bool sortByDist(const ConnectingNodeStruct &lhs, const ConnectingNodeStruct &rhs) {
	return lhs.dist < rhs.dist;
}


struct PathInfo {
	btVector3 points[2];
	bool searchedForPath;
	bool didFindPath;
	int nextInd;
	
	std::vector<btVector3> finalPoints;
	
};


struct GroupIdStruct {
	int ind;
	int groupId;
	int cameFromInd;
	int pathCost;
};

struct GroupInfoStruct {
	//bool touchesFace[6];
	int begInd;
	int endInd;
	int centerInd;
	
	int visitId;
};


struct PathResult {
	
	ConnectingNodeStruct conNode;
	
	int blockId;
	int holderId;
	int groupId;
	
	int lastBlockId;
	int lastHolderId;
	int lastGroupId;
	
	int lastIndex;
};

enum E_PATH_FILL_OPS {
	E_PFO_CLEAR_GROUPS,
	E_PFO_SEARCH_GROUPS,
	E_PFO_LENGTH
};


enum E_COL_TYPES {
    COL_NOTHING = 0,
    COL_STATIC = 1,
    COL_DYN = 2,
    COL_MARKER = 4,
    COL_BODY = 8
};

const static int terCollidesWith = COL_NOTHING;//COL_DYN|COL_BODY; //COL_MARKER|
const static int markerCollidesWith = COL_NOTHING;//COL_STATIC;
const static int dynCollidesWith = COL_DYN|COL_BODY; //COL_STATIC|
const static int bodyCollidesWith = COL_DYN|COL_BODY; //COL_STATIC|


enum E_JOINT_TYPES {
	E_JT_LIMB,
	E_JT_BALL,
	E_JT_NORM,
	E_JT_CONT,
	E_JT_OBJ,
	E_JT_LENGTH
};

// enum E_LIMB_CLASSES {
// 	E_LIMB_CLASS_FIST_R,
// 	E_LIMB_CLASS_
// };

struct BodyStruct {
	btRigidBody* body;
	btVector3 lastVel;
	btVector3 totAV;
	btVector3 totLV;
	
	float mass;
	float rad;
	float length;
	
	int actorJointId;
	int boneId;
	int jointType;
	//int classType;
	
	bool isVisible;
	bool inWater;
	bool isFalling;
	bool hasContact;
	bool isInside;
	
	
	
};

struct RigJointStruct {
	int boneId;
	int jointType;
	int jointId;
	int parentId;
	
	float rad;
	float length;
	
	bool isFixed;
		
	btVector3 begOrig;
	btVector3 midOrig;
	btVector3 endOrig;
	btVector3 targAlignT;
	btVector3 targAlignB;
	btVector3 targAlignN;
	btQuaternion quat;
	btMatrix3x3 basis;
	//btVector3 pivotAxis;
	
	
	std::vector<int> children;
	btCollisionShape* shape;
	btRigidBody* body;
	btTypedConstraint* joint;
};




#define E_SPECIAL_DATA_TYPE(DDD) \
DDD(E_SDT_SHADERPARAMS) \
DDD(E_SDT_OBJECTDATA) \
DDD(E_SDT_STATDATA) \
DDD(E_SDT_STATUSDATA) \
DDD(E_SDT_LENGTH)

string E_SPECIAL_DATA_TYPE_STRINGS[] = {
	E_SPECIAL_DATA_TYPE(DO_DESCRIPTION)
};

enum E_SPECIAL_DATA_TYPE_VALS {
	E_SPECIAL_DATA_TYPE(DO_ENUM)
};



#define E_FLOATING_MENU(DDD) \
DDD(E_FM_MAINMENU) \
DDD(E_FM_DDMENU) \
DDD(E_FM_CONTMENU) \
DDD(E_FM_FIELDMENU) \
DDD(E_FM_STATMENU) \
DDD(E_FM_HUDMENU) \
DDD(E_FM_LENGTH)

string E_FLOATING_MENU_STRINGS[] = {
	E_FLOATING_MENU(DO_DESCRIPTION)
};

enum E_FLOATING_MENU_VALS {
	E_FLOATING_MENU(DO_ENUM)
};






struct PoseKey {
	int index;
	int group;
	int RLBN;
	int step;
};










#define E_POSE_GROUPS(DDD) \
DDD(E_PG_TPOSE) \
DDD(E_PG_NONPOSE) \
DDD(E_PG_JUMP) \
DDD(E_PG_DEAD) \
DDD(E_PG_FLAIL) \
DDD(E_PG_PICKUP) \
DDD(E_PG_IDLE) \
DDD(E_PG_WALKFORWARD) \
DDD(E_PG_SLSH) \
DDD(E_PG_BACK) \
DDD(E_PG_HACK) \
DDD(E_PG_STAB) \
DDD(E_PG_HOOK) \
DDD(E_PG_ELBO) \
DDD(E_PG_UPPR) \
DDD(E_PG_JABP) \
DDD(E_PG_ROUN) \
DDD(E_PG_REVR) \
DDD(E_PG_BKIK) \
DDD(E_PG_FRNT) \
DDD(E_PG_WPTPOSE) \
DDD(E_PG_WPSWORD) \
DDD(E_PG_WPAXE) \
DDD(E_PG_WPMACE) \
DDD(E_PG_WPHAMMER) \
DDD(E_PG_WPSTAFF) \
DDD(E_PG_WPSPEAR) \
DDD(E_PG_LENGTH)

string E_POSE_GROUP_STRINGS[] = {
	E_POSE_GROUPS(DO_DESCRIPTION)
};

enum E_POSE_GROUP_VALS {
	E_POSE_GROUPS(DO_ENUM)
};



#define E_JSON_PARAMS(DDD) \
DDD(E_JP_STATMENUAVAILDIV) \
DDD(E_JP_LENGTH)

string E_JSON_PARAM_STRINGS[] = {
	E_JSON_PARAMS(DO_DESCRIPTION)
};

enum E_JSON_PARAM_VALS {
	E_JSON_PARAMS(DO_ENUM)
};



#define E_SUBTYPES(DDD) \
DDD(E_SUB_DEFAULT) \
DDD(E_SUB_SWING) \
DDD(E_SUB_PUNCH) \
DDD(E_SUB_KICK) \
DDD(E_SUB_WEAPON) \
DDD(E_SUB_LENGTH)

string E_SUBTYPE_STRINGS[] = {
	E_SUBTYPES(DO_DESCRIPTION)
};

enum E_SUBTYPE_VALS {
	E_SUBTYPES(DO_ENUM)
};


int stringToEnum(
	string* enumStringArr,
	int enumStringArrLength,
	string testString
) {
	int i;
	
	for (i = 0; i < enumStringArrLength; i++) {
		if (enumStringArr[i].compare(testString) == 0) {
			return i;
		}
	}
	
	return -1;
	
}



enum E_POSETYPES {
	E_POSETYPE_HUMAN,
	E_POSETYPE_WEAPON,
	E_POSETYPE_LENGTH
};

enum RLBN_FLAGS {
	RLBN_FLAG_RIGHT = 1,
	RLBN_FLAG_LEFT = 2,
	RLBN_FLAG_BOTH = 4,
	RLBN_FLAG_NEITHER = 8
};

// do not rearrange
enum RLBN_ENUMS {
	RLBN_RIGT,
	RLBN_LEFT,
	RLBN_BOTH,
	RLBN_NEIT,
	RLBN_LENGTH
};
// do not rearrange
enum E_ACTION_STATES {
	E_ACT_NULL,
	E_ACT_ISHIT,
	E_ACT_ISJUMPING,
	E_ACT_ISWALKING,
	E_ACT_ISSWINGING,
	E_ACT_HASNOTHIT,
	E_ACT_ISPICKINGUP,
	E_ACT_LENGTH
};


/////////////////////////////

#define E_PIK(DDD) \
DDD(E_PIK_POSETYPE) \
DDD(E_PIK_SUBTYPE) \
DDD(E_PIK_NUMSTEPS) \
DDD(E_PIK_EXTRASTEPS) \
DDD(E_PIK_RLBN) \
DDD(E_PIK_DOLOOP) \
DDD(E_PIK_LERPSPEED) \
DDD(E_PIK_TIMEINTERVAL) \
DDD(E_PIK_LENGTH)

string E_PIK_STRINGS[] = {
	E_PIK(DO_DESCRIPTION)
};

enum E_PIK_ENUMS {
	E_PIK(DO_ENUM)
};

/////////////////////////////



string poseSideStrings[] = {
	"R", // right
	"L", // left
	"B", // both
	"N"	 // neither
};

const static int MAX_POSE_STEPS = 8;

struct PoseStepInfo {
	string fileString[MAX_POSE_STEPS];
	int gamePoseIndex[MAX_POSE_STEPS];
};

struct PoseInfo {
	float data[E_PIK_LENGTH];
	string stringData[E_PIK_LENGTH];
	PoseStepInfo poseSteps[RLBN_LENGTH];
};

struct materialNode {
	float h;
	float s;
	float l;
	float r;
	float g;
	float b;
	float power;
	float ratio;
};

struct iVector4 {
	int x;
	int y;
	int z;
	int w;
};
struct fVector4 {
	float x;
	float y;
	float z;
	float w;
};

struct iVector3 {
	int x;
	int y;
	int z;
};
struct fVector3 {
	float x;
	float y;
	float z;
};


struct iVector2 {
	int x;
	int y;
};
struct fVector2 {
	float x;
	float y;
};

struct iBoundingBox {
	int xMin;
	int yMin;
	int xMax;
	int yMax;
};

struct fBoundingBox {
	float xMin;
	float yMin;
	float xMax;
	float yMax;
};





struct intPair {
	int v0;
	int v1;
};

bool operator==(const intPair& lhs, const intPair& rhs)
{
    return (lhs.v0 == rhs.v0)&&(lhs.v1==rhs.v1);
}

bool operator>(const intPair& lhs, const intPair& rhs)
{
	long lhs2 = lhs.v1;
	long rhs2 = rhs.v1;

	lhs2 = lhs2 << 16;
	rhs2 = rhs2 << 16;

	lhs2 |= lhs.v0;
	rhs2 |= rhs.v0;


	return (lhs2) > (rhs2);
}

bool operator<(const intPair& lhs, const intPair& rhs)
{
    long lhs2 = lhs.v1;
	long rhs2 = rhs.v1;

	lhs2 = lhs2 << 16;
	rhs2 = rhs2 << 16;

	lhs2 |= lhs.v0;
	rhs2 |= rhs.v0;

	return (lhs2) < (rhs2);
}

struct intPairVec {
	std::vector<intPair> data;	
};
struct intVec {
	std::vector<int> data;	
};

struct floatAndIndex {
	float value;
	int index1;
	int index2;
};

struct coordAndIndex {
	float x;
	float y;
	float xTen;
	float yTen;
	int index;
};

struct PlantRules
{
	float numChildren[2];
	float divergenceAngleV[2];
	float begThickness;
	float endThickness;
	float curLength[MAX_PLANT_GEN];
	float sphereGen;
	float sphereRad;
	//float baseLength;
	//float nodeLengthMultiplier;
	float numGenerations;
	float angleUniformityU;
	float isInit;


};

struct FloatVec {
	std::vector<float> data;	
};

struct TerTexture {
	int usedByBlockId;
	GLuint texId;
	bool alreadyBound;
};


// struct PathNode {
// 	int index;
// 	int blockId;
// 	int x;
// 	int y;
// 	int z;
// };
// bool operator==(const PathNode& lhs, const PathNode& rhs)
// {
//     return (lhs.index == rhs.index)&&(lhs.blockId==rhs.blockId);
// }

// struct PathHolder {
// 	std::vector<PathNode> pathList;
// 	std::vector<PathNode> visitedList;
// };


struct MapNode {
	int connectionProps[TOT_MAP_DIRS];
	int terHeight;
	int adjustedHeight;
	int houseHeight;
	int id;
};

const static unsigned int BC_FLAG_INSIDE = 1;
const static unsigned int BC_FLAG_WING_BEG = 2;
const static unsigned int BC_FLAG_WING_END = 4;

struct BuildingCon {
	int conType;
	unsigned int nodeFlags;
	//bool isWingBeg;
	//bool isWingEnd;
	float wingMult;
	float wallRadInCells;
	int heightDelta;
	int direction; 	// -1: negative,
					//  0: neutral,
					//  1: positve
};


struct BuildingNode {

	BuildingCon con[TOT_NODE_VALS];

	// int con[TOT_NODE_VALS]; // connections
	// bool isWingBeg[TOT_NODE_VALS];
	// bool isWingEnd[TOT_NODE_VALS];

	//std::vector<ConnectionProp> connections;

	int mazeIndex;
	int id;
	int visited;
	float powerValU;
	float powerValV;
	bool nearTerrain;
	bool nearAir;

	// float terHeight;
	// bool isWingTip;

	// int centerType;
	// int connectionTypes[4];
	// int shortTypes[4];

	// int centerHeight;
	// int connectionHeights[4];
	// int shortHeights[4];


};



const int GLUT_NO_BUTTON = 99;
const int GLUT_OVER = 8;
const int GLUT_OUT = 9;
const int GLUT_CHANGING = 10;


enum E_MUSIC_LIST {
	EML_BIRDSONG0,
	EML_CRICKETS0,
	EML_OCEANWAVES0,
	EML_UNDERWATER0,
	EML_LENGTH
};



string colorStrings[] = {
	"Red",
	"Orange",
	"Yellow",
	"Green",
	"Aqua",
	"Blue",
	"Purple",
	"Pink",
	"Brown",
	"Black",
	"Gray",
	"White",
	"Empty",
	"Broken"
};
string gemStrings[] = {
	"Ruby",
	"Citrine",
	"Topaz",
	"Emerald",
	"Aquamarine",
	"Sapphire",
	"Amethyst",
	"Quartz",
	"Beryl",
	"Onyx",
	"Moonstone",
	"Diamond"
};
string metalStrings[] = {
	"Copper",
	"Silver",
	"Gold",
	"Platinum",
	"Meteorite"
};
string weaponStrings[] = {
	"Sword",
	"Axe",
	"Spear",
	"Dagger",
	"Mace",
	"Staff",
	"Wand",
	"Throwing Star",
	"Bow",
	"Knuckles",
	"Punch Dagger"
};
string elementStrings[] = {
	"Normal",
	"Fire",
	"Ice",
	"Poison",
	"Earth",
	"Electric",
	"Light",
	"Dark",
	"Holy",
	"Unholy",
	"Crystal",
	"Artifact",
	"Artifact",
	"Artifact",
	"Artifact",
	"Artifact"
};

string musicStrings[] = {
	"birdsong0",
	"crickets0",
	"oceanwaves0",
	"underwater0"
};





// enum E_GUI_SECTIONS {
// 	E_GS_MAINMENU,
// 	E_GS_CONTEXTMENU,
// 	E_GS_LENGTH
// };

// do not reorder!
enum GUI_TYPES {
	E_GT_HOLDER,  // 0
	E_GT_SLIDER,  // 1 also a toggle if 1 division
	E_GT_BUTTON,  // 2
	E_GT_RADIO,   // 3
	E_GT_MENUBAR, // 4
	E_GT_DRAGPAD, // 5
	E_GT_CHECK,   // 6
	E_GT_LENGTH
};

enum GUI_STRING_TYPES {
	E_GST_LABEL,
	E_GST_UID,
	E_GST_SS,
	E_GST_DATAREF,
	E_GST_DATAFILE,
	E_GST_DATAKEY,
	E_GST_VALREF,
	E_GST_LENGTH
};

char* guiStringTypes[] = {
	"label",
	"uid",
	"ss",
	"dataRef",
	"dataFile",
	"dataKey",
	"valRef"
};

enum E_HOVER_TYPES {
	E_HT_NORMAL,		// 0
	E_HT_TOOLTIP,		// 1
	E_HT_ONSELECTED,	// 2
	E_HT_TOOLTIP_VALUE, // 3
	E_HT_ROOT,			// 4
	E_HT_LENGTH
};

enum GUI_FLOAT_TYPES {
	E_GFT_TYPE,
	E_GFT_DIVISIONS,
	E_GFT_VALUE,
	E_GFT_HASBACKGROUND,
	E_GFT_SINGLELINE,
	E_GFT_FILLRATIOX,
	E_GFT_FILLRATIOY,
	E_GFT_FILLDIR,
	E_GFT_ALIGNX,
	E_GFT_ALIGNY,
	E_GFT_LAYER,
	E_GFT_HOVERTYPE, // 0: normal, 1: tooltip, 2: show when parent is selected
	E_GFT_MAXDIMX,
	E_GFT_MAXDIMY,
	E_GFT_MINDIMX,
	E_GFT_MINDIMY,
	E_GFT_FLAGS,
	E_GFT_VALUE0,
	E_GFT_VALUE1,
	E_GFT_VALUE2,
	E_GFT_VALUE3,
	E_GFT_MATCODE,
	E_GFT_LENGTH
};
char* guiFloatTypes[] = {
	"type",
	"divisions",
	"value",
	"hasBackground",
	"singleLine",
	"fillRatioX",
	"fillRatioY",
	"fillDir",
	"alignX",
	"alignY",
	"layer",
	"hoverType",
	"maxDimX",
	"maxDimY",
	"minDimX",
	"minDimY",
	"flags",
	"value0",
	"value1",
	"value2",
	"value3",
	"matCode"
	
	
};

enum E_GUI_FLAGS {
	E_GF_X = 1,
	E_GF_Y = 2,
	E_GF_Z = 4,
	E_GF_W = 8,
	E_GF_MAT = 16
};

string guiStringValues[E_GST_LENGTH];
double guiFloatValues[E_GFT_LENGTH];

enum E_DIR_SPECS {
	E_DIR_X,
	E_DIR_Y,
	E_DIR_Z,
	E_DIR_LENGTH
};



enum eSSProperties {

	E_SS_BGCOL0_R,
	E_SS_BGCOL0_G,
	E_SS_BGCOL0_B,
	E_SS_BGCOL0_A,

	E_SS_BGCOL1_R,
	E_SS_BGCOL1_G,
	E_SS_BGCOL1_B,
	E_SS_BGCOL1_A,

	E_SS_FGCOL0_R,
	E_SS_FGCOL0_G,
	E_SS_FGCOL0_B,
	E_SS_FGCOL0_A,

	E_SS_FGCOL1_R,
	E_SS_FGCOL1_G,
	E_SS_FGCOL1_B,
	E_SS_FGCOL1_A,

	E_SS_BGCOLTEXT0_R,
	E_SS_BGCOLTEXT0_G,
	E_SS_BGCOLTEXT0_B,
	E_SS_BGCOLTEXT0_A,

	E_SS_BGCOLTEXT1_R,
	E_SS_BGCOLTEXT1_G,
	E_SS_BGCOLTEXT1_B,
	E_SS_BGCOLTEXT1_A,

	E_SS_FGCOLTEXT0_R,
	E_SS_FGCOLTEXT0_G,
	E_SS_FGCOLTEXT0_B,
	E_SS_FGCOLTEXT0_A,

	E_SS_FGCOLTEXT1_R,
	E_SS_FGCOLTEXT1_G,
	E_SS_FGCOLTEXT1_B,
	E_SS_FGCOLTEXT1_A,

	E_SS_TGCOL0_R,
	E_SS_TGCOL0_G,
	E_SS_TGCOL0_B,
	E_SS_TGCOL0_A,

	E_SS_TGCOL1_R,
	E_SS_TGCOL1_G,
	E_SS_TGCOL1_B,
	E_SS_TGCOL1_A,

	E_SS_BDCOL_R,
	E_SS_BDCOL_G,
	E_SS_BDCOL_B,
	E_SS_BDCOL_A,

	E_SS_PADDING,
	E_SS_BORDER,
	E_SS_MARGIN,
	E_SS_CORNERRAD,
	E_SS_ROUNDNESS,

	E_SS_PROPS_SIZE
};

enum E_FIELD_CALLBACKS {
	E_FC_SAVEORG,
	E_FC_LOADORG,
	E_FC_LENGTH
};

enum eCompStates {
	E_COMP_UP,
	E_COMP_OVER,
	E_COMP_DOWN,
	E_COMP_TOTAL
};

struct CharStruct {
	float consumedW;
	float consumedH;
	
	float offsetX;
	float offsetY;
	
	float sampX;
	float sampY;
	float sampW;
	float sampH;
};



class StyleSheetState {
private:

public:

	float props[E_SS_PROPS_SIZE];

	StyleSheetState() {

	}

	void setVal(int offsetVal, float x, float y, float z, float w) {
		props[offsetVal] = x;
		props[offsetVal + 1] = y;
		props[offsetVal + 2] = z;
		props[offsetVal + 3] = w;

	}

	void init() {

		int i;

		for (i = 0; i < E_SS_PROPS_SIZE; i++) {
			props[i] = 0.0f;
		}
	}

	void copyFrom(StyleSheetState *cf) {
		int i;

		for (i = 0; i < E_SS_PROPS_SIZE; i++) {
			props[i] = cf->props[i];
		}
	}


};

class StyleSheet {
private:

public:
	StyleSheetState compStates[E_COMP_TOTAL];

	StyleSheet() {

	}

	void copyFrom(StyleSheet* fromSS) {
		compStates[E_COMP_UP].copyFrom(&(fromSS->compStates[E_COMP_UP]));
		compStates[E_COMP_OVER].copyFrom(&(fromSS->compStates[E_COMP_OVER]));
		compStates[E_COMP_DOWN].copyFrom(&(fromSS->compStates[E_COMP_DOWN]));
	}

	void init() {
		int i;

		for (i = 0; i < E_COMP_TOTAL; i++) {
			compStates[i].init();
		}

	}


};

class StyleSheetResult: public StyleSheetState {
private:

public:
	StyleSheet *baseSS;
	float incVal;
	float stateTotal;
	float stateAmounts[E_COMP_TOTAL];

	typedef StyleSheetState super;

	StyleSheetResult() {

	}

	void init(StyleSheet *_baseSS) {
		baseSS = _baseSS;
		super::init();

		int i;

		incVal = 0.1f;

		for (i = 0; i < E_COMP_TOTAL; i++) {
			stateAmounts[i] = 0.0f;
		}

		stateAmounts[E_COMP_UP] = 1.0f;
	}


	void incrementVal(int enumVal) {
		int i;
		for (i = 0; i < E_COMP_TOTAL; i++) {
			stateAmounts[i] -= incVal;
		}

		stateAmounts[enumVal] += 2.0 * incVal;

		for (i = 0; i < E_COMP_TOTAL; i++) {
			if (stateAmounts[i] < 0.0f) {
				stateAmounts[i] = 0.0f;
			}
			if (stateAmounts[i] > 1.0f) {
				stateAmounts[i] = 1.0f;
			}
		}

		float tot = 0.0f;

		for (i = 0; i < E_COMP_TOTAL; i++) {
			tot += stateAmounts[i];
		}
		stateTotal = tot;

	}

	void update(bool mouseOver, bool mouseDown) {


		if (mouseOver) {
			if (mouseDown) {
				incrementVal(E_COMP_DOWN);
			}
			else {
				incrementVal(E_COMP_OVER);
			}
		}
		else {
			incrementVal(E_COMP_UP);
		}


		int i;
		int j;

		float bval;

		for (i = 0; i < E_SS_PROPS_SIZE; i++) {

			props[i] = 0.0f;
			for (j = 0; j < E_COMP_TOTAL; j++) {
				bval = baseSS->compStates[j].props[i];
				props[i] += bval * stateAmounts[j];
			}
			props[i] /= stateTotal;
		}

	}
};





////////////////////////////////////////////////////

//    DONT FORGET SEMICOLONS!

////////////////////////////////////////////////////
 
///////////////////////////////////////////////////////////////////////////////
// Matrice.h
// =========
// NxN Matrix Math classes
//
// The elements of the matrix are stored as column major order.
// | 0 2 |    | 0 3 6 |    |  0  4  8 12 |
// | 1 3 |    | 1 4 7 |    |  1  5  9 13 |
//            | 2 5 8 |    |  2  6 10 14 |
//                         |  3  7 11 15 |
//
//  AUTHOR: Song Ho Ahn (song.ahn at gmail.com)
// CREATED: 2005-06-24
// UPDATED: 2013-09-30
//
// Copyright (C) 2005 Song Ho Ahn
///////////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// 2D vector
///////////////////////////////////////////////////////////////////////////////
struct Vector2
{
    float x;
    float y;

    // ctors
    Vector2() : x(0), y(0) {};
    Vector2(float x, float y) : x(x), y(y) {};

    // utils functions
    void        set(float x, float y);
    float       length() const;                         //
    float       distance(const Vector2& vec) const;     // distance between two vectors
    Vector2&    normalize();                            //
    float       dot(const Vector2& vec) const;          // dot product
    bool        equal(const Vector2& vec, float e) const; // compare with epsilon

    // operators
    Vector2     operator-() const;                      // unary operator (negate)
    Vector2     operator+(const Vector2& rhs) const;    // add rhs
    Vector2     operator-(const Vector2& rhs) const;    // subtract rhs
    Vector2&    operator+=(const Vector2& rhs);         // add rhs and update this object
    Vector2&    operator-=(const Vector2& rhs);         // subtract rhs and update this object
    Vector2     operator*(const float scale) const;     // scale
    Vector2     operator*(const Vector2& rhs) const;    // multiply each element
    Vector2&    operator*=(const float scale);          // scale and update this object
    Vector2&    operator*=(const Vector2& rhs);         // multiply each element and update this object
    Vector2     operator/(const float scale) const;     // inverse scale
    Vector2&    operator/=(const float scale);          // scale and update this object
    bool        operator==(const Vector2& rhs) const;   // exact compare, no epsilon
    bool        operator!=(const Vector2& rhs) const;   // exact compare, no epsilon
    bool        operator<(const Vector2& rhs) const;    // comparison for sort
    float       operator[](int index) const;            // subscript operator v[0], v[1]
    float&      operator[](int index);                  // subscript operator v[0], v[1]

    friend Vector2 operator*(const float a, const Vector2 vec);
    friend std::ostream& operator<<(std::ostream& os, const Vector2& vec);
};



///////////////////////////////////////////////////////////////////////////////
// 3D vector
///////////////////////////////////////////////////////////////////////////////
struct Vector3
{
    float x;
    float y;
    float z;

    // ctors
    Vector3() : x(0), y(0), z(0) {};
    Vector3(float x, float y, float z) : x(x), y(y), z(z) {};

    // utils functions
    void        set(float x, float y, float z);
    float       length() const;                         //
    float       distance(const Vector3& vec) const;     // distance between two vectors
    Vector3&    normalize();                            //
    float       dot(const Vector3& vec) const;          // dot product
    Vector3     cross(const Vector3& vec) const;        // cross product
    bool        equal(const Vector3& vec, float e) const; // compare with epsilon

    // operators
    Vector3     operator-() const;                      // unary operator (negate)
    Vector3     operator+(const Vector3& rhs) const;    // add rhs
    Vector3     operator-(const Vector3& rhs) const;    // subtract rhs
    Vector3&    operator+=(const Vector3& rhs);         // add rhs and update this object
    Vector3&    operator-=(const Vector3& rhs);         // subtract rhs and update this object
    Vector3     operator*(const float scale) const;     // scale
    Vector3     operator*(const Vector3& rhs) const;    // multiplay each element
    Vector3&    operator*=(const float scale);          // scale and update this object
    Vector3&    operator*=(const Vector3& rhs);         // product each element and update this object
    Vector3     operator/(const float scale) const;     // inverse scale
    Vector3&    operator/=(const float scale);          // scale and update this object
    bool        operator==(const Vector3& rhs) const;   // exact compare, no epsilon
    bool        operator!=(const Vector3& rhs) const;   // exact compare, no epsilon
    bool        operator<(const Vector3& rhs) const;    // comparison for sort
    float       operator[](int index) const;            // subscript operator v[0], v[1]
    float&      operator[](int index);                  // subscript operator v[0], v[1]

    friend Vector3 operator*(const float a, const Vector3 vec);
    friend std::ostream& operator<<(std::ostream& os, const Vector3& vec);
};



///////////////////////////////////////////////////////////////////////////////
// 4D vector
///////////////////////////////////////////////////////////////////////////////
struct Vector4
{
    float x;
    float y;
    float z;
    float w;

    // ctors
    Vector4() : x(0), y(0), z(0), w(0) {};
    Vector4(float x, float y, float z, float w) : x(x), y(y), z(z), w(w) {};

    // utils functions
    void        set(float x, float y, float z, float w);
    float       length() const;                         //
    float       distance(const Vector4& vec) const;     // distance between two vectors
    Vector4&    normalize();                            //
    float       dot(const Vector4& vec) const;          // dot product
    bool        equal(const Vector4& vec, float e) const; // compare with epsilon

    // operators
    Vector4     operator-() const;                      // unary operator (negate)
    Vector4     operator+(const Vector4& rhs) const;    // add rhs
    Vector4     operator-(const Vector4& rhs) const;    // subtract rhs
    Vector4&    operator+=(const Vector4& rhs);         // add rhs and update this object
    Vector4&    operator-=(const Vector4& rhs);         // subtract rhs and update this object
    Vector4     operator*(const float scale) const;     // scale
    Vector4     operator*(const Vector4& rhs) const;    // multiply each element
    Vector4&    operator*=(const float scale);          // scale and update this object
    Vector4&    operator*=(const Vector4& rhs);         // multiply each element and update this object
    Vector4     operator/(const float scale) const;     // inverse scale
    Vector4&    operator/=(const float scale);          // scale and update this object
    bool        operator==(const Vector4& rhs) const;   // exact compare, no epsilon
    bool        operator!=(const Vector4& rhs) const;   // exact compare, no epsilon
    bool        operator<(const Vector4& rhs) const;    // comparison for sort
    float       operator[](int index) const;            // subscript operator v[0], v[1]
    float&      operator[](int index);                  // subscript operator v[0], v[1]

    friend Vector4 operator*(const float a, const Vector4 vec);
    friend std::ostream& operator<<(std::ostream& os, const Vector4& vec);
};



// fast math routines from Doom3 SDK
inline float invSqrt(float x)
{
    float xhalf = 0.5f * x;
    int i = *(int*)&x;          // get bits for floating value
    i = 0x5f3759df - (i>>1);    // gives initial guess
    x = *(float*)&i;            // convert bits back to float
    x = x * (1.5f - xhalf*x*x); // Newton step
    return x;
}



///////////////////////////////////////////////////////////////////////////////
// inline functions for Vector2
///////////////////////////////////////////////////////////////////////////////
inline Vector2 Vector2::operator-() const {
    return Vector2(-x, -y);
}

inline Vector2 Vector2::operator+(const Vector2& rhs) const {
    return Vector2(x+rhs.x, y+rhs.y);
}

inline Vector2 Vector2::operator-(const Vector2& rhs) const {
    return Vector2(x-rhs.x, y-rhs.y);
}

inline Vector2& Vector2::operator+=(const Vector2& rhs) {
    x += rhs.x; y += rhs.y; return *this;
}

inline Vector2& Vector2::operator-=(const Vector2& rhs) {
    x -= rhs.x; y -= rhs.y; return *this;
}

inline Vector2 Vector2::operator*(const float a) const {
    return Vector2(x*a, y*a);
}

inline Vector2 Vector2::operator*(const Vector2& rhs) const {
    return Vector2(x*rhs.x, y*rhs.y);
}

inline Vector2& Vector2::operator*=(const float a) {
    x *= a; y *= a; return *this;
}

inline Vector2& Vector2::operator*=(const Vector2& rhs) {
    x *= rhs.x; y *= rhs.y; return *this;
}

inline Vector2 Vector2::operator/(const float a) const {
    return Vector2(x/a, y/a);
}

inline Vector2& Vector2::operator/=(const float a) {
    x /= a; y /= a; return *this;
}

inline bool Vector2::operator==(const Vector2& rhs) const {
    return (x == rhs.x) && (y == rhs.y);
}

inline bool Vector2::operator!=(const Vector2& rhs) const {
    return (x != rhs.x) || (y != rhs.y);
}

inline bool Vector2::operator<(const Vector2& rhs) const {
    if(x < rhs.x) return true;
    if(x > rhs.x) return false;
    if(y < rhs.y) return true;
    if(y > rhs.y) return false;
    return false;
}

inline float Vector2::operator[](int index) const {
    return (&x)[index];
}

inline float& Vector2::operator[](int index) {
    return (&x)[index];
}

inline void Vector2::set(float x, float y) {
    this->x = x; this->y = y;
}

inline float Vector2::length() const {
    return sqrtf(x*x + y*y);
}

inline float Vector2::distance(const Vector2& vec) const {
    return sqrtf((vec.x-x)*(vec.x-x) + (vec.y-y)*(vec.y-y));
}

inline Vector2& Vector2::normalize() {
    float xxyy = x*x + y*y;

    //float invLength = invSqrt(xxyy);
    float invLength = 1.0f / sqrtf(xxyy);
    x *= invLength;
    y *= invLength;
    return *this;
}

inline float Vector2::dot(const Vector2& rhs) const {
    return (x*rhs.x + y*rhs.y);
}

inline bool Vector2::equal(const Vector2& rhs, float epsilon) const {
    return fabs(x - rhs.x) < epsilon && fabs(y - rhs.y) < epsilon;
}

inline Vector2 operator*(const float a, const Vector2 vec) {
    return Vector2(a*vec.x, a*vec.y);
}

inline std::ostream& operator<<(std::ostream& os, const Vector2& vec) {
    os << "(" << vec.x << ", " << vec.y << ")";
    return os;
}
// END OF VECTOR2 /////////////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////////
// inline functions for Vector3
///////////////////////////////////////////////////////////////////////////////
inline Vector3 Vector3::operator-() const {
    return Vector3(-x, -y, -z);
}

inline Vector3 Vector3::operator+(const Vector3& rhs) const {
    return Vector3(x+rhs.x, y+rhs.y, z+rhs.z);
}

inline Vector3 Vector3::operator-(const Vector3& rhs) const {
    return Vector3(x-rhs.x, y-rhs.y, z-rhs.z);
}

inline Vector3& Vector3::operator+=(const Vector3& rhs) {
    x += rhs.x; y += rhs.y; z += rhs.z; return *this;
}

inline Vector3& Vector3::operator-=(const Vector3& rhs) {
    x -= rhs.x; y -= rhs.y; z -= rhs.z; return *this;
}

inline Vector3 Vector3::operator*(const float a) const {
    return Vector3(x*a, y*a, z*a);
}

inline Vector3 Vector3::operator*(const Vector3& rhs) const {
    return Vector3(x*rhs.x, y*rhs.y, z*rhs.z);
}

inline Vector3& Vector3::operator*=(const float a) {
    x *= a; y *= a; z *= a; return *this;
}

inline Vector3& Vector3::operator*=(const Vector3& rhs) {
    x *= rhs.x; y *= rhs.y; z *= rhs.z; return *this;
}

inline Vector3 Vector3::operator/(const float a) const {
    return Vector3(x/a, y/a, z/a);
}

inline Vector3& Vector3::operator/=(const float a) {
    x /= a; y /= a; z /= a; return *this;
}

inline bool Vector3::operator==(const Vector3& rhs) const {
    return (x == rhs.x) && (y == rhs.y) && (z == rhs.z);
}

inline bool Vector3::operator!=(const Vector3& rhs) const {
    return (x != rhs.x) || (y != rhs.y) || (z != rhs.z);
}

inline bool Vector3::operator<(const Vector3& rhs) const {
    if(x < rhs.x) return true;
    if(x > rhs.x) return false;
    if(y < rhs.y) return true;
    if(y > rhs.y) return false;
    if(z < rhs.z) return true;
    if(z > rhs.z) return false;
    return false;
}

inline float Vector3::operator[](int index) const {
    return (&x)[index];
}

inline float& Vector3::operator[](int index) {
    return (&x)[index];
}

inline void Vector3::set(float x, float y, float z) {
    this->x = x; this->y = y; this->z = z;
}

inline float Vector3::length() const {
    return sqrtf(x*x + y*y + z*z);
}

inline float Vector3::distance(const Vector3& vec) const {
    return sqrtf((vec.x-x)*(vec.x-x) + (vec.y-y)*(vec.y-y) + (vec.z-z)*(vec.z-z));
}

inline Vector3& Vector3::normalize() {
    float xxyyzz = x*x + y*y + z*z;
    //float invLength = invSqrt(xxyyzz);
    float invLength = 1.0f / sqrtf(xxyyzz);
    x *= invLength;
    y *= invLength;
    z *= invLength;
    return *this;
}

inline float Vector3::dot(const Vector3& rhs) const {
    return (x*rhs.x + y*rhs.y + z*rhs.z);
}

inline Vector3 Vector3::cross(const Vector3& rhs) const {
    return Vector3(y*rhs.z - z*rhs.y, z*rhs.x - x*rhs.z, x*rhs.y - y*rhs.x);
}

inline bool Vector3::equal(const Vector3& rhs, float epsilon) const {
    return fabs(x - rhs.x) < epsilon && fabs(y - rhs.y) < epsilon && fabs(z - rhs.z) < epsilon;
}

inline Vector3 operator*(const float a, const Vector3 vec) {
    return Vector3(a*vec.x, a*vec.y, a*vec.z);
}

inline std::ostream& operator<<(std::ostream& os, const Vector3& vec) {
    os << "(" << vec.x << ", " << vec.y << ", " << vec.z << ")";
    return os;
}
// END OF VECTOR3 /////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////////
// inline functions for Vector4
///////////////////////////////////////////////////////////////////////////////
inline Vector4 Vector4::operator-() const {
    return Vector4(-x, -y, -z, -w);
}

inline Vector4 Vector4::operator+(const Vector4& rhs) const {
    return Vector4(x+rhs.x, y+rhs.y, z+rhs.z, w+rhs.w);
}

inline Vector4 Vector4::operator-(const Vector4& rhs) const {
    return Vector4(x-rhs.x, y-rhs.y, z-rhs.z, w-rhs.w);
}

inline Vector4& Vector4::operator+=(const Vector4& rhs) {
    x += rhs.x; y += rhs.y; z += rhs.z; w += rhs.w; return *this;
}

inline Vector4& Vector4::operator-=(const Vector4& rhs) {
    x -= rhs.x; y -= rhs.y; z -= rhs.z; w -= rhs.w; return *this;
}

inline Vector4 Vector4::operator*(const float a) const {
    return Vector4(x*a, y*a, z*a, w*a);
}

inline Vector4 Vector4::operator*(const Vector4& rhs) const {
    return Vector4(x*rhs.x, y*rhs.y, z*rhs.z, w*rhs.w);
}

inline Vector4& Vector4::operator*=(const float a) {
    x *= a; y *= a; z *= a; w *= a; return *this;
}

inline Vector4& Vector4::operator*=(const Vector4& rhs) {
    x *= rhs.x; y *= rhs.y; z *= rhs.z; w *= rhs.w; return *this;
}

inline Vector4 Vector4::operator/(const float a) const {
    return Vector4(x/a, y/a, z/a, w/a);
}

inline Vector4& Vector4::operator/=(const float a) {
    x /= a; y /= a; z /= a; w /= a; return *this;
}

inline bool Vector4::operator==(const Vector4& rhs) const {
    return (x == rhs.x) && (y == rhs.y) && (z == rhs.z) && (w == rhs.w);
}

inline bool Vector4::operator!=(const Vector4& rhs) const {
    return (x != rhs.x) || (y != rhs.y) || (z != rhs.z) || (w != rhs.w);
}

inline bool Vector4::operator<(const Vector4& rhs) const {
    if(x < rhs.x) return true;
    if(x > rhs.x) return false;
    if(y < rhs.y) return true;
    if(y > rhs.y) return false;
    if(z < rhs.z) return true;
    if(z > rhs.z) return false;
    if(w < rhs.w) return true;
    if(w > rhs.w) return false;
    return false;
}

inline float Vector4::operator[](int index) const {
    return (&x)[index];
}

inline float& Vector4::operator[](int index) {
    return (&x)[index];
}

inline void Vector4::set(float x, float y, float z, float w) {
    this->x = x; this->y = y; this->z = z; this->w = w;
}

inline float Vector4::length() const {
    return sqrtf(x*x + y*y + z*z + w*w);
}

inline float Vector4::distance(const Vector4& vec) const {
    return sqrtf((vec.x-x)*(vec.x-x) + (vec.y-y)*(vec.y-y) + (vec.z-z)*(vec.z-z) + (vec.w-w)*(vec.w-w));
}

inline Vector4& Vector4::normalize() {
    //NOTE: leave w-component untouched
    float xxyyzz = x*x + y*y + z*z;
    //float invLength = invSqrt(xxyyzz);
    float invLength = 1.0f / sqrtf(xxyyzz);
    x *= invLength;
    y *= invLength;
    z *= invLength;
    return *this;
}

inline float Vector4::dot(const Vector4& rhs) const {
    return (x*rhs.x + y*rhs.y + z*rhs.z + w*rhs.w);
}

inline bool Vector4::equal(const Vector4& rhs, float epsilon) const {
    return fabs(x - rhs.x) < epsilon && fabs(y - rhs.y) < epsilon &&
           fabs(z - rhs.z) < epsilon && fabs(w - rhs.w) < epsilon;
}

inline Vector4 operator*(const float a, const Vector4 vec) {
    return Vector4(a*vec.x, a*vec.y, a*vec.z, a*vec.w);
}

inline std::ostream& operator<<(std::ostream& os, const Vector4& vec) {
    os << "(" << vec.x << ", " << vec.y << ", " << vec.z << ", " << vec.w << ")";
    return os;
}
// END OF VECTOR4 /////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
// 2x2 matrix
///////////////////////////////////////////////////////////////////////////
class Matrix2
{
public:
    // constructors
    Matrix2();  // init with identity
    Matrix2(const float src[4]);
    Matrix2(float m0, float m1, float m2, float m3);

    void        set(const float src[4]);
    void        set(float m0, float m1, float m2, float m3);
    void        setRow(int index, const float row[2]);
    void        setRow(int index, const Vector2& v);
    void        setColumn(int index, const float col[2]);
    void        setColumn(int index, const Vector2& v);

    float* get();
    float       getDeterminant();

    Matrix2&    identity();
    Matrix2&    transpose();                            // transpose itself and return reference
    Matrix2&    invert();

    // operators
    Matrix2     operator+(const Matrix2& rhs) const;    // add rhs
    Matrix2     operator-(const Matrix2& rhs) const;    // subtract rhs
    Matrix2&    operator+=(const Matrix2& rhs);         // add rhs and update this object
    Matrix2&    operator-=(const Matrix2& rhs);         // subtract rhs and update this object
    Vector2     operator*(const Vector2& rhs) const;    // multiplication: v' = M * v
    Matrix2     operator*(const Matrix2& rhs) const;    // multiplication: M3 = M1 * M2
    Matrix2&    operator*=(const Matrix2& rhs);         // multiplication: M1' = M1 * M2
    bool        operator==(const Matrix2& rhs) const;   // exact compare, no epsilon
    bool        operator!=(const Matrix2& rhs) const;   // exact compare, no epsilon
    float       operator[](int index) const;            // subscript operator v[0], v[1]
    float&      operator[](int index);                  // subscript operator v[0], v[1]

    friend Matrix2 operator-(const Matrix2& m);                     // unary operator (-)
    friend Matrix2 operator*(float scalar, const Matrix2& m);       // pre-multiplication
    friend Vector2 operator*(const Vector2& vec, const Matrix2& m); // pre-multiplication
    friend std::ostream& operator<<(std::ostream& os, const Matrix2& m);

protected:

private:
    float m[4];

};



///////////////////////////////////////////////////////////////////////////
// 3x3 matrix
///////////////////////////////////////////////////////////////////////////
class Matrix3
{
public:
    // constructors
    Matrix3();  // init with identity
    Matrix3(const float src[9]);
    Matrix3(float m0, float m1, float m2,           // 1st column
            float m3, float m4, float m5,           // 2nd column
            float m6, float m7, float m8);          // 3rd column

    void        set(const float src[9]);
    void        set(float m0, float m1, float m2,   // 1st column
                    float m3, float m4, float m5,   // 2nd column
                    float m6, float m7, float m8);  // 3rd column
    void        set4(const float src[16]);
    void        setRow(int index, const float row[3]);
    void        setRow(int index, const Vector3& v);
    void        setColumn(int index, const float col[3]);
    void        setColumn(int index, const Vector3& v);

    float* get();
    float       getDeterminant();

    Matrix3&    identity();
    Matrix3&    transpose();                            // transpose itself and return reference
    Matrix3&    invert();

    // operators
    Matrix3     operator+(const Matrix3& rhs) const;    // add rhs
    Matrix3     operator-(const Matrix3& rhs) const;    // subtract rhs
    Matrix3&    operator+=(const Matrix3& rhs);         // add rhs and update this object
    Matrix3&    operator-=(const Matrix3& rhs);         // subtract rhs and update this object
    Vector3     operator*(const Vector3& rhs) const;    // multiplication: v' = M * v
    Matrix3     operator*(const Matrix3& rhs) const;    // multiplication: M3 = M1 * M2
    Matrix3&    operator*=(const Matrix3& rhs);         // multiplication: M1' = M1 * M2
    bool        operator==(const Matrix3& rhs) const;   // exact compare, no epsilon
    bool        operator!=(const Matrix3& rhs) const;   // exact compare, no epsilon
    float       operator[](int index) const;            // subscript operator v[0], v[1]
    float&      operator[](int index);                  // subscript operator v[0], v[1]

    friend Matrix3 operator-(const Matrix3& m);                     // unary operator (-)
    friend Matrix3 operator*(float scalar, const Matrix3& m);       // pre-multiplication
    friend Vector3 operator*(const Vector3& vec, const Matrix3& m); // pre-multiplication
    friend std::ostream& operator<<(std::ostream& os, const Matrix3& m);

protected:

private:
    float m[9];

};



///////////////////////////////////////////////////////////////////////////
// 4x4 matrix
///////////////////////////////////////////////////////////////////////////
class Matrix4
{
public:
    // constructors
    Matrix4();  // init with identity
    Matrix4(const float src[16]);
    Matrix4(float m00, float m01, float m02, float m03, // 1st column
            float m04, float m05, float m06, float m07, // 2nd column
            float m08, float m09, float m10, float m11, // 3rd column
            float m12, float m13, float m14, float m15);// 4th column

    void        set(const float src[16]);
    void        set(float m00, float m01, float m02, float m03, // 1st column
                    float m04, float m05, float m06, float m07, // 2nd column
                    float m08, float m09, float m10, float m11, // 3rd column
                    float m12, float m13, float m14, float m15);// 4th column
    void        setRow(int index, const float row[4]);
    void        setRow(int index, const Vector4& v);
    void        setRow(int index, const Vector3& v);
    void        setColumn(int index, const float col[4]);
    void        setColumn(int index, const Vector4& v);
    void        setColumn(int index, const Vector3& v);

    float* get();
    const float* getTranspose();                        // return transposed matrix
    float        getDeterminant();

    Matrix4&    identity();
    Matrix4&    transpose();                            // transpose itself and return reference
    Matrix4&    invert();                               // check best inverse method before inverse
    Matrix4&    invertEuclidean();                      // inverse of Euclidean transform matrix
    Matrix4&    invertAffine();                         // inverse of affine transform matrix
    Matrix4&    invertProjective();                     // inverse of projective matrix using partitioning
    Matrix4&    invertGeneral();                        // inverse of generic matrix

    // transform matrix
    Matrix4&    translate(float x, float y, float z);   // translation by (x,y,z)
    Matrix4&    translate(const Vector3& v);            //
    Matrix4&    rotate(float angle, const Vector3& axis); // rotate angle(degree) along the given axix
    Matrix4&    rotate(float angle, float x, float y, float z);
    Matrix4&    rotateX(float angle);                   // rotate on X-axis with degree
    Matrix4&    rotateY(float angle);                   // rotate on Y-axis with degree
    Matrix4&    rotateZ(float angle);                   // rotate on Z-axis with degree
    Matrix4&    scale(float scale);                     // uniform scale
    Matrix4&    scale(float sx, float sy, float sz);    // scale by (sx, sy, sz) on each axis

    // operators
    Matrix4     operator+(const Matrix4& rhs) const;    // add rhs
    Matrix4     operator-(const Matrix4& rhs) const;    // subtract rhs
    Matrix4&    operator+=(const Matrix4& rhs);         // add rhs and update this object
    Matrix4&    operator-=(const Matrix4& rhs);         // subtract rhs and update this object
    Vector4     operator*(const Vector4& rhs) const;    // multiplication: v' = M * v
    Vector3     operator*(const Vector3& rhs) const;    // multiplication: v' = M * v
    Matrix4     operator*(const Matrix4& rhs) const;    // multiplication: M3 = M1 * M2
    Matrix4&    operator*=(const Matrix4& rhs);         // multiplication: M1' = M1 * M2
    bool        operator==(const Matrix4& rhs) const;   // exact compare, no epsilon
    bool        operator!=(const Matrix4& rhs) const;   // exact compare, no epsilon
    float       operator[](int index) const;            // subscript operator v[0], v[1]
    float&      operator[](int index);                  // subscript operator v[0], v[1]

    friend Matrix4 operator-(const Matrix4& m);                     // unary operator (-)
    friend Matrix4 operator*(float scalar, const Matrix4& m);       // pre-multiplication
    friend Vector3 operator*(const Vector3& vec, const Matrix4& m); // pre-multiplication
    friend Vector4 operator*(const Vector4& vec, const Matrix4& m); // pre-multiplication
    friend std::ostream& operator<<(std::ostream& os, const Matrix4& m);

protected:

private:
    float       getCofactor(float m0, float m1, float m2,
                            float m3, float m4, float m5,
                            float m6, float m7, float m8);

    float m[16];
    float tm[16];                                       // transpose m

};



///////////////////////////////////////////////////////////////////////////
// inline functions for Matrix2
///////////////////////////////////////////////////////////////////////////
inline Matrix2::Matrix2()
{
    // initially identity matrix
    identity();
}



inline Matrix2::Matrix2(const float src[4])
{
    set(src);
}



inline Matrix2::Matrix2(float m0, float m1, float m2, float m3)
{
    set(m0, m1, m2, m3);
}



inline void Matrix2::set(const float src[4])
{
    m[0] = src[0];  m[1] = src[1];  m[2] = src[2];  m[3] = src[3];
}



inline void Matrix2::set(float m0, float m1, float m2, float m3)
{
    m[0]= m0;  m[1] = m1;  m[2] = m2;  m[3]= m3;
}



inline void Matrix2::setRow(int index, const float row[2])
{
    m[index] = row[0];  m[index + 2] = row[1];
}



inline void Matrix2::setRow(int index, const Vector2& v)
{
    m[index] = v.x;  m[index + 2] = v.y;
}



inline void Matrix2::setColumn(int index, const float col[2])
{
    m[index*2] = col[0];  m[index*2 + 1] = col[1];
}



inline void Matrix2::setColumn(int index, const Vector2& v)
{
    m[index*2] = v.x;  m[index*2 + 1] = v.y;
}



inline float* Matrix2::get()
{
    return m;
}



inline Matrix2& Matrix2::identity()
{
    m[0] = m[3] = 1.0f;
    m[1] = m[2] = 0.0f;
    return *this;
}



inline Matrix2 Matrix2::operator+(const Matrix2& rhs) const
{
    return Matrix2(m[0]+rhs[0], m[1]+rhs[1], m[2]+rhs[2], m[3]+rhs[3]);
}



inline Matrix2 Matrix2::operator-(const Matrix2& rhs) const
{
    return Matrix2(m[0]-rhs[0], m[1]-rhs[1], m[2]-rhs[2], m[3]-rhs[3]);
}



inline Matrix2& Matrix2::operator+=(const Matrix2& rhs)
{
    m[0] += rhs[0];  m[1] += rhs[1];  m[2] += rhs[2];  m[3] += rhs[3];
    return *this;
}



inline Matrix2& Matrix2::operator-=(const Matrix2& rhs)
{
    m[0] -= rhs[0];  m[1] -= rhs[1];  m[2] -= rhs[2];  m[3] -= rhs[3];
    return *this;
}



inline Vector2 Matrix2::operator*(const Vector2& rhs) const
{
    return Vector2(m[0]*rhs.x + m[2]*rhs.y,  m[1]*rhs.x + m[3]*rhs.y);
}



inline Matrix2 Matrix2::operator*(const Matrix2& rhs) const
{
    return Matrix2(m[0]*rhs[0] + m[2]*rhs[1],  m[1]*rhs[0] + m[3]*rhs[1],
                   m[0]*rhs[2] + m[2]*rhs[3],  m[1]*rhs[2] + m[3]*rhs[3]);
}



inline Matrix2& Matrix2::operator*=(const Matrix2& rhs)
{
    *this = *this * rhs;
    return *this;
}



inline bool Matrix2::operator==(const Matrix2& rhs) const
{
    return (m[0] == rhs[0]) && (m[1] == rhs[1]) && (m[2] == rhs[2]) && (m[3] == rhs[3]);
}



inline bool Matrix2::operator!=(const Matrix2& rhs) const
{
    return (m[0] != rhs[0]) || (m[1] != rhs[1]) || (m[2] != rhs[2]) || (m[3] != rhs[3]);
}



inline float Matrix2::operator[](int index) const
{
    return m[index];
}



inline float& Matrix2::operator[](int index)
{
    return m[index];
}



inline Matrix2 operator-(const Matrix2& rhs)
{
    return Matrix2(-rhs[0], -rhs[1], -rhs[2], -rhs[3]);
}



inline Matrix2 operator*(float s, const Matrix2& rhs)
{
    return Matrix2(s*rhs[0], s*rhs[1], s*rhs[2], s*rhs[3]);
}



inline Vector2 operator*(const Vector2& v, const Matrix2& rhs)
{
    return Vector2(v.x*rhs[0] + v.y*rhs[1],  v.x*rhs[2] + v.y*rhs[3]);
}



inline std::ostream& operator<<(std::ostream& os, const Matrix2& m)
{
    os << std::fixed << std::setprecision(5);
    os << "[" << std::setw(10) << m[0] << " " << std::setw(10) << m[2] << "]\n"
       << "[" << std::setw(10) << m[1] << " " << std::setw(10) << m[3] << "]\n";
    os << std::resetiosflags(std::ios_base::fixed | std::ios_base::floatfield);
    return os;
}
// END OF MATRIX2 INLINE //////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////
// inline functions for Matrix3
///////////////////////////////////////////////////////////////////////////
inline Matrix3::Matrix3()
{
    // initially identity matrix
    identity();
}



inline Matrix3::Matrix3(const float src[9])
{
    set(src);
}



inline Matrix3::Matrix3(float m0, float m1, float m2,
                        float m3, float m4, float m5,
                        float m6, float m7, float m8)
{
    set(m0, m1, m2,  m3, m4, m5,  m6, m7, m8);
}



inline void Matrix3::set(const float src[9])
{
    m[0] = src[0];  m[1] = src[1];  m[2] = src[2];
    m[3] = src[3];  m[4] = src[4];  m[5] = src[5];
    m[6] = src[6];  m[7] = src[7];  m[8] = src[8];
}

inline void Matrix3::set4(const float src[16])
{
    m[0] = src[0];  m[1] = src[1];  m[2] = src[2]; // src[3]
    m[3] = src[4];  m[4] = src[5];  m[5] = src[6]; // src[7]
    m[6] = src[8];  m[7] = src[9];  m[8] = src[10]; // src[11]
}


inline void Matrix3::set(float m0, float m1, float m2,
                         float m3, float m4, float m5,
                         float m6, float m7, float m8)
{
    m[0] = m0;  m[1] = m1;  m[2] = m2;
    m[3] = m3;  m[4] = m4;  m[5] = m5;
    m[6] = m6;  m[7] = m7;  m[8] = m8;
}



inline void Matrix3::setRow(int index, const float row[3])
{
    m[index] = row[0];  m[index + 3] = row[1];  m[index + 6] = row[2];
}



inline void Matrix3::setRow(int index, const Vector3& v)
{
    m[index] = v.x;  m[index + 3] = v.y;  m[index + 6] = v.z;
}



inline void Matrix3::setColumn(int index, const float col[3])
{
    m[index*3] = col[0];  m[index*3 + 1] = col[1];  m[index*3 + 2] = col[2];
}



inline void Matrix3::setColumn(int index, const Vector3& v)
{
    m[index*3] = v.x;  m[index*3 + 1] = v.y;  m[index*3 + 2] = v.z;
}



inline float* Matrix3::get()
{
    return m;
}



inline Matrix3& Matrix3::identity()
{
    m[0] = m[4] = m[8] = 1.0f;
    m[1] = m[2] = m[3] = m[5] = m[6] = m[7] = 0.0f;
    return *this;
}



inline Matrix3 Matrix3::operator+(const Matrix3& rhs) const
{
    return Matrix3(m[0]+rhs[0], m[1]+rhs[1], m[2]+rhs[2],
                   m[3]+rhs[3], m[4]+rhs[4], m[5]+rhs[5],
                   m[6]+rhs[6], m[7]+rhs[7], m[8]+rhs[8]);
}



inline Matrix3 Matrix3::operator-(const Matrix3& rhs) const
{
    return Matrix3(m[0]-rhs[0], m[1]-rhs[1], m[2]-rhs[2],
                   m[3]-rhs[3], m[4]-rhs[4], m[5]-rhs[5],
                   m[6]-rhs[6], m[7]-rhs[7], m[8]-rhs[8]);
}



inline Matrix3& Matrix3::operator+=(const Matrix3& rhs)
{
    m[0] += rhs[0];  m[1] += rhs[1];  m[2] += rhs[2];
    m[3] += rhs[3];  m[4] += rhs[4];  m[5] += rhs[5];
    m[6] += rhs[6];  m[7] += rhs[7];  m[8] += rhs[8];
    return *this;
}



inline Matrix3& Matrix3::operator-=(const Matrix3& rhs)
{
    m[0] -= rhs[0];  m[1] -= rhs[1];  m[2] -= rhs[2];
    m[3] -= rhs[3];  m[4] -= rhs[4];  m[5] -= rhs[5];
    m[6] -= rhs[6];  m[7] -= rhs[7];  m[8] -= rhs[8];
    return *this;
}



inline Vector3 Matrix3::operator*(const Vector3& rhs) const
{
    return Vector3(m[0]*rhs.x + m[3]*rhs.y + m[6]*rhs.z,
                   m[1]*rhs.x + m[4]*rhs.y + m[7]*rhs.z,
                   m[2]*rhs.x + m[5]*rhs.y + m[8]*rhs.z);
}



inline Matrix3 Matrix3::operator*(const Matrix3& rhs) const
{
    return Matrix3(m[0]*rhs[0] + m[3]*rhs[1] + m[6]*rhs[2],  m[1]*rhs[0] + m[4]*rhs[1] + m[7]*rhs[2],  m[2]*rhs[0] + m[5]*rhs[1] + m[8]*rhs[2],
                   m[0]*rhs[3] + m[3]*rhs[4] + m[6]*rhs[5],  m[1]*rhs[3] + m[4]*rhs[4] + m[7]*rhs[5],  m[2]*rhs[3] + m[5]*rhs[4] + m[8]*rhs[5],
                   m[0]*rhs[6] + m[3]*rhs[7] + m[6]*rhs[8],  m[1]*rhs[6] + m[4]*rhs[7] + m[7]*rhs[8],  m[2]*rhs[6] + m[5]*rhs[7] + m[8]*rhs[8]);
}



inline Matrix3& Matrix3::operator*=(const Matrix3& rhs)
{
    *this = *this * rhs;
    return *this;
}



inline bool Matrix3::operator==(const Matrix3& rhs) const
{
    return (m[0] == rhs[0]) && (m[1] == rhs[1]) && (m[2] == rhs[2]) &&
           (m[3] == rhs[3]) && (m[4] == rhs[4]) && (m[5] == rhs[5]) &&
           (m[6] == rhs[6]) && (m[7] == rhs[7]) && (m[8] == rhs[8]);
}



inline bool Matrix3::operator!=(const Matrix3& rhs) const
{
    return (m[0] != rhs[0]) || (m[1] != rhs[1]) || (m[2] != rhs[2]) ||
           (m[3] != rhs[3]) || (m[4] != rhs[4]) || (m[5] != rhs[5]) ||
           (m[6] != rhs[6]) || (m[7] != rhs[7]) || (m[8] != rhs[8]);
}



inline float Matrix3::operator[](int index) const
{
    return m[index];
}



inline float& Matrix3::operator[](int index)
{
    return m[index];
}



inline Matrix3 operator-(const Matrix3& rhs)
{
    return Matrix3(-rhs[0], -rhs[1], -rhs[2], -rhs[3], -rhs[4], -rhs[5], -rhs[6], -rhs[7], -rhs[8]);
}



inline Matrix3 operator*(float s, const Matrix3& rhs)
{
    return Matrix3(s*rhs[0], s*rhs[1], s*rhs[2], s*rhs[3], s*rhs[4], s*rhs[5], s*rhs[6], s*rhs[7], s*rhs[8]);
}



inline Vector3 operator*(const Vector3& v, const Matrix3& m)
{
    return Vector3(v.x*m[0] + v.y*m[1] + v.z*m[2],  v.x*m[3] + v.y*m[4] + v.z*m[5],  v.x*m[6] + v.y*m[7] + v.z*m[8]);
}



inline std::ostream& operator<<(std::ostream& os, const Matrix3& m)
{
    os << std::fixed << std::setprecision(5);
    os << "[" << std::setw(10) << m[0] << " " << std::setw(10) << m[3] << " " << std::setw(10) << m[6] << "]\n"
       << "[" << std::setw(10) << m[1] << " " << std::setw(10) << m[4] << " " << std::setw(10) << m[7] << "]\n"
       << "[" << std::setw(10) << m[2] << " " << std::setw(10) << m[5] << " " << std::setw(10) << m[8] << "]\n";
    os << std::resetiosflags(std::ios_base::fixed | std::ios_base::floatfield);
    return os;
}
// END OF MATRIX3 INLINE //////////////////////////////////////////////////////




///////////////////////////////////////////////////////////////////////////
// inline functions for Matrix4
///////////////////////////////////////////////////////////////////////////
inline Matrix4::Matrix4()
{
    // initially identity matrix
    identity();
}



inline Matrix4::Matrix4(const float src[16])
{
    set(src);
}



inline Matrix4::Matrix4(float m00, float m01, float m02, float m03,
                        float m04, float m05, float m06, float m07,
                        float m08, float m09, float m10, float m11,
                        float m12, float m13, float m14, float m15)
{
    set(m00, m01, m02, m03,  m04, m05, m06, m07,  m08, m09, m10, m11,  m12, m13, m14, m15);
}



inline void Matrix4::set(const float src[16])
{
    m[0] = src[0];  m[1] = src[1];  m[2] = src[2];  m[3] = src[3];
    m[4] = src[4];  m[5] = src[5];  m[6] = src[6];  m[7] = src[7];
    m[8] = src[8];  m[9] = src[9];  m[10]= src[10]; m[11]= src[11];
    m[12]= src[12]; m[13]= src[13]; m[14]= src[14]; m[15]= src[15];
}



inline void Matrix4::set(float m00, float m01, float m02, float m03,
                         float m04, float m05, float m06, float m07,
                         float m08, float m09, float m10, float m11,
                         float m12, float m13, float m14, float m15)
{
    m[0] = m00;  m[1] = m01;  m[2] = m02;  m[3] = m03;
    m[4] = m04;  m[5] = m05;  m[6] = m06;  m[7] = m07;
    m[8] = m08;  m[9] = m09;  m[10]= m10;  m[11]= m11;
    m[12]= m12;  m[13]= m13;  m[14]= m14;  m[15]= m15;
}



inline void Matrix4::setRow(int index, const float row[4])
{
    m[index] = row[0];  m[index + 4] = row[1];  m[index + 8] = row[2];  m[index + 12] = row[3];
}



inline void Matrix4::setRow(int index, const Vector4& v)
{
    m[index] = v.x;  m[index + 4] = v.y;  m[index + 8] = v.z;  m[index + 12] = v.w;
}



inline void Matrix4::setRow(int index, const Vector3& v)
{
    m[index] = v.x;  m[index + 4] = v.y;  m[index + 8] = v.z;
}



inline void Matrix4::setColumn(int index, const float col[4])
{
    m[index*4] = col[0];  m[index*4 + 1] = col[1];  m[index*4 + 2] = col[2];  m[index*4 + 3] = col[3];
}



inline void Matrix4::setColumn(int index, const Vector4& v)
{
    m[index*4] = v.x;  m[index*4 + 1] = v.y;  m[index*4 + 2] = v.z;  m[index*4 + 3] = v.w;
}



inline void Matrix4::setColumn(int index, const Vector3& v)
{
    m[index*4] = v.x;  m[index*4 + 1] = v.y;  m[index*4 + 2] = v.z;
}



inline float* Matrix4::get()
{
    return m;
}



inline const float* Matrix4::getTranspose()
{
    tm[0] = m[0];   tm[1] = m[4];   tm[2] = m[8];   tm[3] = m[12];
    tm[4] = m[1];   tm[5] = m[5];   tm[6] = m[9];   tm[7] = m[13];
    tm[8] = m[2];   tm[9] = m[6];   tm[10]= m[10];  tm[11]= m[14];
    tm[12]= m[3];   tm[13]= m[7];   tm[14]= m[11];  tm[15]= m[15];
    return tm;
}



inline Matrix4& Matrix4::identity()
{
    m[0] = m[5] = m[10] = m[15] = 1.0f;
    m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0.0f;
    return *this;
}



inline Matrix4 Matrix4::operator+(const Matrix4& rhs) const
{
    return Matrix4(m[0]+rhs[0],   m[1]+rhs[1],   m[2]+rhs[2],   m[3]+rhs[3],
                   m[4]+rhs[4],   m[5]+rhs[5],   m[6]+rhs[6],   m[7]+rhs[7],
                   m[8]+rhs[8],   m[9]+rhs[9],   m[10]+rhs[10], m[11]+rhs[11],
                   m[12]+rhs[12], m[13]+rhs[13], m[14]+rhs[14], m[15]+rhs[15]);
}



inline Matrix4 Matrix4::operator-(const Matrix4& rhs) const
{
    return Matrix4(m[0]-rhs[0],   m[1]-rhs[1],   m[2]-rhs[2],   m[3]-rhs[3],
                   m[4]-rhs[4],   m[5]-rhs[5],   m[6]-rhs[6],   m[7]-rhs[7],
                   m[8]-rhs[8],   m[9]-rhs[9],   m[10]-rhs[10], m[11]-rhs[11],
                   m[12]-rhs[12], m[13]-rhs[13], m[14]-rhs[14], m[15]-rhs[15]);
}



inline Matrix4& Matrix4::operator+=(const Matrix4& rhs)
{
    m[0] += rhs[0];   m[1] += rhs[1];   m[2] += rhs[2];   m[3] += rhs[3];
    m[4] += rhs[4];   m[5] += rhs[5];   m[6] += rhs[6];   m[7] += rhs[7];
    m[8] += rhs[8];   m[9] += rhs[9];   m[10]+= rhs[10];  m[11]+= rhs[11];
    m[12]+= rhs[12];  m[13]+= rhs[13];  m[14]+= rhs[14];  m[15]+= rhs[15];
    return *this;
}



inline Matrix4& Matrix4::operator-=(const Matrix4& rhs)
{
    m[0] -= rhs[0];   m[1] -= rhs[1];   m[2] -= rhs[2];   m[3] -= rhs[3];
    m[4] -= rhs[4];   m[5] -= rhs[5];   m[6] -= rhs[6];   m[7] -= rhs[7];
    m[8] -= rhs[8];   m[9] -= rhs[9];   m[10]-= rhs[10];  m[11]-= rhs[11];
    m[12]-= rhs[12];  m[13]-= rhs[13];  m[14]-= rhs[14];  m[15]-= rhs[15];
    return *this;
}



inline Vector4 Matrix4::operator*(const Vector4& rhs) const
{
    return Vector4(m[0]*rhs.x + m[4]*rhs.y + m[8]*rhs.z  + m[12]*rhs.w,
                   m[1]*rhs.x + m[5]*rhs.y + m[9]*rhs.z  + m[13]*rhs.w,
                   m[2]*rhs.x + m[6]*rhs.y + m[10]*rhs.z + m[14]*rhs.w,
                   m[3]*rhs.x + m[7]*rhs.y + m[11]*rhs.z + m[15]*rhs.w);
}



inline Vector3 Matrix4::operator*(const Vector3& rhs) const
{
    return Vector3(m[0]*rhs.x + m[4]*rhs.y + m[8]*rhs.z,
                   m[1]*rhs.x + m[5]*rhs.y + m[9]*rhs.z,
                   m[2]*rhs.x + m[6]*rhs.y + m[10]*rhs.z);
}



inline Matrix4 Matrix4::operator*(const Matrix4& n) const
{
    return Matrix4(m[0]*n[0]  + m[4]*n[1]  + m[8]*n[2]  + m[12]*n[3],   m[1]*n[0]  + m[5]*n[1]  + m[9]*n[2]  + m[13]*n[3],   m[2]*n[0]  + m[6]*n[1]  + m[10]*n[2]  + m[14]*n[3],   m[3]*n[0]  + m[7]*n[1]  + m[11]*n[2]  + m[15]*n[3],
                   m[0]*n[4]  + m[4]*n[5]  + m[8]*n[6]  + m[12]*n[7],   m[1]*n[4]  + m[5]*n[5]  + m[9]*n[6]  + m[13]*n[7],   m[2]*n[4]  + m[6]*n[5]  + m[10]*n[6]  + m[14]*n[7],   m[3]*n[4]  + m[7]*n[5]  + m[11]*n[6]  + m[15]*n[7],
                   m[0]*n[8]  + m[4]*n[9]  + m[8]*n[10] + m[12]*n[11],  m[1]*n[8]  + m[5]*n[9]  + m[9]*n[10] + m[13]*n[11],  m[2]*n[8]  + m[6]*n[9]  + m[10]*n[10] + m[14]*n[11],  m[3]*n[8]  + m[7]*n[9]  + m[11]*n[10] + m[15]*n[11],
                   m[0]*n[12] + m[4]*n[13] + m[8]*n[14] + m[12]*n[15],  m[1]*n[12] + m[5]*n[13] + m[9]*n[14] + m[13]*n[15],  m[2]*n[12] + m[6]*n[13] + m[10]*n[14] + m[14]*n[15],  m[3]*n[12] + m[7]*n[13] + m[11]*n[14] + m[15]*n[15]);
}



inline Matrix4& Matrix4::operator*=(const Matrix4& rhs)
{
    *this = *this * rhs;
    return *this;
}



inline bool Matrix4::operator==(const Matrix4& n) const
{
    return (m[0] == n[0])  && (m[1] == n[1])  && (m[2] == n[2])  && (m[3] == n[3])  &&
           (m[4] == n[4])  && (m[5] == n[5])  && (m[6] == n[6])  && (m[7] == n[7])  &&
           (m[8] == n[8])  && (m[9] == n[9])  && (m[10]== n[10]) && (m[11]== n[11]) &&
           (m[12]== n[12]) && (m[13]== n[13]) && (m[14]== n[14]) && (m[15]== n[15]);
}



inline bool Matrix4::operator!=(const Matrix4& n) const
{
    return (m[0] != n[0])  || (m[1] != n[1])  || (m[2] != n[2])  || (m[3] != n[3])  ||
           (m[4] != n[4])  || (m[5] != n[5])  || (m[6] != n[6])  || (m[7] != n[7])  ||
           (m[8] != n[8])  || (m[9] != n[9])  || (m[10]!= n[10]) || (m[11]!= n[11]) ||
           (m[12]!= n[12]) || (m[13]!= n[13]) || (m[14]!= n[14]) || (m[15]!= n[15]);
}



inline float Matrix4::operator[](int index) const
{
    return m[index];
}



inline float& Matrix4::operator[](int index)
{
    return m[index];
}



inline Matrix4 operator-(const Matrix4& rhs)
{
    return Matrix4(-rhs[0], -rhs[1], -rhs[2], -rhs[3], -rhs[4], -rhs[5], -rhs[6], -rhs[7], -rhs[8], -rhs[9], -rhs[10], -rhs[11], -rhs[12], -rhs[13], -rhs[14], -rhs[15]);
}



inline Matrix4 operator*(float s, const Matrix4& rhs)
{
    return Matrix4(s*rhs[0], s*rhs[1], s*rhs[2], s*rhs[3], s*rhs[4], s*rhs[5], s*rhs[6], s*rhs[7], s*rhs[8], s*rhs[9], s*rhs[10], s*rhs[11], s*rhs[12], s*rhs[13], s*rhs[14], s*rhs[15]);
}



inline Vector4 operator*(const Vector4& v, const Matrix4& m)
{
    return Vector4(v.x*m[0] + v.y*m[1] + v.z*m[2] + v.w*m[3],  v.x*m[4] + v.y*m[5] + v.z*m[6] + v.w*m[7],  v.x*m[8] + v.y*m[9] + v.z*m[10] + v.w*m[11], v.x*m[12] + v.y*m[13] + v.z*m[14] + v.w*m[15]);
}



inline Vector3 operator*(const Vector3& v, const Matrix4& m)
{
    return Vector3(v.x*m[0] + v.y*m[1] + v.z*m[2],  v.x*m[4] + v.y*m[5] + v.z*m[6],  v.x*m[8] + v.y*m[9] + v.z*m[10]);
}



inline std::ostream& operator<<(std::ostream& os, const Matrix4& m)
{
    os << std::fixed << std::setprecision(5);
    os << "[" << std::setw(10) << m[0] << " " << std::setw(10) << m[4] << " " << std::setw(10) << m[8]  <<  " " << std::setw(10) << m[12] << "]\n"
       << "[" << std::setw(10) << m[1] << " " << std::setw(10) << m[5] << " " << std::setw(10) << m[9]  <<  " " << std::setw(10) << m[13] << "]\n"
       << "[" << std::setw(10) << m[2] << " " << std::setw(10) << m[6] << " " << std::setw(10) << m[10] <<  " " << std::setw(10) << m[14] << "]\n"
       << "[" << std::setw(10) << m[3] << " " << std::setw(10) << m[7] << " " << std::setw(10) << m[11] <<  " " << std::setw(10) << m[15] << "]\n";
    os << std::resetiosflags(std::ios_base::fixed | std::ios_base::floatfield);
    return os;
}






//###


///////////////////////////////////////////////////////////////////////////////
// Matrice.cpp
// ===========
// NxN Matrix Math classes
//
// The elements of the matrix are stored as column major order.
// | 0 2 |    | 0 3 6 |    |  0  4  8 12 |
// | 1 3 |    | 1 4 7 |    |  1  5  9 13 |
//            | 2 5 8 |    |  2  6 10 14 |
//                         |  3  7 11 15 |
//
//  AUTHOR: Song Ho Ahn (song.ahn at gmail.com)
// CREATED: 2005-06-24
// UPDATED: 2014-09-21
//
// Copyright (C) 2005 Song Ho Ahn
///////////////////////////////////////////////////////////////////////////////


const float DEG2RAD = 3.141593f / 180;
const float EPSILON = 0.00001f;



///////////////////////////////////////////////////////////////////////////////
// transpose 2x2 matrix
///////////////////////////////////////////////////////////////////////////////
Matrix2& Matrix2::transpose()
{
    std::swap(m[1],  m[2]);
    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// return the determinant of 2x2 matrix
///////////////////////////////////////////////////////////////////////////////
float Matrix2::getDeterminant()
{
    return m[0] * m[3] - m[1] * m[2];
}



///////////////////////////////////////////////////////////////////////////////
// inverse of 2x2 matrix
// If cannot find inverse, set identity matrix
///////////////////////////////////////////////////////////////////////////////
Matrix2& Matrix2::invert()
{
    float determinant = getDeterminant();
    if(fabs(determinant) <= EPSILON)
    {
        return identity();
    }

    float tmp = m[0];   // copy the first element
    float invDeterminant = 1.0f / determinant;
    m[0] =  invDeterminant * m[3];
    m[1] = -invDeterminant * m[1];
    m[2] = -invDeterminant * m[2];
    m[3] =  invDeterminant * tmp;

    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// transpose 3x3 matrix
///////////////////////////////////////////////////////////////////////////////
Matrix3& Matrix3::transpose()
{
    std::swap(m[1],  m[3]);
    std::swap(m[2],  m[6]);
    std::swap(m[5],  m[7]);

    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// return determinant of 3x3 matrix
///////////////////////////////////////////////////////////////////////////////
float Matrix3::getDeterminant()
{
    return m[0] * (m[4] * m[8] - m[5] * m[7]) -
           m[1] * (m[3] * m[8] - m[5] * m[6]) +
           m[2] * (m[3] * m[7] - m[4] * m[6]);
}



///////////////////////////////////////////////////////////////////////////////
// inverse 3x3 matrix
// If cannot find inverse, set identity matrix
///////////////////////////////////////////////////////////////////////////////
Matrix3& Matrix3::invert()
{
    float determinant, invDeterminant;
    float tmp[9];

    tmp[0] = m[4] * m[8] - m[5] * m[7];
    tmp[1] = m[2] * m[7] - m[1] * m[8];
    tmp[2] = m[1] * m[5] - m[2] * m[4];
    tmp[3] = m[5] * m[6] - m[3] * m[8];
    tmp[4] = m[0] * m[8] - m[2] * m[6];
    tmp[5] = m[2] * m[3] - m[0] * m[5];
    tmp[6] = m[3] * m[7] - m[4] * m[6];
    tmp[7] = m[1] * m[6] - m[0] * m[7];
    tmp[8] = m[0] * m[4] - m[1] * m[3];

    // check determinant if it is 0
    determinant = m[0] * tmp[0] + m[1] * tmp[3] + m[2] * tmp[6];
    if(fabs(determinant) <= EPSILON)
    {
        return identity(); // cannot inverse, make it idenety matrix
    }

    // divide by the determinant
    invDeterminant = 1.0f / determinant;
    m[0] = invDeterminant * tmp[0];
    m[1] = invDeterminant * tmp[1];
    m[2] = invDeterminant * tmp[2];
    m[3] = invDeterminant * tmp[3];
    m[4] = invDeterminant * tmp[4];
    m[5] = invDeterminant * tmp[5];
    m[6] = invDeterminant * tmp[6];
    m[7] = invDeterminant * tmp[7];
    m[8] = invDeterminant * tmp[8];

    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// transpose 4x4 matrix
///////////////////////////////////////////////////////////////////////////////
Matrix4& Matrix4::transpose()
{
    std::swap(m[1],  m[4]);
    std::swap(m[2],  m[8]);
    std::swap(m[3],  m[12]);
    std::swap(m[6],  m[9]);
    std::swap(m[7],  m[13]);
    std::swap(m[11], m[14]);

    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// inverse 4x4 matrix
///////////////////////////////////////////////////////////////////////////////
Matrix4& Matrix4::invert()
{
    // If the 4th row is [0,0,0,1] then it is affine matrix and
    // it has no projective transformation.
    if(m[3] == 0 && m[7] == 0 && m[11] == 0 && m[15] == 1)
        this->invertAffine();
    else
    {
        this->invertGeneral();
        
    }

    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// compute the inverse of 4x4 Euclidean transformation matrix
//
// Euclidean transformation is translation, rotation, and reflection.
// With Euclidean transform, only the position and orientation of the object
// will be changed. Euclidean transform does not change the shape of an object
// (no scaling). Length and angle are reserved.
//
// Use inverseAffine() if the matrix has scale and shear transformation.
//
// M = [ R | T ]
//     [ --+-- ]    (R denotes 3x3 rotation/reflection matrix)
//     [ 0 | 1 ]    (T denotes 1x3 translation matrix)
//
// y = M*x  ->  y = R*x + T  ->  x = R^-1*(y - T)  ->  x = R^T*y - R^T*T
// (R is orthogonal,  R^-1 = R^T)
//
//  [ R | T ]-1    [ R^T | -R^T * T ]    (R denotes 3x3 rotation matrix)
//  [ --+-- ]   =  [ ----+--------- ]    (T denotes 1x3 translation)
//  [ 0 | 1 ]      [  0  |     1    ]    (R^T denotes R-transpose)
///////////////////////////////////////////////////////////////////////////////
Matrix4& Matrix4::invertEuclidean()
{
    // transpose 3x3 rotation matrix part
    // | R^T | 0 |
    // | ----+-- |
    // |  0  | 1 |
    float tmp;
    tmp = m[1];  m[1] = m[4];  m[4] = tmp;
    tmp = m[2];  m[2] = m[8];  m[8] = tmp;
    tmp = m[6];  m[6] = m[9];  m[9] = tmp;

    // compute translation part -R^T * T
    // | 0 | -R^T x |
    // | --+------- |
    // | 0 |   0    |
    float x = m[12];
    float y = m[13];
    float z = m[14];
    m[12] = -(m[0] * x + m[4] * y + m[8] * z);
    m[13] = -(m[1] * x + m[5] * y + m[9] * z);
    m[14] = -(m[2] * x + m[6] * y + m[10]* z);

    // last row should be unchanged (0,0,0,1)

    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// compute the inverse of a 4x4 affine transformation matrix
//
// Affine transformations are generalizations of Euclidean transformations.
// Affine transformation includes translation, rotation, reflection, scaling,
// and shearing. Length and angle are NOT preserved.
// M = [ R | T ]
//     [ --+-- ]    (R denotes 3x3 rotation/scale/shear matrix)
//     [ 0 | 1 ]    (T denotes 1x3 translation matrix)
//
// y = M*x  ->  y = R*x + T  ->  x = R^-1*(y - T)  ->  x = R^-1*y - R^-1*T
//
//  [ R | T ]-1   [ R^-1 | -R^-1 * T ]
//  [ --+-- ]   = [ -----+---------- ]
//  [ 0 | 1 ]     [  0   +     1     ]
///////////////////////////////////////////////////////////////////////////////
Matrix4& Matrix4::invertAffine()
{
    // R^-1
    Matrix3 r(m[0],m[1],m[2], m[4],m[5],m[6], m[8],m[9],m[10]);
    r.invert();
    m[0] = r[0];  m[1] = r[1];  m[2] = r[2];
    m[4] = r[3];  m[5] = r[4];  m[6] = r[5];
    m[8] = r[6];  m[9] = r[7];  m[10]= r[8];

    // -R^-1 * T
    float x = m[12];
    float y = m[13];
    float z = m[14];
    m[12] = -(r[0] * x + r[3] * y + r[6] * z);
    m[13] = -(r[1] * x + r[4] * y + r[7] * z);
    m[14] = -(r[2] * x + r[5] * y + r[8] * z);

    // last row should be unchanged (0,0,0,1)
    //m[3] = m[7] = m[11] = 0.0f;
    //m[15] = 1.0f;

    return * this;
}



///////////////////////////////////////////////////////////////////////////////
// inverse matrix using matrix partitioning (blockwise inverse)
// It devides a 4x4 matrix into 4 of 2x2 matrices. It works in case of where
// det(A) != 0. If not, use the generic inverse method
// inverse formula.
// M = [ A | B ]    A, B, C, D are 2x2 matrix blocks
//     [ --+-- ]    det(M) = |A| * |D - ((C * A^-1) * B)|
//     [ C | D ]
//
// M^-1 = [ A' | B' ]   A' = A^-1 - (A^-1 * B) * C'
//        [ ---+--- ]   B' = (A^-1 * B) * -D'
//        [ C' | D' ]   C' = -D' * (C * A^-1)
//                      D' = (D - ((C * A^-1) * B))^-1
//
// NOTE: I wrap with () if it it used more than once.
//       The matrix is invertable even if det(A)=0, so must check det(A) before
//       calling this function, and use invertGeneric() instead.
///////////////////////////////////////////////////////////////////////////////
Matrix4& Matrix4::invertProjective()
{
    // partition
    Matrix2 a(m[0], m[1], m[4], m[5]);
    Matrix2 b(m[8], m[9], m[12], m[13]);
    Matrix2 c(m[2], m[3], m[6], m[7]);
    Matrix2 d(m[10], m[11], m[14], m[15]);

    // pre-compute repeated parts
    a.invert();             // A^-1
    Matrix2 ab = a * b;     // A^-1 * B
    Matrix2 ca = c * a;     // C * A^-1
    Matrix2 cab = ca * b;   // C * A^-1 * B
    Matrix2 dcab = d - cab; // D - C * A^-1 * B

    // check determinant if |D - C * A^-1 * B| = 0
    //NOTE: this function assumes det(A) is already checked. if |A|=0 then,
    //      cannot use this function.
    float determinant = dcab[0] * dcab[3] - dcab[1] * dcab[2];
    if(fabs(determinant) <= EPSILON)
    {
        return identity();
    }

    // compute D' and -D'
    Matrix2 d1 = dcab;      //  (D - C * A^-1 * B)
    d1.invert();            //  (D - C * A^-1 * B)^-1
    Matrix2 d2 = -d1;       // -(D - C * A^-1 * B)^-1

    // compute C'
    Matrix2 c1 = d2 * ca;   // -D' * (C * A^-1)

    // compute B'
    Matrix2 b1 = ab * d2;   // (A^-1 * B) * -D'

    // compute A'
    Matrix2 a1 = a - (ab * c1); // A^-1 - (A^-1 * B) * C'

    // assemble inverse matrix
    m[0] = a1[0];  m[4] = a1[2]; /*|*/ m[8] = b1[0];  m[12]= b1[2];
    m[1] = a1[1];  m[5] = a1[3]; /*|*/ m[9] = b1[1];  m[13]= b1[3];
    /*-----------------------------+-----------------------------*/
    m[2] = c1[0];  m[6] = c1[2]; /*|*/ m[10]= d1[0];  m[14]= d1[2];
    m[3] = c1[1];  m[7] = c1[3]; /*|*/ m[11]= d1[1];  m[15]= d1[3];

    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// compute the inverse of a general 4x4 matrix using Cramer's Rule
// If cannot find inverse, return indentity matrix
// M^-1 = adj(M) / det(M)
///////////////////////////////////////////////////////////////////////////////
Matrix4& Matrix4::invertGeneral()
{
    // get cofactors of minor matrices
    float cofactor0 = getCofactor(m[5],m[6],m[7], m[9],m[10],m[11], m[13],m[14],m[15]);
    float cofactor1 = getCofactor(m[4],m[6],m[7], m[8],m[10],m[11], m[12],m[14],m[15]);
    float cofactor2 = getCofactor(m[4],m[5],m[7], m[8],m[9], m[11], m[12],m[13],m[15]);
    float cofactor3 = getCofactor(m[4],m[5],m[6], m[8],m[9], m[10], m[12],m[13],m[14]);

    // get determinant
    float determinant = m[0] * cofactor0 - m[1] * cofactor1 + m[2] * cofactor2 - m[3] * cofactor3;
    if(fabs(determinant) <= EPSILON)
    {
        return identity();
    }

    // get rest of cofactors for adj(M)
    float cofactor4 = getCofactor(m[1],m[2],m[3], m[9],m[10],m[11], m[13],m[14],m[15]);
    float cofactor5 = getCofactor(m[0],m[2],m[3], m[8],m[10],m[11], m[12],m[14],m[15]);
    float cofactor6 = getCofactor(m[0],m[1],m[3], m[8],m[9], m[11], m[12],m[13],m[15]);
    float cofactor7 = getCofactor(m[0],m[1],m[2], m[8],m[9], m[10], m[12],m[13],m[14]);

    float cofactor8 = getCofactor(m[1],m[2],m[3], m[5],m[6], m[7],  m[13],m[14],m[15]);
    float cofactor9 = getCofactor(m[0],m[2],m[3], m[4],m[6], m[7],  m[12],m[14],m[15]);
    float cofactor10= getCofactor(m[0],m[1],m[3], m[4],m[5], m[7],  m[12],m[13],m[15]);
    float cofactor11= getCofactor(m[0],m[1],m[2], m[4],m[5], m[6],  m[12],m[13],m[14]);

    float cofactor12= getCofactor(m[1],m[2],m[3], m[5],m[6], m[7],  m[9], m[10],m[11]);
    float cofactor13= getCofactor(m[0],m[2],m[3], m[4],m[6], m[7],  m[8], m[10],m[11]);
    float cofactor14= getCofactor(m[0],m[1],m[3], m[4],m[5], m[7],  m[8], m[9], m[11]);
    float cofactor15= getCofactor(m[0],m[1],m[2], m[4],m[5], m[6],  m[8], m[9], m[10]);

    // build inverse matrix = adj(M) / det(M)
    // adjugate of M is the transpose of the cofactor matrix of M
    float invDeterminant = 1.0f / determinant;
    m[0] =  invDeterminant * cofactor0;
    m[1] = -invDeterminant * cofactor4;
    m[2] =  invDeterminant * cofactor8;
    m[3] = -invDeterminant * cofactor12;

    m[4] = -invDeterminant * cofactor1;
    m[5] =  invDeterminant * cofactor5;
    m[6] = -invDeterminant * cofactor9;
    m[7] =  invDeterminant * cofactor13;

    m[8] =  invDeterminant * cofactor2;
    m[9] = -invDeterminant * cofactor6;
    m[10]=  invDeterminant * cofactor10;
    m[11]= -invDeterminant * cofactor14;

    m[12]= -invDeterminant * cofactor3;
    m[13]=  invDeterminant * cofactor7;
    m[14]= -invDeterminant * cofactor11;
    m[15]=  invDeterminant * cofactor15;

    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// return determinant of 4x4 matrix
///////////////////////////////////////////////////////////////////////////////
float Matrix4::getDeterminant()
{
    return m[0] * getCofactor(m[5],m[6],m[7], m[9],m[10],m[11], m[13],m[14],m[15]) -
           m[1] * getCofactor(m[4],m[6],m[7], m[8],m[10],m[11], m[12],m[14],m[15]) +
           m[2] * getCofactor(m[4],m[5],m[7], m[8],m[9], m[11], m[12],m[13],m[15]) -
           m[3] * getCofactor(m[4],m[5],m[6], m[8],m[9], m[10], m[12],m[13],m[14]);
}



///////////////////////////////////////////////////////////////////////////////
// compute cofactor of 3x3 minor matrix without sign
// input params are 9 elements of the minor matrix
// NOTE: The caller must know its sign.
///////////////////////////////////////////////////////////////////////////////
float Matrix4::getCofactor(float m0, float m1, float m2,
                           float m3, float m4, float m5,
                           float m6, float m7, float m8)
{
    return m0 * (m4 * m8 - m5 * m7) -
           m1 * (m3 * m8 - m5 * m6) +
           m2 * (m3 * m7 - m4 * m6);
}



///////////////////////////////////////////////////////////////////////////////
// translate this matrix by (x, y, z)
///////////////////////////////////////////////////////////////////////////////
Matrix4& Matrix4::translate(const Vector3& v)
{
    return translate(v.x, v.y, v.z);
}

Matrix4& Matrix4::translate(float x, float y, float z)
{
    m[0] += m[3] * x;   m[4] += m[7] * x;   m[8] += m[11]* x;   m[12]+= m[15]* x;
    m[1] += m[3] * y;   m[5] += m[7] * y;   m[9] += m[11]* y;   m[13]+= m[15]* y;
    m[2] += m[3] * z;   m[6] += m[7] * z;   m[10]+= m[11]* z;   m[14]+= m[15]* z;

    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// uniform scale
///////////////////////////////////////////////////////////////////////////////
Matrix4& Matrix4::scale(float s)
{
    return scale(s, s, s);
}

Matrix4& Matrix4::scale(float x, float y, float z)
{
    m[0] *= x;   m[4] *= x;   m[8] *= x;   m[12] *= x;
    m[1] *= y;   m[5] *= y;   m[9] *= y;   m[13] *= y;
    m[2] *= z;   m[6] *= z;   m[10]*= z;   m[14] *= z;
    return *this;
}



///////////////////////////////////////////////////////////////////////////////
// build a rotation matrix with given angle(degree) and rotation axis, then
// multiply it with this object
///////////////////////////////////////////////////////////////////////////////
Matrix4& Matrix4::rotate(float angle, const Vector3& axis)
{
    return rotate(angle, axis.x, axis.y, axis.z);
}

Matrix4& Matrix4::rotate(float angle, float x, float y, float z)
{
    float c = cosf(angle * DEG2RAD);    // cosine
    float s = sinf(angle * DEG2RAD);    // sine
    float c1 = 1.0f - c;                // 1 - c
    float m0 = m[0],  m4 = m[4],  m8 = m[8],  m12= m[12],
          m1 = m[1],  m5 = m[5],  m9 = m[9],  m13= m[13],
          m2 = m[2],  m6 = m[6],  m10= m[10], m14= m[14];

    // build rotation matrix
    float r0 = x * x * c1 + c;
    float r1 = x * y * c1 + z * s;
    float r2 = x * z * c1 - y * s;
    float r4 = x * y * c1 - z * s;
    float r5 = y * y * c1 + c;
    float r6 = y * z * c1 + x * s;
    float r8 = x * z * c1 + y * s;
    float r9 = y * z * c1 - x * s;
    float r10= z * z * c1 + c;

    // multiply rotation matrix
    m[0] = r0 * m0 + r4 * m1 + r8 * m2;
    m[1] = r1 * m0 + r5 * m1 + r9 * m2;
    m[2] = r2 * m0 + r6 * m1 + r10* m2;
    m[4] = r0 * m4 + r4 * m5 + r8 * m6;
    m[5] = r1 * m4 + r5 * m5 + r9 * m6;
    m[6] = r2 * m4 + r6 * m5 + r10* m6;
    m[8] = r0 * m8 + r4 * m9 + r8 * m10;
    m[9] = r1 * m8 + r5 * m9 + r9 * m10;
    m[10]= r2 * m8 + r6 * m9 + r10* m10;
    m[12]= r0 * m12+ r4 * m13+ r8 * m14;
    m[13]= r1 * m12+ r5 * m13+ r9 * m14;
    m[14]= r2 * m12+ r6 * m13+ r10* m14;

    return *this;
}

Matrix4& Matrix4::rotateX(float angle)
{
    float c = cosf(angle * DEG2RAD);
    float s = sinf(angle * DEG2RAD);
    float m1 = m[1],  m2 = m[2],
          m5 = m[5],  m6 = m[6],
          m9 = m[9],  m10= m[10],
          m13= m[13], m14= m[14];

    m[1] = m1 * c + m2 *-s;
    m[2] = m1 * s + m2 * c;
    m[5] = m5 * c + m6 *-s;
    m[6] = m5 * s + m6 * c;
    m[9] = m9 * c + m10*-s;
    m[10]= m9 * s + m10* c;
    m[13]= m13* c + m14*-s;
    m[14]= m13* s + m14* c;

    return *this;
}

Matrix4& Matrix4::rotateY(float angle)
{
    float c = cosf(angle * DEG2RAD);
    float s = sinf(angle * DEG2RAD);
    float m0 = m[0],  m2 = m[2],
          m4 = m[4],  m6 = m[6],
          m8 = m[8],  m10= m[10],
          m12= m[12], m14= m[14];

    m[0] = m0 * c + m2 * s;
    m[2] = m0 *-s + m2 * c;
    m[4] = m4 * c + m6 * s;
    m[6] = m4 *-s + m6 * c;
    m[8] = m8 * c + m10* s;
    m[10]= m8 *-s + m10* c;
    m[12]= m12* c + m14* s;
    m[14]= m12*-s + m14* c;

    return *this;
}

Matrix4& Matrix4::rotateZ(float angle)
{
    float c = cosf(angle * DEG2RAD);
    float s = sinf(angle * DEG2RAD);
    float m0 = m[0],  m1 = m[1],
          m4 = m[4],  m5 = m[5],
          m8 = m[8],  m9 = m[9],
          m12= m[12], m13= m[13];

    m[0] = m0 * c + m1 *-s;
    m[1] = m0 * s + m1 * c;
    m[4] = m4 * c + m5 *-s;
    m[5] = m4 * s + m5 * c;
    m[8] = m8 * c + m9 *-s;
    m[9] = m8 * s + m9 * c;
    m[12]= m12* c + m13*-s;
    m[13]= m12* s + m13* c;

    return *this;
}
 



int boolToInt(bool val) {
	if (val) {
		return 1;
	}
	else {
		return 0;
	}
}

uint* toUintPtr(char* baseAdr) {
	void* voidPtr = baseAdr;
	uint* uintPtr = (uint*)voidPtr;
	return uintPtr;
}

int* toIntPtr(char* baseAdr) {
	void* voidPtr = baseAdr;
	int* intPtr = (int*)voidPtr;
	return intPtr;
}

float* toFloatPtr(char* baseAdr) {
	void* voidPtr = baseAdr;
	float* floatPtr = (float*)voidPtr;
	return floatPtr;
}

float fract(float val) {
	return (val - floor(val));
}

int intDiv(int v, int s) {
	float fv = v;
	float fs = s;

	if (v < 0) {
		return -ceil(-fv / fs);
	}
	else {
		return v / s;
	}
}

void pack16(float num, float &outR, float &outG) {

    int iz = int(num);
    int ir = iz%256;
    int ig = iz/256;

    outR = float(ir)/255.0;
    outG = float(ig)/255.0;

}

uint zipBits(bool* boolArr, int len) {
	uint i;
	uint result = 0;
	uint oneVal = 1;
	
	for (i = 0; i < len; i++) {
		if (boolArr[i]) {
			result = result | (oneVal<<i);
		}
		
	}
	
	return result;
}

void unzipBits(uint zipped, bool* boolArr, int len) {
	uint i;
	uint zeroVal = 0;
	uint oneVal = 1;
	
	
	
	for (i = 0; i < len; i++) {
		boolArr[i] = (
			(zipped & (oneVal<<i)) > zeroVal
		);
	}
	
}


// inline uint clampChar(int baseVal, int bitShift) {
// 	int val = baseVal;
	
// 	if (val > 255) {
// 		val = 255;
// 	}
// 	if (val < 0) {
// 		val = 0;
// 	}
	
// 	uint retVal = val;
	
// 	return (retVal << bitShift);
	
// }

int clamp(int val, int min, int max) {
	if (val > max) {
		val = max;
	}
	if (val < min) {
		val = min;
	}
	return val;
}

float mixf(float v1, float v2, float lerpVal) {
	return v1*(1.0f-lerpVal) + v2*lerpVal;
}

float mixb(float v1, float v2, bool lerpVal) {
	if (lerpVal) {
		return v2;
	}
	else {
		return v1;
	}
}


float roundVal(float val) {
	//return floor(val);
	if (val < 0.0) {
		return -floor(abs(val)+0.5f);
	}
	else {
		return floor(val+0.5f);
	}
}


float signedFloor(float val) {
	//return floor(val);
	if (val < 0.0) {
		return -floor(abs(val));
	}
	else {
		return floor(val);
	}
}

float clampf(float val, float min, float max) {
	if (val > max) {
		val = max;
	}
	if (val < min) {
		val = min;
	}
	return val;
}

float smoothstep(float edge0, float edge1, float x) {
    // Scale, bias and saturate x to 0..1 range
    x = clampf((x - edge0)/(edge1 - edge0), 0.0f, 1.0f); 
    // Evaluate polynomial
    return x*x*(3.0f - 2.0f*x);
}

inline float clampfZO(float val) {
	return clampf(val, 0.0f, 1.0f);
}


// these random generators are used for things that DO NOT effect networking

inline float fGenRand() {
	float intPart;
	float res = abs ( modf(sin(RAND_COUNTER*433.2351267) * 43758.8563f, &intPart) );
	RAND_COUNTER += 1.0f;
	if (RAND_COUNTER >= 8000000.0f) {
		RAND_COUNTER = 0.0f;
	}
	
	return res;
}

inline int iGenRand(int nMin, int nMax)
{
	return nMin + (int)( (fGenRand()) * (nMax + 1 - nMin));
}

// these random generators are used for things that DO effect networking

inline float fGenRand2() {
	float intPart;
	float res = abs ( modf(sin(RAND_COUNTER2*433.2351267) * 43758.8563f, &intPart) );
	RAND_COUNTER2 += 1.0f;
	if (RAND_COUNTER2 >= 8000000.0f) {
		RAND_COUNTER2 = 0.0f;
	}
	
	return res;
}

inline int iGenRand2(int nMin, int nMax)
{
	return nMin + (int)( (fGenRand2()) * (nMax + 1 - nMin));
}




float fSeedRand2(float x, float y) {
	float intPart;
	return modf(sin(x * 12.9898 + y * 78.233) * 43758.5453, &intPart);
}

int iSeedRand2(float x, float y, int minV, int maxV) {
	float res = fSeedRand2(x, y);
	return minV + max(int((maxV + 1 - minV) * res), 0);
}




unsigned int intLogB2 (unsigned int val) {
	unsigned int ret = -1;
	while (val != 0) {
		val >>= 1;
		ret++;
	}
	return ret;
}

int intPow(int x, int p) {
	int i = 1;
	for (int j = 1; j <= p; j++) {
		i *= x;
	}
	return i;
}

int wrapCoord(int val, int max) {
	while (val < 0) {
		val += max;
	}
	while (val >= max) {
		val -= max;
	}

	return val;
}



class FIVector4 {
private:
	iVector4 iv4;
	fVector4 fv4;

	iVector3 iv3;
	fVector3 fv3;

	iVector2 iv2;
	fVector2 fv2;

public:

	FIVector4() {
		iv4.x = 0;
		iv4.y = 0;
		iv4.z = 0;
		iv4.w = 0;
		fv4.x = 0.0;
		fv4.y = 0.0;
		fv4.z = 0.0;
		fv4.w = 0.0;
	}

	float operator[] (int ind) { //float&
		
		switch (ind) {
			case 0:
				return fv4.x;
			break;
			case 1:
				return fv4.y;
			break;
			case 2:
				return fv4.z;
			break;
			case 3:
				return fv4.w;
			break;
		}
		
		cout << "invalid vector index";
		return -1.0f;
	}

	void setIndex(int ind, float val) {
		
		switch (ind) {
			case 0:
				fv4.x = val;
				iv4.x = val;
			break;
			case 1:
				fv4.y = val;
				iv4.y = val;
			break;
			case 2:
				fv4.z = val;
				iv4.z = val;
			break;
			case 3:
				fv4.w = val;
				iv4.w = val;
			break;
		}
	}
	
	float getIndex(int ind) {
		
		switch (ind) {
			case 0:
				return fv4.x;
			break;
			case 1:
				return fv4.y;
			break;
			case 2:
				return fv4.z;
			break;
			case 3:
				return fv4.w;
			break;
		}
		
		return 0.0f;
	}

	btVector3 getBTV() {
		return btVector3(fv4.x,fv4.y,fv4.z);
	}
	void setBTV(btVector3 myBTV) {
		setFXYZ(myBTV.getX(), myBTV.getY(), myBTV.getZ());
	}

	void setIXYZW(int x, int y, int z, int w) {
		iv4.x = x;
		iv4.y = y;
		iv4.z = z;
		iv4.w = w;
		fv4.x = (float)x;
		fv4.y = (float)y;
		fv4.z = (float)z;
		fv4.w = (float)w;
	}
	void setIXYZ(int x, int y, int z) {
		iv4.x = x;
		iv4.y = y;
		iv4.z = z;
		fv4.x = (float)x;
		fv4.y = (float)y;
		fv4.z = (float)z;
	}
	void setIXY(int x, int y) {
		iv4.x = x;
		iv4.y = y;
		fv4.x = (float)x;
		fv4.y = (float)y;
	}
	void setIX(int x) {
		iv4.x = x;
		fv4.x = (float)x;
	}
	void setIY(int y) {
		iv4.y = y;
		fv4.y = (float)y;
	}
	void setIZ(int z) {
		iv4.z = z;
		fv4.z = (float)z;
	}
	void setIW(int w) {
		iv4.w = w;
		fv4.w = (float)w;
	}

	void copyFrom(FIVector4 *cf) {
		iv4.x = cf->getIX();
		iv4.y = cf->getIY();
		iv4.z = cf->getIZ();
		iv4.w = cf->getIW();

		fv4.x = cf->getFX();
		fv4.y = cf->getFY();
		fv4.z = cf->getFZ();
		fv4.w = cf->getFW();
	}

	void copyIntDiv(FIVector4 *cf, int val) {
		iv4.x = cf->getIX();
		iv4.y = cf->getIY();
		iv4.z = cf->getIZ();
		iv4.w = cf->getIW();

		fv4.x = cf->getFX();
		fv4.y = cf->getFY();
		fv4.z = cf->getFZ();
		fv4.w = cf->getFW();

		intDivXYZ(val);
	}

	void copyIntMult(FIVector4 *cf, int val) {
		iv4.x = cf->getIX();
		iv4.y = cf->getIY();
		iv4.z = cf->getIZ();
		iv4.w = cf->getIW();

		fv4.x = cf->getFX();
		fv4.y = cf->getFY();
		fv4.z = cf->getFZ();
		fv4.w = cf->getFW();

		multXYZ(val);
	}

	void setFloatArr(float* vals) {
		fv4.x = vals[0];
		fv4.y = vals[1];
		fv4.z = vals[2];
		iv4.x = fv4.x;
		iv4.y = fv4.y;
		iv4.z = fv4.z;
	}

	void setFXYZW(float x, float y, float z, float w) {
		fv4.x = x;
		fv4.y = y;
		fv4.z = z;
		fv4.w = w;
		iv4.x = (int)x;
		iv4.y = (int)y;
		iv4.z = (int)z;
		iv4.w = (int)w;
	}
	void setFXYZ(float x, float y, float z) {
		fv4.x = x;
		fv4.y = y;
		fv4.z = z;
		iv4.x = (int)x;
		iv4.y = (int)y;
		iv4.z = (int)z;
	}
	
	void setFXYZ(float scalar) {
		fv4.x = scalar;
		fv4.y = scalar;
		fv4.z = scalar;
		iv4.x = (int)scalar;
		iv4.y = (int)scalar;
		iv4.z = (int)scalar;
	}

	void setFXYZRef(FIVector4 *v1) {
		fv4.x = v1->getFX();
		fv4.y = v1->getFY();
		fv4.z = v1->getFZ();
		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}

	void setFXY(float x, float y) {
		fv4.x = x;
		fv4.y = y;
		iv4.x = (int)x;
		iv4.y = (int)y;
	}
	void setFX(float x) {
		fv4.x = x;
		iv4.x = (int)x;
	}
	void setFY(float y) {
		fv4.y = y;
		iv4.y = (int)y;
	}
	void setFZ(float z) {
		fv4.z = z;
		iv4.z = (int)z;
	}
	void setFW(float w) {
		fv4.w = w;
		iv4.w = (int)w;
	}
	
	
	
	
	void fixForRot() {
		iv4.x = -iv4.x;
		iv4.y = -iv4.y;
		iv4.z = -iv4.z;
		
		iv4.x = max(iv4.x, 0);
		iv4.y = max(iv4.y, 0);
		iv4.z = max(iv4.z, 0);
		
		fv4.x = (float)iv4.x;
		fv4.y = (float)iv4.y;
		fv4.z = (float)iv4.z;
	}
	
	void setRandNoSeed() {

		fv4.x = fGenRand();
		fv4.y = fGenRand();
		fv4.z = fGenRand();

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}
	
	void setRand(FIVector4 *seedPos, float addVal, float multVal) {

		// default output is -1 to 1

		FIVector4 r0;
		FIVector4 r1;
		FIVector4 r2;

		FIVector4 l0;
		FIVector4 l1;
		FIVector4 l2;

		float intPart;

		r0.setFXYZ(12.989f, 78.233f, 98.422f);
		r1.setFXYZ(93.989f, 67.345f, 54.256f);
		r2.setFXYZ(43.332f, 93.532f, 43.734f);

		l0.setFXYZ(
			seedPos->getFX(),
			seedPos->getFY(),
			seedPos->getFZ()
		);
		l1.setFXYZ(
			seedPos->getFZ(),
			seedPos->getFY(),
			seedPos->getFX()
		);
		l2.setFXYZ(
			seedPos->getFY(),
			seedPos->getFX(),
			seedPos->getFZ()
		);

		fv4.x = modf(sin(l0.dot(&r0)) * 43758.8563f, &intPart);
		fv4.y = modf(sin(l1.dot(&r1)) * 24634.6345f, &intPart);
		fv4.z = modf(sin(l2.dot(&r2)) * 56445.2345f, &intPart);
		
		
		fv4.x += addVal;
		fv4.y += addVal;
		fv4.z += addVal;
		
		fv4.x *= multVal;
		fv4.y *= multVal;
		fv4.z *= multVal;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}

	void addXYZ(float scalar, float multiplier = 1.0f) {
		fv4.x += scalar * multiplier;
		fv4.y += scalar * multiplier;
		fv4.z += scalar * multiplier;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}
	
	void addW(float scalar) {
		fv4.w += scalar;
		iv4.w = (int)fv4.w;
	}
	
	void addXYZ(float scalarX, float scalarY, float scalarZ, float multiplier = 1.0f) {
		fv4.x += scalarX * multiplier;
		fv4.y += scalarY * multiplier;
		fv4.z += scalarZ * multiplier;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}
	
	void addXYZW(float scalarX, float scalarY, float scalarZ, float scalarW, float multiplier = 1.0f) {
		fv4.x += scalarX * multiplier;
		fv4.y += scalarY * multiplier;
		fv4.z += scalarZ * multiplier;
		fv4.w += scalarW * multiplier;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
		iv4.w = (int)fv4.w;
	}
	
	void addXYZRef(FIVector4 *scalar, float multiplier = 1.0f) {
		fv4.x += scalar->getFX() * multiplier;
		fv4.y += scalar->getFY() * multiplier;
		fv4.z += scalar->getFZ() * multiplier;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}
	
	void multXYZRef(FIVector4 *scalar) {
		fv4.x *= scalar->getFX();
		fv4.y *= scalar->getFY();
		fv4.z *= scalar->getFZ();

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}

	void lerpXYZ(FIVector4 *v2, float amount) {
		float iamount = 1.0f-amount;
		fv4.x = fv4.x*iamount + v2->getFX()*amount;
		fv4.y = fv4.y*iamount + v2->getFY()*amount;
		fv4.z = fv4.z*iamount + v2->getFZ()*amount;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}
	
	void lerpXYZW(FIVector4 *v2, float amount) {
		float iamount = 1.0f-amount;
		fv4.x = fv4.x*iamount + v2->getFX()*amount;
		fv4.y = fv4.y*iamount + v2->getFY()*amount;
		fv4.z = fv4.z*iamount + v2->getFZ()*amount;
		fv4.w = fv4.w*iamount + v2->getFW()*amount;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
		iv4.w = (int)fv4.w;
	}
	
	void lerpXYZ(FIVector4 *v2, FIVector4* av) {
		
		float xa;
		float ya;
		float za;
		
		if (av == NULL) {
			xa = 1.0f;
			ya = 1.0f;
			za = 1.0f;
		}
		else {
			xa = (*av)[0];
			ya = (*av)[1];
			za = (*av)[2];
		}
		
		
		float ixa = 1.0f-xa;
		float iya = 1.0f-ya;
		float iza = 1.0f-za;
		fv4.x = fv4.x*ixa + v2->getFX()*xa;
		fv4.y = fv4.y*iya + v2->getFY()*ya;
		fv4.z = fv4.z*iza + v2->getFZ()*za;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}


	void multXYZ(float scalar) {
		fv4.x *= scalar;
		fv4.y *= scalar;
		fv4.z *= scalar;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}
	void multXYZ(float scalarX, float scalarY, float scalarZ) {
		fv4.x *= scalarX;
		fv4.y *= scalarY;
		fv4.z *= scalarZ;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}


	void multXYZ(FIVector4 *scalar) {
		fv4.x *= scalar->getFX();
		fv4.y *= scalar->getFY();
		fv4.z *= scalar->getFZ();

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}

	void divXYZ(FIVector4 *scalar) {
		fv4.x /= scalar->getFX();
		fv4.y /= scalar->getFY();
		fv4.z /= scalar->getFZ();

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}

	void floorXYZ() {
		fv4.x = floor(fv4.x);
		fv4.y = floor(fv4.y);
		fv4.z = floor(fv4.z);

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}


	void intDivXYZ(int scalar) {

		iv4.x = intDiv(iv4.x, scalar);
		iv4.y = intDiv(iv4.y, scalar);
		iv4.z = intDiv(iv4.z, scalar);

		fv4.x = (float)iv4.x;
		fv4.y = (float)iv4.y;
		fv4.z = (float)iv4.z;

	}
	
	void intDivXYZ(int scalarX, int scalarY, int scalarZ) {


		iv4.x = intDiv(iv4.x, scalarX);
		iv4.y = intDiv(iv4.y, scalarY);
		iv4.z = intDiv(iv4.z, scalarZ);

		fv4.x = (float)iv4.x;
		fv4.y = (float)iv4.y;
		fv4.z = (float)iv4.z;

	}

	void modXYZ(int scalar) {
		iv4.x = iv4.x % scalar;
		iv4.y = iv4.y % scalar;
		iv4.z = iv4.z % scalar;

		fv4.x = (float)iv4.x;
		fv4.y = (float)iv4.y;
		fv4.z = (float)iv4.z;

	}

	

	void wrapXYZ(int scalar) {
		iv4.x = wrapCoord(iv4.x, scalar);
		iv4.y = wrapCoord(iv4.y, scalar);
		iv4.z = wrapCoord(iv4.z, scalar);

		fv4.x = (float)iv4.x;
		fv4.y = (float)iv4.y;
		fv4.z = (float)iv4.z;

	}

	void wrapXY(int scalar) {
		iv4.x = wrapCoord(iv4.x, scalar);
		iv4.y = wrapCoord(iv4.y, scalar);

		fv4.x = (float)iv4.x;
		fv4.y = (float)iv4.y;

	}

	void powXYZ(float p1, float p2, float p3) {
		fv4.x = pow(fv4.x,p1);
		fv4.y = pow(fv4.y,p2);
		fv4.z = pow(fv4.z,p3);

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}

	void absXYZ() {
		fv4.x = abs(fv4.x);
		fv4.y = abs(fv4.y);
		fv4.z = abs(fv4.z);

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}
	
	void averageXYZ(FIVector4 *v1, FIVector4 *v2) {
		fv4.x = (v1->getFX() + v2->getFX())*0.5f;
		fv4.y = (v1->getFY() + v2->getFY())*0.5f;
		fv4.z = (v1->getFZ() + v2->getFZ())*0.5f;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}
	
	void averageNegXYZ(FIVector4 *v1, FIVector4 *v2) {
		fv4.x = (v1->getFX() - v2->getFX())*0.5f;
		fv4.y = (v1->getFY() - v2->getFY())*0.5f;
		fv4.z = (v1->getFZ() - v2->getFZ())*0.5f;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}


	void minXYZ(FIVector4 *v1, FIVector4 *v2) {
		fv4.x = std::min(v1->getFX(), v2->getFX());
		fv4.y = std::min(v1->getFY(), v2->getFY());
		fv4.z = std::min(v1->getFZ(), v2->getFZ());

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}

	void maxXYZ(FIVector4 *v1, FIVector4 *v2) {
		fv4.x = std::max(v1->getFX(), v2->getFX());
		fv4.y = std::max(v1->getFY(), v2->getFY());
		fv4.z = std::max(v1->getFZ(), v2->getFZ());

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}

	void clampXYZS(float minV, float maxV) {
		if (fv4.x < minV) {
			fv4.x = minV;
		}
		if (fv4.y < minV) {
			fv4.y = minV;
		}
		if (fv4.z < minV) {
			fv4.z = minV;
		}
		if (fv4.x > maxV) {
			fv4.x = maxV;
		}
		if (fv4.y > maxV) {
			fv4.y = maxV;
		}
		if (fv4.z > maxV) {
			fv4.z = maxV;
		}

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}

	void clampXYZ(FIVector4 *minV, FIVector4 *maxV) {
		if (fv4.x < minV->getFX()) {
			fv4.x = minV->getFX();
		}
		if (fv4.y < minV->getFY()) {
			fv4.y = minV->getFY();
		}
		if (fv4.z < minV->getFZ()) {
			fv4.z = minV->getFZ();
		}
		if (fv4.x > maxV->getFX()) {
			fv4.x = maxV->getFX();
		}
		if (fv4.y > maxV->getFY()) {
			fv4.y = maxV->getFY();
		}
		if (fv4.z > maxV->getFZ()) {
			fv4.z = maxV->getFZ();
		}

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}

	void clampX(FIVector4 *minV, FIVector4 *maxV) {
		if (fv4.x < minV->getFX()) {
			fv4.x = minV->getFX();
		}
		if (fv4.x > maxV->getFX()) {
			fv4.x = maxV->getFX();
		}

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}
	void clampY(FIVector4 *minV, FIVector4 *maxV) {

		if (fv4.y < minV->getFY()) {
			fv4.y = minV->getFY();
		}
		if (fv4.y > maxV->getFY()) {
			fv4.y = maxV->getFY();
		}

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;
	}
	void clampZ(float minV, float maxV) {

		if (fv4.z < minV) {
			fv4.z = minV;
		}
		if (fv4.z > maxV) {
			fv4.z = maxV;
		}

		iv4.z = (int)fv4.z;
	}



	bool inBoundsIsEqualXYZ(FIVector4 *minV, FIVector4 *maxV) {
		if (fv4.x < minV->getFX()) {
			return false;
		}
		if (fv4.y < minV->getFY()) {
			return false;
		}
		if (fv4.z < minV->getFZ()) {
			return false;
		}
		if (fv4.x > maxV->getFX()) {
			return false;
		}
		if (fv4.y > maxV->getFY()) {
			return false;
		}
		if (fv4.z > maxV->getFZ()) {
			return false;
		}

		return true;
	}

	static void normalizeBounds(FIVector4 *minBounds, FIVector4 *maxBounds) {
		float temp;

		if (minBounds->getFX() > maxBounds->getFX()) {
			temp = maxBounds->getFX();
			maxBounds->setFX(minBounds->getFX());
			minBounds->setFX(temp);
		}
		if (minBounds->getFY() > maxBounds->getFY()) {
			temp = maxBounds->getFY();
			maxBounds->setFY(minBounds->getFY());
			minBounds->setFY(temp);
		}
		if (minBounds->getFZ() > maxBounds->getFZ()) {
			temp = maxBounds->getFZ();
			maxBounds->setFZ(minBounds->getFZ());
			minBounds->setFZ(temp);
		}
	}


	
	static bool intersectInt(FIVector4 *aMin, FIVector4 *aMax, FIVector4 *bMin, FIVector4 *bMax) {
		
		if (aMax->getFX() <= bMin->getFX()) return false;
		if (aMin->getFX() >= bMax->getFX()) return false;
		if (aMax->getFY() <= bMin->getFY()) return false;
		if (aMin->getFY() >= bMax->getFY()) return false;
		if (aMax->getFZ() <= bMin->getFZ()) return false;
		if (aMin->getFZ() >= bMax->getFZ()) return false;
		
		return true;
		
	}
	
	

	static bool intersect(FIVector4 *aMin, FIVector4 *aMax, FIVector4 *bMin, FIVector4 *bMax) {

		float aWidth = aMax->getFX() - aMin->getFX();
		float aHeight = aMax->getFY() - aMin->getFY();
		float aDepth = aMax->getFZ() - aMin->getFZ();

		float bWidth = bMax->getFX() - bMin->getFX();
		float bHeight = bMax->getFY() - bMin->getFY();
		float bDepth = bMax->getFZ() - bMin->getFZ();

		float aWidthC = (aMax->getFX() + aMin->getFX()) / 2.0f;
		float aHeightC = (aMax->getFY() + aMin->getFY()) / 2.0f;
		float aDepthC = (aMax->getFZ() + aMin->getFZ()) / 2.0f;

		float bWidthC = (bMax->getFX() + bMin->getFX()) / 2.0f;
		float bHeightC = (bMax->getFY() + bMin->getFY()) / 2.0f;
		float bDepthC = (bMax->getFZ() + bMin->getFZ()) / 2.0f;



		return  (abs(aWidthC - bWidthC) * 2.0f <= (aWidth + bWidth)) &&
						(abs(aHeightC - bHeightC) * 2.0f <= (aHeight + bHeight)) &&
						(abs(aDepthC - bDepthC) * 2.0f <= (aDepth + bDepth));
	}

	static void growBoundary(FIVector4 *minB, FIVector4 *maxB, FIVector4 *minV, FIVector4 *maxV) {
		if (minB->getFX() > minV->getFX()) {
			minB->setFX(minV->getFX());
		}
		if (minB->getFY() > minV->getFY()) {
			minB->setFY(minV->getFY());
		}
		if (minB->getFZ() > minV->getFZ()) {
			minB->setFZ(minV->getFZ());
		}
		if (maxB->getFX() < maxV->getFX()) {
			maxB->setFX(maxV->getFX());
		}
		if (maxB->getFY() < maxV->getFY()) {
			maxB->setFY(maxV->getFY());
		}
		if (maxB->getFZ() < maxV->getFZ()) {
			maxB->setFZ(maxV->getFZ());
		}

	}
	
	bool anyXYZ() {
		return (
			(fv4.x != 0.0f) ||
			(fv4.y != 0.0f) ||
			(fv4.z != 0.0f)
		);
	}
	
	bool any() {
		return (
			(fv4.x != 0.0f) ||
			(fv4.y != 0.0f) ||
			(fv4.z != 0.0f) ||
			(fv4.w != 0.0f)
		);
	}
	bool all() {
		return (
			(fv4.x != 0.0f) &&
			(fv4.y != 0.0f) &&
			(fv4.z != 0.0f) &&
			(fv4.w != 0.0f)
		);
	}


	bool inBoundsXYZ(FIVector4 *minV, FIVector4 *maxV) {
		if (fv4.x < minV->getFX()) {
			return false;
		}
		if (fv4.y < minV->getFY()) {
			return false;
		}
		if (fv4.z < minV->getFZ()) {
			return false;
		}
		if (fv4.x >= maxV->getFX()) {
			return false;
		}
		if (fv4.y >= maxV->getFY()) {
			return false;
		}
		if (fv4.z >= maxV->getFZ()) {
			return false;
		}

		return true;
	}
	
	bool inBoundsXYZSlack(FIVector4 *minV, FIVector4 *maxV, float slack) {
		if (fv4.x < minV->getFX()-slack) {
			return false;
		}
		if (fv4.y < minV->getFY()-slack) {
			return false;
		}
		if (fv4.z < minV->getFZ()-slack) {
			return false;
		}
		if (fv4.x >= maxV->getFX()+slack) {
			return false;
		}
		if (fv4.y >= maxV->getFY()+slack) {
			return false;
		}
		if (fv4.z >= maxV->getFZ()+slack) {
			return false;
		}

		return true;
	}





	bool inBoundsXY(FIVector4 *minV, FIVector4 *maxV) {
		if (fv4.x < minV->getFX()) {
			return false;
		}
		if (fv4.y < minV->getFY()) {
			return false;
		}
		if (fv4.x > maxV->getFX()) {
			return false;
		}
		if (fv4.y > maxV->getFY()) {
			return false;
		}

		return true;
	}

	bool iNotEqual(FIVector4 *otherVec) {
		return (
			(iv4.x != otherVec->getIX()) ||
			(iv4.y != otherVec->getIY()) ||
			(iv4.z != otherVec->getIZ()) ||
			(iv4.w != otherVec->getIW())
		);
	}
	
	bool fNotEqual4(FIVector4 *otherVec) {
		return (
			(fv4.x != otherVec->getFX()) ||
			(fv4.y != otherVec->getFY()) ||
			(fv4.z != otherVec->getFZ()) ||
			(fv4.w != otherVec->getFW())
		);
	}



	float wrapDistance(FIVector4 *otherVec, int maxPitch, bool doSet = true) {

		int i;
		int j;

		int bestI;
		int bestJ;

		float shortestDis = FLT_MAX;
		float curDis;

		for (i = -1; i <= 1; i++) {
			for (j = -1; j <= 1; j++) {

				otherVec->addXYZ(i * maxPitch, j * maxPitch, 0, 1.0f);
				curDis = distance(otherVec);
				otherVec->addXYZ(i * maxPitch, j * maxPitch, 0, -1.0f);

				if (curDis < shortestDis) {
					shortestDis = curDis;
					bestI = i;
					bestJ = j;
				}

			}
		}

		if (doSet) {
			otherVec->addXYZ(bestI * maxPitch, bestJ * maxPitch, 0);
		}


		return shortestDis;

	}

	/*

	var raw_dx = Math.abs(x2 - x1);
	var raw_dy = Math.abs(y2 - y1);

	var dx = (raw_dx < (xmax / 2)) ? raw_dx : xmax - raw_dx;
	var dy = (raw_dy < (ymax / 2)) ? raw_dy : ymax - raw_dy;

	var l2dist = Math.sqrt((dx * dx) + (dy * dy));

	*/

	void rotate(float a, int plane) {

		float xp = fv4.x;
		float yp = fv4.y;
		float zp = fv4.z;

		switch (plane) {
		case E_PLANE_XY:
			xp = fv4.x * cos(a) - fv4.y * sin(a);
			yp = fv4.y * cos(a) + fv4.x * sin(a);
			break;

		case E_PLANE_YZ:
			zp = fv4.z * cos(a) - fv4.y * sin(a);
			yp = fv4.y * cos(a) + fv4.z * sin(a);
			break;

		case E_PLANE_XZ:
			xp = fv4.x * cos(a) - fv4.z * sin(a);
			zp = fv4.z * cos(a) + fv4.x * sin(a);
			break;
		}

		fv4.x = xp;
		fv4.y = yp;
		fv4.z = zp;

		iv4.x = (int)fv4.x;
		iv4.y = (int)fv4.y;
		iv4.z = (int)fv4.z;

	}

	void rotate90(int ind) {
		switch (ind) {
		case 0: // 0 deg

			break;

		case 1: // 90 deg
			setFXY(-fv4.y, fv4.x);
			break;

		case 2: // 180 deg
			setFXY(-fv4.x, -fv4.y);
			break;

		case 3: // 270 deg
			setFXY(fv4.y, -fv4.x);
			break;
		}
	}
	
	float distanceXY(FIVector4 *otherVec) {

		float dx = fv4.x - otherVec->getFX();
		float dy = fv4.y - otherVec->getFY();

		return sqrt(dx * dx + dy * dy);
	}

	float distance(FIVector4 *otherVec) {

		float dx = fv4.x - otherVec->getFX();
		float dy = fv4.y - otherVec->getFY();
		float dz = fv4.z - otherVec->getFZ();

		return sqrt(dx * dx + dy * dy + dz * dz);
	}
	
	

	float length() {
		return sqrt(fv4.x * fv4.x + fv4.y * fv4.y + fv4.z * fv4.z);
	}
	float lengthXY() {
		return sqrt(fv4.x * fv4.x + fv4.y * fv4.y);
	}

	float manhattanDis(FIVector4 *otherVec) {

		float dx = abs(fv4.x - otherVec->getFX());
		float dy = abs(fv4.y - otherVec->getFY());
		float dz = abs(fv4.z - otherVec->getFZ());

		return max(max(dx, dy), dz);
	}

	void normalize() {
		float len = sqrt(fv4.x * fv4.x + fv4.y * fv4.y + fv4.z * fv4.z);

		fv4.x = fv4.x / len;
		fv4.y = fv4.y / len;
		fv4.z = fv4.z / len;

	}
	
	void normalizeXY() {
		float len = sqrt(fv4.x * fv4.x + fv4.y * fv4.y);
		
		fv4.x = fv4.x / len;
		fv4.y = fv4.y / len;
	}
	

	float dot(FIVector4 *otherVec) {

		return fv4.x * otherVec->getFX() +
					 fv4.y * otherVec->getFY() +
					 fv4.z * otherVec->getFZ();
	}

	static void cross(FIVector4 *outVec, FIVector4 *v1, FIVector4 *v2) {


		float x1 = v1->getFX();
		float y1 = v1->getFY();
		float z1 = v1->getFZ();

		float x2 = v2->getFX();
		float y2 = v2->getFY();
		float z2 = v2->getFZ();

		outVec->setFXYZ(
			(y1 * z2) - (y2 * z1),
			(z1 * x2) - (z2 * x1),
			(x1 * y2) - (x2 * y1)
		);

	}




	iVector4 *getIXYZW() {
		return &iv4;
	}
	fVector4 *getFXYZW() {
		return &fv4;
	}

	iVector3 *getIXYZ() {
		iv3.x = iv4.x;
		iv3.y = iv4.y;
		iv3.z = iv4.z;
		return &iv3;
	}
	fVector3 *getFXYZ() {
		fv3.x = fv4.x;
		fv3.y = fv4.y;
		fv3.z = fv4.z;
		return &fv3;
	}

	iVector2 *getIXY() {
		iv2.x = iv4.x;
		iv2.y = iv4.y;
		return &iv2;
	}
	fVector2 *getFXY() {
		fv2.x = fv4.x;
		fv2.y = fv4.y;
		return &fv2;
	}

	int getIX() {
		return iv4.x;
	}
	int getIY() {
		return iv4.y;
	}
	int getIZ() {
		return iv4.z;
	}
	int getIW() {
		return iv4.w;
	}

	float getFX() {
		return fv4.x;
	}
	float getFY() {
		return fv4.y;
	}
	float getFZ() {
		return fv4.z;
	}
	float getFW() {
		return fv4.w;
	}


};




void hsv2rgb(materialNode* matNode) {
	
	
	static FIVector4 K_HSV;
	static FIVector4 P_HSV;
	static FIVector4 C_HSV;
	static FIVector4 R_HSV;
	
	K_HSV.setFXYZW(1.0f, 2.0f / 3.0f, 1.0f / 3.0f, 3.0f);
	
	C_HSV.setFXYZ(matNode->h,matNode->s,matNode->l);
	
	
	P_HSV.setFXYZ(
		abs(fract(C_HSV[0] + K_HSV[0]) * 6.0f - K_HSV[3]),
		abs(fract(C_HSV[0] + K_HSV[1]) * 6.0f - K_HSV[3]),
		abs(fract(C_HSV[0] + K_HSV[2]) * 6.0f - K_HSV[3])
	);
	R_HSV.setFXYZ(
		C_HSV[2] * mixf(K_HSV[0], clampf(P_HSV[0] - K_HSV[0], 0.0f, 1.0f), C_HSV[1]),
		C_HSV[2] * mixf(K_HSV[0], clampf(P_HSV[1] - K_HSV[0], 0.0f, 1.0f), C_HSV[1]),
		C_HSV[2] * mixf(K_HSV[0], clampf(P_HSV[2] - K_HSV[0], 0.0f, 1.0f), C_HSV[1])	
	);
	
	matNode->r = R_HSV[0];
	matNode->g = R_HSV[1];
	matNode->b = R_HSV[2];
	
}


struct RotationInfo {
	float rotMatrix[16];
	FIVector4 basePoint;
	FIVector4 axisAngle;
};

struct ModUnitStruct {
	FIVector4 basePos;
	int brushAction;
	int modType;
	int radius;
};



float getRandSeededPos(float xv, float yv, float zv) {
	float intPart;		
	return abs ( modf(sin(xv*433.2 + yv*522.9 + zv*839.4) * 43758.8563f, &intPart) );
}


float getRandSeeded(FIVector4 *seedPos, FIVector4 *seedVals) {
	float intPart;		
	return abs ( modf(sin(seedPos->dot(seedVals)) * 43758.8563f, &intPart) );
}

int iGetRandSeeded(
	FIVector4 *seedPos,
	FIVector4 *seedVals,
	int minV,
	int maxV
) {
	float intPart = 0.0f;		
	int res = abs( modf(sin(seedPos->dot(seedVals)) * 43758.8563f, &intPart) )*1000000.0f;
	res = (res % (maxV + 1 - minV)) + minV;
	
	return res;
}




class AxisRotation {

public:

	float rotationMatrix[16];
	float inputMatrix[4];
	float outputMatrix[4];

	FIVector4 tempRes1;
	FIVector4 tempRes2;
	FIVector4 tempRes3;

	void doRotationOr(FIVector4 *output, FIVector4 *input, int orientationOffset)
	{
		int i;
		int j;
		int k;

		outputMatrix[0] = 0.0f;
		outputMatrix[1] = 0.0f;
		outputMatrix[2] = 0.0f;
		outputMatrix[3] = 0.0f;

		inputMatrix[0] = input->getFX();
		inputMatrix[1] = input->getFY();
		inputMatrix[2] = input->getFZ();
		inputMatrix[3] = 1.0;


		for (i = 0; i < 4; i++ ) {
			for (j = 0; j < 1; j++) {
				outputMatrix[i] = 0;
				for (k = 0; k < 4; k++) {
					outputMatrix[i] += ALL_ROT[orientationOffset+i*4+k] * inputMatrix[k];
				}
			}
		}

		output->setFXYZW(
			outputMatrix[0],
			outputMatrix[1],
			outputMatrix[2],
			outputMatrix[3]
		);

	}

	void doRotation(FIVector4 *output, FIVector4 *input, FIVector4 *axis, float angle)
	{
		int i;
		int j;
		int k;

		float u = axis->getFX();
		float v = axis->getFY();
		float w = axis->getFZ();

		float L = (u * u + v * v + w * w);
		float u2 = u * u;
		float v2 = v * v;
		float w2 = w * w;

		float sqrtL = sqrt(L);
		float ca = cos(angle);
		float sa = sin(angle);

		rotationMatrix[0] = (u2 + (v2 + w2) * ca) / L;
		rotationMatrix[1] = (u * v * (1 - ca) - w * sqrtL * sa) / L;
		rotationMatrix[2] = (u * w * (1 - ca) + v * sqrtL * sa) / L;
		rotationMatrix[3] = 0.0f;

		rotationMatrix[4] = (u * v * (1 - ca) + w * sqrtL * sa) / L;
		rotationMatrix[5] = (v2 + (u2 + w2) * ca) / L;
		rotationMatrix[6] = (v * w * (1 - ca) - u * sqrtL * sa) / L;
		rotationMatrix[7] = 0.0f;

		rotationMatrix[8] = (u * w * (1 - ca) - v * sqrtL * sa) / L;
		rotationMatrix[9] = (v * w * (1 - ca) + u * sqrtL * sa) / L;
		rotationMatrix[10] = (w2 + (u2 + v2) * ca) / L;
		rotationMatrix[11] = 0.0f;

		rotationMatrix[12] = 0.0f;
		rotationMatrix[13] = 0.0f;
		rotationMatrix[14] = 0.0f;
		rotationMatrix[15] = 1.0f;



		outputMatrix[0] = 0.0f;
		outputMatrix[1] = 0.0f;
		outputMatrix[2] = 0.0f;
		outputMatrix[3] = 0.0f;

		inputMatrix[0] = input->getFX();
		inputMatrix[1] = input->getFY();
		inputMatrix[2] = input->getFZ();
		inputMatrix[3] = 1.0;


		for (i = 0; i < 4; i++ ) {
			for (j = 0; j < 1; j++) {
				outputMatrix[i] = 0;
				for (k = 0; k < 4; k++) {
					outputMatrix[i] += rotationMatrix[i*4+k] * inputMatrix[k];
				}
			}
		}

		output->setFXYZW(
			outputMatrix[0],
			outputMatrix[1],
			outputMatrix[2],
			outputMatrix[3]
		);

	}
	
	
	
	void buildRotMatrix(
		RotationInfo* rotInfo
	) {
		
		float u = rotInfo->axisAngle.getFX();
		float v = rotInfo->axisAngle.getFY();
		float w = rotInfo->axisAngle.getFZ();
		float angle = rotInfo->axisAngle.getFW();

		float L = (u * u + v * v + w * w);
		float u2 = u * u;
		float v2 = v * v;
		float w2 = w * w;

		float sqrtL = sqrt(L);
		float ca = cos(angle);
		float sa = sin(angle);

		rotInfo->rotMatrix[0] = (u2 + (v2 + w2) * ca) / L;
		rotInfo->rotMatrix[1] = (u * v * (1 - ca) - w * sqrtL * sa) / L;
		rotInfo->rotMatrix[2] = (u * w * (1 - ca) + v * sqrtL * sa) / L;
		rotInfo->rotMatrix[3] = 0.0f;

		rotInfo->rotMatrix[4] = (u * v * (1 - ca) + w * sqrtL * sa) / L;
		rotInfo->rotMatrix[5] = (v2 + (u2 + w2) * ca) / L;
		rotInfo->rotMatrix[6] = (v * w * (1 - ca) - u * sqrtL * sa) / L;
		rotInfo->rotMatrix[7] = 0.0f;

		rotInfo->rotMatrix[8] = (u * w * (1 - ca) - v * sqrtL * sa) / L;
		rotInfo->rotMatrix[9] = (v * w * (1 - ca) + u * sqrtL * sa) / L;
		rotInfo->rotMatrix[10] = (w2 + (u2 + v2) * ca) / L;
		rotInfo->rotMatrix[11] = 0.0f;

		rotInfo->rotMatrix[12] = 0.0f;
		rotInfo->rotMatrix[13] = 0.0f;
		rotInfo->rotMatrix[14] = 0.0f;
		rotInfo->rotMatrix[15] = 1.0f;

	}
	
	
	void applyRotation(
		FIVector4 *output,
		FIVector4 *input,
		RotationInfo* rotInfo
	) {
		int i;
		int j;
		int k;
		int m;
		
		//tempRes3.copyFrom(baseOffset);
		//tempRes3.addXYZRef(parentOffset,-1.0f);

		float u = rotInfo->axisAngle.getFX();
		float v = rotInfo->axisAngle.getFY();
		float w = rotInfo->axisAngle.getFZ();
		float angle = rotInfo->axisAngle.getFW();

		float L = (u * u + v * v + w * w);
		float u2 = u * u;
		float v2 = v * v;
		float w2 = w * w;

		float sqrtL = sqrt(L);
		float ca = cos(angle);
		float sa = sin(angle);

		


		for (m = 0; m < 3; m++) {
			outputMatrix[0] = 0.0f;
			outputMatrix[1] = 0.0f;
			outputMatrix[2] = 0.0f;
			outputMatrix[3] = 0.0f;

			inputMatrix[0] = input[m].getFX();// - (rotInfo->basePoint[0]);
			inputMatrix[1] = input[m].getFY();// - (rotInfo->basePoint[1]);
			inputMatrix[2] = input[m].getFZ();// - (rotInfo->basePoint[2]);
			inputMatrix[3] = 1.0;


			for (i = 0; i < 4; i++ ) {
				for (j = 0; j < 1; j++) {
					outputMatrix[i] = 0;
					for (k = 0; k < 4; k++) {
						outputMatrix[i] += rotInfo->rotMatrix[i*4+k] * inputMatrix[k];
					}
				}
			}

			output[m].setFXYZW(
				outputMatrix[0],// + (rotInfo->basePoint[0]),
				outputMatrix[1],// + (rotInfo->basePoint[1]),
				outputMatrix[2],// + (rotInfo->basePoint[2]),
				outputMatrix[3]
			);
			//output[m].normalize();
		}

		

	}
	
	
	void doRotationTBN(
		FIVector4 *output,
		FIVector4 *input,
		FIVector4 *axisAngle,
		FIVector4 *parentOffset,
		FIVector4 *baseOffset
	) {
		int i;
		int j;
		int k;
		int m;
		
		tempRes3.copyFrom(baseOffset);
		tempRes3.addXYZRef(parentOffset,-1.0f);

		float u = axisAngle->getFX();
		float v = axisAngle->getFY();
		float w = axisAngle->getFZ();
		float angle = axisAngle->getFW();

		float L = (u * u + v * v + w * w);
		float u2 = u * u;
		float v2 = v * v;
		float w2 = w * w;

		float sqrtL = sqrt(L);
		float ca = cos(angle);
		float sa = sin(angle);

		rotationMatrix[0] = (u2 + (v2 + w2) * ca) / L;
		rotationMatrix[1] = (u * v * (1 - ca) - w * sqrtL * sa) / L;
		rotationMatrix[2] = (u * w * (1 - ca) + v * sqrtL * sa) / L;
		rotationMatrix[3] = 0.0f;

		rotationMatrix[4] = (u * v * (1 - ca) + w * sqrtL * sa) / L;
		rotationMatrix[5] = (v2 + (u2 + w2) * ca) / L;
		rotationMatrix[6] = (v * w * (1 - ca) - u * sqrtL * sa) / L;
		rotationMatrix[7] = 0.0f;

		rotationMatrix[8] = (u * w * (1 - ca) - v * sqrtL * sa) / L;
		rotationMatrix[9] = (v * w * (1 - ca) + u * sqrtL * sa) / L;
		rotationMatrix[10] = (w2 + (u2 + v2) * ca) / L;
		rotationMatrix[11] = 0.0f;

		rotationMatrix[12] = 0.0f;
		rotationMatrix[13] = 0.0f;
		rotationMatrix[14] = 0.0f;
		rotationMatrix[15] = 1.0f;



		for (m = 0; m < 3; m++) {
			outputMatrix[0] = 0.0f;
			outputMatrix[1] = 0.0f;
			outputMatrix[2] = 0.0f;
			outputMatrix[3] = 0.0f;

			inputMatrix[0] = input[m].getFX() + (tempRes3[0]);
			inputMatrix[1] = input[m].getFY() + (tempRes3[1]);
			inputMatrix[2] = input[m].getFZ() + (tempRes3[2]);
			inputMatrix[3] = 1.0;


			for (i = 0; i < 4; i++ ) {
				for (j = 0; j < 1; j++) {
					outputMatrix[i] = 0;
					for (k = 0; k < 4; k++) {
						outputMatrix[i] += rotationMatrix[i*4+k] * inputMatrix[k];
					}
				}
			}

			output[m].setFXYZW(
				outputMatrix[0] - (tempRes3[0]),
				outputMatrix[1] - (tempRes3[1]),
				outputMatrix[2] - (tempRes3[2]),
				outputMatrix[3]
			);
			output[m].normalize();
		}

		

	}
	

};
AxisRotation axisRotationInstance;








void safeNorm(btVector3 &normRef) {
	if (normRef.fuzzyZero()) {
		
	}
	else {
		normRef.normalize();
	}
}

float getShortestAngle(float begInRad, float endInRad, float amount) {
	int begInDeg = begInRad*180/M_PI;
	int endInDeg = endInRad*180/M_PI;
	
	float shortest_angle = ((((endInDeg - begInDeg) % 360) + 540) % 360) - 180;
	
	return shortest_angle * amount * M_PI / 180.0f;
}

btVector3 roundBTV(btVector3 v) {
	return btVector3(
		roundVal(v.getX()),
		roundVal(v.getY()),
		roundVal(v.getZ())	
	);
}
btVector3 floorBTV(btVector3 v) {
	return btVector3(
		floor(v.getX()),
		floor(v.getY()),
		floor(v.getZ())	
	);
}

btVector3 multByOtherRot( btVector3 imp, btMatrix3x3 otherRot) {
	// Vector3 myRHS = Vector3(imp.getX(),imp.getY(),imp.getZ());
	// Vector3 res = otherRot*myRHS;
	
	// return btVector3(res.x,res.y,res.z);
	
	return otherRot*imp;
}

btVector3 rotBTV2D(btVector3 source, float ang) {
	float baseAng = atan2(source.getY(),source.getX());
	baseAng += ang + M_PI/2.0f;
	
	

	return -btVector3(cos(baseAng),sin(baseAng),0.0f);
}

struct SphereStruct {
	FIVector4 position;
	float maxRad;
	float curRad;
	float radVel;
	float radAcc;
};

typedef int BaseObjType;




struct SkillCard {
	
	// whenever x, do y
	
	
	
	// condition
	// subject
	// action
	// subject
	
	// gain / lose
	
	
	std::vector<int> triggers;
};

struct StatSheet {
	std::vector<int> availableSkills;
	std::vector<int> activeSkills;
	std::vector<int> statusList;
	
	int baseStats[E_CS_LENGTH];
	int unapplyedStats[E_CS_LENGTH];
	
	int curStatus[E_STATUS_LENGTH];
	int maxStatus[E_STATUS_LENGTH];
	
	int availPoints;
	
	
};




class BaseObj
{
private:
	FIVector4 centerPoint;
	FIVector4 linVelocity;
	
	bool actionStates[E_ACT_LENGTH*RLBN_LENGTH];
	
public:
	
	PathInfo targPath;
	StatSheet statSheet;
	
	int objectType;
	int maxFrames;
	
	PoseKey defaultPose;
	
	BaseObjType uid;
	BaseObjType parentUID;
	vector<BaseObjType> children;
	btVector3 startPoint;
	btVector3 skelOffset;
	
	std::vector<int> targWeaponStack;
	std::vector<BodyStruct> bodies;
	
	int actorId;
	int orgId;
	
	int contactCount;
	int isGrabbedById;
	int isGrabbedByHand;
	int entType;
	int subType;
	bool isHidden;
	bool isOpen;
	bool isEquipped;
	bool zeroZ;
	
	float bounciness;
	float friction;
	float windResistance;
	
	// skeleton
	btVector3 aabbMinSkel;
	btVector3 aabbMaxSkel;
	
	// visual objects
	btVector3 aabbMinVis;
	btVector3 aabbMaxVis;
	
	
	
	
	//////////////////
	// NPC SPECIFIC //
	//////////////////
	
	int tbDir;
	btVector3 tbPos;
	
	int swingType[4];
	int isGrabbingId[4];
	
	int hitCooldown;
	int jumpCooldown;
	
	
	float airCount;	
	float bindingPower;
	float swingCount;
	float blockCount;
	float lastBlockDis;
	
	btVector3 behaviorTarget;
	btVector3 npcRepel;
	
	
	
	//////////////////
	// END SPECIFIC //
	//////////////////
	
	bool hasAtLeast(int status, int val) {
		return (statSheet.curStatus[status] >= val);
	}
	
	void modifyStatus(int status, int modVal) {
		statSheet.curStatus[status] += modVal;
		
		
		if (statSheet.curStatus[status] < 0) {
			statSheet.curStatus[status] = 0;
		}
		if (statSheet.curStatus[status] > statSheet.maxStatus[status]) {
			statSheet.curStatus[status] = statSheet.maxStatus[status];
		}
		
	}
	
	btVector3 getUnitBounds(bool getMax) {
		
		if (bodies.size() < 1) {
			cout << "ERROR: getUnitBounds() with no bodies\n";
		}
		
		btVector3 cp = getCenterPoint( E_BDG_CENTER );
		
		float diamXY = 2.0f;
		float diamZ = 4.0f;
		
		btVector3 newRad = btVector3(diamXY*0.5f,diamXY*0.5f,diamZ*0.5f);
		
		
		switch (entType) {
			case E_ENTTYPE_NPC:
				
			break;
			default:
			
			break;
		}
		
		cp = btVector3(floor(cp.getX()),floor(cp.getY()),cp.getZ());
		
		if (getMax) {
			cp += btVector3(1.0f,1.0f,newRad.getZ());
		}
		else {
			cp -= btVector3(0.0f,0.0f,newRad.getZ());
		}
		
		return cp;
		
	}
	
	
	
	
	bool holdingWeapon(int handNum) {
		
		if (handNum == -1) {
			return (
				( isGrabbingId[RLBN_LEFT] > -1 ) ||
				( isGrabbingId[RLBN_RIGT] > -1 )
			);
		}
		else {
			return ( isGrabbingId[handNum] > -1 );
		}
		
		
	}
	
	
	void setDamping(float linear, float angular) {
		int i;
		
		for (i = 0; i < bodies.size(); i++) {
			bodies[i].body->setDamping(linear,angular);
		}
	}
	
	void clearAABB(btVector3* aabbMin, btVector3* aabbMax) {
		*aabbMin = btVector3(FLT_MAX,FLT_MAX,FLT_MAX);
		*aabbMax = btVector3(FLT_MIN,FLT_MIN,FLT_MIN);	
	}
	
	void addAABBPoint(btVector3* aabbMin, btVector3* aabbMax, btVector3 newPoint) {
		btVector3 tempv;
		
		tempv = btVector3(
			max(newPoint.getX(), aabbMax->getX()),
			max(newPoint.getY(), aabbMax->getY()),
			max(newPoint.getZ(), aabbMax->getZ())
		);
		
		*aabbMax = tempv;
		
		tempv = btVector3(
			min(newPoint.getX(), aabbMin->getX()),
			min(newPoint.getY(), aabbMin->getY()),
			min(newPoint.getZ(), aabbMin->getZ())
		);
		
		*aabbMin = tempv;
	}
	
	
	bool hasBodies() {
		return (bodies.size() > 0);
	}
	
	void multVel(int i, btVector3 velMod) {
		
		bodies[i].body->setLinearVelocity(
			bodies[i].body->getLinearVelocity() * velMod
		);
	}
	
	void multVelAng(int i, btVector3 velMod) {
		
		bodies[i].body->setAngularVelocity(
			bodies[i].body->getAngularVelocity() * velMod
		);
	}
	
	void addVel(int i, btVector3 velMod) {
		
		bodies[i].body->setLinearVelocity(
			bodies[i].body->getLinearVelocity() + velMod
		);
	}
	
	FIVector4* getVel(int i) {
		
		if (i < bodies.size()) {
			
			linVelocity.setBTV( bodies[i].body->getLinearVelocity() );
		}
		
		
		return &linVelocity;
	}
	
	BodyStruct* getBodyByBoneId(int id) {
		int i;
		
		for (i = 0; i < bodies.size(); i++) {
			if (bodies[i].boneId == id) {
				return &(bodies[i]);
			}
		}
		
		return NULL;
	}
	
	float getTotalMass() {
		int i;
		
		float tot = 0.0f;
		
		for (i = 0; i < bodies.size(); i++) {
			tot += bodies[i].mass;
		}
		
		return tot;
	}
	
	float getMarkerMass() {
		return bodies[E_BDG_CENTER].mass;
	}
	
	
	
	void wakeAll() {
		// int i;
		
		// for (i = 0; i < bodies.size(); i++) {
		// 	bodies[i].body->setActivationState(ACTIVE_TAG);
		// }
	}
	
	
	
	bool allFalling() {
		int i;
		
		for (i = 0; i < bodies.size(); i++) {
			if (bodies[i].hasContact) {
				return false;
			}
		}
		
		return true;
	}
	
	bool baseContact() {
		return bodies[E_BDG_CENTER].hasContact;
	}
	
	float getPlanarVel() {
		
		if (bodies.size() < 1) {
			return 0.0f;
		}
		
		btVector3 sourceVel = bodies[E_BDG_CENTER].body->getLinearVelocity();
		
		return sqrt( sourceVel.getX()*sourceVel.getX() + sourceVel.getY()*sourceVel.getY() );
	}
	
	void setLinVel(btVector3 newVel, int i) {
		if (i < bodies.size()) {
			bodies[i].body->setLinearVelocity(newVel);
			bodies[i].body->setActivationState(ACTIVE_TAG);
		}
	}
	
	void applyImpulses(float timeDelta, int i) {
		
		if (i < bodies.size()) {
			if (bodies[i].totAV.isZero()&&bodies[i].totLV.isZero()) {
				
			}
			else {
				
				// if (zeroZ) {
				// 	bodies[i].body->setLinearVelocity(btVector3(
				// 		bodies[i].body->getLinearVelocity().getX(),
				// 		bodies[i].body->getLinearVelocity().getY(),
				// 		0.0f	
				// 	));
				// }
				
				bodies[i].body->setAngularVelocity(bodies[i].body->getAngularVelocity() + bodies[i].totAV*timeDelta);
				bodies[i].body->applyCentralImpulse(bodies[i].totLV*timeDelta);
				bodies[i].body->setActivationState(ACTIVE_TAG);
			
			}
		}
		
	}
	
	
	
	// void begSwing() {
	// 	targWeaponStack.push_back(E_WEAPON_STATE_BEG);
	// }
	// void endSwing() {
	// 	targWeaponStack.push_back(E_WEAPON_STATE_END);
	// 	targWeaponStack.push_back(E_WEAPON_STATE_IDLE);
	// 	//targWeaponStack.push_back(E_WEAPON_POS_RELAXED);
	// }
	
	// int getStackElem(int n) {
	// 	std::list<int>::iterator ptr;
	// 	int i;

	// 	for( i = 0 , ptr = targWeaponStack.begin() ; i < n && ptr != targWeaponStack.end() ; i++ , ptr++ );

	// 	if( ptr == targWeaponStack.end() ) {
	// 	    // list too short 
	// 	    return -1;
	// 	}
	// 	else {
	// 	    // 'ptr' points to n-th element of list
	// 	    return *ptr;
	// 	}
	// }
	
	
	btVector3 getWeaponPos(int curPos) {
		
		float newLR = 0.0f;
		float newUD = 0.0f;
		
		switch (curPos) {
			case E_WEAPON_POS_RELAXED:
				newLR = 0.5f;
				newUD = 0.25f;
			break;
			case E_WEAPON_POS_LEFT:
				newLR = 0.0f;
				newUD = 0.5f;
			break;
			case E_WEAPON_POS_RIGHT:
				newLR = 1.0f;
				newUD = 0.5f;
			break;
			case E_WEAPON_POS_UP:
				newLR = 0.5f;
				newUD = 0.0f;
			break;
			case E_WEAPON_POS_DOWN:
				newLR = 0.5f;
				newUD = 1.0f;
			break;
			
			case E_WEAPON_POS_UP_LEFT:
				newLR = 0.0f;
				newUD = 0.25f;
			break;
			case E_WEAPON_POS_UP_RIGHT:
				newLR = 1.0f;
				newUD = 0.25f;
			break;
			case E_WEAPON_POS_DOWN_LEFT:
				newLR = 0.0f;
				newUD = 0.75f;
			break;
			case E_WEAPON_POS_DOWN_RIGHT:
				newLR = 1.0f;
				newUD = 0.75f;
			break;
			case E_WEAPON_POS_FORWARD:
				newLR = 0.5f;
				newUD = 0.5f;
			break;
			
		}
		
		return btVector3(newLR,newUD,0.0f);
	}
	
	void setGrabbedBy(int newId, int handNum) {
		int i;
		
		isGrabbedByHand = handNum;
		isGrabbedById = newId;
		
		int heldUID = newId;
		
		if (heldUID < 0) {
			heldUID = -3;
		}
		
		for (i = 0; i < bodies.size(); i++) {
			bodies[i].body->heldByUID = heldUID;
		}
	}
	
	// void updateWeaponTargs(double curStepTime) {
		
		
	// 	totWeaponTime += curStepTime;
		
		
	// 	if (totWeaponTime >= 1.0) {
	// 		totWeaponTime = 1.0;
			
	// 		if (targWeaponStack.size() > 1) {
	// 			//targWeaponStack.pop_front();
	// 			targWeaponStack.erase(targWeaponStack.begin() + 0);
	// 			totWeaponTime = 0.0f;
	// 		}
	// 	}
		
	// 	int curStep = E_WEAPON_STATE_IDLE;
	// 	int nextStep = E_WEAPON_STATE_IDLE;
		
	// 	if (targWeaponStack.size() > 0) {
	// 		curStep = targWeaponStack[0];
	// 	}
		
	// 	if (targWeaponStack.size() > 1) {
	// 		nextStep = targWeaponStack[1];
	// 	}
	// 	else {
	// 		nextStep = curStep;
	// 	}
		
		
		
		
		
		
	// 	float lerpTime = totWeaponTime;
		
	// 	btVector3 res0;
	// 	btVector3 res1;
		
		
	// 	if (
	// 		(curStep == E_WEAPON_STATE_IDLE) &&
	// 		(nextStep == E_WEAPON_STATE_IDLE)	
	// 	) {
	// 		res0 = getWeaponPos(E_WEAPON_POS_RELAXED);
	// 		res1 = getWeaponPos(E_WEAPON_POS_RELAXED);
	// 	}
		
	// 	if (
	// 		(curStep == E_WEAPON_STATE_BEG) &&
	// 		(nextStep == E_WEAPON_STATE_BEG)
	// 	) {
	// 		res0 = getWeaponPos(E_WEAPON_POS_UP_LEFT);
	// 		res1 = getWeaponPos(E_WEAPON_POS_UP_LEFT);
	// 	}
		
	// 	if (
	// 		(curStep == E_WEAPON_STATE_IDLE) &&
	// 		(nextStep == E_WEAPON_STATE_BEG)	
	// 	) {
	// 		res0 = getWeaponPos(E_WEAPON_POS_RELAXED);
	// 		res1 = getWeaponPos(E_WEAPON_POS_UP_LEFT);
	// 	}
		
		
	// 	if (
	// 		(curStep == E_WEAPON_STATE_BEG) &&
	// 		(nextStep == E_WEAPON_STATE_END)	
	// 	) {
	// 		if (totWeaponTime < 0.5f) {
	// 			res0 = getWeaponPos(E_WEAPON_POS_UP_LEFT);
	// 			res1 = getWeaponPos(E_WEAPON_POS_FORWARD);
	// 			lerpTime = totWeaponTime*2.0f;
	// 		}
	// 		else {
	// 			res0 = getWeaponPos(E_WEAPON_POS_FORWARD);
	// 			res1 = getWeaponPos(E_WEAPON_POS_RIGHT);
	// 			lerpTime = (totWeaponTime-0.5f)*2.0f;
	// 		}
	// 	}
	
	// 	if (
	// 		(curStep == E_WEAPON_STATE_END) &&
	// 		(nextStep == E_WEAPON_STATE_IDLE)	
	// 	) {
	// 		res0 = getWeaponPos(E_WEAPON_POS_RELAXED);
	// 		res1 = getWeaponPos(E_WEAPON_POS_RIGHT);
	// 	}
		
		
		
	// 	lrBounds = mixf(res0.getX(), res1.getX(), lerpTime);
	// 	udBounds = mixf(res0.getY(), res1.getY(), lerpTime);
		
		
	// }
	
	
	// void updateWeapon(
	// 	int handNum,
	// 	btVector3 weaponBeg,
	// 	btVector3 weaponEnd,
	// 	double curStepTime,
	// 	// float lrBounds,
	// 	// float udBounds,
	// 	float weaponLen
	// ) {
		
	// 	totTime += curStepTime;
		
	// 	//updateWeaponTargs(curStepTime);
		
		
		
		
	// 	float myMat[16];
	// 	Matrix4 myMatrix4;
	// 	Vector3 myVector0;
	// 	Vector3 myVector1;
	// 	Vector3 normVec;
	// 	Vector4 resVector0;
	// 	Vector4 resVector1;
		
	// 	Vector4 vf0;
	// 	Vector4 vf1;
		
	// 	btVector3 basePos;
	// 	float rad0 = 1.0f;
	// 	float rad1 = rad0 + weaponLen;
		
	// 	//float lrBounds = sin(totTime/4.0);
	// 	//float udBounds = sin(totTime);
	// 	//float udBounds2 = udBounds;//sin(totTime/8.0);
		
	// 	if (bodies.size() < 1) {
	// 		return;
	// 	}
		
		
	// 	// float weaponTheta = M_PI_2 + lrBounds*M_PI_8;
	// 	// float weaponPhi = M_PI_4 + udBounds*M_PI_4;
		
	// 	// float weaponTheta2 = (1.0f - lrBounds)*M_PI + cos(totTime/2.0f)*0.1f;
	// 	// float weaponPhi2 = 0 + udBounds*M_PI_2*1.5f + sin(totTime/3.0f)*0.1f;
		
		
	// 	bodies[E_BDG_CENTER].body->getWorldTransform().getOpenGLMatrix(myMat);
	// 	myMatrix4 = Matrix4(myMat);
		
	// 	// myVector0 = Vector3(
	// 	// 	cos(weaponTheta)*sin(weaponPhi)*rad0,
	// 	// 	sin(weaponTheta)*sin(weaponPhi)*rad0 + 0.5f,
	// 	// 	cos(weaponPhi)*rad0 + (1.0f-udBounds2)*0.75f
	// 	// );
	// 	// myVector1 = Vector3(
	// 	// 	cos(weaponTheta2)*sin(weaponPhi2)*rad1,
	// 	// 	sin(weaponTheta2)*sin(weaponPhi2)*rad1 + 0.5f,
	// 	// 	cos(weaponPhi2)*rad1
	// 	// );
		
	// 	// myVector0.x -= (myVector0.x*0.5f + myVector1.x*0.5f)*0.25f;
	// 	// myVector0.y -= (myVector0.y*0.5f + myVector0.y*0.5f)*0.25f;
		
	// 	// myVector0 *= 0.75f;
		
	// 	// myVector0.y += 0.25f;
		
	// 	// //if (myVector1.x > 0.0f) {
	// 	// 	myVector0.x += myVector1.x*0.25f;
	// 	// //}
		
	// 	// myVector1.y += 1.0f-abs(cos(weaponPhi2));
		
	// 	BodyStruct* handBody;
		
	// 	if (handNum == RLBN_LEFT) {
	// 		handBody = getBodyByBoneId(getCorrectedName(E_BONE_L_METACARPALS));
	// 	}
	// 	else {
	// 		handBody = getBodyByBoneId(getCorrectedName(E_BONE_R_METACARPALS));
	// 	}
		
		
		
	// 	btVector3 handCenter = handBody->body->getCenterOfMassPosition();
		
	// 	myVector0 = Vector3(weaponBeg.getX(), weaponBeg.getY(),weaponBeg.getZ());
	// 	myVector1 = Vector3(weaponEnd.getX(), weaponEnd.getY(),weaponEnd.getZ());
		
		
	// 	normVec = myVector1 - myVector0;
	// 	normVec.normalize();
	// 	normVec = normVec*(rad1-rad0);
	// 	myVector1 = myVector0 + normVec;
		
	// 	rightHandTop = true;//(myVector0.x < 0.0f);
		
		
		
	// 	vf0 = Vector4(myVector0.x, myVector0.y, myVector0.z, 1.0f);
	// 	vf1 = Vector4(myVector1.x, myVector1.y, myVector1.z, 1.0f);
		
	// 	resVector0 = myMatrix4*vf0;
	// 	resVector1 = myMatrix4*vf1;
		
	// 	weaponVec0[handNum] = btVector3(resVector0.x,resVector0.y,resVector0.z);
	// 	weaponVec1[handNum] = btVector3(resVector1.x,resVector1.y,resVector1.z);
		
	// 	btVector3 weapDif = handCenter-weaponVec0[handNum];
		
	// 	weaponVec0[handNum] += weapDif;
	// 	weaponVec1[handNum] += weapDif;
		
		
	// 	vf0 = Vector4( 1.0f,0.0f,0.0f,1.0f);
	// 	vf1 = Vector4(-1.0f,0.0f,0.0f,1.0f);
		
	// 	resVector0 = myMatrix4*vf0;
	// 	resVector1 = myMatrix4*vf1;
		
	// 	rightVec = btVector3(resVector0.x,resVector0.y,resVector0.z);
	// 	leftVec = btVector3(resVector1.x,resVector1.y,resVector1.z);
		
		
		
		
		
		
	// }
	
	
	void flushImpulses() {
		
		int i;
		
		for (i = 0; i < bodies.size(); i++) {
			bodies[i].totAV = btVector3(0.0f,0.0f,0.0f);
			bodies[i].totLV = btVector3(0.0f,0.0f,0.0f);
		}
		
		
	}
	
	float turnTowardsTargAng( float targAng ) {
		btVector3 curVec = bodies[E_BDG_CENTER].body->getCenterOfMassTransform().getBasis()*btVector3(0.0f,1.0f,0.0f);
		curVec.setZ(0.0f);
		curVec.normalize();
		
		float curAng = atan2(curVec.getY(),curVec.getX());
		
		return getShortestAngle(curAng,targAng,1.0f);
	}
	
	float turnTowardsPointDelta(btVector3 targPoint) {
		btVector3 centerPoint = getCenterPoint(E_BDG_CENTER);
		
		btVector3 targVec = targPoint-centerPoint;
		targVec.setZ(0.0f);
		targVec.normalize();
		
		float targAng = atan2(targVec.getY(),targVec.getX());
		
		return turnTowardsTargAng(targAng);
		
		
		//return targAng-curAng;
		
		// btQuaternion quat;
		
		// if ( abs(vectorA.dot(vectorB)) == 1.0f ) {
		// 	// todo: handle (anti)parallel case
		// 	//curJoint->pivotAxis = btVector3(0.0f,0.0f,0.0f);
		// 	//curJoint->quat = btQuaternion(btVector3(0.0f,0.0f,1.0f), 0.0f);
		// }
		// else {
		// 	axis = (vectorA.cross(vectorB)).normalized();
		// 	angle = btAcos(vectorA.dot(vectorB)) / (vectorA.length() * vectorB.length());
		// 	quat = btQuaternion(axis, angle);
		// 	transform.setRotation(curJoint->quat);
		// 	//curJoint->pivotAxis = axis;
		// }
	}
	
	void applyAngularImpulse(btVector3 newAV, bool delayed, int i) {
		
		
		if (i < bodies.size()) {
			if (delayed) {
				bodies[i].totAV += newAV;
			}
			else {
				
				bodies[i].body->setAngularVelocity(bodies[i].body->getAngularVelocity() + newAV);
				bodies[i].body->setActivationState(ACTIVE_TAG);
			}

		}
		
	}
	
	void applyImpulse(btVector3 imp, bool delayed, int i) {
		if (i < bodies.size()) {
			
			if (delayed) {
				bodies[i].totLV += imp;
			}
			else {
			
			
				bodies[i].body->applyCentralImpulse(imp);
				bodies[i].body->setActivationState(ACTIVE_TAG);
			}
		}
		
	}
	
	void applyImpulseOtherRot(btVector3 imp, btMatrix3x3 otherRot, bool delayed, int i) {
		
		//Vector3 myRHS = Vector3(imp.getX(),imp.getY(),imp.getZ());
		//Vector3 res = otherRot*myRHS;
		btVector3 newImp = otherRot*imp;//btVector3(res.x,res.y,res.z);
		
		if (i < bodies.size()) {
			if (delayed) {
				bodies[i].totLV += newImp;
			}
			else {
				
				bodies[i].body->applyCentralImpulse(newImp);
				bodies[i].body->setActivationState(ACTIVE_TAG);
			}
		}
		
		
	}
	
	bool isHumanoid() {
		return (
			(entType == E_ENTTYPE_NPC)
		);
	}
	
	// void makeWalk(btVector3 imp, btMatrix3x3 otherRot) {
		
	// 	if (isHumanoid()) {
			
	// 	}
	// 	else {
	// 		return;
	// 	}
		
		
	// 	bool lfDown = bodies[E_BDG_LFOOT].hasContact && 
	// 		(bodies[E_BDG_LFOOT].body->getLinearVelocity().length() < 0.1f);
	// 	bool rfDown = bodies[E_BDG_RFOOT].hasContact && 
	// 		(bodies[E_BDG_RFOOT].body->getLinearVelocity().length() < 0.1f);
		
	// 	int resInd = -1;
		
	// 	if (lfDown && rfDown) {
	// 		leftActive = !leftActive;
	// 		//resInd = E_BDG_LFOOT;
			
	// 		if (leftActive) {
	// 			resInd = E_BDG_LFOOT;
	// 		}
	// 		else {
	// 			resInd = E_BDG_RFOOT;
	// 		}
			
	// 	}
	// 	// else {
	// 	// 	if (lfDown) {
	// 	// 		resInd = E_BDG_LFOOT;
	// 	// 	}
	// 	// 	else {
	// 	// 		if (rfDown) {
	// 	// 			resInd = E_BDG_RFOOT;
	// 	// 		}
	// 	// 	}
	// 	// }
		
	// 	if (resInd == -1) {
	// 		return;
	// 	}
		
		
	// 	btVector3 newImp = otherRot*imp*bodies[resInd].mass;
		
	// 	bodies[resInd].body->applyCentralImpulse(newImp);
	// 	bodies[resInd].body->setActivationState(ACTIVE_TAG);
		
		
	// }
	
	
	
	void moveOffset(btVector3 offset, int ind) {
		btTransform trans;
		
		
		if (ind < bodies.size()) {
			
			trans.setIdentity();
			trans.setOrigin(
				bodies[ind].body->getCenterOfMassPosition() + offset
			);
			bodies[ind].body->setActivationState(ACTIVE_TAG);
			bodies[ind].body->setCenterOfMassTransform(
				trans
			);
			
		}
	}
	
	void moveToPoint(btVector3 newPoint, int ind) {
		btTransform trans;
		
		
		if (ind < bodies.size()) {
			
			trans.setIdentity();
			trans.setOrigin(newPoint);
			bodies[ind].body->setActivationState(ACTIVE_TAG);
			bodies[ind].body->setCenterOfMassTransform(
				trans
			);
			
		}
	}
	
	// void setCenterPoint(FIVector4* newPos) {
		
	// 	centerPoint.copyFrom(newPos);
				
	// }
	
	btVector3 getCenterPoint(int ind) {
		if (
			ind < bodies.size()
		) {
			return bodies[ind].body->getCenterOfMassPosition();
		}
		else {
			return btVector3(0.0f,0.0f,0.0f);
		}
	}
	
	FIVector4* getCenterPointFIV(int ind) {
		if (
			ind < bodies.size()
		) {
			centerPoint.setBTV( bodies[ind].body->getCenterOfMassPosition() );
		}
		else {
			centerPoint.setFXYZ(0.0f,0.0f,0.0f);
		}
		
		return &centerPoint;
	}
	
	
	BaseObj() {
		
	}
	
	void removeChild(BaseObjType _uid) {
		int i;
		
		for (i = 0; i < children.size(); i++) {
			if (children[i] == _uid) {
				children.erase(children.begin() + i);
				return;
			}
		}
	}
	
	
	float healthPerc() {
		return ((float)statSheet.curStatus[E_STATUS_HEALTH])/((float)statSheet.maxStatus[E_STATUS_HEALTH]);
	}
	
	bool isDead() {
		return (statSheet.curStatus[E_STATUS_HEALTH] <= 0);
	}
	
	bool isAlive() {
		return (statSheet.curStatus[E_STATUS_HEALTH] > 0);
	}
	
	bool getActionState(int action, int handNum) {
		return actionStates[action*RLBN_LENGTH + handNum];
	}
	
	void setActionState(int action, int handNum, bool newVal) {
		actionStates[action*RLBN_LENGTH + handNum] = newVal;
	}
	
	void clearActionStates() {
		int i;
		
		for (i = 0; i < E_ACT_LENGTH*RLBN_LENGTH; i++) {
			actionStates[i] = false;
		}
		
	}
	
	
	void init(
		BaseObjType _uid,
		BaseObjType _parentUID,
		int _objectType,
		int _entType,
		int _subType,
		FIVector4* cellPos
	) {
		
		int i;
		
		contactCount = 0;
		
		//mass = 10.0f;
		orgId = -1;
		actorId = -1;
		isHidden = false;
		
		maxFrames = 0;
		objectType = _objectType;
		entType = _entType;
		subType = _subType;
		
		behaviorTarget = btVector3(0.0f,0.0f,0.0f);
		npcRepel = btVector3(0.0f,0.0f,0.0f);
		
		isGrabbedByHand = -1;
		isGrabbedById = -1;
		
		lastBlockDis = 0.0f;
		blockCount = 0.0f;
		swingCount = 0.0f;
		bindingPower = 1.0f;
		airCount = 0.0f;
		
		tbDir = 0;
		
		for (i = 0; i < RLBN_LENGTH; i++) {
			isGrabbingId[i] = -1;
			swingType[i] = E_PG_SLSH;
		}
		
		for (i = 0; i < E_CS_LENGTH; i++) {
			statSheet.baseStats[i] = 5;
			statSheet.unapplyedStats[i] = 5;	
		}
		statSheet.availPoints = 10;
		
		for (i = 0; i < E_STATUS_LENGTH; i++) {
			statSheet.curStatus[i] = 10;
			statSheet.maxStatus[i] = 10;
		}
		
		
		zeroZ = false;
		jumpCooldown = 0;
		hitCooldown = 0;
		
		
		clearActionStates();
		
		
		isOpen = false;
		isEquipped = false;
		parentUID = _parentUID;
		uid = _uid;
		
		skelOffset = btVector3(0.0f,0.0f,0.0f);
		startPoint = cellPos->getBTV();
		
		bounciness = 0.0f;
		friction = 0.9;
		windResistance = 0.9;
		
		
		//tbPos = getUnitBounds(false);
		
		targPath.points[0] = btVector3(0.0f,0.0f,0.0f);
		targPath.points[1] = btVector3(0.0f,0.0f,0.0f);
		targPath.searchedForPath = false;
		targPath.didFindPath = false;
		targPath.finalPoints.clear();
		targPath.nextInd = -1;
		
		
	}
	
};

typedef map<BaseObjType, BaseObj>::iterator itBaseObj;


class VNode {
public:
	
	int tokenIndex;
	int ruleNumber;
	std::vector<VNode*> children;
	
	VNode(int _tokenIndex) {
		tokenIndex = _tokenIndex;
	}
	
	~VNode() {
		int i;
		
		for (i = 0; i < children.size(); i++) {
			delete children[i];
		}
		children.clear();
	}
	
};

struct AssignStruct {
	VNode* lastAssign;
	VNode* newAssign;
	int tokenIndex;
	int genIndex;
};



inline float qSign(float x) {return (x >= 0.0f) ? +1.0f : -1.0f;}
inline float qNorm(float a, float b, float c, float d) {return sqrt(a * a + b * b + c * c + d * d);}


btQuaternion matToQuat(
	float r11, float r12, float r13,
	float r21, float r22, float r23,
	float r31, float r32, float r33 	
) {
	float q0 = ( r11 + r22 + r33 + 1.0f) / 4.0f;
	float q1 = ( r11 - r22 - r33 + 1.0f) / 4.0f;
	float q2 = (-r11 + r22 - r33 + 1.0f) / 4.0f;
	float q3 = (-r11 - r22 + r33 + 1.0f) / 4.0f;
	if(q0 < 0.0f) q0 = 0.0f;
	if(q1 < 0.0f) q1 = 0.0f;
	if(q2 < 0.0f) q2 = 0.0f;
	if(q3 < 0.0f) q3 = 0.0f;
	q0 = sqrt(q0);
	q1 = sqrt(q1);
	q2 = sqrt(q2);
	q3 = sqrt(q3);
	if(q0 >= q1 && q0 >= q2 && q0 >= q3) {
	    q0 *= +1.0f;
	    q1 *= qSign(r32 - r23);
	    q2 *= qSign(r13 - r31);
	    q3 *= qSign(r21 - r12);
	} else if(q1 >= q0 && q1 >= q2 && q1 >= q3) {
	    q0 *= qSign(r32 - r23);
	    q1 *= +1.0f;
	    q2 *= qSign(r21 + r12);
	    q3 *= qSign(r13 + r31);
	} else if(q2 >= q0 && q2 >= q1 && q2 >= q3) {
	    q0 *= qSign(r13 - r31);
	    q1 *= qSign(r21 + r12);
	    q2 *= +1.0f;
	    q3 *= qSign(r32 + r23);
	} else if(q3 >= q0 && q3 >= q1 && q3 >= q2) {
	    q0 *= qSign(r21 - r12);
	    q1 *= qSign(r31 + r13);
	    q2 *= qSign(r32 + r23);
	    q3 *= +1.0f;
	} else {
	    cout << "Quaternion error\n";
	}
	float r = qNorm(q0, q1, q2, q3);
	q0 /= r;
	q1 /= r;
	q2 /= r;
	q3 /= r;
	
	return btQuaternion(q0,q1,q2,q3);
}

btVector3 quatToEulerXYZ(const btQuaternion &quat) {
	btVector3 euler;
	float w=quat.getW();   float x=quat.getX();   float y=quat.getY();   float z=quat.getZ();
	double sqw = w*w; double sqx = x*x; double sqy = y*y; double sqz = z*z; 
	euler.setZ((atan2(2.0 * (x*y + z*w),(sqx - sqy - sqz + sqw))));
	euler.setX((atan2(2.0 * (y*z + x*w),(-sqx - sqy + sqz + sqw))));
	euler.setY((asin(-2.0 * (x*z - y*w))));
	
	return euler;
}


void moveToOrientation(
	btRigidBody* myBody,
	btVector3 tanAxis,
	btVector3 bitAxis,
	btVector3 norAxis,
	float kv = 0.5f
) {
	btQuaternion targetOrientation = matToQuat(
		tanAxis.getX(),	bitAxis.getX(), norAxis.getX(),
		tanAxis.getX(),	bitAxis.getX(), norAxis.getX(),
		tanAxis.getX(),	bitAxis.getX(), norAxis.getX()
	);
	btQuaternion currentOrientation = myBody->getOrientation();
	btQuaternion deltaOrientation = targetOrientation * currentOrientation.inverse();
	btVector3 deltaEuler = quatToEulerXYZ(deltaOrientation);
	btVector3 torqueToApply = (-1.0f*kv)*deltaEuler;
	myBody->applyTorque(torqueToApply);
	
}


class VBOWrapper {
public:
	GLuint vao, vbo, ibo;

	int sizeOfID;
	int sizeOfVD;
	GLfloat* vertexData;
	GLuint* indexData;

	VBOWrapper() {
		
	}
	
	void init(GLfloat* _vertexData, int _sizeOfVD, GLuint* _indexData, int _sizeOfID) {
		
		
		sizeOfID = _sizeOfID;
		sizeOfVD = _sizeOfVD;
		vertexData = _vertexData;
		indexData = _indexData;
		
		
		
		// vao and vbo handle
		
		
		// generate and bind the vao
		glGenVertexArrays(1, &vao);
		glBindVertexArray(vao);
		
		// generate and bind the vertex buffer object
		glGenBuffers(1, &vbo);
		glBindBuffer(GL_ARRAY_BUFFER, vbo);
		
		
		// fill with data
		glBufferData(GL_ARRAY_BUFFER, sizeof(GLfloat)*sizeOfVD, vertexData, GL_STATIC_DRAW);
		
		
		// set up generic attrib pointers
		glEnableVertexAttribArray(0);
		glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 8*sizeof(GLfloat), (char*)0 + 0*sizeof(GLfloat));
		
		glEnableVertexAttribArray(1);
		glVertexAttribPointer(1, 4, GL_FLOAT, GL_FALSE, 8*sizeof(GLfloat), (char*)0 + 4*sizeof(GLfloat));
		
		
		// generate and bind the index buffer object
		glGenBuffers(1, &ibo);
		glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
		

		// fill with data
		glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(GLuint)*sizeOfID, indexData, GL_STATIC_DRAW);
		
		// "unbind" vao
		glBindVertexArray(0);
		
	
	}
	
	void draw() {
		glBindVertexArray(vao);
		glDrawElements(GL_TRIANGLES, sizeOfID, GL_UNSIGNED_INT, 0);
		glBindVertexArray(0);
	}
	
	
};

// class PlaneGrid {
// public:

// 	PlaneGrid() {
		
// 	}
// 	void init() {
// 		int plane_width = 4; // amount of columns
// 		int plane_height = 2; // amount of rows

// 		int total_vertices = (plane_width + 1) * (plane_height + 1);
// 		planeVert = new CIwFVec2[total_vertices];
// 		memset(planeVert, 0, sizeof(CIwFVec2) * total_vertices);

// 		int numIndPerRow = plane_width * 2 + 2;
// 		int numIndDegensReq = (plane_height - 1) * 2;
// 		int total_indices = numIndPerRow * plane_height + numIndDegensReq;

// 		planeInd = new uint16[total_indices];

// 		make_plane(plane_width, plane_height, planeVert, planeInd);

// 		...

// 		void make_plane(int width, int height, CIwFVec2 *vertices, uint16 *indices) {
			
// 			width++;
// 			height++;

// 			int size = sizeof(CIwFVec2);
// 			// Set up vertices
// 			for(int y = 0; y < height; y++)
// 			{
// 			    int base = y * width;
// 			    for(int x = 0; x < width; x++)
// 			    {
// 			        int index = base + x;
// 			        CIwFVec2 *v = vertices + index;
// 			        v->x = (float) x;
// 			        v->y = (float) y;
// 			        Debug::PrintDebug("%d: %f, %f", index, v->x, v->y);
// 			    }
// 			}

// 			Debug::PrintDebug("-------------------------");

// 			// Set up indices
// 			int i = 0;
// 			height--;
// 			for(int y = 0; y < height; y++)
// 			{
// 			    int base = y * width;

// 			    //indices[i++] = (uint16)base;
// 			    for(int x = 0; x < width; x++)
// 			    {
// 			        indices[i++] = (uint16)(base + x);
// 			        indices[i++] = (uint16)(base + width + x);
// 			    }
// 			    // add a degenerate triangle (except in a last row)
// 			    if(y < height - 1)
// 			    {
// 			        indices[i++] = (uint16)((y + 1) * width + (width - 1));
// 			        indices[i++] = (uint16)((y + 1) * width);
// 			    }
// 			}

// 			for(int ind=0; ind < i; ind++)
// 			    Debug::PrintDebug("%d ", indices[ind]);
			
// 		}
// 	}
// };




class TBOWrapper {
public:
	GLuint tbo_buf;
	GLuint tbo_tex;
	
	int dataSize;
	
	bool isFloat;
	
	TBOWrapper() {
		
	}
	
	void init(bool _isFloat, float* tbo_data, uint* tbo_data2, int _dataSize) {
		
		isFloat = _isFloat;
		
		dataSize = _dataSize;

		glGenBuffers(1, &tbo_buf);
		glBindBuffer(GL_TEXTURE_BUFFER, tbo_buf);
		
		if (isFloat) {
			glTexBuffer(GL_TEXTURE_BUFFER, GL_RGBA32F, tbo_buf);
			glBufferData(GL_TEXTURE_BUFFER, dataSize, tbo_data, GL_DYNAMIC_DRAW); // todo: dynamic draw? //GL_STATIC_DRAW
			
		}
		else {
			glTexBuffer(GL_TEXTURE_BUFFER, GL_RGBA32UI, tbo_buf);		
			glBufferData(GL_TEXTURE_BUFFER, dataSize, tbo_data2, GL_DYNAMIC_DRAW); // todo: dynamic draw? //GL_STATIC_DRAW
			
		}
		
		glGenTextures(1, &tbo_tex);
		glBindBuffer(GL_TEXTURE_BUFFER, 0);
	}
	
	void update(float* tbo_data, uint* tbo_data2, int newDataSize) {
		
		int tempDataSize;
		
		if (newDataSize < 0) {
			tempDataSize = dataSize;
		}
		else {
			tempDataSize = newDataSize;
		}
		
		
		tempDataSize = min(tempDataSize,dataSize);
		
		
		
		glBindBuffer(GL_TEXTURE_BUFFER, tbo_buf);
		if (isFloat) {
			glBufferSubData(GL_TEXTURE_BUFFER, 0, tempDataSize, tbo_data);
		}
		else {
			glBufferSubData(GL_TEXTURE_BUFFER, 0, tempDataSize, tbo_data2);
		}
		
		glBindBuffer(GL_TEXTURE_BUFFER, 0);
	}
	
	
};

class ThreadWrapper {
private:
	bool threadRunningEx; // thread is running (exclusive, must lock)
public:
	std::thread threadMain;
	std::mutex threadMutex;
	bool threadRunning; // thread is running (not exclusive)
	
	int threadDataInt[THREAD_DATA_COUNT];
	
	ThreadWrapper() {
		
	}
	
	void init() {
		threadRunning = false;
		threadRunningEx = false;
	}
	
	void setRunningLocked(bool val) {
		threadMutex.lock();
		threadRunningEx = val;
		threadMutex.unlock();
	}
	
	bool isReady() {
		bool doProc = false;
		
		if (threadRunning) {
			if (threadMutex.try_lock()) {
				if (threadRunningEx) {
					
				}
				else {
					doProc = true;
				}
				threadMutex.unlock();
			}
		}
		else {
			doProc = true;
		}
		
		return doProc;
	}
	
};



struct PushModStruct
{
	int actionType;
	FIVector4 data[4];
};


// class Q3Rend : public q3Render {
// public:
// 	void SetPenColor( f32 r, f32 g, f32 b, f32 a = 1.0f ) override
// 	{
// 		// Q3_UNUSED( a );

// 		// glColor3f( (float)r, (float)g, (float)b );
// 	}

// 	void SetPenPosition( f32 x, f32 y, f32 z ) override
// 	{
// 		x_ = x, y_ = y, z_ = z;
// 	}

// 	void SetScale( f32 sx, f32 sy, f32 sz ) override
// 	{
// 		// glPointSize( (float)sx );
// 		// sx_ = sx, sy_ = sy, sz_ = sz;
// 	}

// 	void Line( f32 x, f32 y, f32 z ) override
// 	{
// 		// glBegin( GL_LINES );
// 		// glVertex3f( (float)x_, (float)y_, (float)z_ );
// 		// glVertex3f( (float)x, (float)y, (float)z );
// 		// SetPenPosition( x, y, z );
// 		// glEnd( );
// 	}

// 	void Triangle(
// 		f32 x1, f32 y1, f32 z1,
// 		f32 x2, f32 y2, f32 z2,
// 		f32 x3, f32 y3, f32 z3
// 		) override
// 	{
		
// 		//glEnable( GL_LIGHTING );
// 		//glBegin( GL_TRIANGLES );
// 		//glColor4f( 0.2f, 0.4f, 0.7f, 0.5f );
// 		glVertex3f( (float)x1, (float)y1, (float)z1 );
// 		glVertex3f( (float)x2, (float)y2, (float)z2 );
// 		glVertex3f( (float)x3, (float)y3, (float)z3 );
// 		//glEnd( );
// 		//glDisable( GL_LIGHTING );
// 	}

// 	void SetTriNormal( f32 x, f32 y, f32 z ) override
// 	{
// 		glNormal3f( (float)x, (float)y, (float)z );
// 	}

// 	void Point( ) override
// 	{
// 		// glBegin( GL_POINTS );
// 		// glVertex3f( (float)x_, (float)y_, (float)z_ );
// 		// glEnd( );
// 	};

// private:
// 	f32 x_, y_, z_;
// 	f32 sx_, sy_, sz_;
// };

// Q3Rend q3Rend;





// struct vec2 {
// 	float x;
// 	float y;
// 	float z;	
// };

// struct vec3 {
// 	float x;
// 	float y;
// 	float z;	
// };

// struct vec4 {
// 	float x;
// 	float y;
// 	float z;
// 	float w;
// };

// class ShaderSimplex() {
// public:

// 	ShaderSimplex() {
		
// 	}
	
	
// 	//#############################


// 	//
// 	// Description : Array and textureless GLSL 2D/3D/4D simplex 
// 	//               noise functions.
// 	//      Author : Ian McEwan, Ashima Arts.
// 	//  Maintainer : ijm
// 	//     Lastmod : 20110822 (ijm)
// 	//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
// 	//               Distributed under the MIT License. See LICENSE file.
// 	//               https://github.com/ashima/webgl-noise
// 	// 

// 	vec3 mod289(vec3 q) {
// 		vec3 res;
// 		q - floor(q * (1.0 / 289.0)) * 289.0;
// 		return res;
// 	}

// 	vec4 mod289(vec4 q) {
// 		vec4 res;
// 		q - floor(q * (1.0 / 289.0)) * 289.0;
// 		return res;
// 	}

// 	vec4 permute(vec4 q) {
// 		vec4 res;
// 		mod289(((q*34.0)+1.0)*q);
// 		return res;
		
// 	}

// 	vec4 taylorInvSqrt(vec4 q) {
// 		vec4 res;
// 		1.79284291400159 - 0.85373472095314 * q;
// 		return res;
// 	}

// 	float snoise(vec3 v) { 
// 		const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
// 		const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);

// 		// First corner
// 		vec3 i  = floor(v + dot(v, C.yyy) );
// 		vec3 x0 =   v - i + dot(i, C.xxx) ;

// 		// Other corners
// 		vec3 g = step(x0.yzx, x0.xyz);
// 		vec3 l = 1.0 - g;
// 		vec3 i1 = min( g.xyz, l.zxy );
// 		vec3 i2 = max( g.xyz, l.zxy );

// 		//   x0 = x0 - 0.0 + 0.0 * C.xxx;
// 		//   x1 = x0 - i1  + 1.0 * C.xxx;
// 		//   x2 = x0 - i2  + 2.0 * C.xxx;
// 		//   x3 = x0 - 1.0 + 3.0 * C.xxx;
// 		vec3 x1 = x0 - i1 + C.xxx;
// 		vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
// 		vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y

// 		// Permutations
// 		i = mod289(i); 
// 		vec4 p = permute( permute( permute( 
// 		         i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
// 		       + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
// 		       + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));

// 		// Gradients: 7x7 points over a square, mapped onto an octahedron.
// 		// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
// 		float n_ = 0.142857142857; // 1.0/7.0
// 		vec3  ns = n_ * D.wyz - D.xzx;

// 		vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)

// 		vec4 x_ = floor(j * ns.z);
// 		vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)

// 		vec4 x = x_ * ns.x + ns.yyyy;
// 		vec4 y = y_ * ns.x + ns.yyyy;
// 		vec4 h = 1.0 - abs(x) - abs(y);

// 		vec4 b0 = vec4( x.xy, y.xy );
// 		vec4 b1 = vec4( x.zw, y.zw );

// 		//vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
// 		//vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
// 		vec4 s0 = floor(b0)*2.0 + 1.0;
// 		vec4 s1 = floor(b1)*2.0 + 1.0;
// 		vec4 sh = -step(h, vec4(0.0));

// 		vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
// 		vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;

// 		vec3 p0 = vec3(a0.xy,h.x);
// 		vec3 p1 = vec3(a0.zw,h.y);
// 		vec3 p2 = vec3(a1.xy,h.z);
// 		vec3 p3 = vec3(a1.zw,h.w);

// 		//Normalise gradients
// 		vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
// 		p0 *= norm.x;
// 		p1 *= norm.y;
// 		p2 *= norm.z;
// 		p3 *= norm.w;

// 		// Mix final noise value
// 		vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
// 		m = m * m;
// 		return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
// 	}


// 	//#############################
	
	
// };



// void opSeamlessSimplexNoise(float oct, float pers, float freq) {
	
// 	currentState = S_OP_SEAMLESS_SIMPLEX_NOISE;

// 	int i;

// 	int ix;
// 	int iy;
// 	int iz;

// 	float fx;
// 	float fy;
// 	float fz;

// 	float testVal;

// 	//float oct = 4.0;
// 	//float pers = 0.5;
// 	//float freq =- 1.0/gfTEXTURE_SIZE;

// 	float ts = gfTEXTURE_SIZE;


// 	for (i = 0; i < iTotalUnits; i++) {
// 		ix = i%(iPageSize);
// 		iy = (i%(iPageSize*iPageSize))/iPageSize;
// 		iz = i/(iPageSize*iPageSize);

// 		fx = ((float)ix) + fOffsets.x;
// 		fy = ((float)iy) + fOffsets.y;
// 		fz = ((float)iz) + fOffsets.z;

// 		//float simplexScaledNoise( const float octaves, const float persistence, const float scale, const float loBound, const float hiBound, const float x, const float y, const float z ) {
// 		testVal = 
// 			(
// 			simplexScaledNoise(oct, pers, freq, 0.0f, 1.0f, fx, 	fy, 	fz) * 		(ts-fx) *		(ts-fy) *	(ts-fz) +
// 			simplexScaledNoise(oct, pers, freq, 0.0f, 1.0f, fx-ts, 	fy, 	fz) * 		(fx) *			(ts-fy) *	(ts-fz) +
// 			simplexScaledNoise(oct, pers, freq, 0.0f, 1.0f, fx, 	fy-ts, 	fz) * 		(ts-fx) *		(fy) *		(ts-fz) +
// 			simplexScaledNoise(oct, pers, freq, 0.0f, 1.0f, fx-ts, 	fy-ts, 	fz) * 		(fx) *			(fy) *		(ts-fz) +
// 			simplexScaledNoise(oct, pers, freq, 0.0f, 1.0f, fx, 	fy, 	fz-ts) * 	(ts-fx) *		(ts-fy) *	(fz) +
// 			simplexScaledNoise(oct, pers, freq, 0.0f, 1.0f, fx-ts, 	fy, 	fz-ts) * 	(fx) *			(ts-fy) *	(fz) +
// 			simplexScaledNoise(oct, pers, freq, 0.0f, 1.0f, fx, 	fy-ts, 	fz-ts) * 	(ts-fx) *		(fy) *		(fz) +
// 			simplexScaledNoise(oct, pers, freq, 0.0f, 1.0f, fx-ts, 	fy-ts, 	fz-ts) * 	(fx) *			(fy) *		(fz)
// 			)/(ts*ts*ts);

// 		fDataArray[i] = testVal;

		
// 	}

// 	currentState = E_OP_SEAMLESS_SIMPLEX_NOISE;
// }


 
class GameEnt {
private:

	FIVector4 boundsMinInPixels;
	FIVector4 boundsMaxInPixels;
	FIVector4 visMinInPixels;
	FIVector4 visMaxInPixels;
	
	
	
	
	
public:
	
	int templateId;
	FIVector4 templatePos;
	
	int entType;
	//int toggleState;
	//int maxToggleStates;
	
	bool toggled;
	bool visible;
	//bool isFalling;
	
	float camDistance;

	
	
	FIVector4 geomParams[E_GP_LENGTH];

	FIVector4 anchorPointInPixels;
	FIVector4 moveMinInPixels;
	FIVector4 moveMaxInPixels;

	GameEnt *light;

	
	
	bool hasAnchor;

	//   1
	// 2   0
	//   3


	int rotDir;
	int minRot;
	int maxRot;
	int curRot;
	
	int buildingType;


	FIVector4 tempVec1;
	FIVector4 tempVec2;
	FIVector4 tempVec3;
	FIVector4 tempVec4;
	FIVector4 tempVec5;
	

	void setLightPos(FIVector4* newPos) {
		geomParams[E_LP_POSITION].copyFrom(newPos);
		geomParams[E_CP_VISMININPIXELST].copyFrom(newPos);
		geomParams[E_CP_VISMAXINPIXELST].copyFrom(newPos);
		
		geomParams[E_CP_VISMININPIXELST].addXYZRef(&(geomParams[E_LP_RADIUS]),-1.0f);
		geomParams[E_CP_VISMAXINPIXELST].addXYZRef(&(geomParams[E_LP_RADIUS]),1.0f);
		
		
		moveMinInPixels.setFXYZRef(&(geomParams[E_CP_VISMININPIXELST]));
		moveMaxInPixels.setFXYZRef(&(geomParams[E_CP_VISMAXINPIXELST]));
		
	}

	void initLight(
		FIVector4 *position,
		FIVector4 *color,
		float radius
	) {
		
		geomParams[E_LP_COLOR].copyFrom(color);
		geomParams[E_LP_RADIUS].setFXYZ(radius,radius,radius);
		
		setLightPos(position);
		
	}
	
	
	
	
	
	
	
	
	
	

	
	FIVector4 *getVisMinInPixelsT() {
		return &geomParams[E_CP_VISMININPIXELST];
	}
	FIVector4 *getVisMaxInPixelsT() {
		return &geomParams[E_CP_VISMAXINPIXELST];
	}

	int getClampedRot() {
		int tempRot = curRot;
		while (tempRot < 0) {
			tempRot += 4;
		}
		while (tempRot > 3) {
			tempRot -= 4;
		}

		return tempRot;
	}

	void rotate(int mod, bool ignoreConstraints) {

		if (hasAnchor) {
			curRot += mod;


			if (ignoreConstraints) {
				if (curRot > 3) {
					curRot = 0;
				}
				if (curRot < 0) {
					curRot = 3;
				}
			}
			else {
				if (curRot > maxRot) {
					curRot = maxRot - 1;
					rotDir *= -1;
				}
				if (curRot < minRot) {
					curRot = minRot + 1;
					rotDir *= -1;

				}

			}


		}
		else {
			cout << "Attemped to rotate without anchor.\n";
		}


	}
	
	
	
	
	
	
	GameEnt() {
		
		templateId = 0;
		
		light = NULL;
		//toggleState = 0;
		//maxToggleStates = 2;
		toggled = false;
		visible = true;
	}
	
	

	void initBounds(
		int _buildingType,
		int alignBottomMiddleTop,

		float _zOffset,

		FIVector4 *p1,
		FIVector4 *p2,
		FIVector4 *rad,
		FIVector4 *_cornerDisInPixels,
		FIVector4 *_visInsetFromMin,
		FIVector4 *_visInsetFromMax,
		FIVector4 *_powerVals,
		FIVector4 *_powerVals2,
		FIVector4 *_thickVals,
		FIVector4 *_matParams,
		FIVector4 *_anchorPoint,
		int _minRot,
		int _maxRot

	) {
		buildingType = _buildingType;
		float temp;
		float zOffset = _zOffset;
		
		

		curRot = 0;
		rotDir = 1;
		hasAnchor = false;

		anchorPointInPixels.setFXYZ(0.0f, 0.0f, 0.0f);


		boundsMinInPixels.setFXYZRef(p1);
		boundsMaxInPixels.setFXYZRef(p2);

		FIVector4::normalizeBounds(&boundsMinInPixels, &boundsMaxInPixels);




		boundsMinInPixels.addXYZRef(rad, -1.0f);
		boundsMaxInPixels.addXYZRef(rad, 1.0f);

		switch (alignBottomMiddleTop) {

		case E_ALIGN_BOTTOM: // bottom _$_
			zOffset += (rad->getFZ() - _visInsetFromMin->getFZ());
			break;
		case E_ALIGN_MIDDLE: // middle -$-
			zOffset += 0.0f;
			break;
			//               ___
		case E_ALIGN_TOP: // top  $
			zOffset += -(rad->getFZ() - _visInsetFromMax->getFZ());
			break;


		}

		boundsMinInPixels.addXYZ(0.0f, 0.0f, zOffset);
		boundsMaxInPixels.addXYZ(0.0f, 0.0f, zOffset);


		visMinInPixels.setFXYZRef(&boundsMinInPixels);
		visMaxInPixels.setFXYZRef(&boundsMaxInPixels);

		visMinInPixels.addXYZRef(_visInsetFromMin, 1.0f);
		visMaxInPixels.addXYZRef(_visInsetFromMax, -1.0f);

		geomParams[E_GP_CORNERDISINPIXELS].setFXYZRef(_cornerDisInPixels);
		geomParams[E_GP_POWERVALS].setFXYZRef(_powerVals);
		geomParams[E_GP_POWERVALS2].setFXYZRef(_powerVals2);
		geomParams[E_GP_THICKVALS].setFXYZRef(_thickVals);
		geomParams[E_GP_MATPARAMS].setFXYZRef(_matParams);

		moveMinInPixels.setFXYZRef(&boundsMinInPixels);
		moveMaxInPixels.setFXYZRef(&boundsMaxInPixels);

		geomParams[E_GP_BOUNDSMININPIXELST].setFXYZRef(&boundsMinInPixels);
		geomParams[E_GP_BOUNDSMAXINPIXELST].setFXYZRef(&boundsMaxInPixels);
		geomParams[E_CP_VISMININPIXELST].setFXYZRef(&visMinInPixels);
		geomParams[E_CP_VISMAXINPIXELST].setFXYZRef(&visMaxInPixels);


		if (_minRot != _maxRot) {
			initAnchorPoint(_anchorPoint, _minRot, _maxRot);
		}

	}


	void initLines(
		int _buildingType,
		float scale,
		
		FIVector4 *_offset,

		FIVector4 *_orgVec,
		FIVector4 *_tanVec, // already scaled
		FIVector4 *_bitVec,
		FIVector4 *_norVec,
		FIVector4 *_radVec0,
		FIVector4 *_radVec1,
		//FIVector4 *_radVecScale0,
		//FIVector4 *_radVecScale1,
		FIVector4 *_matParams



	) {
		buildingType = _buildingType;
		float temp;
		float radMax;
		
		

		curRot = 0;
		rotDir = 1;
		hasAnchor = false;

		anchorPointInPixels.setFXYZ(0.0f, 0.0f, 0.0f);

		tempVec1.setFXYZRef(_orgVec);
		tempVec2.setFXYZRef(_radVec0);
		tempVec3.setFXYZRef(_radVec1);
		
		//tempVec2.multXYZ(_radVecScale0);
		//tempVec3.multXYZ(_radVecScale1);
		
		tempVec1.multXYZ(scale);
		tempVec2.multXYZ(scale);
		tempVec3.multXYZ(scale);
		
		tempVec1.addXYZRef(_offset);
		

		boundsMinInPixels.setFXYZRef(&tempVec1);
		boundsMaxInPixels.setFXYZRef(&tempVec1);
		
		tempVec4.copyFrom(_tanVec);
		tempVec5.copyFrom(_tanVec);
		tempVec4.multXYZ(-_radVec0->getFX()*scale);
		tempVec5.multXYZ(_radVec1->getFX()*scale);
		
		boundsMinInPixels.addXYZRef(&tempVec4);
		boundsMaxInPixels.addXYZRef(&tempVec5);
		
		FIVector4::normalizeBounds(&boundsMinInPixels, &boundsMaxInPixels);

		radMax = max(
			max(
				max(tempVec2[0], tempVec2[1]),
				max(tempVec3[0], tempVec3[1])
			),
			max(tempVec2[2], tempVec3[2])
		);
		
		boundsMinInPixels.addXYZ(-radMax);
		boundsMaxInPixels.addXYZ(radMax);

		visMinInPixels.setFXYZRef(&boundsMinInPixels);
		visMaxInPixels.setFXYZRef(&boundsMaxInPixels);

		moveMinInPixels.setFXYZRef(&boundsMinInPixels);
		moveMaxInPixels.setFXYZRef(&boundsMaxInPixels);




		geomParams[E_AP_ORG].setFXYZRef(&tempVec1);
		geomParams[E_AP_TAN].setFXYZRef(_tanVec);
		geomParams[E_AP_BIT].setFXYZRef(_bitVec);
		geomParams[E_AP_NOR].setFXYZRef(_norVec);
		geomParams[E_AP_RAD0].setFXYZRef(&tempVec2);
		geomParams[E_AP_RAD1].setFXYZRef(&tempVec3);
		geomParams[E_AP_MATPARAMS].setFXYZRef(_matParams);
		geomParams[E_CP_VISMININPIXELST].setFXYZRef(&visMinInPixels);
		geomParams[E_CP_VISMAXINPIXELST].setFXYZRef(&visMaxInPixels);


	}


	void initTree(
		int _buildingType,

		// p0, p1 = start, end
		// p2 = control point or tangent

		FIVector4 *p0,
		FIVector4 *p1,
		FIVector4 *p2,

		float radP0,
		float radP1,
		float sphereRad,

		FIVector4 *_matParams



	) {
		buildingType = _buildingType;
		float temp;

		float radMax = max(max(radP0, radP1), sphereRad);

		curRot = 0;
		rotDir = 1;
		hasAnchor = false;

		anchorPointInPixels.setFXYZ(0.0f, 0.0f, 0.0f);


		boundsMinInPixels.setFXYZRef(p0);
		boundsMaxInPixels.setFXYZRef(p1);

		//boundsMinInPixels.addXYZ(-radMax);
		//boundsMaxInPixels.addXYZ(radMax);

		FIVector4::normalizeBounds(&boundsMinInPixels, &boundsMaxInPixels);

		FIVector4::growBoundary(&boundsMinInPixels, &boundsMaxInPixels, p2, p2);

		boundsMinInPixels.addXYZ(-radMax);
		boundsMaxInPixels.addXYZ(radMax);



		visMinInPixels.setFXYZRef(&boundsMinInPixels);
		visMaxInPixels.setFXYZRef(&boundsMaxInPixels);


		geomParams[E_TP_P0].setFXYZRef(p0);
		geomParams[E_TP_P1].setFXYZRef(p1);
		geomParams[E_TP_P2].setFXYZRef(p2);
		geomParams[E_TP_THICKVALS].setFXYZ(radP0, radP1, sphereRad);

		geomParams[E_TP_MATPARAMS].setFXYZRef(_matParams);

		moveMinInPixels.setFXYZRef(&boundsMinInPixels);
		moveMaxInPixels.setFXYZRef(&boundsMaxInPixels);
		geomParams[E_CP_VISMININPIXELST].setFXYZRef(&visMinInPixels);
		geomParams[E_CP_VISMAXINPIXELST].setFXYZRef(&visMaxInPixels);


	}

	void toggle() {
		// toggleState++;
		// cout << "toggleState " << toggleState << "\n";
		// if (toggleState >= maxToggleStates) {
		// 	toggleState = 0;
		// }
		// cout << "toggleState " << toggleState << "\n";
		
		toggled = !toggled;
	}

	void toggleTransform() {
		toggle();
		applyTransform(rotDir, false);
	}

	void applyTransform(int rotMod, bool ignoreConstraints) {

		rotate(rotMod, ignoreConstraints);

		geomParams[E_GP_BOUNDSMININPIXELST].setFXYZRef(&boundsMinInPixels);
		geomParams[E_GP_BOUNDSMAXINPIXELST].setFXYZRef(&boundsMaxInPixels);
		geomParams[E_CP_VISMININPIXELST].setFXYZRef(&visMinInPixels);
		geomParams[E_CP_VISMAXINPIXELST].setFXYZRef(&visMaxInPixels);

		geomParams[E_GP_BOUNDSMININPIXELST].addXYZRef(&anchorPointInPixels, -1.0f);
		geomParams[E_GP_BOUNDSMAXINPIXELST].addXYZRef(&anchorPointInPixels, -1.0f);
		geomParams[E_CP_VISMININPIXELST].addXYZRef(&anchorPointInPixels, -1.0f);
		geomParams[E_CP_VISMAXINPIXELST].addXYZRef(&anchorPointInPixels, -1.0f);

		geomParams[E_GP_BOUNDSMININPIXELST].rotate90(getClampedRot());
		geomParams[E_GP_BOUNDSMAXINPIXELST].rotate90(getClampedRot());
		geomParams[E_CP_VISMININPIXELST].rotate90(getClampedRot());
		geomParams[E_CP_VISMAXINPIXELST].rotate90(getClampedRot());

		geomParams[E_GP_BOUNDSMININPIXELST].addXYZRef(&anchorPointInPixels, 1.0f);
		geomParams[E_GP_BOUNDSMAXINPIXELST].addXYZRef(&anchorPointInPixels, 1.0f);
		geomParams[E_CP_VISMININPIXELST].addXYZRef(&anchorPointInPixels, 1.0f);
		geomParams[E_CP_VISMAXINPIXELST].addXYZRef(&anchorPointInPixels, 1.0f);

		FIVector4::normalizeBounds(&geomParams[E_GP_BOUNDSMININPIXELST], &geomParams[E_GP_BOUNDSMAXINPIXELST]);
		FIVector4::normalizeBounds(&geomParams[E_CP_VISMININPIXELST], &geomParams[E_CP_VISMAXINPIXELST]);

		FIVector4::growBoundary(&moveMinInPixels, &moveMaxInPixels, &geomParams[E_CP_VISMININPIXELST], &geomParams[E_CP_VISMAXINPIXELST]);
	}

	void initAnchorPoint(FIVector4 *_anchorPointInPixels, int _minRot, int _maxRot) {

		int i;


		hasAnchor = true;
		anchorPointInPixels.setFXYZRef(_anchorPointInPixels);
		minRot = _minRot;
		maxRot = _maxRot;

		for (i = 0; i < 4; i++) {
			applyTransform(1, true);
		}

	}
	
	
	
	
	
	
	
	
	
	
};

struct EntVec {
	std::vector<GameEnt> data;	
};



class EntSelection {
public:
	int selEntListInd;
	std::vector<GameEnt *> selEntList;
	std::map<intPair, int> selEntMap;
	
	EntSelection() {
		selEntListInd = 0;
	}
	
	GameEnt* getSelectedEnt() {
		if (selEntList.size() > 0) {
			return selEntList[selEntListInd];
		}
		else {
			return NULL;
		}
	}
	
	void cycleEnts() {
		selEntListInd++;
		if (selEntListInd >= selEntList.size()) {
			selEntListInd = 0;
		}
	}
};



class DynObject {

public:

	FIVector4 pos;
	FIVector4 color;
	FIVector4 posRel;
	FIVector4 posTrackball;

	int r;
	int g;
	int b;

	//bool isTrackball;
	//bool isRelative;
	int moveType;
	bool doRender;
	bool firstRun;

	float radius;
	float lightRadius;

	GameEnt childLight;


	DynObject() {
		firstRun = true;
	}

	GameEnt *getLight() {
		
		if (firstRun) {
			childLight.toggled = true;
			firstRun = false;
		}
		childLight.initLight(
			&pos,
			&color,
			lightRadius
		);
		
		
		return &childLight;
	}

	void init(
		int _x, int _y, int _z,
		int _r, int _g, int _b,
		bool _doRender, int _moveType,//bool _isRelative, bool _isTrackball,
		FIVector4 *_cameraPos,
		float _radius,
		float _lightRadius=0.0f
	) {
		//isRelative = _isRelative;
		//isTrackball = _isTrackball;
		doRender = _doRender;
		moveType = _moveType;
		
		lightRadius = _lightRadius;

		if (moveType == E_MT_RELATIVE) {
			posRel.setIXYZ(_x, _y, _z);
			pos.setFXYZRef(_cameraPos);
			pos.addXYZRef(&posRel);
		}
		else {
			pos.setIXYZ(_x, _y, _z);
			posRel.setIXYZ(0, 0, 0);
		}

		radius = _radius;

		r = _r;
		g = _g;
		b = _b;

		color.setFXYZ(
			((float)r),
			((float)g),
			((float)b)
		);

		
	}


};

 


enum JSONType { JSONType_Null, JSONType_String, JSONType_Bool, JSONType_Number, JSONType_Array, JSONType_Object };

class JSONValue;

typedef std::vector<JSONValue*> JSONArray;
typedef std::map<std::string, JSONValue*> JSONObject;
typedef std::map<std::string, JSONValue*>::iterator joi_type;

class JSONValue
{
	
	public:
		JSONValue(/*NULL*/);
		JSONValue(const char *m_char_value);
		JSONValue(const std::string &m_string_value);
		JSONValue(bool m_bool_value);
		JSONValue(double m_number_value);
		JSONValue(const JSONArray &m_array_value);
		JSONValue(const JSONObject &m_object_value);
		~JSONValue();

		bool IsNull() const;
		bool IsString() const;
		bool IsBool() const;
		bool IsNumber() const;
		bool IsArray() const;
		bool IsObject() const;
		
		const std::string &AsString() const;
		bool AsBool() const;
		double AsNumber() const;
		const JSONArray &AsArray() const;
		const JSONObject &AsObject() const;

		int CountChildren() const;
		
		bool HasChild(int index) const;
		JSONValue *Child(int index);
		
		bool HasChild(const char* name) const;
		JSONValue *Child(const char* name);
		
		bool HasChild(string name) const;
		JSONValue *Child(string name);

		std::string Stringify(int curLev) const;

		static JSONValue *Parse(const char **data);

		static std::string StringifyString(const std::string &str);
	
		//JSONValue* insertValue(string name, JSONValue* val);
	
		JSONType type;
		std::string string_value;
		bool bool_value;
		double number_value;
		JSONArray array_value;
		JSONObject object_value;
		string lastKey;
};



class JSON
{
	
	public:
		static JSONValue* Parse(const char *data);
		static std::string Stringify(const JSONValue *value);

		static bool SkipWhitespace(const char **data);
		static bool ExtractString(const char **data, std::string &str);
		static double ParseInt(const char **data);
		static double ParseDecimal(const char **data);

		JSON();
};




// Macros to free an array/object
#define FREE_ARRAY(x) { JSONArray::iterator iter; for (iter = x.begin(); iter != x.end(); iter++) { delete *iter; } }
#define FREE_OBJECT(x) { JSONObject::iterator iter; for (iter = x.begin(); iter != x.end(); iter++) { delete (*iter).second; } }


// JSONValue* JSONValue::insertValue(string name, JSONValue* value) {
// 	if (object_value.find(name) != object_value.end()) {
// 		delete object_value[name];
// 	}

// 	if (value == NULL) {
// 		cout << name << " parsed to NULL\n";
// 	}
// 	object_value[name] = value;
// 	return object_value[name];
// }


/**
 * Parses a JSON encoded value to a JSONValue object
 *
 * @access protected
 *
 * @param char** data Pointer to a char* that contains the data
 *
 * @return JSONValue* Returns a pointer to a JSONValue object on success, NULL on error
 */
JSONValue *JSONValue::Parse(const char **data)
{
	// Is it a string?
	if (**data == '"')
	{
		std::string str;
		if (!JSON::ExtractString(&(++(*data)), str))
			return NULL;
		else
			return new JSONValue(str);
	}
	
	// Is it a boolean?
	else if ((simplejson_wcsnlen(*data, 4) && newcasecmp(*data, "true", 4) == 0) || (simplejson_wcsnlen(*data, 5) && newcasecmp(*data, "false", 5) == 0))
	{
		bool value = newcasecmp(*data, "true", 4) == 0;
		(*data) += value ? 4 : 5;
		return new JSONValue(value);
	}
	
	// Is it a null?
	else if (simplejson_wcsnlen(*data, 4) && newcasecmp(*data, "null", 4) == 0)
	{
		(*data) += 4;
		return new JSONValue();
	}
	
	// Is it a number?
	else if (**data == '-' || (**data >= '0' && **data <= '9'))
	{
		// Negative?
		bool neg = **data == '-';
		if (neg) (*data)++;

		double number = 0.0;

		// Parse the whole part of the number - only if it wasn't 0
		if (**data == '0')
			(*data)++;
		else if (**data >= '1' && **data <= '9')
			number = JSON::ParseInt(data);
		else
			return NULL;
		
		// Could be a decimal now...
		if (**data == '.')
		{
			(*data)++;

			// Not get any digits?
			if (!(**data >= '0' && **data <= '9'))
				return NULL;
			
			// Find the decimal and sort the decimal place out
			// Use ParseDecimal as ParseInt won't work with decimals less than 0.1
			// thanks to Javier Abadia for the report & fix
			double decimal = JSON::ParseDecimal(data);
			
			// Save the number
			number += decimal;
		}

		// Could be an exponent now...
		if (**data == 'E' || **data == 'e')
		{
			(*data)++;

			// Check signage of expo
			bool neg_expo = false;
			if (**data == '-' || **data == '+')
			{
				neg_expo = **data == '-';
				(*data)++;
			}
			
			// Not get any digits?
			if (!(**data >= '0' && **data <= '9'))
				return NULL;

			// Sort the expo out
			double expo = JSON::ParseInt(data);
			for (double i = 0.0; i < expo; i++)
				number = neg_expo ? (number / 10.0) : (number * 10.0);
		}

		// Was it neg?
		if (neg) number *= -1;

		return new JSONValue(number);
	}

	// An object?
	else if (**data == '{')
	{
		JSONObject object;
		
		(*data)++;
	
		while (**data != 0)
		{
			// Whitespace at the start?
			if (!JSON::SkipWhitespace(data))
			{
				FREE_OBJECT(object);
				return NULL;
			}
			
			// Special case - empty object
			if (object.size() == 0 && **data == '}')
			{
				(*data)++;
				return new JSONValue(object);
			}
			
			// We want a string now...
			std::string name;
			if (!JSON::ExtractString(&(++(*data)), name))
			{
				FREE_OBJECT(object);
				return NULL;
			}
			
			// More whitespace?
			if (!JSON::SkipWhitespace(data))
			{
				FREE_OBJECT(object);
				return NULL;
			}
			
			// Need a : now
			if (*((*data)++) != ':')
			{
				FREE_OBJECT(object);
				return NULL;
			}
			
			// More whitespace?
			if (!JSON::SkipWhitespace(data))
			{
				FREE_OBJECT(object);
				return NULL;
			}
			
			// The value is here
			JSONValue *value = Parse(data);
			if (value == NULL)
			{
				FREE_OBJECT(object);
				return NULL;
			}
			
			// Add the name:value
			if (object.find(name) != object.end())
				delete object[name];
			object[name] = value;
			
			// More whitespace?
			if (!JSON::SkipWhitespace(data))
			{
				FREE_OBJECT(object);
				return NULL;
			}
			
			// End of object?
			if (**data == '}')
			{
				(*data)++;
				return new JSONValue(object);
			}
			
			// Want a , now
			if (**data != ',')
			{
				FREE_OBJECT(object);
				return NULL;
			}
			
			(*data)++;
		}
		
		// Only here if we ran out of data
		FREE_OBJECT(object);
		return NULL;
	}
	
	// An array?
	else if (**data == '[')
	{
		JSONArray array;
		
		(*data)++;
		
		while (**data != 0)
		{
			// Whitespace at the start?
			if (!JSON::SkipWhitespace(data))
			{
				FREE_ARRAY(array);
				return NULL;
			}
			
			// Special case - empty array
			if (array.size() == 0 && **data == ']')
			{
				(*data)++;
				return new JSONValue(array);
			}
			
			// Get the value
			JSONValue *value = Parse(data);
			if (value == NULL)
			{
				FREE_ARRAY(array);
				return NULL;
			}
			
			// Add the value
			array.push_back(value);
			
			// More whitespace?
			if (!JSON::SkipWhitespace(data))
			{
				FREE_ARRAY(array);
				return NULL;
			}
			
			// End of array?
			if (**data == ']')
			{
				(*data)++;
				return new JSONValue(array);
			}
			
			// Want a , now
			if (**data != ',')
			{
				FREE_ARRAY(array);
				return NULL;
			}
			
			(*data)++;
		}
		
		// Only here if we ran out of data
		FREE_ARRAY(array);
		return NULL;
	}
	
	// Ran out of possibilites, it's bad!
	else
	{
		return NULL;
	}
}

/**
 * Basic constructor for creating a JSON Value of type NULL
 *
 * @access public
 */
JSONValue::JSONValue(/*NULL*/)
{
	type = JSONType_Null;
}

/**
 * Basic constructor for creating a JSON Value of type String
 *
 * @access public
 *
 * @param char* m_char_value The string to use as the value
 */
JSONValue::JSONValue(const char *m_char_value)
{
	type = JSONType_String;
	string_value = std::string(m_char_value);
}

/**
 * Basic constructor for creating a JSON Value of type String
 *
 * @access public
 *
 * @param std::string m_string_value The string to use as the value
 */
JSONValue::JSONValue(const std::string &m_string_value)
{
	type = JSONType_String;
	string_value = m_string_value;
}

/**
 * Basic constructor for creating a JSON Value of type Bool
 *
 * @access public
 *
 * @param bool m_bool_value The bool to use as the value
 */
JSONValue::JSONValue(bool m_bool_value)
{
	type = JSONType_Bool;
	bool_value = m_bool_value;
}

/**
 * Basic constructor for creating a JSON Value of type Number
 *
 * @access public
 *
 * @param double m_number_value The number to use as the value
 */
JSONValue::JSONValue(double m_number_value)
{
	type = JSONType_Number;
	number_value = m_number_value;
}

/**
 * Basic constructor for creating a JSON Value of type Array
 *
 * @access public
 *
 * @param JSONArray m_array_value The JSONArray to use as the value
 */
JSONValue::JSONValue(const JSONArray &m_array_value)
{
	type = JSONType_Array;
	array_value = m_array_value;
}

/**
 * Basic constructor for creating a JSON Value of type Object
 *
 * @access public
 *
 * @param JSONObject m_object_value The JSONObject to use as the value
 */
JSONValue::JSONValue(const JSONObject &m_object_value)
{
	type = JSONType_Object;
	object_value = m_object_value;
}

/**
 * The destructor for the JSON Value object
 * Handles deleting the objects in the array or the object value
 *
 * @access public
 */
JSONValue::~JSONValue()
{
	if (type == JSONType_Array)
	{
		JSONArray::iterator iter;
		for (iter = array_value.begin(); iter != array_value.end(); iter++)
			delete *iter;
	}
	else if (type == JSONType_Object)
	{
		JSONObject::iterator iter;
		for (iter = object_value.begin(); iter != object_value.end(); iter++)
		{
			delete (*iter).second;
		}
	}
}

/**
 * Checks if the value is a NULL
 *
 * @access public
 *
 * @return bool Returns true if it is a NULL value, false otherwise
 */
bool JSONValue::IsNull() const
{
	return type == JSONType_Null;
}

/**
 * Checks if the value is a String
 *
 * @access public
 *
 * @return bool Returns true if it is a String value, false otherwise
 */
bool JSONValue::IsString() const
{
	return type == JSONType_String;
}

/**
 * Checks if the value is a Bool
 *
 * @access public
 *
 * @return bool Returns true if it is a Bool value, false otherwise
 */
bool JSONValue::IsBool() const
{
	return type == JSONType_Bool;
}

/**
 * Checks if the value is a Number
 *
 * @access public
 *
 * @return bool Returns true if it is a Number value, false otherwise
 */
bool JSONValue::IsNumber() const
{
	return type == JSONType_Number;
}

/**
 * Checks if the value is an Array
 *
 * @access public
 *
 * @return bool Returns true if it is an Array value, false otherwise
 */
bool JSONValue::IsArray() const
{
	return type == JSONType_Array;
}

/**
 * Checks if the value is an Object
 *
 * @access public
 *
 * @return bool Returns true if it is an Object value, false otherwise
 */
bool JSONValue::IsObject() const
{
	return type == JSONType_Object;
}

/**
 * Retrieves the String value of this JSONValue
 * Use IsString() before using this method.
 *
 * @access public
 *
 * @return std::string Returns the string value
 */
const std::string &JSONValue::AsString() const
{
	return string_value;
}

/**
 * Retrieves the Bool value of this JSONValue
 * Use IsBool() before using this method.
 *
 * @access public
 *
 * @return bool Returns the bool value
 */
bool JSONValue::AsBool() const
{
	return bool_value;
}

/**
 * Retrieves the Number value of this JSONValue
 * Use IsNumber() before using this method.
 *
 * @access public
 *
 * @return double Returns the number value
 */
double JSONValue::AsNumber() const
{
	return number_value;
}

/**
 * Retrieves the Array value of this JSONValue
 * Use IsArray() before using this method.
 *
 * @access public
 *
 * @return JSONArray Returns the array value
 */
const JSONArray &JSONValue::AsArray() const
{
	return array_value;
}

/**
 * Retrieves the Object value of this JSONValue
 * Use IsObject() before using this method.
 *
 * @access public
 *
 * @return JSONObject Returns the object value
 */
const JSONObject &JSONValue::AsObject() const
{
	return object_value;
}

/**
 * Retrieves the number of children of this JSONValue.
 * This number will be 0 or the actual number of children
 * if IsArray() or IsObject().
 *
 * @access public
 *
 * @return The number of children.
 */
int JSONValue::CountChildren() const
{
	switch (type)
	{
		case JSONType_Array:
			return array_value.size();
		case JSONType_Object:
			return object_value.size();
		default:
			return 0;
	}
}

/**
 * Checks if this JSONValue has a child at the given index.
 * Use IsArray() before using this method.
 *
 * @access public
 *
 * @return bool Returns true if the array has a value at the given index.
 */
bool JSONValue::HasChild(int index) const
{
	if (type == JSONType_Array)
	{
		return index < array_value.size();
	}
	else
	{
		return false;
	}
}

/**
 * Retrieves the child of this JSONValue at the given index.
 * Use IsArray() before using this method.
 *
 * @access public
 *
 * @return JSONValue* Returns JSONValue at the given index or NULL
 *                    if it doesn't exist.
 */
JSONValue *JSONValue::Child(int index)
{
	
	int count = 0;
	
	switch (type)
	{
		case JSONType_Array:
			if (index < array_value.size()) {
				return array_value[index];
			}
			else {
				return NULL;
			}
		break;
		case JSONType_Object:
			
			for (joi_type iterator = object_value.begin(); iterator != object_value.end(); iterator++) {
			    // iterator->first = key
			    // iterator->second = value
			    
			    if (count == index) {
			    	lastKey = iterator->first;
			    	return iterator->second;
			    }
			    
			    count++;
			    
			}
			return NULL;
		break;
		default:
			return NULL;
		break;
	}
	
	
	
	
}

/**
 * Checks if this JSONValue has a child at the given key.
 * Use IsObject() before using this method.
 *
 * @access public
 *
 * @return bool Returns true if the object has a value at the given key.
 */
bool JSONValue::HasChild(const char* name) const
{
	if (type == JSONType_Object)
	{
		return object_value.find(name) != object_value.end();
	}
	else
	{
		return false;
	}
}

bool JSONValue::HasChild(string name) const
{
	if (type == JSONType_Object)
	{
		return object_value.find(name.c_str()) != object_value.end();
	}
	else
	{
		return false;
	}
}

/**
 * Retrieves the child of this JSONValue at the given key.
 * Use IsObject() before using this method.
 *
 * @access public
 *
 * @return JSONValue* Returns JSONValue for the given key in the object
 *                    or NULL if it doesn't exist.
 */
JSONValue* JSONValue::Child(const char* name)
{
	JSONObject::const_iterator it = object_value.find(name);
	if (it != object_value.end())
	{
		return it->second;
	}
	else
	{
		return NULL;
	}
}

JSONValue* JSONValue::Child(string name)
{
	JSONObject::const_iterator it = object_value.find(name.c_str());
	if (it != object_value.end())
	{
		return it->second;
	}
	else
	{
		return NULL;
	}
}

/**
 * Creates a JSON encoded string for the value with all necessary characters escaped
 *
 * @access public
 *
 * @return std::string Returns the JSON string
 */
std::string JSONValue::Stringify(int curLev = 0) const
{
	std::string ret_string;
	
	switch (type)
	{
		case JSONType_Null:
			ret_string = "null";
			break;
		
		case JSONType_String:
			ret_string = StringifyString(string_value);
			break;
		
		case JSONType_Bool:
			ret_string = bool_value ? "true" : "false";
			break;
		
		case JSONType_Number:
		{
			if (isinf(number_value) || isnan(number_value))
				ret_string = "null";
			else
			{
				std::stringstream ss;
				ss.precision(15);
				ss << number_value;
				ret_string = ss.str();
			}
			break;
		}
		
		case JSONType_Array:
		{
			ret_string = "[";
			JSONArray::const_iterator iter = array_value.begin();
			while (iter != array_value.end())
			{
				//ret_string += SPACE_BUFFER[curLev];
				ret_string += (*iter)->Stringify(curLev + 1);
				
				// Not at the end - add a separator
				if (++iter != array_value.end()) {
					ret_string += ",";
				}
				else {
					//ret_string += "\n";
				}
			}
			ret_string += "]"; //SPACE_BUFFER[curLev]+
			break;
		}
		
		case JSONType_Object:
		{
			ret_string = "{\n";
			JSONObject::const_iterator iter = object_value.begin();
			while (iter != object_value.end())
			{
				ret_string += SPACE_BUFFER[curLev];
				ret_string += StringifyString((*iter).first);
				ret_string += ":";
				ret_string += (*iter).second->Stringify(curLev+1);
				
				// Not at the end - add a separator
				if (++iter != object_value.end()) {
					ret_string += ",\n";
				}
				else {
					ret_string += "\n";
				}
			}
			ret_string += SPACE_BUFFER[curLev]+"}";
			break;
		}
	}

	return ret_string;
}

/**
 * Creates a JSON encoded string with all required fields escaped
 * Works from http://www.ecma-internationl.org/publications/files/ECMA-ST/ECMA-262.pdf
 * Section 15.12.3.
 *
 * @access private
 *
 * @param std::string str The string that needs to have the characters escaped
 *
 * @return std::string Returns the JSON string
 */
std::string JSONValue::StringifyString(const std::string &str)
{
	std::string str_out = "\"";
	str_out += str;
	
	// std::string::const_iterator iter = str.begin();
	// while (iter != str.end())
	// {
	// 	char chr = *iter;

	// 	if (chr == '"' || chr == '\\' || chr == '/')
	// 	{
	// 		str_out += '\\';
	// 		str_out += chr;
	// 	}
	// 	else if (chr == '\b')
	// 	{
	// 		str_out += "\\b";
	// 	}
	// 	else if (chr == '\f')
	// 	{
	// 		str_out += "\\f";
	// 	}
	// 	else if (chr == '\n')
	// 	{
	// 		str_out += "\\n";
	// 	}
	// 	else if (chr == '\r')
	// 	{
	// 		str_out += "\\r";
	// 	}
	// 	else if (chr == '\t')
	// 	{
	// 		str_out += "\\t";
	// 	}
	// 	else if (chr < ' ')
	// 	{
	// 		str_out += "\\u";
	// 		for (int i = 0; i < 4; i++)
	// 		{
	// 			int value = (chr >> 12) & 0xf;
	// 			if (value >= 0 && value <= 9)
	// 				str_out += (char)('0' + value);
	// 			else if (value >= 10 && value <= 15)
	// 				str_out += (char)('A' + (value - 10));
	// 			chr <<= 4;
	// 		}
	// 	}
	// 	else
	// 	{
	// 		str_out += chr;
	// 	}
		
	// 	iter++;
	// }
	
	
	str_out += "\"";
	return str_out;
}



JSON::JSON()
{
}

/**
 * Parses a complete JSON encoded string (UNICODE input version)
 *
 * @access public
 *
 * @param char* data The JSON text
 *
 * @return JSONValue* Returns a JSON Value representing the root, or NULL on error
 */
JSONValue *JSON::Parse(const char *data)
{
	// Skip any preceding whitespace, end of data = no JSON = fail
	if (!SkipWhitespace(&data)) {
		//cout << "jp a\n";
		return NULL;
	}
	

	// We need the start of a value here now...
	JSONValue *value = JSONValue::Parse(&data);
	if (value == NULL) {
		//cout << "jp b\n";
		return NULL;
	}
	
	// Can be white space now and should be at the end of the string then...
	// if (SkipWhitespace(&data))
	// {
		
	// 	cout << "jp c\n";
	// 	delete value;
	// 	return NULL;
	// }
	
	
	//cout << "jp d\n";
	
	// We're now at the end of the string
	return value;
}

/**
 * Turns the passed in JSONValue into a JSON encode string
 *
 * @access public
 *
 * @param JSONValue* value The root value
 *
 * @return std::string Returns a JSON encoded string representation of the given value
 */
std::string JSON::Stringify(const JSONValue *value)
{
	if (value != NULL)
		return value->Stringify();
	else
		return "";
}

/**
 * Skips over any whitespace characters (space, tab, \r or \n) defined by the JSON spec
 *
 * @access protected
 *
 * @param char** data Pointer to a char* that contains the JSON text
 *
 * @return bool Returns true if there is more data, or false if the end of the text was reached
 */
bool JSON::SkipWhitespace(const char **data)
{
	while (**data != 0 && (**data == ' ' || **data == '\t' || **data == '\r' || **data == '\n'))
		(*data)++;
	
	return **data != 0;
}

/**
 * Extracts a JSON String as defined by the spec - "<some chars>"
 * Any escaped characters are swapped out for their unescaped values
 *
 * @access protected
 *
 * @param char** data Pointer to a char* that contains the JSON text
 * @param std::string& str Reference to a std::string to receive the extracted string
 *
 * @return bool Returns true on success, false on failure
 */
bool JSON::ExtractString(const char **data, std::string &str)
{
	str = "";
	
	while (**data != 0)
	{
		// Save the char so we can change it if need be
		char next_char = **data;
		
		// Escaping something?
		if (next_char == '\\')
		{
			// Move over the escape char
			(*data)++;
			
			// Deal with the escaped char
			switch (**data)
			{
				case '"': next_char = '"'; break;
				case '\\': next_char = '\\'; break;
				case '/': next_char = '/'; break;
				case 'b': next_char = '\b'; break;
				case 'f': next_char = '\f'; break;
				case 'n': next_char = '\n'; break;
				case 'r': next_char = '\r'; break;
				case 't': next_char = '\t'; break;
				case 'u':
				{
					// We need 5 chars (4 hex + the 'u') or its not valid
					if (!simplejson_wcsnlen(*data, 5))
						return false;
					
					// Deal with the chars
					next_char = 0;
					for (int i = 0; i < 4; i++)
					{
						// Do it first to move off the 'u' and leave us on the
						// final hex digit as we move on by one later on
						(*data)++;
						
						next_char <<= 4;
						
						// Parse the hex digit
						if (**data >= '0' && **data <= '9')
							next_char |= (**data - '0');
						else if (**data >= 'A' && **data <= 'F')
							next_char |= (10 + (**data - 'A'));
						else if (**data >= 'a' && **data <= 'f')
							next_char |= (10 + (**data - 'a'));
						else
						{
							// Invalid hex digit = invalid JSON
							return false;
						}
					}
					break;
				}
				
				// By the spec, only the above cases are allowed
				default:
					return false;
			}
		}
		
		// End of the string?
		else if (next_char == '"')
		{
			(*data)++;
			str.reserve(); // Remove unused capacity
			return true;
		}
		
		// Disallowed char?
		else if (next_char < ' ' && next_char != '\t')
		{
			// SPEC Violation: Allow tabs due to real world cases
			return false;
		}
		
		// Add the next char
		str += next_char;
		
		// Move on
		(*data)++;
	}
	
	// If we're here, the string ended incorrectly
	return false;
}

/**
 * Parses some text as though it is an integer
 *
 * @access protected
 *
 * @param char** data Pointer to a char* that contains the JSON text
 *
 * @return double Returns the double value of the number found
 */
double JSON::ParseInt(const char **data)
{
	double integer = 0;
	while (**data != 0 && **data >= '0' && **data <= '9')
		integer = integer * 10 + (*(*data)++ - '0');
	
	return integer;
}

/**
 * Parses some text as though it is a decimal
 *
 * @access protected
 *
 * @param char** data Pointer to a char* that contains the JSON text
 *
 * @return double Returns the double value of the decimal found
 */
double JSON::ParseDecimal(const char **data)
{
	double decimal = 0.0;
  double factor = 0.1;
	while (**data != 0 && **data >= '0' && **data <= '9')
  {
    int digit = (*(*data)++ - '0');
		decimal = decimal + digit * factor;
    factor *= 0.1;
  }
	return decimal;
}




 
/*
LodePNG version 20130831

Copyright (c) 2005-2013 Lode Vandevenne

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

    1. The origin of this software must not be misrepresented; you must not
    claim that you wrote the original software. If you use this software
    in a product, an acknowledgment in the product documentation would be
    appreciated but is not required.

    2. Altered source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.

    3. This notice may not be removed or altered from any source
    distribution.
*/

#ifndef LODEPNG_H
#define LODEPNG_H



/*
The following #defines are used to create code sections. They can be disabled
to disable code sections, which can give faster compile time and smaller binary.
The "NO_COMPILE" defines are designed to be used to pass as defines to the
compiler command to disable them without modifying this header, e.g.
-DLODEPNG_NO_COMPILE_ZLIB for gcc.
*/
/*deflate & zlib. If disabled, you must specify alternative zlib functions in
the custom_zlib field of the compress and decompress settings*/
#ifndef LODEPNG_NO_COMPILE_ZLIB
#define LODEPNG_COMPILE_ZLIB
#endif
/*png encoder and png decoder*/
#ifndef LODEPNG_NO_COMPILE_PNG
#define LODEPNG_COMPILE_PNG
#endif
/*deflate&zlib decoder and png decoder*/
#ifndef LODEPNG_NO_COMPILE_DECODER
#define LODEPNG_COMPILE_DECODER
#endif
/*deflate&zlib encoder and png encoder*/
#ifndef LODEPNG_NO_COMPILE_ENCODER
#define LODEPNG_COMPILE_ENCODER
#endif
/*the optional built in harddisk file loading and saving functions*/
#ifndef LODEPNG_NO_COMPILE_DISK
#define LODEPNG_COMPILE_DISK
#endif
/*support for chunks other than IHDR, IDAT, PLTE, tRNS, IEND: ancillary and unknown chunks*/
#ifndef LODEPNG_NO_COMPILE_ANCILLARY_CHUNKS
#define LODEPNG_COMPILE_ANCILLARY_CHUNKS
#endif
/*ability to convert error numerical codes to English text string*/
#ifndef LODEPNG_NO_COMPILE_ERROR_TEXT
#define LODEPNG_COMPILE_ERROR_TEXT
#endif
/*Compile the default allocators (C's free, malloc and realloc). If you disable this,
you can define the functions lodepng_free, lodepng_malloc and lodepng_realloc in your
source files with custom allocators.*/
#ifndef LODEPNG_NO_COMPILE_ALLOCATORS
#define LODEPNG_COMPILE_ALLOCATORS
#endif
/*compile the C++ version (you can disable the C++ wrapper here even when compiling for C++)*/

#define LODEPNG_NO_COMPILE_CPP

#ifdef LODEPNG_COMPILE_PNG
/*The PNG color types (also used for raw).*/
typedef enum LodePNGColorType
{
  LCT_GREY = 0, /*greyscale: 1,2,4,8,16 bit*/
  LCT_RGB = 2, /*RGB: 8,16 bit*/
  LCT_PALETTE = 3, /*palette: 1,2,4,8 bit*/
  LCT_GREY_ALPHA = 4, /*greyscale with alpha: 8,16 bit*/
  LCT_RGBA = 6 /*RGB with alpha: 8,16 bit*/
} LodePNGColorType;

#ifdef LODEPNG_COMPILE_DECODER
/*
Converts PNG data in memory to raw pixel data.
out: Output parameter. Pointer to buffer that will contain the raw pixel data.
     After decoding, its size is w * h * (bytes per pixel) bytes larger than
     initially. Bytes per pixel depends on colortype and bitdepth.
     Must be freed after usage with free(*out).
     Note: for 16-bit per channel colors, uses big endian format like PNG does.
w: Output parameter. Pointer to width of pixel data.
h: Output parameter. Pointer to height of pixel data.
in: Memory buffer with the PNG file.
insize: size of the in buffer.
colortype: the desired color type for the raw output image. See explanation on PNG color types.
bitdepth: the desired bit depth for the raw output image. See explanation on PNG color types.
Return value: LodePNG error code (0 means no error).
*/
unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h,
                               const unsigned char* in, size_t insize,
                               LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_decode_memory, but always decodes to 32-bit RGBA raw image*/
unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h,
                          const unsigned char* in, size_t insize);

/*Same as lodepng_decode_memory, but always decodes to 24-bit RGB raw image*/
unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h,
                          const unsigned char* in, size_t insize);

#ifdef LODEPNG_COMPILE_DISK
/*
Load PNG from disk, from file with given name.
Same as the other decode functions, but instead takes a filename as input.
*/
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h,
                             const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_decode_file, but always decodes to 32-bit RGBA raw image.*/
unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h,
                               const char* filename);

/*Same as lodepng_decode_file, but always decodes to 24-bit RGB raw image.*/
unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h,
                               const char* filename);
#endif /*LODEPNG_COMPILE_DISK*/
#endif /*LODEPNG_COMPILE_DECODER*/


#ifdef LODEPNG_COMPILE_ENCODER
/*
Converts raw pixel data into a PNG image in memory. The colortype and bitdepth
  of the output PNG image cannot be chosen, they are automatically determined
  by the colortype, bitdepth and content of the input pixel data.
  Note: for 16-bit per channel colors, needs big endian format like PNG does.
out: Output parameter. Pointer to buffer that will contain the PNG image data.
     Must be freed after usage with free(*out).
outsize: Output parameter. Pointer to the size in bytes of the out buffer.
image: The raw pixel data to encode. The size of this buffer should be
       w * h * (bytes per pixel), bytes per pixel depends on colortype and bitdepth.
w: width of the raw pixel data in pixels.
h: height of the raw pixel data in pixels.
colortype: the color type of the raw input image. See explanation on PNG color types.
bitdepth: the bit depth of the raw input image. See explanation on PNG color types.
Return value: LodePNG error code (0 means no error).
*/
unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize,
                               const unsigned char* image, unsigned w, unsigned h,
                               LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_encode_memory, but always encodes from 32-bit RGBA raw image.*/
unsigned lodepng_encode32(unsigned char** out, size_t* outsize,
                          const unsigned char* image, unsigned w, unsigned h);

/*Same as lodepng_encode_memory, but always encodes from 24-bit RGB raw image.*/
unsigned lodepng_encode24(unsigned char** out, size_t* outsize,
                          const unsigned char* image, unsigned w, unsigned h);

#ifdef LODEPNG_COMPILE_DISK
/*
Converts raw pixel data into a PNG file on disk.
Same as the other encode functions, but instead takes a filename as output.
NOTE: This overwrites existing files without warning!
*/
unsigned lodepng_encode_file(const char* filename,
                             const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth);

/*Same as lodepng_encode_file, but always encodes from 32-bit RGBA raw image.*/
unsigned lodepng_encode32_file(const char* filename,
                               const unsigned char* image, unsigned w, unsigned h);

/*Same as lodepng_encode_file, but always encodes from 24-bit RGB raw image.*/
unsigned lodepng_encode24_file(const char* filename,
                               const unsigned char* image, unsigned w, unsigned h);
#endif /*LODEPNG_COMPILE_DISK*/
#endif /*LODEPNG_COMPILE_ENCODER*/


#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*Returns an English description of the numerical error code.*/
const char* lodepng_error_text(unsigned code);
#endif /*LODEPNG_COMPILE_ERROR_TEXT*/

#ifdef LODEPNG_COMPILE_DECODER
/*Settings for zlib decompression*/
typedef struct LodePNGDecompressSettings LodePNGDecompressSettings;
struct LodePNGDecompressSettings
{
  unsigned ignore_adler32; /*if 1, continue and don't give an error message if the Adler32 checksum is corrupted*/

  /*use custom zlib decoder instead of built in one (default: null)*/
  unsigned (*custom_zlib)(unsigned char**, size_t*,
                          const unsigned char*, size_t,
                          const LodePNGDecompressSettings*);
  /*use custom deflate decoder instead of built in one (default: null)
  if custom_zlib is used, custom_deflate is ignored since only the built in
  zlib function will call custom_deflate*/
  unsigned (*custom_inflate)(unsigned char**, size_t*,
                             const unsigned char*, size_t,
                             const LodePNGDecompressSettings*);

  void* custom_context; /*optional custom settings for custom functions*/
};

extern const LodePNGDecompressSettings lodepng_default_decompress_settings;
void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*
Settings for zlib compression. Tweaking these settings tweaks the balance
between speed and compression ratio.
*/
typedef struct LodePNGCompressSettings LodePNGCompressSettings;
struct LodePNGCompressSettings /*deflate = compress*/
{
  /*LZ77 related settings*/
  unsigned btype; /*the block type for LZ (0, 1, 2 or 3, see zlib standard). Should be 2 for proper compression.*/
  unsigned use_lz77; /*whether or not to use LZ77. Should be 1 for proper compression.*/
  unsigned windowsize; /*the maximum is 32768, higher gives more compression but is slower. Typical value: 2048.*/
  unsigned minmatch; /*mininum lz77 length. 3 is normally best, 6 can be better for some PNGs. Default: 0*/
  unsigned nicematch; /*stop searching if >= this length found. Set to 258 for best compression. Default: 128*/
  unsigned lazymatching; /*use lazy matching: better compression but a bit slower. Default: true*/

  /*use custom zlib encoder instead of built in one (default: null)*/
  unsigned (*custom_zlib)(unsigned char**, size_t*,
                          const unsigned char*, size_t,
                          const LodePNGCompressSettings*);
  /*use custom deflate encoder instead of built in one (default: null)
  if custom_zlib is used, custom_deflate is ignored since only the built in
  zlib function will call custom_deflate*/
  unsigned (*custom_deflate)(unsigned char**, size_t*,
                             const unsigned char*, size_t,
                             const LodePNGCompressSettings*);

  void* custom_context; /*optional custom settings for custom functions*/
};

extern const LodePNGCompressSettings lodepng_default_compress_settings;
void lodepng_compress_settings_init(LodePNGCompressSettings* settings);
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_PNG
/*
Color mode of an image. Contains all information required to decode the pixel
bits to RGBA colors. This information is the same as used in the PNG file
format, and is used both for PNG and raw image data in LodePNG.
*/
typedef struct LodePNGColorMode
{
  /*header (IHDR)*/
  LodePNGColorType colortype; /*color type, see PNG standard or documentation further in this header file*/
  unsigned bitdepth;  /*bits per sample, see PNG standard or documentation further in this header file*/

  /*
  palette (PLTE and tRNS)

  Dynamically allocated with the colors of the palette, including alpha.
  When encoding a PNG, to store your colors in the palette of the LodePNGColorMode, first use
  lodepng_palette_clear, then for each color use lodepng_palette_add.
  If you encode an image without alpha with palette, don't forget to put value 255 in each A byte of the palette.

  When decoding, by default you can ignore this palette, since LodePNG already
  fills the palette colors in the pixels of the raw RGBA output.

  The palette is only supported for color type 3.
  */
  unsigned char* palette; /*palette in RGBARGBA... order. When allocated, must be either 0, or have size 1024*/
  size_t palettesize; /*palette size in number of colors (amount of bytes is 4 * palettesize)*/

  /*
  transparent color key (tRNS)

  This color uses the same bit depth as the bitdepth value in this struct, which can be 1-bit to 16-bit.
  For greyscale PNGs, r, g and b will all 3 be set to the same.

  When decoding, by default you can ignore this information, since LodePNG sets
  pixels with this key to transparent already in the raw RGBA output.

  The color key is only supported for color types 0 and 2.
  */
  unsigned key_defined; /*is a transparent color key given? 0 = false, 1 = true*/
  unsigned key_r;       /*red/greyscale component of color key*/
  unsigned key_g;       /*green component of color key*/
  unsigned key_b;       /*blue component of color key*/
} LodePNGColorMode;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_color_mode_init(LodePNGColorMode* info);
void lodepng_color_mode_cleanup(LodePNGColorMode* info);
/*return value is error code (0 means no error)*/
unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source);

void lodepng_palette_clear(LodePNGColorMode* info);
/*add 1 color to the palette*/
unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a);

/*get the total amount of bits per pixel, based on colortype and bitdepth in the struct*/
unsigned lodepng_get_bpp(const LodePNGColorMode* info);
/*get the amount of color channels used, based on colortype in the struct.
If a palette is used, it counts as 1 channel.*/
unsigned lodepng_get_channels(const LodePNGColorMode* info);
/*is it a greyscale type? (only colortype 0 or 4)*/
unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info);
/*has it got an alpha channel? (only colortype 2 or 6)*/
unsigned lodepng_is_alpha_type(const LodePNGColorMode* info);
/*has it got a palette? (only colortype 3)*/
unsigned lodepng_is_palette_type(const LodePNGColorMode* info);
/*only returns true if there is a palette and there is a value in the palette with alpha < 255.
Loops through the palette to check this.*/
unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info);
/*
Check if the given color info indicates the possibility of having non-opaque pixels in the PNG image.
Returns true if the image can have translucent or invisible pixels (it still be opaque if it doesn't use such pixels).
Returns false if the image can only have opaque pixels.
In detail, it returns true only if it's a color type with alpha, or has a palette with non-opaque values,
or if "key_defined" is true.
*/
unsigned lodepng_can_have_alpha(const LodePNGColorMode* info);
/*Returns the byte size of a raw image buffer with given width, height and color mode*/
size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color);

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*The information of a Time chunk in PNG.*/
typedef struct LodePNGTime
{
  unsigned year;    /*2 bytes used (0-65535)*/
  unsigned month;   /*1-12*/
  unsigned day;     /*1-31*/
  unsigned hour;    /*0-23*/
  unsigned minute;  /*0-59*/
  unsigned second;  /*0-60 (to allow for leap seconds)*/
} LodePNGTime;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*Information about the PNG image, except pixels, width and height.*/
typedef struct LodePNGInfo
{
  /*header (IHDR), palette (PLTE) and transparency (tRNS) chunks*/
  unsigned compression_method;/*compression method of the original file. Always 0.*/
  unsigned filter_method;     /*filter method of the original file*/
  unsigned interlace_method;  /*interlace method of the original file*/
  LodePNGColorMode color;     /*color type and bits, palette and transparency of the PNG file*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*
  suggested background color chunk (bKGD)
  This color uses the same color mode as the PNG (except alpha channel), which can be 1-bit to 16-bit.

  For greyscale PNGs, r, g and b will all 3 be set to the same. When encoding
  the encoder writes the red one. For palette PNGs: When decoding, the RGB value
  will be stored, not a palette index. But when encoding, specify the index of
  the palette in background_r, the other two are then ignored.

  The decoder does not use this background color to edit the color of pixels.
  */
  unsigned background_defined; /*is a suggested background color given?*/
  unsigned background_r;       /*red component of suggested background color*/
  unsigned background_g;       /*green component of suggested background color*/
  unsigned background_b;       /*blue component of suggested background color*/

  /*
  non-international text chunks (tEXt and zTXt)

  The char** arrays each contain num strings. The actual messages are in
  text_strings, while text_keys are keywords that give a short description what
  the actual text represents, e.g. Title, Author, Description, or anything else.

  A keyword is minimum 1 character and maximum 79 characters long. It's
  discouraged to use a single line length longer than 79 characters for texts.

  Don't allocate these text buffers yourself. Use the init/cleanup functions
  correctly and use lodepng_add_text and lodepng_clear_text.
  */
  size_t text_num; /*the amount of texts in these char** buffers (there may be more texts in itext)*/
  char** text_keys; /*the keyword of a text chunk (e.g. "Comment")*/
  char** text_strings; /*the actual text*/

  /*
  international text chunks (iTXt)
  Similar to the non-international text chunks, but with additional strings
  "langtags" and "transkeys".
  */
  size_t itext_num; /*the amount of international texts in this PNG*/
  char** itext_keys; /*the English keyword of the text chunk (e.g. "Comment")*/
  char** itext_langtags; /*language tag for this text's language, ISO/IEC 646 string, e.g. ISO 639 language tag*/
  char** itext_transkeys; /*keyword translated to the international language - UTF-8 string*/
  char** itext_strings; /*the actual international text - UTF-8 string*/

  /*time chunk (tIME)*/
  unsigned time_defined; /*set to 1 to make the encoder generate a tIME chunk*/
  LodePNGTime time;

  /*phys chunk (pHYs)*/
  unsigned phys_defined; /*if 0, there is no pHYs chunk and the values below are undefined, if 1 else there is one*/
  unsigned phys_x; /*pixels per unit in x direction*/
  unsigned phys_y; /*pixels per unit in y direction*/
  unsigned phys_unit; /*may be 0 (unknown unit) or 1 (metre)*/

  /*
  unknown chunks
  There are 3 buffers, one for each position in the PNG where unknown chunks can appear
  each buffer contains all unknown chunks for that position consecutively
  The 3 buffers are the unknown chunks between certain critical chunks:
  0: IHDR-PLTE, 1: PLTE-IDAT, 2: IDAT-IEND
  Do not allocate or traverse this data yourself. Use the chunk traversing functions declared
  later, such as lodepng_chunk_next and lodepng_chunk_append, to read/write this struct.
  */
  unsigned char* unknown_chunks_data[3];
  size_t unknown_chunks_size[3]; /*size in bytes of the unknown chunks, given for protection*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGInfo;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_info_init(LodePNGInfo* info);
void lodepng_info_cleanup(LodePNGInfo* info);
/*return value is error code (0 means no error)*/
unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source);

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
void lodepng_clear_text(LodePNGInfo* info); /*use this to clear the texts again after you filled them in*/
unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str); /*push back both texts at once*/

void lodepng_clear_itext(LodePNGInfo* info); /*use this to clear the itexts again after you filled them in*/
unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str); /*push back the 4 texts of 1 chunk at once*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*
Converts raw buffer from one color type to another color type, based on
LodePNGColorMode structs to describe the input and output color type.
See the reference manual at the end of this header file to see which color conversions are supported.
return value = LodePNG error code (0 if all went ok, an error if the conversion isn't supported)
The out buffer must have size (w * h * bpp + 7) / 8, where bpp is the bits per pixel
of the output color type (lodepng_get_bpp)
The fix_png value works as described in struct LodePNGDecoderSettings.
Note: for 16-bit per channel colors, uses big endian format like PNG does.
*/
unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         LodePNGColorMode* mode_out, LodePNGColorMode* mode_in,
                         unsigned w, unsigned h, unsigned fix_png);


#ifdef LODEPNG_COMPILE_DECODER
/*
Settings for the decoder. This contains settings for the PNG and the Zlib
decoder, but not the Info settings from the Info structs.
*/
typedef struct LodePNGDecoderSettings
{
  LodePNGDecompressSettings zlibsettings; /*in here is the setting to ignore Adler32 checksums*/

  unsigned ignore_crc; /*ignore CRC checksums*/
  /*
  The fix_png setting, if 1, makes the decoder tolerant towards some PNG images
  that do not correctly follow the PNG specification. This only supports errors
  that are fixable, were found in images that are actually used on the web, and
  are silently tolerated by other decoders as well. Currently only one such fix
  is implemented: if a palette index is out of bounds given the palette size,
  interpret it as opaque black.
  By default this value is 0, which makes it stop with an error on such images.
  */
  unsigned fix_png;
  unsigned color_convert; /*whether to convert the PNG to the color type you want. Default: yes*/

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned read_text_chunks; /*if false but remember_unknown_chunks is true, they're stored in the unknown chunks*/
  /*store all bytes from unknown chunks in the LodePNGInfo (off by default, useful for a png editor)*/
  unsigned remember_unknown_chunks;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGDecoderSettings;

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*automatically use color type with less bits per pixel if losslessly possible. Default: AUTO*/
typedef enum LodePNGFilterStrategy
{
  /*every filter at zero*/
  LFS_ZERO,
  /*Use filter that gives minumum sum, as described in the official PNG filter heuristic.*/
  LFS_MINSUM,
  /*Use the filter type that gives smallest Shannon entropy for this scanline. Depending
  on the image, this is better or worse than minsum.*/
  LFS_ENTROPY,
  /*
  Brute-force-search PNG filters by compressing each filter for each scanline.
  Experimental, very slow, and only rarely gives better compression than MINSUM.
  */
  LFS_BRUTE_FORCE,
  /*use predefined_filters buffer: you specify the filter type for each scanline*/
  LFS_PREDEFINED
} LodePNGFilterStrategy;

/*automatically use color type with less bits per pixel if losslessly possible. Default: LAC_AUTO*/
typedef enum LodePNGAutoConvert
{
  LAC_NO, /*use color type user requested*/
  LAC_ALPHA, /*use color type user requested, but if only opaque pixels and RGBA or grey+alpha, use RGB or grey*/
  LAC_AUTO, /*use PNG color type that can losslessly represent the uncompressed image the smallest possible*/
  /*
  like AUTO, but do not choose 1, 2 or 4 bit per pixel types.
  sometimes a PNG image compresses worse if less than 8 bits per pixels.
  */
  LAC_AUTO_NO_NIBBLES,
  /*
  like AUTO, but never choose palette color type. For small images, encoding
  the palette may take more bytes than what is gained. Note that AUTO also
  already prevents encoding the palette for extremely small images, but that may
  not be sufficient because due to the compression it cannot predict when to
  switch.
  */
  LAC_AUTO_NO_PALETTE,
  LAC_AUTO_NO_NIBBLES_NO_PALETTE
} LodePNGAutoConvert;


/*Settings for the encoder.*/
typedef struct LodePNGEncoderSettings
{
  LodePNGCompressSettings zlibsettings; /*settings for the zlib encoder, such as window size, ...*/

  LodePNGAutoConvert auto_convert; /*how to automatically choose output PNG color type, if at all*/

  /*If true, follows the official PNG heuristic: if the PNG uses a palette or lower than
  8 bit depth, set all filters to zero. Otherwise use the filter_strategy. Note that to
  completely follow the official PNG heuristic, filter_palette_zero must be true and
  filter_strategy must be LFS_MINSUM*/
  unsigned filter_palette_zero;
  /*Which filter strategy to use when not using zeroes due to filter_palette_zero.
  Set filter_palette_zero to 0 to ensure always using your chosen strategy. Default: LFS_MINSUM*/
  LodePNGFilterStrategy filter_strategy;
  /*used if filter_strategy is LFS_PREDEFINED. In that case, this must point to a buffer with
  the same length as the amount of scanlines in the image, and each value must <= 5. You
  have to cleanup this buffer, LodePNG will never free it. Don't forget that filter_palette_zero
  must be set to 0 to ensure this is also used on palette or low bitdepth images.*/
  unsigned char* predefined_filters;

  /*force creating a PLTE chunk if colortype is 2 or 6 (= a suggested palette).
  If colortype is 3, PLTE is _always_ created.*/
  unsigned force_palette;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  /*add LodePNG identifier and version as a text chunk, for debugging*/
  unsigned add_id;
  /*encode text chunks as zTXt chunks instead of tEXt chunks, and use compression in iTXt chunks*/
  unsigned text_compression;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
} LodePNGEncoderSettings;

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings);
#endif /*LODEPNG_COMPILE_ENCODER*/


#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)
/*The settings, state and information for extended encoding and decoding.*/
typedef struct LodePNGState
{
#ifdef LODEPNG_COMPILE_DECODER
  LodePNGDecoderSettings decoder; /*the decoding settings*/
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  LodePNGEncoderSettings encoder; /*the encoding settings*/
#endif /*LODEPNG_COMPILE_ENCODER*/
  LodePNGColorMode info_raw; /*specifies the format in which you would like to get the raw pixel buffer*/
  LodePNGInfo info_png; /*info of the PNG image obtained after decoding*/
  unsigned error;

} LodePNGState;

/*init, cleanup and copy functions to use with this struct*/
void lodepng_state_init(LodePNGState* state);
void lodepng_state_cleanup(LodePNGState* state);
void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source);
#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */

#ifdef LODEPNG_COMPILE_DECODER
/*
Same as lodepng_decode_memory, but uses a LodePNGState to allow custom settings and
getting much more information about the PNG image and color mode.
*/
unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize);

/*
Read the PNG header, but not the actual data. This returns only the information
that is in the header chunk of the PNG, such as width, height and color type. The
information is placed in the info_png field of the LodePNGState.
*/
unsigned lodepng_inspect(unsigned* w, unsigned* h,
                         LodePNGState* state,
                         const unsigned char* in, size_t insize);
#endif /*LODEPNG_COMPILE_DECODER*/


#ifdef LODEPNG_COMPILE_ENCODER
/*This function allocates the out buffer with standard malloc and stores the size in *outsize.*/
unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state);
#endif /*LODEPNG_COMPILE_ENCODER*/

/*
The lodepng_chunk functions are normally not needed, except to traverse the
unknown chunks stored in the LodePNGInfo struct, or add new ones to it.
It also allows traversing the chunks of an encoded PNG file yourself.

PNG standard chunk naming conventions:
First byte: uppercase = critical, lowercase = ancillary
Second byte: uppercase = public, lowercase = private
Third byte: must be uppercase
Fourth byte: uppercase = unsafe to copy, lowercase = safe to copy
*/

/*get the length of the data of the chunk. Total chunk length has 12 bytes more.*/
unsigned lodepng_chunk_length(const unsigned char* chunk);

/*puts the 4-byte type in null terminated string*/
void lodepng_chunk_type(char type[5], const unsigned char* chunk);

/*check if the type is the given type*/
unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type);

/*0: it's one of the critical chunk types, 1: it's an ancillary chunk (see PNG standard)*/
unsigned char lodepng_chunk_ancillary(const unsigned char* chunk);

/*0: public, 1: private (see PNG standard)*/
unsigned char lodepng_chunk_private(const unsigned char* chunk);

/*0: the chunk is unsafe to copy, 1: the chunk is safe to copy (see PNG standard)*/
unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk);

/*get pointer to the data of the chunk, where the input points to the header of the chunk*/
unsigned char* lodepng_chunk_data(unsigned char* chunk);
const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk);

/*returns 0 if the crc is correct, 1 if it's incorrect (0 for OK as usual!)*/
unsigned lodepng_chunk_check_crc(const unsigned char* chunk);

/*generates the correct CRC from the data and puts it in the last 4 bytes of the chunk*/
void lodepng_chunk_generate_crc(unsigned char* chunk);

/*iterate to next chunks. don't use on IEND chunk, as there is no next chunk then*/
unsigned char* lodepng_chunk_next(unsigned char* chunk);
const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk);

/*
Appends chunk to the data in out. The given chunk should already have its chunk header.
The out variable and outlength are updated to reflect the new reallocated buffer.
Returns error code (0 if it went ok)
*/
unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk);

/*
Appends new chunk to out. The chunk to append is given by giving its length, type
and data separately. The type is a 4-letter string.
The out variable and outlength are updated to reflect the new reallocated buffer.
Returne error code (0 if it went ok)
*/
unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
                              const char* type, const unsigned char* data);


/*Calculate CRC32 of buffer*/
unsigned lodepng_crc32(const unsigned char* buf, size_t len);
#endif /*LODEPNG_COMPILE_PNG*/


#ifdef LODEPNG_COMPILE_ZLIB
/*
This zlib part can be used independently to zlib compress and decompress a
buffer. It cannot be used to create gzip files however, and it only supports the
part of zlib that is required for PNG, it does not support dictionaries.
*/

#ifdef LODEPNG_COMPILE_DECODER
/*Inflate a buffer. Inflate is the decompression step of deflate. Out buffer must be freed after use.*/
unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings);

/*
Decompresses Zlib data. Reallocates the out buffer and appends the data. The
data must be according to the zlib specification.
Either, *out must be NULL and *outsize must be 0, or, *out must be a valid
buffer and *outsize its size in bytes. out must be freed by user after usage.
*/
unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings);
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER
/*
Compresses data with Zlib. Reallocates the out buffer and appends the data.
Zlib adds a small header and trailer around the deflate data.
The data is output in the format of the zlib specification.
Either, *out must be NULL and *outsize must be 0, or, *out must be a valid
buffer and *outsize its size in bytes. out must be freed by user after usage.
*/
unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize,
                               const unsigned char* in, size_t insize,
                               const LodePNGCompressSettings* settings);

/*
Find length-limited Huffman code for given frequencies. This function is in the
public interface only for tests, it's used internally by lodepng_deflate.
*/
unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen);

/*Compress a buffer with deflate. See RFC 1951. Out buffer must be freed after use.*/
unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings);

#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_ZLIB*/

#ifdef LODEPNG_COMPILE_DISK
/*
Load a file from disk into buffer. The function allocates the out buffer, and
after usage you should free it.
out: output parameter, contains pointer to loaded buffer.
outsize: output parameter, size of the allocated out buffer
filename: the path to the file to load
return value: error code (0 means ok)
*/
unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename);

/*
Save a file from buffer to disk. Warning, if it exists, this function overwrites
the file without warning!
buffer: the buffer to write
buffersize: size of the buffer to write
filename: the path to the file to save to
return value: error code (0 means ok)
*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename);
#endif /*LODEPNG_COMPILE_DISK*/


/*
TODO:
[.] test if there are no memory leaks or security exploits - done a lot but needs to be checked often
[.] check compatibility with vareous compilers  - done but needs to be redone for every newer version
[X] converting color to 16-bit per channel types
[ ] read all public PNG chunk types (but never let the color profile and gamma ones touch RGB values)
[ ] make sure encoder generates no chunks with size > (2^31)-1
[ ] partial decoding (stream processing)
[X] let the "isFullyOpaque" function check color keys and transparent palettes too
[X] better name for the variables "codes", "codesD", "codelengthcodes", "clcl" and "lldl"
[ ] don't stop decoding on errors like 69, 57, 58 (make warnings)
[ ] make option to choose if the raw image with non multiple of 8 bits per scanline should have padding bits or not
[ ] let the C++ wrapper catch exceptions coming from the standard library and return LodePNG error codes
*/

#endif /*LODEPNG_H inclusion guard*/

/*
LodePNG version 20130831

Copyright (c) 2005-2013 Lode Vandevenne

This software is provided 'as-is', without any express or implied
warranty. In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

    1. The origin of this software must not be misrepresented; you must not
    claim that you wrote the original software. If you use this software
    in a product, an acknowledgment in the product documentation would be
    appreciated but is not required.

    2. Altered source versions must be plainly marked as such, and must not be
    misrepresented as being the original software.

    3. This notice may not be removed or altered from any source
    distribution.
*/

/*
The manual and changelog are in the header file "lodepng.h"
Rename this file to lodepng.cpp to use it for C++, or to lodepng.c to use it for C.
*/



#define VERSION_STRING "20130831"

/*
This source file is built up in the following large parts. The code sections
with the "LODEPNG_COMPILE_" #defines divide this up further in an intermixed way.
-Tools for C and common code for PNG and Zlib
-C Code for Zlib (huffman, deflate, ...)
-C Code for PNG (file format chunks, adam7, PNG filters, color conversions, ...)
-The C++ wrapper around all of the above
*/

/*The malloc, realloc and free functions defined here with "lodepng_" in front
of the name, so that you can easily change them to others related to your
platform if needed. Everything else in the code calls these. Pass
-DLODEPNG_NO_COMPILE_ALLOCATORS to the compiler, or comment out
#define LODEPNG_COMPILE_ALLOCATORS in the header, to disable the ones here and
define them in your own project's source files without needing to change
lodepng source code. Don't forget to remove "static" if you copypaste them
from here.*/

#ifdef LODEPNG_COMPILE_ALLOCATORS
static void* lodepng_malloc(size_t size)
{
  return malloc(size);
}

static void* lodepng_realloc(void* ptr, size_t new_size)
{
  return realloc(ptr, new_size);
}

static void lodepng_free(void* ptr)
{
  free(ptr);
}
#else /*LODEPNG_COMPILE_ALLOCATORS*/
void* lodepng_malloc(size_t size);
void* lodepng_realloc(void* ptr, size_t new_size);
void lodepng_free(void* ptr);
#endif /*LODEPNG_COMPILE_ALLOCATORS*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // Tools for C, and common code for PNG and Zlib.                       // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

/*
Often in case of an error a value is assigned to a variable and then it breaks
out of a loop (to go to the cleanup phase of a function). This macro does that.
It makes the error handling code shorter and more readable.

Example: if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83);
*/
#define CERROR_BREAK(errorvar, code)\
{\
  errorvar = code;\
  break;\
}

/*version of CERROR_BREAK that assumes the common case where the error variable is named "error"*/
#define ERROR_BREAK(code) CERROR_BREAK(error, code)

/*Set error var to the error code, and return it.*/
#define CERROR_RETURN_ERROR(errorvar, code)\
{\
  errorvar = code;\
  return code;\
}

/*Try the code, if it returns error, also return the error.*/
#define CERROR_TRY_RETURN(call)\
{\
  unsigned error = call;\
  if(error) return error;\
}

/*
About uivector, ucvector and string:
-All of them wrap dynamic arrays or text strings in a similar way.
-LodePNG was originally written in C++. The vectors replace the std::vectors that were used in the C++ version.
-The string tools are made to avoid problems with compilers that declare things like strncat as deprecated.
-They're not used in the interface, only internally in this file as static functions.
-As with many other structs in this file, the init and cleanup functions serve as ctor and dtor.
*/

#ifdef LODEPNG_COMPILE_ZLIB
/*dynamic vector of unsigned ints*/
typedef struct uivector
{
  unsigned* data;
  size_t size; /*size in number of unsigned longs*/
  size_t allocsize; /*allocated size in bytes*/
} uivector;

static void uivector_cleanup(void* p)
{
  ((uivector*)p)->size = ((uivector*)p)->allocsize = 0;
  lodepng_free(((uivector*)p)->data);
  ((uivector*)p)->data = NULL;
}

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_resize(uivector* p, size_t size)
{
  if(size * sizeof(unsigned) > p->allocsize)
  {
    size_t newsize = size * sizeof(unsigned) * 2;
    void* data = lodepng_realloc(p->data, newsize);
    if(data)
    {
      p->allocsize = newsize;
      p->data = (unsigned*)data;
      p->size = size;
    }
    else return 0;
  }
  else p->size = size;
  return 1;
}

/*resize and give all new elements the value*/
static unsigned uivector_resizev(uivector* p, size_t size, unsigned value)
{
  size_t oldsize = p->size, i;
  if(!uivector_resize(p, size)) return 0;
  for(i = oldsize; i < size; i++) p->data[i] = value;
  return 1;
}

static void uivector_init(uivector* p)
{
  p->data = NULL;
  p->size = p->allocsize = 0;
}

#ifdef LODEPNG_COMPILE_ENCODER
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_push_back(uivector* p, unsigned c)
{
  if(!uivector_resize(p, p->size + 1)) return 0;
  p->data[p->size - 1] = c;
  return 1;
}

/*copy q to p, returns 1 if success, 0 if failure ==> nothing done*/
static unsigned uivector_copy(uivector* p, const uivector* q)
{
  size_t i;
  if(!uivector_resize(p, q->size)) return 0;
  for(i = 0; i < q->size; i++) p->data[i] = q->data[i];
  return 1;
}

static void uivector_swap(uivector* p, uivector* q)
{
  size_t tmp;
  unsigned* tmpp;
  tmp = p->size; p->size = q->size; q->size = tmp;
  tmp = p->allocsize; p->allocsize = q->allocsize; q->allocsize = tmp;
  tmpp = p->data; p->data = q->data; q->data = tmpp;
}
#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_ZLIB*/

/* /////////////////////////////////////////////////////////////////////////// */

/*dynamic vector of unsigned chars*/
typedef struct ucvector
{
  unsigned char* data;
  size_t size; /*used size*/
  size_t allocsize; /*allocated size*/
} ucvector;

/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_resize(ucvector* p, size_t size)
{
  if(size * sizeof(unsigned char) > p->allocsize)
  {
    size_t newsize = size * sizeof(unsigned char) * 2;
    void* data = lodepng_realloc(p->data, newsize);
    if(data)
    {
      p->allocsize = newsize;
      p->data = (unsigned char*)data;
      p->size = size;
    }
    else return 0; /*error: not enough memory*/
  }
  else p->size = size;
  return 1;
}

#ifdef LODEPNG_COMPILE_PNG

static void ucvector_cleanup(void* p)
{
  ((ucvector*)p)->size = ((ucvector*)p)->allocsize = 0;
  lodepng_free(((ucvector*)p)->data);
  ((ucvector*)p)->data = NULL;
}

static void ucvector_init(ucvector* p)
{
  p->data = NULL;
  p->size = p->allocsize = 0;
}

#ifdef LODEPNG_COMPILE_DECODER
/*resize and give all new elements the value*/
static unsigned ucvector_resizev(ucvector* p, size_t size, unsigned char value)
{
  size_t oldsize = p->size, i;
  if(!ucvector_resize(p, size)) return 0;
  for(i = oldsize; i < size; i++) p->data[i] = value;
  return 1;
}
#endif /*LODEPNG_COMPILE_DECODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ZLIB
/*you can both convert from vector to buffer&size and vica versa. If you use
init_buffer to take over a buffer and size, it is not needed to use cleanup*/
static void ucvector_init_buffer(ucvector* p, unsigned char* buffer, size_t size)
{
  p->data = buffer;
  p->allocsize = p->size = size;
}
#endif /*LODEPNG_COMPILE_ZLIB*/

#if (defined(LODEPNG_COMPILE_PNG) && defined(LODEPNG_COMPILE_ANCILLARY_CHUNKS)) || defined(LODEPNG_COMPILE_ENCODER)
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned ucvector_push_back(ucvector* p, unsigned char c)
{
  if(!ucvector_resize(p, p->size + 1)) return 0;
  p->data[p->size - 1] = c;
  return 1;
}
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/


/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_PNG
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*returns 1 if success, 0 if failure ==> nothing done*/
static unsigned string_resize(char** out, size_t size)
{
  char* data = (char*)lodepng_realloc(*out, size + 1);
  if(data)
  {
    data[size] = 0; /*null termination char*/
    *out = data;
  }
  return data != 0;
}

/*init a {char*, size_t} pair for use as string*/
static void string_init(char** out)
{
  *out = NULL;
  string_resize(out, 0);
}

/*free the above pair again*/
static void string_cleanup(char** out)
{
  lodepng_free(*out);
  *out = NULL;
}

static void string_set(char** out, const char* in)
{
  size_t insize = strlen(in), i = 0;
  if(string_resize(out, insize))
  {
    for(i = 0; i < insize; i++)
    {
      (*out)[i] = in[i];
    }
  }
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
#endif /*LODEPNG_COMPILE_PNG*/

/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_read32bitInt(const unsigned char* buffer)
{
  return (buffer[0] << 24) | (buffer[1] << 16) | (buffer[2] << 8) | buffer[3];
}

#if defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)
/*buffer must have at least 4 allocated bytes available*/
static void lodepng_set32bitInt(unsigned char* buffer, unsigned value)
{
  buffer[0] = (unsigned char)((value >> 24) & 0xff);
  buffer[1] = (unsigned char)((value >> 16) & 0xff);
  buffer[2] = (unsigned char)((value >>  8) & 0xff);
  buffer[3] = (unsigned char)((value      ) & 0xff);
}
#endif /*defined(LODEPNG_COMPILE_PNG) || defined(LODEPNG_COMPILE_ENCODER)*/

#ifdef LODEPNG_COMPILE_ENCODER
static void lodepng_add32bitInt(ucvector* buffer, unsigned value)
{
  ucvector_resize(buffer, buffer->size + 4); /*todo: give error if resize failed*/
  lodepng_set32bitInt(&buffer->data[buffer->size - 4], value);
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / File IO                                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DISK

unsigned lodepng_load_file(unsigned char** out, size_t* outsize, const char* filename)
{
  FILE* file;
  long size;

  /*provide some proper output values if error will happen*/
  *out = 0;
  *outsize = 0;

  file = fopen(filename, "rb");
  if(!file) return 78;

  /*get filesize:*/
  fseek(file , 0 , SEEK_END);
  size = ftell(file);
  rewind(file);

  /*read contents of the file into the vector*/
  *outsize = 0;
  *out = (unsigned char*)lodepng_malloc((size_t)size);
  if(size && (*out)) (*outsize) = fread(*out, 1, (size_t)size, file);

  fclose(file);
  if(!(*out) && size) return 83; /*the above malloc failed*/
  return 0;
}

/*write given buffer to the file, overwriting the file, it doesn't append to it.*/
unsigned lodepng_save_file(const unsigned char* buffer, size_t buffersize, const char* filename)
{
  FILE* file;
  file = fopen(filename, "wb" );
  if(!file) return 79;
  fwrite((char*)buffer , 1 , buffersize, file);
  fclose(file);
  return 0;
}

#endif /*LODEPNG_COMPILE_DISK*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // End of common code and tools. Begin of Zlib related code.            // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_ZLIB
#ifdef LODEPNG_COMPILE_ENCODER
/*TODO: this ignores potential out of memory errors*/
static void addBitToStream(size_t* bitpointer, ucvector* bitstream, unsigned char bit)
{
  /*add a new byte at the end*/
  if((*bitpointer) % 8 == 0) ucvector_push_back(bitstream, (unsigned char)0);
  /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/
  (bitstream->data[bitstream->size - 1]) |= (bit << ((*bitpointer) & 0x7));
  (*bitpointer)++;
}

static void addBitsToStream(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)
{
  size_t i;
  for(i = 0; i < nbits; i++) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> i) & 1));
}

static void addBitsToStreamReversed(size_t* bitpointer, ucvector* bitstream, unsigned value, size_t nbits)
{
  size_t i;
  for(i = 0; i < nbits; i++) addBitToStream(bitpointer, bitstream, (unsigned char)((value >> (nbits - 1 - i)) & 1));
}
#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

#define READBIT(bitpointer, bitstream) ((bitstream[bitpointer >> 3] >> (bitpointer & 0x7)) & (unsigned char)1)

static unsigned char readBitFromStream(size_t* bitpointer, const unsigned char* bitstream)
{
  unsigned char result = (unsigned char)(READBIT(*bitpointer, bitstream));
  (*bitpointer)++;
  return result;
}

static unsigned readBitsFromStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
{
  unsigned result = 0, i;
  for(i = 0; i < nbits; i++)
  {
    result += ((unsigned)READBIT(*bitpointer, bitstream)) << i;
    (*bitpointer)++;
  }
  return result;
}
#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / Deflate - Huffman                                                      / */
/* ////////////////////////////////////////////////////////////////////////// */

#define FIRST_LENGTH_CODE_INDEX 257
#define LAST_LENGTH_CODE_INDEX 285
/*256 literals, the end code, some length codes, and 2 unused codes*/
#define NUM_DEFLATE_CODE_SYMBOLS 288
/*the distance codes have their own symbols, 30 used, 2 unused*/
#define NUM_DISTANCE_SYMBOLS 32
/*the code length codes. 0-15: code lengths, 16: copy previous 3-6 times, 17: 3-10 zeros, 18: 11-138 zeros*/
#define NUM_CODE_LENGTH_CODES 19

/*the base lengths represented by codes 257-285*/
static const unsigned LENGTHBASE[29]
  = {3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59,
     67, 83, 99, 115, 131, 163, 195, 227, 258};

/*the extra bits used by codes 257-285 (added to base length)*/
static const unsigned LENGTHEXTRA[29]
  = {0, 0, 0, 0, 0, 0, 0,  0,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,
      4,  4,  4,   4,   5,   5,   5,   5,   0};

/*the base backwards distances (the bits of distance codes appear after length codes and use their own huffman tree)*/
static const unsigned DISTANCEBASE[30]
  = {1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513,
     769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577};

/*the extra bits of backwards distances (added to base)*/
static const unsigned DISTANCEEXTRA[30]
  = {0, 0, 0, 0, 1, 1, 2,  2,  3,  3,  4,  4,  5,  5,   6,   6,   7,   7,   8,
       8,    9,    9,   10,   10,   11,   11,   12,    12,    13,    13};

/*the order in which "code length alphabet code lengths" are stored, out of this
the huffman tree of the dynamic huffman tree lengths is generated*/
static const unsigned CLCL_ORDER[NUM_CODE_LENGTH_CODES]
  = {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

/* ////////////////////////////////////////////////////////////////////////// */

/*
Huffman tree struct, containing multiple representations of the tree
*/
typedef struct HuffmanTree
{
  unsigned* tree2d;
  unsigned* tree1d;
  unsigned* lengths; /*the lengths of the codes of the 1d-tree*/
  unsigned maxbitlen; /*maximum number of bits a single code can get*/
  unsigned numcodes; /*number of symbols in the alphabet = number of codes*/
} HuffmanTree;

/*function used for debug purposes to draw the tree in ascii art with C++*/
/*
static void HuffmanTree_draw(HuffmanTree* tree)
{
  std::cout << "tree. length: " << tree->numcodes << " maxbitlen: " << tree->maxbitlen << std::endl;
  for(size_t i = 0; i < tree->tree1d.size; i++)
  {
    if(tree->lengths.data[i])
      std::cout << i << " " << tree->tree1d.data[i] << " " << tree->lengths.data[i] << std::endl;
  }
  std::cout << std::endl;
}*/

static void HuffmanTree_init(HuffmanTree* tree)
{
  tree->tree2d = 0;
  tree->tree1d = 0;
  tree->lengths = 0;
}

static void HuffmanTree_cleanup(HuffmanTree* tree)
{
  lodepng_free(tree->tree2d);
  lodepng_free(tree->tree1d);
  lodepng_free(tree->lengths);
}

/*the tree representation used by the decoder. return value is error*/
static unsigned HuffmanTree_make2DTree(HuffmanTree* tree)
{
  unsigned nodefilled = 0; /*up to which node it is filled*/
  unsigned treepos = 0; /*position in the tree (1 of the numcodes columns)*/
  unsigned n, i;

  tree->tree2d = (unsigned*)lodepng_malloc(tree->numcodes * 2 * sizeof(unsigned));
  if(!tree->tree2d) return 83; /*alloc fail*/

  /*
  convert tree1d[] to tree2d[][]. In the 2D array, a value of 32767 means
  uninited, a value >= numcodes is an address to another bit, a value < numcodes
  is a code. The 2 rows are the 2 possible bit values (0 or 1), there are as
  many columns as codes - 1.
  A good huffmann tree has N * 2 - 1 nodes, of which N - 1 are internal nodes.
  Here, the internal nodes are stored (what their 0 and 1 option point to).
  There is only memory for such good tree currently, if there are more nodes
  (due to too long length codes), error 55 will happen
  */
  for(n = 0; n < tree->numcodes * 2; n++)
  {
    tree->tree2d[n] = 32767; /*32767 here means the tree2d isn't filled there yet*/
  }

  for(n = 0; n < tree->numcodes; n++) /*the codes*/
  {
    for(i = 0; i < tree->lengths[n]; i++) /*the bits for this code*/
    {
      unsigned char bit = (unsigned char)((tree->tree1d[n] >> (tree->lengths[n] - i - 1)) & 1);
      if(treepos > tree->numcodes - 2) return 55; /*oversubscribed, see comment in lodepng_error_text*/
      if(tree->tree2d[2 * treepos + bit] == 32767) /*not yet filled in*/
      {
        if(i + 1 == tree->lengths[n]) /*last bit*/
        {
          tree->tree2d[2 * treepos + bit] = n; /*put the current code in it*/
          treepos = 0;
        }
        else
        {
          /*put address of the next step in here, first that address has to be found of course
          (it's just nodefilled + 1)...*/
          nodefilled++;
          /*addresses encoded with numcodes added to it*/
          tree->tree2d[2 * treepos + bit] = nodefilled + tree->numcodes;
          treepos = nodefilled;
        }
      }
      else treepos = tree->tree2d[2 * treepos + bit] - tree->numcodes;
    }
  }

  for(n = 0;  n < tree->numcodes * 2; n++)
  {
    if(tree->tree2d[n] == 32767) tree->tree2d[n] = 0; /*remove possible remaining 32767's*/
  }

  return 0;
}

/*
Second step for the ...makeFromLengths and ...makeFromFrequencies functions.
numcodes, lengths and maxbitlen must already be filled in correctly. return
value is error.
*/
static unsigned HuffmanTree_makeFromLengths2(HuffmanTree* tree)
{
  uivector blcount;
  uivector nextcode;
  unsigned bits, n, error = 0;

  uivector_init(&blcount);
  uivector_init(&nextcode);

  tree->tree1d = (unsigned*)lodepng_malloc(tree->numcodes * sizeof(unsigned));
  if(!tree->tree1d) error = 83; /*alloc fail*/

  if(!uivector_resizev(&blcount, tree->maxbitlen + 1, 0)
  || !uivector_resizev(&nextcode, tree->maxbitlen + 1, 0))
    error = 83; /*alloc fail*/

  if(!error)
  {
    /*step 1: count number of instances of each code length*/
    for(bits = 0; bits < tree->numcodes; bits++) blcount.data[tree->lengths[bits]]++;
    /*step 2: generate the nextcode values*/
    for(bits = 1; bits <= tree->maxbitlen; bits++)
    {
      nextcode.data[bits] = (nextcode.data[bits - 1] + blcount.data[bits - 1]) << 1;
    }
    /*step 3: generate all the codes*/
    for(n = 0; n < tree->numcodes; n++)
    {
      if(tree->lengths[n] != 0) tree->tree1d[n] = nextcode.data[tree->lengths[n]]++;
    }
  }

  uivector_cleanup(&blcount);
  uivector_cleanup(&nextcode);

  if(!error) return HuffmanTree_make2DTree(tree);
  else return error;
}

/*
given the code lengths (as stored in the PNG file), generate the tree as defined
by Deflate. maxbitlen is the maximum bits that a code in the tree can have.
return value is error.
*/
static unsigned HuffmanTree_makeFromLengths(HuffmanTree* tree, const unsigned* bitlen,
                                            size_t numcodes, unsigned maxbitlen)
{
  unsigned i;
  tree->lengths = (unsigned*)lodepng_malloc(numcodes * sizeof(unsigned));
  if(!tree->lengths) return 83; /*alloc fail*/
  for(i = 0; i < numcodes; i++) tree->lengths[i] = bitlen[i];
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
  tree->maxbitlen = maxbitlen;
  return HuffmanTree_makeFromLengths2(tree);
}

#ifdef LODEPNG_COMPILE_ENCODER

/*
A coin, this is the terminology used for the package-merge algorithm and the
coin collector's problem. This is used to generate the huffman tree.
A coin can be multiple coins (when they're merged)
*/
typedef struct Coin
{
  uivector symbols;
  float weight; /*the sum of all weights in this coin*/
} Coin;

static void coin_init(Coin* c)
{
  uivector_init(&c->symbols);
}

/*argument c is void* so that this dtor can be given as function pointer to the vector resize function*/
static void coin_cleanup(void* c)
{
  uivector_cleanup(&((Coin*)c)->symbols);
}

static void coin_copy(Coin* c1, const Coin* c2)
{
  c1->weight = c2->weight;
  uivector_copy(&c1->symbols, &c2->symbols);
}

static void add_coins(Coin* c1, const Coin* c2)
{
  size_t i;
  for(i = 0; i < c2->symbols.size; i++) uivector_push_back(&c1->symbols, c2->symbols.data[i]);
  c1->weight += c2->weight;
}

static void init_coins(Coin* coins, size_t num)
{
  size_t i;
  for(i = 0; i < num; i++) coin_init(&coins[i]);
}

static void cleanup_coins(Coin* coins, size_t num)
{
  size_t i;
  for(i = 0; i < num; i++) coin_cleanup(&coins[i]);
}

/*
This uses a simple combsort to sort the data. This function is not critical for
overall encoding speed and the data amount isn't that large.
*/
static void sort_coins(Coin* data, size_t amount)
{
  size_t gap = amount;
  unsigned char swapped = 0;
  while((gap > 1) || swapped)
  {
    size_t i;
    gap = (gap * 10) / 13; /*shrink factor 1.3*/
    if(gap == 9 || gap == 10) gap = 11; /*combsort11*/
    if(gap < 1) gap = 1;
    swapped = 0;
    for(i = 0; i < amount - gap; i++)
    {
      size_t j = i + gap;
      if(data[j].weight < data[i].weight)
      {
        float temp = data[j].weight; data[j].weight = data[i].weight; data[i].weight = temp;
        uivector_swap(&data[i].symbols, &data[j].symbols);
        swapped = 1;
      }
    }
  }
}

static unsigned append_symbol_coins(Coin* coins, const unsigned* frequencies, unsigned numcodes, size_t sum)
{
  unsigned i;
  unsigned j = 0; /*index of present symbols*/
  for(i = 0; i < numcodes; i++)
  {
    if(frequencies[i] != 0) /*only include symbols that are present*/
    {
      coins[j].weight = frequencies[i] / (float)sum;
      uivector_push_back(&coins[j].symbols, i);
      j++;
    }
  }
  return 0;
}

unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,
                                      size_t numcodes, unsigned maxbitlen)
{
  unsigned i, j;
  size_t sum = 0, numpresent = 0;
  unsigned error = 0;
  Coin* coins; /*the coins of the currently calculated row*/
  Coin* prev_row; /*the previous row of coins*/
  unsigned numcoins;
  unsigned coinmem;

  if(numcodes == 0) return 80; /*error: a tree of 0 symbols is not supposed to be made*/

  for(i = 0; i < numcodes; i++)
  {
    if(frequencies[i] > 0)
    {
      numpresent++;
      sum += frequencies[i];
    }
  }

  for(i = 0; i < numcodes; i++) lengths[i] = 0;

  /*ensure at least two present symbols. There should be at least one symbol
  according to RFC 1951 section 3.2.7. To decoders incorrectly require two. To
  make these work as well ensure there are at least two symbols. The
  Package-Merge code below also doesn't work correctly if there's only one
  symbol, it'd give it the theoritical 0 bits but in practice zlib wants 1 bit*/
  if(numpresent == 0)
  {
    lengths[0] = lengths[1] = 1; /*note that for RFC 1951 section 3.2.7, only lengths[0] = 1 is needed*/
  }
  else if(numpresent == 1)
  {
    for(i = 0; i < numcodes; i++)
    {
      if(frequencies[i])
      {
        lengths[i] = 1;
        lengths[i == 0 ? 1 : 0] = 1;
        break;
      }
    }
  }
  else
  {
    /*Package-Merge algorithm represented by coin collector's problem
    For every symbol, maxbitlen coins will be created*/

    coinmem = numpresent * 2; /*max amount of coins needed with the current algo*/
    coins = (Coin*)lodepng_malloc(sizeof(Coin) * coinmem);
    prev_row = (Coin*)lodepng_malloc(sizeof(Coin) * coinmem);
    if(!coins || !prev_row)
    {
      lodepng_free(coins);
      lodepng_free(prev_row);
      return 83; /*alloc fail*/
    }
    init_coins(coins, coinmem);
    init_coins(prev_row, coinmem);

    /*first row, lowest denominator*/
    error = append_symbol_coins(coins, frequencies, numcodes, sum);
    numcoins = numpresent;
    sort_coins(coins, numcoins);
    if(!error)
    {
      unsigned numprev = 0;
      for(j = 1; j <= maxbitlen && !error; j++) /*each of the remaining rows*/
      {
        unsigned tempnum;
        Coin* tempcoins;
        /*swap prev_row and coins, and their amounts*/
        tempcoins = prev_row; prev_row = coins; coins = tempcoins;
        tempnum = numprev; numprev = numcoins; numcoins = tempnum;

        cleanup_coins(coins, numcoins);
        init_coins(coins, numcoins);

        numcoins = 0;

        /*fill in the merged coins of the previous row*/
        for(i = 0; i + 1 < numprev; i += 2)
        {
          /*merge prev_row[i] and prev_row[i + 1] into new coin*/
          Coin* coin = &coins[numcoins++];
          coin_copy(coin, &prev_row[i]);
          add_coins(coin, &prev_row[i + 1]);
        }
        /*fill in all the original symbols again*/
        if(j < maxbitlen)
        {
          error = append_symbol_coins(coins + numcoins, frequencies, numcodes, sum);
          numcoins += numpresent;
        }
        sort_coins(coins, numcoins);
      }
    }

    if(!error)
    {
      /*calculate the lenghts of each symbol, as the amount of times a coin of each symbol is used*/
      for(i = 0; i < numpresent - 1; i++)
      {
        Coin* coin = &coins[i];
        for(j = 0; j < coin->symbols.size; j++) lengths[coin->symbols.data[j]]++;
      }
    }

    cleanup_coins(coins, coinmem);
    lodepng_free(coins);
    cleanup_coins(prev_row, coinmem);
    lodepng_free(prev_row);
  }

  return error;
}

/*Create the Huffman tree given the symbol frequencies*/
static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,
                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)
{
  unsigned error = 0;
  while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/
  tree->maxbitlen = maxbitlen;
  tree->numcodes = (unsigned)numcodes; /*number of symbols*/
  tree->lengths = (unsigned*)lodepng_realloc(tree->lengths, numcodes * sizeof(unsigned));
  if(!tree->lengths) return 83; /*alloc fail*/
  /*initialize all lengths to 0*/
  memset(tree->lengths, 0, numcodes * sizeof(unsigned));

  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);
  if(!error) error = HuffmanTree_makeFromLengths2(tree);
  return error;
}

static unsigned HuffmanTree_getCode(const HuffmanTree* tree, unsigned index)
{
  return tree->tree1d[index];
}

static unsigned HuffmanTree_getLength(const HuffmanTree* tree, unsigned index)
{
  return tree->lengths[index];
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/*get the literal and length code tree of a deflated block with fixed tree, as per the deflate specification*/
static unsigned generateFixedLitLenTree(HuffmanTree* tree)
{
  unsigned i, error = 0;
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
  if(!bitlen) return 83; /*alloc fail*/

  /*288 possible codes: 0-255=literals, 256=endcode, 257-285=lengthcodes, 286-287=unused*/
  for(i =   0; i <= 143; i++) bitlen[i] = 8;
  for(i = 144; i <= 255; i++) bitlen[i] = 9;
  for(i = 256; i <= 279; i++) bitlen[i] = 7;
  for(i = 280; i <= 287; i++) bitlen[i] = 8;

  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DEFLATE_CODE_SYMBOLS, 15);

  lodepng_free(bitlen);
  return error;
}

/*get the distance code tree of a deflated block with fixed tree, as specified in the deflate specification*/
static unsigned generateFixedDistanceTree(HuffmanTree* tree)
{
  unsigned i, error = 0;
  unsigned* bitlen = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
  if(!bitlen) return 83; /*alloc fail*/

  /*there are 32 distance codes, but 30-31 are unused*/
  for(i = 0; i < NUM_DISTANCE_SYMBOLS; i++) bitlen[i] = 5;
  error = HuffmanTree_makeFromLengths(tree, bitlen, NUM_DISTANCE_SYMBOLS, 15);

  lodepng_free(bitlen);
  return error;
}

#ifdef LODEPNG_COMPILE_DECODER

/*
returns the code, or (unsigned)(-1) if error happened
inbitlength is the length of the complete buffer, in bits (so its byte length times 8)
*/
static unsigned huffmanDecodeSymbol(const unsigned char* in, size_t* bp,
                                    const HuffmanTree* codetree, size_t inbitlength)
{
  unsigned treepos = 0, ct;
  for(;;)
  {
    if(*bp >= inbitlength) return (unsigned)(-1); /*error: end of input memory reached without endcode*/
    /*
    decode the symbol from the tree. The "readBitFromStream" code is inlined in
    the expression below because this is the biggest bottleneck while decoding
    */
    ct = codetree->tree2d[(treepos << 1) + READBIT(*bp, in)];
    (*bp)++;
    if(ct < codetree->numcodes) return ct; /*the symbol is decoded, return it*/
    else treepos = ct - codetree->numcodes; /*symbol not yet decoded, instead move tree position*/

    if(treepos >= codetree->numcodes) return (unsigned)(-1); /*error: it appeared outside the codetree*/
  }
}
#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_DECODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / Inflator (Decompressor)                                                / */
/* ////////////////////////////////////////////////////////////////////////// */

/*get the tree of a deflated block with fixed tree, as specified in the deflate specification*/
static void getTreeInflateFixed(HuffmanTree* tree_ll, HuffmanTree* tree_d)
{
  /*TODO: check for out of memory errors*/
  generateFixedLitLenTree(tree_ll);
  generateFixedDistanceTree(tree_d);
}

/*get the tree of a deflated block with dynamic tree, the tree itself is also Huffman compressed with a known tree*/
static unsigned getTreeInflateDynamic(HuffmanTree* tree_ll, HuffmanTree* tree_d,
                                      const unsigned char* in, size_t* bp, size_t inlength)
{
  /*make sure that length values that aren't filled in will be 0, or a wrong tree will be generated*/
  unsigned error = 0;
  unsigned n, HLIT, HDIST, HCLEN, i;
  size_t inbitlength = inlength * 8;

  /*see comments in deflateDynamic for explanation of the context and these variables, it is analogous*/
  unsigned* bitlen_ll = 0; /*lit,len code lengths*/
  unsigned* bitlen_d = 0; /*dist code lengths*/
  /*code length code lengths ("clcl"), the bit lengths of the huffman tree used to compress bitlen_ll and bitlen_d*/
  unsigned* bitlen_cl = 0;
  HuffmanTree tree_cl; /*the code tree for code length codes (the huffman tree for compressed huffman trees)*/

  if((*bp) >> 3 >= inlength - 2) return 49; /*error: the bit pointer is or will go past the memory*/

  /*number of literal/length codes + 257. Unlike the spec, the value 257 is added to it here already*/
  HLIT =  readBitsFromStream(bp, in, 5) + 257;
  /*number of distance codes. Unlike the spec, the value 1 is added to it here already*/
  HDIST = readBitsFromStream(bp, in, 5) + 1;
  /*number of code length codes. Unlike the spec, the value 4 is added to it here already*/
  HCLEN = readBitsFromStream(bp, in, 4) + 4;

  HuffmanTree_init(&tree_cl);

  while(!error)
  {
    /*read the code length codes out of 3 * (amount of code length codes) bits*/

    bitlen_cl = (unsigned*)lodepng_malloc(NUM_CODE_LENGTH_CODES * sizeof(unsigned));
    if(!bitlen_cl) ERROR_BREAK(83 /*alloc fail*/);

    for(i = 0; i < NUM_CODE_LENGTH_CODES; i++)
    {
      if(i < HCLEN) bitlen_cl[CLCL_ORDER[i]] = readBitsFromStream(bp, in, 3);
      else bitlen_cl[CLCL_ORDER[i]] = 0; /*if not, it must stay 0*/
    }

    error = HuffmanTree_makeFromLengths(&tree_cl, bitlen_cl, NUM_CODE_LENGTH_CODES, 7);
    if(error) break;

    /*now we can use this tree to read the lengths for the tree that this function will return*/
    bitlen_ll = (unsigned*)lodepng_malloc(NUM_DEFLATE_CODE_SYMBOLS * sizeof(unsigned));
    bitlen_d = (unsigned*)lodepng_malloc(NUM_DISTANCE_SYMBOLS * sizeof(unsigned));
    if(!bitlen_ll || !bitlen_d) ERROR_BREAK(83 /*alloc fail*/);
    for(i = 0; i < NUM_DEFLATE_CODE_SYMBOLS; i++) bitlen_ll[i] = 0;
    for(i = 0; i < NUM_DISTANCE_SYMBOLS; i++) bitlen_d[i] = 0;

    /*i is the current symbol we're reading in the part that contains the code lengths of lit/len and dist codes*/
    i = 0;
    while(i < HLIT + HDIST)
    {
      unsigned code = huffmanDecodeSymbol(in, bp, &tree_cl, inbitlength);
      if(code <= 15) /*a length code*/
      {
        if(i < HLIT) bitlen_ll[i] = code;
        else bitlen_d[i - HLIT] = code;
        i++;
      }
      else if(code == 16) /*repeat previous*/
      {
        unsigned replength = 3; /*read in the 2 bits that indicate repeat length (3-6)*/
        unsigned value; /*set value to the previous code*/

        if(*bp >= inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/
        if (i == 0) ERROR_BREAK(54); /*can't repeat previous if i is 0*/

        replength += readBitsFromStream(bp, in, 2);

        if(i < HLIT + 1) value = bitlen_ll[i - 1];
        else value = bitlen_d[i - HLIT - 1];
        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; n++)
        {
          if(i >= HLIT + HDIST) ERROR_BREAK(13); /*error: i is larger than the amount of codes*/
          if(i < HLIT) bitlen_ll[i] = value;
          else bitlen_d[i - HLIT] = value;
          i++;
        }
      }
      else if(code == 17) /*repeat "0" 3-10 times*/
      {
        unsigned replength = 3; /*read in the bits that indicate repeat length*/
        if(*bp >= inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/

        replength += readBitsFromStream(bp, in, 3);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; n++)
        {
          if(i >= HLIT + HDIST) ERROR_BREAK(14); /*error: i is larger than the amount of codes*/

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          i++;
        }
      }
      else if(code == 18) /*repeat "0" 11-138 times*/
      {
        unsigned replength = 11; /*read in the bits that indicate repeat length*/
        if(*bp >= inbitlength) ERROR_BREAK(50); /*error, bit pointer jumps past memory*/

        replength += readBitsFromStream(bp, in, 7);

        /*repeat this value in the next lengths*/
        for(n = 0; n < replength; n++)
        {
          if(i >= HLIT + HDIST) ERROR_BREAK(15); /*error: i is larger than the amount of codes*/

          if(i < HLIT) bitlen_ll[i] = 0;
          else bitlen_d[i - HLIT] = 0;
          i++;
        }
      }
      else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
      {
        if(code == (unsigned)(-1))
        {
          /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
          (10=no endcode, 11=wrong jump outside of tree)*/
          error = (*bp) > inbitlength ? 10 : 11;
        }
        else error = 16; /*unexisting code, this can never happen*/
        break;
      }
    }
    if(error) break;

    if(bitlen_ll[256] == 0) ERROR_BREAK(64); /*the length of the end code 256 must be larger than 0*/

    /*now we've finally got HLIT and HDIST, so generate the code trees, and the function is done*/
    error = HuffmanTree_makeFromLengths(tree_ll, bitlen_ll, NUM_DEFLATE_CODE_SYMBOLS, 15);
    if(error) break;
    error = HuffmanTree_makeFromLengths(tree_d, bitlen_d, NUM_DISTANCE_SYMBOLS, 15);

    break; /*end of error-while*/
  }

  lodepng_free(bitlen_cl);
  lodepng_free(bitlen_ll);
  lodepng_free(bitlen_d);
  HuffmanTree_cleanup(&tree_cl);

  return error;
}

/*inflate a block with dynamic of fixed Huffman tree*/
static unsigned inflateHuffmanBlock(ucvector* out, const unsigned char* in, size_t* bp,
                                    size_t* pos, size_t inlength, unsigned btype)
{
  unsigned error = 0;
  HuffmanTree tree_ll; /*the huffman tree for literal and length codes*/
  HuffmanTree tree_d; /*the huffman tree for distance codes*/
  size_t inbitlength = inlength * 8;

  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);

  if(btype == 1) getTreeInflateFixed(&tree_ll, &tree_d);
  else if(btype == 2) error = getTreeInflateDynamic(&tree_ll, &tree_d, in, bp, inlength);

  while(!error) /*decode all symbols until end reached, breaks at end code*/
  {
    /*code_ll is literal, length or end code*/
    unsigned code_ll = huffmanDecodeSymbol(in, bp, &tree_ll, inbitlength);
    if(code_ll <= 255) /*literal symbol*/
    {
      if((*pos) >= out->size)
      {
        /*reserve more room at once*/
        if(!ucvector_resize(out, ((*pos) + 1) * 2)) ERROR_BREAK(83 /*alloc fail*/);
      }
      out->data[(*pos)] = (unsigned char)(code_ll);
      (*pos)++;
    }
    else if(code_ll >= FIRST_LENGTH_CODE_INDEX && code_ll <= LAST_LENGTH_CODE_INDEX) /*length code*/
    {
      unsigned code_d, distance;
      unsigned numextrabits_l, numextrabits_d; /*extra bits for length and distance*/
      size_t start, forward, backward, length;

      /*part 1: get length base*/
      length = LENGTHBASE[code_ll - FIRST_LENGTH_CODE_INDEX];

      /*part 2: get extra bits and add the value of that to length*/
      numextrabits_l = LENGTHEXTRA[code_ll - FIRST_LENGTH_CODE_INDEX];
      if(*bp >= inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/
      length += readBitsFromStream(bp, in, numextrabits_l);

      /*part 3: get distance code*/
      code_d = huffmanDecodeSymbol(in, bp, &tree_d, inbitlength);
      if(code_d > 29)
      {
        if(code_ll == (unsigned)(-1)) /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
        {
          /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
          (10=no endcode, 11=wrong jump outside of tree)*/
          error = (*bp) > inlength * 8 ? 10 : 11;
        }
        else error = 18; /*error: invalid distance code (30-31 are never used)*/
        break;
      }
      distance = DISTANCEBASE[code_d];

      /*part 4: get extra bits from distance*/
      numextrabits_d = DISTANCEEXTRA[code_d];
      if(*bp >= inbitlength) ERROR_BREAK(51); /*error, bit pointer will jump past memory*/

      distance += readBitsFromStream(bp, in, numextrabits_d);

      /*part 5: fill in all the out[n] values based on the length and dist*/
      start = (*pos);
      if(distance > start) ERROR_BREAK(52); /*too long backward distance*/
      backward = start - distance;
      if((*pos) + length >= out->size)
      {
        /*reserve more room at once*/
        if(!ucvector_resize(out, ((*pos) + length) * 2)) ERROR_BREAK(83 /*alloc fail*/);
      }

      for(forward = 0; forward < length; forward++)
      {
        out->data[(*pos)] = out->data[backward];
        (*pos)++;
        backward++;
        if(backward >= start) backward = start - distance;
      }
    }
    else if(code_ll == 256)
    {
      break; /*end code, break the loop*/
    }
    else /*if(code == (unsigned)(-1))*/ /*huffmanDecodeSymbol returns (unsigned)(-1) in case of error*/
    {
      /*return error code 10 or 11 depending on the situation that happened in huffmanDecodeSymbol
      (10=no endcode, 11=wrong jump outside of tree)*/
      error = (*bp) > inlength * 8 ? 10 : 11;
      break;
    }
  }

  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);

  return error;
}

static unsigned inflateNoCompression(ucvector* out, const unsigned char* in, size_t* bp, size_t* pos, size_t inlength)
{
  /*go to first boundary of byte*/
  size_t p;
  unsigned LEN, NLEN, n, error = 0;
  while(((*bp) & 0x7) != 0) (*bp)++;
  p = (*bp) / 8; /*byte position*/

  /*read LEN (2 bytes) and NLEN (2 bytes)*/
  if(p >= inlength - 4) return 52; /*error, bit pointer will jump past memory*/
  LEN = in[p] + 256 * in[p + 1]; p += 2;
  NLEN = in[p] + 256 * in[p + 1]; p += 2;

  /*check if 16-bit NLEN is really the one's complement of LEN*/
  if(LEN + NLEN != 65535) return 21; /*error: NLEN is not one's complement of LEN*/

  if((*pos) + LEN >= out->size)
  {
    if(!ucvector_resize(out, (*pos) + LEN)) return 83; /*alloc fail*/
  }

  /*read the literal data: LEN bytes are now stored in the out buffer*/
  if(p + LEN > inlength) return 23; /*error: reading outside of in buffer*/
  for(n = 0; n < LEN; n++) out->data[(*pos)++] = in[p++];

  (*bp) = p * 8;

  return error;
}

static unsigned lodepng_inflatev(ucvector* out,
                                 const unsigned char* in, size_t insize,
                                 const LodePNGDecompressSettings* settings)
{
  /*bit pointer in the "in" data, current byte is bp >> 3, current bit is bp & 0x7 (from lsb to msb of the byte)*/
  size_t bp = 0;
  unsigned BFINAL = 0;
  size_t pos = 0; /*byte position in the out buffer*/

  unsigned error = 0;

  (void)settings;

  while(!BFINAL)
  {
    unsigned BTYPE;
    if(bp + 2 >= insize * 8) return 52; /*error, bit pointer will jump past memory*/
    BFINAL = readBitFromStream(&bp, in);
    BTYPE = 1 * readBitFromStream(&bp, in);
    BTYPE += 2 * readBitFromStream(&bp, in);

    if(BTYPE == 3) return 20; /*error: invalid BTYPE*/
    else if(BTYPE == 0) error = inflateNoCompression(out, in, &bp, &pos, insize); /*no compression*/
    else error = inflateHuffmanBlock(out, in, &bp, &pos, insize, BTYPE); /*compression, BTYPE 01 or 10*/

    if(error) return error;
  }

  /*Only now we know the true size of out, resize it to that*/
  if(!ucvector_resize(out, pos)) error = 83; /*alloc fail*/

  return error;
}

unsigned lodepng_inflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGDecompressSettings* settings)
{
  unsigned error;
  ucvector v;
  ucvector_init_buffer(&v, *out, *outsize);
  error = lodepng_inflatev(&v, in, insize, settings);
  *out = v.data;
  *outsize = v.size;
  return error;
}

static unsigned inflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGDecompressSettings* settings)
{
  if(settings->custom_inflate)
  {
    return settings->custom_inflate(out, outsize, in, insize, settings);
  }
  else
  {
    return lodepng_inflate(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / Deflator (Compressor)                                                  / */
/* ////////////////////////////////////////////////////////////////////////// */

static const size_t MAX_SUPPORTED_DEFLATE_LENGTH = 258;

/*bitlen is the size in bits of the code*/
static void addHuffmanSymbol(size_t* bp, ucvector* compressed, unsigned code, unsigned bitlen)
{
  addBitsToStreamReversed(bp, compressed, code, bitlen);
}

/*search the index in the array, that has the largest value smaller than or equal to the given value,
given array must be sorted (if no value is smaller, it returns the size of the given array)*/
static size_t searchCodeIndex(const unsigned* array, size_t array_size, size_t value)
{
  /*linear search implementation*/
  /*for(size_t i = 1; i < array_size; i++) if(array[i] > value) return i - 1;
  return array_size - 1;*/

  /*binary search implementation (not that much faster) (precondition: array_size > 0)*/
  size_t left  = 1;
  size_t right = array_size - 1;
  while(left <= right)
  {
    size_t mid = (left + right) / 2;
    if(array[mid] <= value) left = mid + 1; /*the value to find is more to the right*/
    else if(array[mid - 1] > value) right = mid - 1; /*the value to find is more to the left*/
    else return mid - 1;
  }
  return array_size - 1;
}

static void addLengthDistance(uivector* values, size_t length, size_t distance)
{
  /*values in encoded vector are those used by deflate:
  0-255: literal bytes
  256: end
  257-285: length/distance pair (length code, followed by extra length bits, distance code, extra distance bits)
  286-287: invalid*/

  unsigned length_code = (unsigned)searchCodeIndex(LENGTHBASE, 29, length);
  unsigned extra_length = (unsigned)(length - LENGTHBASE[length_code]);
  unsigned dist_code = (unsigned)searchCodeIndex(DISTANCEBASE, 30, distance);
  unsigned extra_distance = (unsigned)(distance - DISTANCEBASE[dist_code]);

  uivector_push_back(values, length_code + FIRST_LENGTH_CODE_INDEX);
  uivector_push_back(values, extra_length);
  uivector_push_back(values, dist_code);
  uivector_push_back(values, extra_distance);
}

static const unsigned HASH_NUM_VALUES = 65536;
static const unsigned HASH_NUM_CHARACTERS = 3;
static const unsigned HASH_SHIFT = 2;
/*
The HASH_NUM_CHARACTERS value is used to make encoding faster by using longer
sequences to generate a hash value from the stream bytes. Setting it to 3
gives exactly the same compression as the brute force method, since deflate's
run length encoding starts with lengths of 3. Setting it to higher values,
like 6, can make the encoding faster (not always though!), but will cause the
encoding to miss any length between 3 and this value, so that the compression
may be worse (but this can vary too depending on the image, sometimes it is
even a bit better instead).
The HASH_NUM_VALUES is the amount of unique possible hash values that
combinations of bytes can give, the higher it is the more memory is needed, but
if it's too low the advantage of hashing is gone.
*/

typedef struct Hash
{
  int* head; /*hash value to head circular pos*/
  int* val; /*circular pos to hash value*/
  /*circular pos to prev circular pos*/
  unsigned short* chain;
  unsigned short* zeros;
} Hash;

static unsigned hash_init(Hash* hash, unsigned windowsize)
{
  unsigned i;
  hash->head = (int*)lodepng_malloc(sizeof(int) * HASH_NUM_VALUES);
  hash->val = (int*)lodepng_malloc(sizeof(int) * windowsize);
  hash->chain = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);
  hash->zeros = (unsigned short*)lodepng_malloc(sizeof(unsigned short) * windowsize);

  if(!hash->head || !hash->val || !hash->chain || !hash->zeros) return 83; /*alloc fail*/

  /*initialize hash table*/
  for(i = 0; i < HASH_NUM_VALUES; i++) hash->head[i] = -1;
  for(i = 0; i < windowsize; i++) hash->val[i] = -1;
  for(i = 0; i < windowsize; i++) hash->chain[i] = i; /*same value as index indicates uninitialized*/

  return 0;
}

static void hash_cleanup(Hash* hash)
{
  lodepng_free(hash->head);
  lodepng_free(hash->val);
  lodepng_free(hash->chain);
  lodepng_free(hash->zeros);
}

static unsigned getHash(const unsigned char* data, size_t size, size_t pos)
{
  unsigned result = 0;
  size_t amount, i;
  if(pos >= size) return 0;
  amount = HASH_NUM_CHARACTERS;
  if(pos + amount >= size) amount = size - pos;
  for(i = 0; i < amount; i++) result ^= (data[pos + i] << (i * HASH_SHIFT));
  return result % HASH_NUM_VALUES;
}

static unsigned countZeros(const unsigned char* data, size_t size, size_t pos)
{
  const unsigned char* start = data + pos;
  const unsigned char* end = start + MAX_SUPPORTED_DEFLATE_LENGTH;
  if(end > data + size) end = data + size;
  data = start;
  while (data != end && *data == 0) data++;
  /*subtracting two addresses returned as 32-bit number (max value is MAX_SUPPORTED_DEFLATE_LENGTH)*/
  return (unsigned)(data - start);
}

static void updateHashChain(Hash* hash, size_t pos, int hashval, unsigned windowsize)
{
  unsigned wpos = pos % windowsize;
  hash->val[wpos] = hashval;
  if(hash->head[hashval] != -1) hash->chain[wpos] = hash->head[hashval];
  hash->head[hashval] = wpos;
}

/*
LZ77-encode the data. Return value is error code. The input are raw bytes, the output
is in the form of unsigned integers with codes representing for example literal bytes, or
length/distance pairs.
It uses a hash table technique to let it encode faster. When doing LZ77 encoding, a
sliding window (of windowsize) is used, and all past bytes in that window can be used as
the "dictionary". A brute force search through all possible distances would be slow, and
this hash technique is one out of several ways to speed this up.
*/
static unsigned encodeLZ77(uivector* out, Hash* hash,
                           const unsigned char* in, size_t inpos, size_t insize, unsigned windowsize,
                           unsigned minmatch, unsigned nicematch, unsigned lazymatching)
{
  unsigned short numzeros = 0;
  int usezeros = windowsize >= 8192; /*for small window size, the 'max chain length' optimization does a better job*/
  unsigned pos, i, error = 0;
  /*for large window lengths, assume the user wants no compression loss. Otherwise, max hash chain length speedup.*/
  unsigned maxchainlength = windowsize >= 8192 ? windowsize : windowsize / 8;
  unsigned maxlazymatch = windowsize >= 8192 ? MAX_SUPPORTED_DEFLATE_LENGTH : 64;

  if(!error)
  {
    unsigned offset; /*the offset represents the distance in LZ77 terminology*/
    unsigned length;
    unsigned lazy = 0;
    unsigned lazylength = 0, lazyoffset = 0;
    unsigned hashval;
    unsigned current_offset, current_length;
    const unsigned char *lastptr, *foreptr, *backptr;
    unsigned short hashpos, prevpos;

    for(pos = inpos; pos < insize; pos++)
    {
      size_t wpos = pos % windowsize; /*position for in 'circular' hash buffers*/

      hashval = getHash(in, insize, pos);
      updateHashChain(hash, pos, hashval, windowsize);

      if(usezeros && hashval == 0)
      {
        numzeros = countZeros(in, insize, pos);
        hash->zeros[wpos] = numzeros;
      }

      /*the length and offset found for the current position*/
      length = 0;
      offset = 0;

      prevpos = hash->head[hashval];
      hashpos = hash->chain[prevpos];

      lastptr = &in[insize < pos + MAX_SUPPORTED_DEFLATE_LENGTH ? insize : pos + MAX_SUPPORTED_DEFLATE_LENGTH];

      /*search for the longest string*/
      if(hash->val[wpos] == (int)hashval)
      {
        unsigned chainlength = 0;
        for(;;)
        {
          /*stop when went completely around the circular buffer*/
          if(prevpos < wpos && hashpos > prevpos && hashpos <= wpos) break;
          if(prevpos > wpos && (hashpos <= wpos || hashpos > prevpos)) break;
          if(chainlength++ >= maxchainlength) break;

          current_offset = hashpos <= wpos ? wpos - hashpos : wpos - hashpos + windowsize;
          if(current_offset > 0)
          {
            /*test the next characters*/
            foreptr = &in[pos];
            backptr = &in[pos - current_offset];

            /*common case in PNGs is lots of zeros. Quickly skip over them as a speedup*/
            if(usezeros && hashval == 0 && hash->val[hashpos] == 0 /*hashval[hashpos] may be out of date*/)
            {
              unsigned short skip = hash->zeros[hashpos];
              if(skip > numzeros) skip = numzeros;
              backptr += skip;
              foreptr += skip;
            }

            /* multiple checks at once per array bounds check */
            while(foreptr != lastptr && *backptr == *foreptr) /*maximum supported length by deflate is max length*/
            {
              ++backptr;
              ++foreptr;
            }
            current_length = (unsigned)(foreptr - &in[pos]);

            if(current_length > length)
            {
              length = current_length; /*the longest length*/
              offset = current_offset; /*the offset that is related to this longest length*/
              /*jump out once a length of max length is found (speed gain)*/
              if(current_length >= nicematch || current_length == MAX_SUPPORTED_DEFLATE_LENGTH) break;
            }
          }

          if(hashpos == hash->chain[hashpos]) break;

          prevpos = hashpos;
          hashpos = hash->chain[hashpos];
        }
      }

      if(lazymatching)
      {
        if(!lazy && length >= 3 && length <= maxlazymatch && length < MAX_SUPPORTED_DEFLATE_LENGTH)
        {
          lazy = 1;
          lazylength = length;
          lazyoffset = offset;
          continue; /*try the next byte*/
        }
        if(lazy)
        {
          lazy = 0;
          if(pos == 0) ERROR_BREAK(81);
          if(length > lazylength + 1)
          {
            /*push the previous character as literal*/
            if(!uivector_push_back(out, in[pos - 1])) ERROR_BREAK(83 /*alloc fail*/);
          }
          else
          {
            length = lazylength;
            offset = lazyoffset;
            hash->head[hashval] = -1; /*the same hashchain update will be done, this ensures no wrong alteration*/
            pos--;
          }
        }
      }
      if(length >= 3 && offset > windowsize) ERROR_BREAK(86 /*too big (or overflown negative) offset*/);

      /**encode it as length/distance pair or literal value**/
      if(length < 3) /*only lengths of 3 or higher are supported as length/distance pair*/
      {
        if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
      }
      else if(length < minmatch || (length == 3 && offset > 4096))
      {
        /*compensate for the fact that longer offsets have more extra bits, a
        length of only 3 may be not worth it then*/
        if(!uivector_push_back(out, in[pos])) ERROR_BREAK(83 /*alloc fail*/);
      }
      else
      {
        addLengthDistance(out, length, offset);
        for(i = 1; i < length; i++)
        {
          pos++;
          hashval = getHash(in, insize, pos);
          updateHashChain(hash, pos, hashval, windowsize);
          if(usezeros && hashval == 0)
          {
            hash->zeros[pos % windowsize] = countZeros(in, insize, pos);
          }
        }
      }

    } /*end of the loop through each character of input*/
  } /*end of "if(!error)"*/

  return error;
}

/* /////////////////////////////////////////////////////////////////////////// */

static unsigned deflateNoCompression(ucvector* out, const unsigned char* data, size_t datasize)
{
  /*non compressed deflate block data: 1 bit BFINAL,2 bits BTYPE,(5 bits): it jumps to start of next byte,
  2 bytes LEN, 2 bytes NLEN, LEN bytes literal DATA*/

  size_t i, j, numdeflateblocks = (datasize + 65534) / 65535;
  unsigned datapos = 0;
  for(i = 0; i < numdeflateblocks; i++)
  {
    unsigned BFINAL, BTYPE, LEN, NLEN;
    unsigned char firstbyte;

    BFINAL = (i == numdeflateblocks - 1);
    BTYPE = 0;

    firstbyte = (unsigned char)(BFINAL + ((BTYPE & 1) << 1) + ((BTYPE & 2) << 1));
    ucvector_push_back(out, firstbyte);

    LEN = 65535;
    if(datasize - datapos < 65535) LEN = (unsigned)datasize - datapos;
    NLEN = 65535 - LEN;

    ucvector_push_back(out, (unsigned char)(LEN % 256));
    ucvector_push_back(out, (unsigned char)(LEN / 256));
    ucvector_push_back(out, (unsigned char)(NLEN % 256));
    ucvector_push_back(out, (unsigned char)(NLEN / 256));

    /*Decompressed data*/
    for(j = 0; j < 65535 && datapos < datasize; j++)
    {
      ucvector_push_back(out, data[datapos++]);
    }
  }

  return 0;
}

/*
write the lz77-encoded data, which has lit, len and dist codes, to compressed stream using huffman trees.
tree_ll: the tree for lit and len codes.
tree_d: the tree for distance codes.
*/
static void writeLZ77data(size_t* bp, ucvector* out, const uivector* lz77_encoded,
                          const HuffmanTree* tree_ll, const HuffmanTree* tree_d)
{
  size_t i = 0;
  for(i = 0; i < lz77_encoded->size; i++)
  {
    unsigned val = lz77_encoded->data[i];
    addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_ll, val), HuffmanTree_getLength(tree_ll, val));
    if(val > 256) /*for a length code, 3 more things have to be added*/
    {
      unsigned length_index = val - FIRST_LENGTH_CODE_INDEX;
      unsigned n_length_extra_bits = LENGTHEXTRA[length_index];
      unsigned length_extra_bits = lz77_encoded->data[++i];

      unsigned distance_code = lz77_encoded->data[++i];

      unsigned distance_index = distance_code;
      unsigned n_distance_extra_bits = DISTANCEEXTRA[distance_index];
      unsigned distance_extra_bits = lz77_encoded->data[++i];

      addBitsToStream(bp, out, length_extra_bits, n_length_extra_bits);
      addHuffmanSymbol(bp, out, HuffmanTree_getCode(tree_d, distance_code),
                       HuffmanTree_getLength(tree_d, distance_code));
      addBitsToStream(bp, out, distance_extra_bits, n_distance_extra_bits);
    }
  }
}

/*Deflate for a block of type "dynamic", that is, with freely, optimally, created huffman trees*/
static unsigned deflateDynamic(ucvector* out, size_t* bp, Hash* hash,
                               const unsigned char* data, size_t datapos, size_t dataend,
                               const LodePNGCompressSettings* settings, int final)
{
  unsigned error = 0;

  /*
  A block is compressed as follows: The PNG data is lz77 encoded, resulting in
  literal bytes and length/distance pairs. This is then huffman compressed with
  two huffman trees. One huffman tree is used for the lit and len values ("ll"),
  another huffman tree is used for the dist values ("d"). These two trees are
  stored using their code lengths, and to compress even more these code lengths
  are also run-length encoded and huffman compressed. This gives a huffman tree
  of code lengths "cl". The code lenghts used to describe this third tree are
  the code length code lengths ("clcl").
  */

  /*The lz77 encoded data, represented with integers since there will also be length and distance codes in it*/
  uivector lz77_encoded;
  HuffmanTree tree_ll; /*tree for lit,len values*/
  HuffmanTree tree_d; /*tree for distance codes*/
  HuffmanTree tree_cl; /*tree for encoding the code lengths representing tree_ll and tree_d*/
  uivector frequencies_ll; /*frequency of lit,len codes*/
  uivector frequencies_d; /*frequency of dist codes*/
  uivector frequencies_cl; /*frequency of code length codes*/
  uivector bitlen_lld; /*lit,len,dist code lenghts (int bits), literally (without repeat codes).*/
  uivector bitlen_lld_e; /*bitlen_lld encoded with repeat codes (this is a rudemtary run length compression)*/
  /*bitlen_cl is the code length code lengths ("clcl"). The bit lengths of codes to represent tree_cl
  (these are written as is in the file, it would be crazy to compress these using yet another huffman
  tree that needs to be represented by yet another set of code lengths)*/
  uivector bitlen_cl;
  size_t datasize = dataend - datapos;

  /*
  Due to the huffman compression of huffman tree representations ("two levels"), there are some anologies:
  bitlen_lld is to tree_cl what data is to tree_ll and tree_d.
  bitlen_lld_e is to bitlen_lld what lz77_encoded is to data.
  bitlen_cl is to bitlen_lld_e what bitlen_lld is to lz77_encoded.
  */

  unsigned BFINAL = final;
  size_t numcodes_ll, numcodes_d, i;
  unsigned HLIT, HDIST, HCLEN;

  uivector_init(&lz77_encoded);
  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);
  HuffmanTree_init(&tree_cl);
  uivector_init(&frequencies_ll);
  uivector_init(&frequencies_d);
  uivector_init(&frequencies_cl);
  uivector_init(&bitlen_lld);
  uivector_init(&bitlen_lld_e);
  uivector_init(&bitlen_cl);

  /*This while loop never loops due to a break at the end, it is here to
  allow breaking out of it to the cleanup phase on error conditions.*/
  while(!error)
  {
    if(settings->use_lz77)
    {
      error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                         settings->minmatch, settings->nicematch, settings->lazymatching);
      if(error) break;
    }
    else
    {
      if(!uivector_resize(&lz77_encoded, datasize)) ERROR_BREAK(83 /*alloc fail*/);
      for(i = datapos; i < dataend; i++) lz77_encoded.data[i] = data[i]; /*no LZ77, but still will be Huffman compressed*/
    }

    if(!uivector_resizev(&frequencies_ll, 286, 0)) ERROR_BREAK(83 /*alloc fail*/);
    if(!uivector_resizev(&frequencies_d, 30, 0)) ERROR_BREAK(83 /*alloc fail*/);

    /*Count the frequencies of lit, len and dist codes*/
    for(i = 0; i < lz77_encoded.size; i++)
    {
      unsigned symbol = lz77_encoded.data[i];
      frequencies_ll.data[symbol]++;
      if(symbol > 256)
      {
        unsigned dist = lz77_encoded.data[i + 2];
        frequencies_d.data[dist]++;
        i += 3;
      }
    }
    frequencies_ll.data[256] = 1; /*there will be exactly 1 end code, at the end of the block*/

    /*Make both huffman trees, one for the lit and len codes, one for the dist codes*/
    error = HuffmanTree_makeFromFrequencies(&tree_ll, frequencies_ll.data, 257, frequencies_ll.size, 15);
    if(error) break;
    /*2, not 1, is chosen for mincodes: some buggy PNG decoders require at least 2 symbols in the dist tree*/
    error = HuffmanTree_makeFromFrequencies(&tree_d, frequencies_d.data, 2, frequencies_d.size, 15);
    if(error) break;

    numcodes_ll = tree_ll.numcodes; if(numcodes_ll > 286) numcodes_ll = 286;
    numcodes_d = tree_d.numcodes; if(numcodes_d > 30) numcodes_d = 30;
    /*store the code lengths of both generated trees in bitlen_lld*/
    for(i = 0; i < numcodes_ll; i++) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_ll, (unsigned)i));
    for(i = 0; i < numcodes_d; i++) uivector_push_back(&bitlen_lld, HuffmanTree_getLength(&tree_d, (unsigned)i));

    /*run-length compress bitlen_ldd into bitlen_lld_e by using repeat codes 16 (copy length 3-6 times),
    17 (3-10 zeroes), 18 (11-138 zeroes)*/
    for(i = 0; i < (unsigned)bitlen_lld.size; i++)
    {
      unsigned j = 0; /*amount of repititions*/
      while(i + j + 1 < (unsigned)bitlen_lld.size && bitlen_lld.data[i + j + 1] == bitlen_lld.data[i]) j++;

      if(bitlen_lld.data[i] == 0 && j >= 2) /*repeat code for zeroes*/
      {
        j++; /*include the first zero*/
        if(j <= 10) /*repeat code 17 supports max 10 zeroes*/
        {
          uivector_push_back(&bitlen_lld_e, 17);
          uivector_push_back(&bitlen_lld_e, j - 3);
        }
        else /*repeat code 18 supports max 138 zeroes*/
        {
          if(j > 138) j = 138;
          uivector_push_back(&bitlen_lld_e, 18);
          uivector_push_back(&bitlen_lld_e, j - 11);
        }
        i += (j - 1);
      }
      else if(j >= 3) /*repeat code for value other than zero*/
      {
        size_t k;
        unsigned num = j / 6, rest = j % 6;
        uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);
        for(k = 0; k < num; k++)
        {
          uivector_push_back(&bitlen_lld_e, 16);
          uivector_push_back(&bitlen_lld_e, 6 - 3);
        }
        if(rest >= 3)
        {
          uivector_push_back(&bitlen_lld_e, 16);
          uivector_push_back(&bitlen_lld_e, rest - 3);
        }
        else j -= rest;
        i += j;
      }
      else /*too short to benefit from repeat code*/
      {
        uivector_push_back(&bitlen_lld_e, bitlen_lld.data[i]);
      }
    }

    /*generate tree_cl, the huffmantree of huffmantrees*/

    if(!uivector_resizev(&frequencies_cl, NUM_CODE_LENGTH_CODES, 0)) ERROR_BREAK(83 /*alloc fail*/);
    for(i = 0; i < bitlen_lld_e.size; i++)
    {
      frequencies_cl.data[bitlen_lld_e.data[i]]++;
      /*after a repeat code come the bits that specify the number of repetitions,
      those don't need to be in the frequencies_cl calculation*/
      if(bitlen_lld_e.data[i] >= 16) i++;
    }

    error = HuffmanTree_makeFromFrequencies(&tree_cl, frequencies_cl.data,
                                            frequencies_cl.size, frequencies_cl.size, 7);
    if(error) break;

    if(!uivector_resize(&bitlen_cl, tree_cl.numcodes)) ERROR_BREAK(83 /*alloc fail*/);
    for(i = 0; i < tree_cl.numcodes; i++)
    {
      /*lenghts of code length tree is in the order as specified by deflate*/
      bitlen_cl.data[i] = HuffmanTree_getLength(&tree_cl, CLCL_ORDER[i]);
    }
    while(bitlen_cl.data[bitlen_cl.size - 1] == 0 && bitlen_cl.size > 4)
    {
      /*remove zeros at the end, but minimum size must be 4*/
      if(!uivector_resize(&bitlen_cl, bitlen_cl.size - 1)) ERROR_BREAK(83 /*alloc fail*/);
    }
    if(error) break;

    /*
    Write everything into the output

    After the BFINAL and BTYPE, the dynamic block consists out of the following:
    - 5 bits HLIT, 5 bits HDIST, 4 bits HCLEN
    - (HCLEN+4)*3 bits code lengths of code length alphabet
    - HLIT + 257 code lenghts of lit/length alphabet (encoded using the code length
      alphabet, + possible repetition codes 16, 17, 18)
    - HDIST + 1 code lengths of distance alphabet (encoded using the code length
      alphabet, + possible repetition codes 16, 17, 18)
    - compressed data
    - 256 (end code)
    */

    /*Write block type*/
    addBitToStream(bp, out, BFINAL);
    addBitToStream(bp, out, 0); /*first bit of BTYPE "dynamic"*/
    addBitToStream(bp, out, 1); /*second bit of BTYPE "dynamic"*/

    /*write the HLIT, HDIST and HCLEN values*/
    HLIT = (unsigned)(numcodes_ll - 257);
    HDIST = (unsigned)(numcodes_d - 1);
    HCLEN = (unsigned)bitlen_cl.size - 4;
    /*trim zeroes for HCLEN. HLIT and HDIST were already trimmed at tree creation*/
    while(!bitlen_cl.data[HCLEN + 4 - 1] && HCLEN > 0) HCLEN--;
    addBitsToStream(bp, out, HLIT, 5);
    addBitsToStream(bp, out, HDIST, 5);
    addBitsToStream(bp, out, HCLEN, 4);

    /*write the code lenghts of the code length alphabet*/
    for(i = 0; i < HCLEN + 4; i++) addBitsToStream(bp, out, bitlen_cl.data[i], 3);

    /*write the lenghts of the lit/len AND the dist alphabet*/
    for(i = 0; i < bitlen_lld_e.size; i++)
    {
      addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_cl, bitlen_lld_e.data[i]),
                       HuffmanTree_getLength(&tree_cl, bitlen_lld_e.data[i]));
      /*extra bits of repeat codes*/
      if(bitlen_lld_e.data[i] == 16) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 2);
      else if(bitlen_lld_e.data[i] == 17) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 3);
      else if(bitlen_lld_e.data[i] == 18) addBitsToStream(bp, out, bitlen_lld_e.data[++i], 7);
    }

    /*write the compressed data symbols*/
    writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);
    /*error: the length of the end code 256 must be larger than 0*/
    if(HuffmanTree_getLength(&tree_ll, 256) == 0) ERROR_BREAK(64);

    /*write the end code*/
    addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));

    break; /*end of error-while*/
  }

  /*cleanup*/
  uivector_cleanup(&lz77_encoded);
  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);
  HuffmanTree_cleanup(&tree_cl);
  uivector_cleanup(&frequencies_ll);
  uivector_cleanup(&frequencies_d);
  uivector_cleanup(&frequencies_cl);
  uivector_cleanup(&bitlen_lld_e);
  uivector_cleanup(&bitlen_lld);
  uivector_cleanup(&bitlen_cl);

  return error;
}

static unsigned deflateFixed(ucvector* out, size_t* bp, Hash* hash,
                             const unsigned char* data,
                             size_t datapos, size_t dataend,
                             const LodePNGCompressSettings* settings, int final)
{
  HuffmanTree tree_ll; /*tree for literal values and length codes*/
  HuffmanTree tree_d; /*tree for distance codes*/

  unsigned BFINAL = final;
  unsigned error = 0;
  size_t i;

  HuffmanTree_init(&tree_ll);
  HuffmanTree_init(&tree_d);

  generateFixedLitLenTree(&tree_ll);
  generateFixedDistanceTree(&tree_d);

  addBitToStream(bp, out, BFINAL);
  addBitToStream(bp, out, 1); /*first bit of BTYPE*/
  addBitToStream(bp, out, 0); /*second bit of BTYPE*/

  if(settings->use_lz77) /*LZ77 encoded*/
  {
    uivector lz77_encoded;
    uivector_init(&lz77_encoded);
    error = encodeLZ77(&lz77_encoded, hash, data, datapos, dataend, settings->windowsize,
                       settings->minmatch, settings->nicematch, settings->lazymatching);
    if(!error) writeLZ77data(bp, out, &lz77_encoded, &tree_ll, &tree_d);
    uivector_cleanup(&lz77_encoded);
  }
  else /*no LZ77, but still will be Huffman compressed*/
  {
    for(i = datapos; i < dataend; i++)
    {
      addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, data[i]), HuffmanTree_getLength(&tree_ll, data[i]));
    }
  }
  /*add END code*/
  if(!error) addHuffmanSymbol(bp, out, HuffmanTree_getCode(&tree_ll, 256), HuffmanTree_getLength(&tree_ll, 256));

  /*cleanup*/
  HuffmanTree_cleanup(&tree_ll);
  HuffmanTree_cleanup(&tree_d);

  return error;
}

static unsigned lodepng_deflatev(ucvector* out, const unsigned char* in, size_t insize,
                                 const LodePNGCompressSettings* settings)
{
  unsigned error = 0;
  size_t i, blocksize, numdeflateblocks;
  size_t bp = 0; /*the bit pointer*/
  Hash hash;

  if(settings->btype > 2) return 61;
  else if(settings->btype == 0) return deflateNoCompression(out, in, insize);
  else if(settings->btype == 1) blocksize = insize;
  else /*if(settings->btype == 2)*/
  {
    blocksize = insize / 8 + 8;
    if(blocksize < 65535) blocksize = 65535;
  }

  numdeflateblocks = (insize + blocksize - 1) / blocksize;
  if(numdeflateblocks == 0) numdeflateblocks = 1;

  error = hash_init(&hash, settings->windowsize);
  if(error) return error;

  for(i = 0; i < numdeflateblocks && !error; i++)
  {
    int final = i == numdeflateblocks - 1;
    size_t start = i * blocksize;
    size_t end = start + blocksize;
    if(end > insize) end = insize;

    if(settings->btype == 1) error = deflateFixed(out, &bp, &hash, in, start, end, settings, final);
    else if(settings->btype == 2) error = deflateDynamic(out, &bp, &hash, in, start, end, settings, final);
  }

  hash_cleanup(&hash);

  return error;
}

unsigned lodepng_deflate(unsigned char** out, size_t* outsize,
                         const unsigned char* in, size_t insize,
                         const LodePNGCompressSettings* settings)
{
  unsigned error;
  ucvector v;
  ucvector_init_buffer(&v, *out, *outsize);
  error = lodepng_deflatev(&v, in, insize, settings);
  *out = v.data;
  *outsize = v.size;
  return error;
}

static unsigned deflate(unsigned char** out, size_t* outsize,
                        const unsigned char* in, size_t insize,
                        const LodePNGCompressSettings* settings)
{
  if(settings->custom_deflate)
  {
    return settings->custom_deflate(out, outsize, in, insize, settings);
  }
  else
  {
    return lodepng_deflate(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* / Adler32                                                                  */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned update_adler32(unsigned adler, const unsigned char* data, unsigned len)
{
   unsigned s1 = adler & 0xffff;
   unsigned s2 = (adler >> 16) & 0xffff;

  while(len > 0)
  {
    /*at least 5550 sums can be done before the sums overflow, saving a lot of module divisions*/
    unsigned amount = len > 5550 ? 5550 : len;
    len -= amount;
    while(amount > 0)
    {
      s1 += (*data++);
      s2 += s1;
      amount--;
    }
    s1 %= 65521;
    s2 %= 65521;
  }

  return (s2 << 16) | s1;
}

/*Return the adler32 of the bytes data[0..len-1]*/
static unsigned adler32(const unsigned char* data, unsigned len)
{
  return update_adler32(1L, data, len);
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Zlib                                                                   / */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_DECODER

unsigned lodepng_zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                 size_t insize, const LodePNGDecompressSettings* settings)
{
  unsigned error = 0;
  unsigned CM, CINFO, FDICT;

  if(insize < 2) return 53; /*error, size of zlib data too small*/
  /*read information from zlib header*/
  if((in[0] * 256 + in[1]) % 31 != 0)
  {
    /*error: 256 * in[0] + in[1] must be a multiple of 31, the FCHECK value is supposed to be made that way*/
    return 24;
  }

  CM = in[0] & 15;
  CINFO = (in[0] >> 4) & 15;
  /*FCHECK = in[1] & 31;*/ /*FCHECK is already tested above*/
  FDICT = (in[1] >> 5) & 1;
  /*FLEVEL = (in[1] >> 6) & 3;*/ /*FLEVEL is not used here*/

  if(CM != 8 || CINFO > 7)
  {
    /*error: only compression method 8: inflate with sliding window of 32k is supported by the PNG spec*/
    return 25;
  }
  if(FDICT != 0)
  {
    /*error: the specification of PNG says about the zlib stream:
      "The additional flags shall not specify a preset dictionary."*/
    return 26;
  }

  error = inflate(out, outsize, in + 2, insize - 2, settings);
  if(error) return error;

  if(!settings->ignore_adler32)
  {
    unsigned ADLER32 = lodepng_read32bitInt(&in[insize - 4]);
    unsigned checksum = adler32(*out, (unsigned)(*outsize));
    if(checksum != ADLER32) return 58; /*error, adler checksum not correct, data must be corrupted*/
  }

  return 0; /*no error*/
}

static unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                size_t insize, const LodePNGDecompressSettings* settings)
{
  if(settings->custom_zlib)
    return settings->custom_zlib(out, outsize, in, insize, settings);
  else
    return lodepng_zlib_decompress(out, outsize, in, insize, settings);
}

#endif /*LODEPNG_COMPILE_DECODER*/

#ifdef LODEPNG_COMPILE_ENCODER

unsigned lodepng_zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                               size_t insize, const LodePNGCompressSettings* settings)
{
  /*initially, *out must be NULL and outsize 0, if you just give some random *out
  that's pointing to a non allocated buffer, this'll crash*/
  ucvector outv;
  size_t i;
  unsigned error;
  unsigned char* deflatedata = 0;
  size_t deflatesize = 0;

  unsigned ADLER32;
  /*zlib data: 1 byte CMF (CM+CINFO), 1 byte FLG, deflate data, 4 byte ADLER32 checksum of the Decompressed data*/
  unsigned CMF = 120; /*0b01111000: CM 8, CINFO 7. With CINFO 7, any window size up to 32768 can be used.*/
  unsigned FLEVEL = 0;
  unsigned FDICT = 0;
  unsigned CMFFLG = 256 * CMF + FDICT * 32 + FLEVEL * 64;
  unsigned FCHECK = 31 - CMFFLG % 31;
  CMFFLG += FCHECK;

  /*ucvector-controlled version of the output buffer, for dynamic array*/
  ucvector_init_buffer(&outv, *out, *outsize);

  ucvector_push_back(&outv, (unsigned char)(CMFFLG / 256));
  ucvector_push_back(&outv, (unsigned char)(CMFFLG % 256));

  error = deflate(&deflatedata, &deflatesize, in, insize, settings);

  if(!error)
  {
    ADLER32 = adler32(in, (unsigned)insize);
    for(i = 0; i < deflatesize; i++) ucvector_push_back(&outv, deflatedata[i]);
    lodepng_free(deflatedata);
    lodepng_add32bitInt(&outv, ADLER32);
  }

  *out = outv.data;
  *outsize = outv.size;

  return error;
}

/* compress using the default or custom zlib function */
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings)
{
  if(settings->custom_zlib)
  {
    return settings->custom_zlib(out, outsize, in, insize, settings);
  }
  else
  {
    return lodepng_zlib_compress(out, outsize, in, insize, settings);
  }
}

#endif /*LODEPNG_COMPILE_ENCODER*/

#else /*no LODEPNG_COMPILE_ZLIB*/

#ifdef LODEPNG_COMPILE_DECODER
static unsigned zlib_decompress(unsigned char** out, size_t* outsize, const unsigned char* in,
                                size_t insize, const LodePNGDecompressSettings* settings)
{
  if (!settings->custom_zlib) return 87; /*no custom zlib function provided */
  return settings->custom_zlib(out, outsize, in, insize, settings);
}
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
static unsigned zlib_compress(unsigned char** out, size_t* outsize, const unsigned char* in,
                              size_t insize, const LodePNGCompressSettings* settings)
{
  if (!settings->custom_zlib) return 87; /*no custom zlib function provided */
  return settings->custom_zlib(out, outsize, in, insize, settings);
}
#endif /*LODEPNG_COMPILE_ENCODER*/

#endif /*LODEPNG_COMPILE_ZLIB*/

/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_ENCODER

/*this is a good tradeoff between speed and compression ratio*/
#define DEFAULT_WINDOWSIZE 2048

void lodepng_compress_settings_init(LodePNGCompressSettings* settings)
{
  /*compress with dynamic huffman tree (not in the mathematical sense, just not the predefined one)*/
  settings->btype = 2;
  settings->use_lz77 = 1;
  settings->windowsize = DEFAULT_WINDOWSIZE;
  settings->minmatch = 3;
  settings->nicematch = 128;
  settings->lazymatching = 1;

  settings->custom_zlib = 0;
  settings->custom_deflate = 0;
  settings->custom_context = 0;
}

const LodePNGCompressSettings lodepng_default_compress_settings = {2, 1, DEFAULT_WINDOWSIZE, 3, 128, 1, 0, 0, 0};


#endif /*LODEPNG_COMPILE_ENCODER*/

#ifdef LODEPNG_COMPILE_DECODER

void lodepng_decompress_settings_init(LodePNGDecompressSettings* settings)
{
  settings->ignore_adler32 = 0;

  settings->custom_zlib = 0;
  settings->custom_inflate = 0;
  settings->custom_context = 0;
}

const LodePNGDecompressSettings lodepng_default_decompress_settings = {0, 0, 0, 0};

#endif /*LODEPNG_COMPILE_DECODER*/

/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */
/* // End of Zlib related code. Begin of PNG related code.                 // */
/* ////////////////////////////////////////////////////////////////////////// */
/* ////////////////////////////////////////////////////////////////////////// */

#ifdef LODEPNG_COMPILE_PNG

/* ////////////////////////////////////////////////////////////////////////// */
/* / CRC32                                                                  / */
/* ////////////////////////////////////////////////////////////////////////// */

/* CRC polynomial: 0xedb88320 */
static unsigned lodepng_crc32_table[256] = {
           0u, 1996959894u, 3993919788u, 2567524794u,  124634137u, 1886057615u, 3915621685u, 2657392035u,
   249268274u, 2044508324u, 3772115230u, 2547177864u,  162941995u, 2125561021u, 3887607047u, 2428444049u,
   498536548u, 1789927666u, 4089016648u, 2227061214u,  450548861u, 1843258603u, 4107580753u, 2211677639u,
   325883990u, 1684777152u, 4251122042u, 2321926636u,  335633487u, 1661365465u, 4195302755u, 2366115317u,
   997073096u, 1281953886u, 3579855332u, 2724688242u, 1006888145u, 1258607687u, 3524101629u, 2768942443u,
   901097722u, 1119000684u, 3686517206u, 2898065728u,  853044451u, 1172266101u, 3705015759u, 2882616665u,
   651767980u, 1373503546u, 3369554304u, 3218104598u,  565507253u, 1454621731u, 3485111705u, 3099436303u,
   671266974u, 1594198024u, 3322730930u, 2970347812u,  795835527u, 1483230225u, 3244367275u, 3060149565u,
  1994146192u,   31158534u, 2563907772u, 4023717930u, 1907459465u,  112637215u, 2680153253u, 3904427059u,
  2013776290u,  251722036u, 2517215374u, 3775830040u, 2137656763u,  141376813u, 2439277719u, 3865271297u,
  1802195444u,  476864866u, 2238001368u, 4066508878u, 1812370925u,  453092731u, 2181625025u, 4111451223u,
  1706088902u,  314042704u, 2344532202u, 4240017532u, 1658658271u,  366619977u, 2362670323u, 4224994405u,
  1303535960u,  984961486u, 2747007092u, 3569037538u, 1256170817u, 1037604311u, 2765210733u, 3554079995u,
  1131014506u,  879679996u, 2909243462u, 3663771856u, 1141124467u,  855842277u, 2852801631u, 3708648649u,
  1342533948u,  654459306u, 3188396048u, 3373015174u, 1466479909u,  544179635u, 3110523913u, 3462522015u,
  1591671054u,  702138776u, 2966460450u, 3352799412u, 1504918807u,  783551873u, 3082640443u, 3233442989u,
  3988292384u, 2596254646u,   62317068u, 1957810842u, 3939845945u, 2647816111u,   81470997u, 1943803523u,
  3814918930u, 2489596804u,  225274430u, 2053790376u, 3826175755u, 2466906013u,  167816743u, 2097651377u,
  4027552580u, 2265490386u,  503444072u, 1762050814u, 4150417245u, 2154129355u,  426522225u, 1852507879u,
  4275313526u, 2312317920u,  282753626u, 1742555852u, 4189708143u, 2394877945u,  397917763u, 1622183637u,
  3604390888u, 2714866558u,  953729732u, 1340076626u, 3518719985u, 2797360999u, 1068828381u, 1219638859u,
  3624741850u, 2936675148u,  906185462u, 1090812512u, 3747672003u, 2825379669u,  829329135u, 1181335161u,
  3412177804u, 3160834842u,  628085408u, 1382605366u, 3423369109u, 3138078467u,  570562233u, 1426400815u,
  3317316542u, 2998733608u,  733239954u, 1555261956u, 3268935591u, 3050360625u,  752459403u, 1541320221u,
  2607071920u, 3965973030u, 1969922972u,   40735498u, 2617837225u, 3943577151u, 1913087877u,   83908371u,
  2512341634u, 3803740692u, 2075208622u,  213261112u, 2463272603u, 3855990285u, 2094854071u,  198958881u,
  2262029012u, 4057260610u, 1759359992u,  534414190u, 2176718541u, 4139329115u, 1873836001u,  414664567u,
  2282248934u, 4279200368u, 1711684554u,  285281116u, 2405801727u, 4167216745u, 1634467795u,  376229701u,
  2685067896u, 3608007406u, 1308918612u,  956543938u, 2808555105u, 3495958263u, 1231636301u, 1047427035u,
  2932959818u, 3654703836u, 1088359270u,  936918000u, 2847714899u, 3736837829u, 1202900863u,  817233897u,
  3183342108u, 3401237130u, 1404277552u,  615818150u, 3134207493u, 3453421203u, 1423857449u,  601450431u,
  3009837614u, 3294710456u, 1567103746u,  711928724u, 3020668471u, 3272380065u, 1510334235u,  755167117u
};

/*Return the CRC of the bytes buf[0..len-1].*/
unsigned lodepng_crc32(const unsigned char* buf, size_t len)
{
  unsigned c = 0xffffffffL;
  size_t n;

  for(n = 0; n < len; n++)
  {
    c = lodepng_crc32_table[(c ^ buf[n]) & 0xff] ^ (c >> 8);
  }
  return c ^ 0xffffffffL;
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Reading and writing single bits and bytes from/to stream for LodePNG   / */
/* ////////////////////////////////////////////////////////////////////////// */

static unsigned char readBitFromReversedStream(size_t* bitpointer, const unsigned char* bitstream)
{
  unsigned char result = (unsigned char)((bitstream[(*bitpointer) >> 3] >> (7 - ((*bitpointer) & 0x7))) & 1);
  (*bitpointer)++;
  return result;
}

static unsigned readBitsFromReversedStream(size_t* bitpointer, const unsigned char* bitstream, size_t nbits)
{
  unsigned result = 0;
  size_t i;
  for(i = nbits - 1; i < nbits; i--)
  {
    result += (unsigned)readBitFromReversedStream(bitpointer, bitstream) << i;
  }
  return result;
}

#ifdef LODEPNG_COMPILE_DECODER
static void setBitOfReversedStream0(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
{
  /*the current bit in bitstream must be 0 for this to work*/
  if(bit)
  {
    /*earlier bit of huffman code is in a lesser significant bit of an earlier byte*/
    bitstream[(*bitpointer) >> 3] |= (bit << (7 - ((*bitpointer) & 0x7)));
  }
  (*bitpointer)++;
}
#endif /*LODEPNG_COMPILE_DECODER*/

static void setBitOfReversedStream(size_t* bitpointer, unsigned char* bitstream, unsigned char bit)
{
  /*the current bit in bitstream may be 0 or 1 for this to work*/
  if(bit == 0) bitstream[(*bitpointer) >> 3] &=  (unsigned char)(~(1 << (7 - ((*bitpointer) & 0x7))));
  else         bitstream[(*bitpointer) >> 3] |=  (1 << (7 - ((*bitpointer) & 0x7)));
  (*bitpointer)++;
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG chunks                                                             / */
/* ////////////////////////////////////////////////////////////////////////// */

unsigned lodepng_chunk_length(const unsigned char* chunk)
{
  return lodepng_read32bitInt(&chunk[0]);
}

void lodepng_chunk_type(char type[5], const unsigned char* chunk)
{
  unsigned i;
  for(i = 0; i < 4; i++) type[i] = chunk[4 + i];
  type[4] = 0; /*null termination char*/
}

unsigned char lodepng_chunk_type_equals(const unsigned char* chunk, const char* type)
{
  if(strlen(type) != 4) return 0;
  return (chunk[4] == type[0] && chunk[5] == type[1] && chunk[6] == type[2] && chunk[7] == type[3]);
}

unsigned char lodepng_chunk_ancillary(const unsigned char* chunk)
{
  return((chunk[4] & 32) != 0);
}

unsigned char lodepng_chunk_private(const unsigned char* chunk)
{
  return((chunk[6] & 32) != 0);
}

unsigned char lodepng_chunk_safetocopy(const unsigned char* chunk)
{
  return((chunk[7] & 32) != 0);
}

unsigned char* lodepng_chunk_data(unsigned char* chunk)
{
  return &chunk[8];
}

const unsigned char* lodepng_chunk_data_const(const unsigned char* chunk)
{
  return &chunk[8];
}

unsigned lodepng_chunk_check_crc(const unsigned char* chunk)
{
  unsigned length = lodepng_chunk_length(chunk);
  unsigned CRC = lodepng_read32bitInt(&chunk[length + 8]);
  /*the CRC is taken of the data and the 4 chunk type letters, not the length*/
  unsigned checksum = lodepng_crc32(&chunk[4], length + 4);
  if(CRC != checksum) return 1;
  else return 0;
}

void lodepng_chunk_generate_crc(unsigned char* chunk)
{
  unsigned length = lodepng_chunk_length(chunk);
  unsigned CRC = lodepng_crc32(&chunk[4], length + 4);
  lodepng_set32bitInt(chunk + 8 + length, CRC);
}

unsigned char* lodepng_chunk_next(unsigned char* chunk)
{
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  return &chunk[total_chunk_length];
}

const unsigned char* lodepng_chunk_next_const(const unsigned char* chunk)
{
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  return &chunk[total_chunk_length];
}

unsigned lodepng_chunk_append(unsigned char** out, size_t* outlength, const unsigned char* chunk)
{
  unsigned i;
  unsigned total_chunk_length = lodepng_chunk_length(chunk) + 12;
  unsigned char *chunk_start, *new_buffer;
  size_t new_length = (*outlength) + total_chunk_length;
  if(new_length < total_chunk_length || new_length < (*outlength)) return 77; /*integer overflow happened*/

  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
  if(!new_buffer) return 83; /*alloc fail*/
  (*out) = new_buffer;
  (*outlength) = new_length;
  chunk_start = &(*out)[new_length - total_chunk_length];

  for(i = 0; i < total_chunk_length; i++) chunk_start[i] = chunk[i];

  return 0;
}

unsigned lodepng_chunk_create(unsigned char** out, size_t* outlength, unsigned length,
                              const char* type, const unsigned char* data)
{
  unsigned i;
  unsigned char *chunk, *new_buffer;
  size_t new_length = (*outlength) + length + 12;
  if(new_length < length + 12 || new_length < (*outlength)) return 77; /*integer overflow happened*/
  new_buffer = (unsigned char*)lodepng_realloc(*out, new_length);
  if(!new_buffer) return 83; /*alloc fail*/
  (*out) = new_buffer;
  (*outlength) = new_length;
  chunk = &(*out)[(*outlength) - length - 12];

  /*1: length*/
  lodepng_set32bitInt(chunk, (unsigned)length);

  /*2: chunk name (4 letters)*/
  chunk[4] = type[0];
  chunk[5] = type[1];
  chunk[6] = type[2];
  chunk[7] = type[3];

  /*3: the data*/
  for(i = 0; i < length; i++) chunk[8 + i] = data[i];

  /*4: CRC (of the chunkname characters and the data)*/
  lodepng_chunk_generate_crc(chunk);

  return 0;
}

/* ////////////////////////////////////////////////////////////////////////// */
/* / Color types and such                                                   / */
/* ////////////////////////////////////////////////////////////////////////// */

/*return type is a LodePNG error code*/
static unsigned checkColorValidity(LodePNGColorType colortype, unsigned bd) /*bd = bitdepth*/
{
  switch(colortype)
  {
    case 0: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8 || bd == 16)) return 37; break; /*grey*/
    case 2: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGB*/
    case 3: if(!(bd == 1 || bd == 2 || bd == 4 || bd == 8            )) return 37; break; /*palette*/
    case 4: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*grey + alpha*/
    case 6: if(!(                                 bd == 8 || bd == 16)) return 37; break; /*RGBA*/
    default: return 31;
  }
  return 0; /*allowed color type / bits combination*/
}

static unsigned getNumColorChannels(LodePNGColorType colortype)
{
  switch(colortype)
  {
    case 0: return 1; /*grey*/
    case 2: return 3; /*RGB*/
    case 3: return 1; /*palette*/
    case 4: return 2; /*grey + alpha*/
    case 6: return 4; /*RGBA*/
  }
  return 0; /*unexisting color type*/
}

static unsigned lodepng_get_bpp_lct(LodePNGColorType colortype, unsigned bitdepth)
{
  /*bits per pixel is amount of channels * bits per channel*/
  return getNumColorChannels(colortype) * bitdepth;
}

/* ////////////////////////////////////////////////////////////////////////// */

void lodepng_color_mode_init(LodePNGColorMode* info)
{
  info->key_defined = 0;
  info->key_r = info->key_g = info->key_b = 0;
  info->colortype = LCT_RGBA;
  info->bitdepth = 8;
  info->palette = 0;
  info->palettesize = 0;
}

void lodepng_color_mode_cleanup(LodePNGColorMode* info)
{
  lodepng_palette_clear(info);
}

unsigned lodepng_color_mode_copy(LodePNGColorMode* dest, const LodePNGColorMode* source)
{
  size_t i;
  lodepng_color_mode_cleanup(dest);
  *dest = *source;
  if(source->palette)
  {
    dest->palette = (unsigned char*)lodepng_malloc(1024);
    if(!dest->palette && source->palettesize) return 83; /*alloc fail*/
    for(i = 0; i < source->palettesize * 4; i++) dest->palette[i] = source->palette[i];
  }
  return 0;
}

static int lodepng_color_mode_equal(const LodePNGColorMode* a, const LodePNGColorMode* b)
{
  size_t i;
  if(a->colortype != b->colortype) return 0;
  if(a->bitdepth != b->bitdepth) return 0;
  if(a->key_defined != b->key_defined) return 0;
  if(a->key_defined)
  {
    if(a->key_r != b->key_r) return 0;
    if(a->key_g != b->key_g) return 0;
    if(a->key_b != b->key_b) return 0;
  }
  if(a->palettesize != b->palettesize) return 0;
  for(i = 0; i < a->palettesize * 4; i++)
  {
    if(a->palette[i] != b->palette[i]) return 0;
  }
  return 1;
}

void lodepng_palette_clear(LodePNGColorMode* info)
{
  if(info->palette) lodepng_free(info->palette);
  info->palette = 0;
  info->palettesize = 0;
}

unsigned lodepng_palette_add(LodePNGColorMode* info,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  unsigned char* data;
  /*the same resize technique as C++ std::vectors is used, and here it's made so that for a palette with
  the max of 256 colors, it'll have the exact alloc size*/
  if(!info->palette) /*allocate palette if empty*/
  {
    /*room for 256 colors with 4 bytes each*/
    data = (unsigned char*)lodepng_realloc(info->palette, 1024);
    if(!data) return 83; /*alloc fail*/
    else info->palette = data;
  }
  info->palette[4 * info->palettesize + 0] = r;
  info->palette[4 * info->palettesize + 1] = g;
  info->palette[4 * info->palettesize + 2] = b;
  info->palette[4 * info->palettesize + 3] = a;
  info->palettesize++;
  return 0;
}

unsigned lodepng_get_bpp(const LodePNGColorMode* info)
{
  /*calculate bits per pixel out of colortype and bitdepth*/
  return lodepng_get_bpp_lct(info->colortype, info->bitdepth);
}

unsigned lodepng_get_channels(const LodePNGColorMode* info)
{
  return getNumColorChannels(info->colortype);
}

unsigned lodepng_is_greyscale_type(const LodePNGColorMode* info)
{
  return info->colortype == LCT_GREY || info->colortype == LCT_GREY_ALPHA;
}

unsigned lodepng_is_alpha_type(const LodePNGColorMode* info)
{
  return (info->colortype & 4) != 0; /*4 or 6*/
}

unsigned lodepng_is_palette_type(const LodePNGColorMode* info)
{
  return info->colortype == LCT_PALETTE;
}

unsigned lodepng_has_palette_alpha(const LodePNGColorMode* info)
{
  size_t i;
  for(i = 0; i < info->palettesize; i++)
  {
    if(info->palette[i * 4 + 3] < 255) return 1;
  }
  return 0;
}

unsigned lodepng_can_have_alpha(const LodePNGColorMode* info)
{
  return info->key_defined
      || lodepng_is_alpha_type(info)
      || lodepng_has_palette_alpha(info);
}

size_t lodepng_get_raw_size(unsigned w, unsigned h, const LodePNGColorMode* color)
{
  return (w * h * lodepng_get_bpp(color) + 7) / 8;
}

size_t lodepng_get_raw_size_lct(unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)
{
  return (w * h * lodepng_get_bpp_lct(colortype, bitdepth) + 7) / 8;
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static void LodePNGUnknownChunks_init(LodePNGInfo* info)
{
  unsigned i;
  for(i = 0; i < 3; i++) info->unknown_chunks_data[i] = 0;
  for(i = 0; i < 3; i++) info->unknown_chunks_size[i] = 0;
}

static void LodePNGUnknownChunks_cleanup(LodePNGInfo* info)
{
  unsigned i;
  for(i = 0; i < 3; i++) lodepng_free(info->unknown_chunks_data[i]);
}

static unsigned LodePNGUnknownChunks_copy(LodePNGInfo* dest, const LodePNGInfo* src)
{
  unsigned i;

  LodePNGUnknownChunks_cleanup(dest);

  for(i = 0; i < 3; i++)
  {
    size_t j;
    dest->unknown_chunks_size[i] = src->unknown_chunks_size[i];
    dest->unknown_chunks_data[i] = (unsigned char*)lodepng_malloc(src->unknown_chunks_size[i]);
    if(!dest->unknown_chunks_data[i] && dest->unknown_chunks_size[i]) return 83; /*alloc fail*/
    for(j = 0; j < src->unknown_chunks_size[i]; j++)
    {
      dest->unknown_chunks_data[i][j] = src->unknown_chunks_data[i][j];
    }
  }

  return 0;
}

/******************************************************************************/

static void LodePNGText_init(LodePNGInfo* info)
{
  info->text_num = 0;
  info->text_keys = NULL;
  info->text_strings = NULL;
}

static void LodePNGText_cleanup(LodePNGInfo* info)
{
  size_t i;
  for(i = 0; i < info->text_num; i++)
  {
    string_cleanup(&info->text_keys[i]);
    string_cleanup(&info->text_strings[i]);
  }
  lodepng_free(info->text_keys);
  lodepng_free(info->text_strings);
}

static unsigned LodePNGText_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  size_t i = 0;
  dest->text_keys = 0;
  dest->text_strings = 0;
  dest->text_num = 0;
  for(i = 0; i < source->text_num; i++)
  {
    CERROR_TRY_RETURN(lodepng_add_text(dest, source->text_keys[i], source->text_strings[i]));
  }
  return 0;
}

void lodepng_clear_text(LodePNGInfo* info)
{
  LodePNGText_cleanup(info);
}

unsigned lodepng_add_text(LodePNGInfo* info, const char* key, const char* str)
{
  char** new_keys = (char**)(lodepng_realloc(info->text_keys, sizeof(char*) * (info->text_num + 1)));
  char** new_strings = (char**)(lodepng_realloc(info->text_strings, sizeof(char*) * (info->text_num + 1)));
  if(!new_keys || !new_strings)
  {
    lodepng_free(new_keys);
    lodepng_free(new_strings);
    return 83; /*alloc fail*/
  }

  info->text_num++;
  info->text_keys = new_keys;
  info->text_strings = new_strings;

  string_init(&info->text_keys[info->text_num - 1]);
  string_set(&info->text_keys[info->text_num - 1], key);

  string_init(&info->text_strings[info->text_num - 1]);
  string_set(&info->text_strings[info->text_num - 1], str);

  return 0;
}

/******************************************************************************/

static void LodePNGIText_init(LodePNGInfo* info)
{
  info->itext_num = 0;
  info->itext_keys = NULL;
  info->itext_langtags = NULL;
  info->itext_transkeys = NULL;
  info->itext_strings = NULL;
}

static void LodePNGIText_cleanup(LodePNGInfo* info)
{
  size_t i;
  for(i = 0; i < info->itext_num; i++)
  {
    string_cleanup(&info->itext_keys[i]);
    string_cleanup(&info->itext_langtags[i]);
    string_cleanup(&info->itext_transkeys[i]);
    string_cleanup(&info->itext_strings[i]);
  }
  lodepng_free(info->itext_keys);
  lodepng_free(info->itext_langtags);
  lodepng_free(info->itext_transkeys);
  lodepng_free(info->itext_strings);
}

static unsigned LodePNGIText_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  size_t i = 0;
  dest->itext_keys = 0;
  dest->itext_langtags = 0;
  dest->itext_transkeys = 0;
  dest->itext_strings = 0;
  dest->itext_num = 0;
  for(i = 0; i < source->itext_num; i++)
  {
    CERROR_TRY_RETURN(lodepng_add_itext(dest, source->itext_keys[i], source->itext_langtags[i],
                                        source->itext_transkeys[i], source->itext_strings[i]));
  }
  return 0;
}

void lodepng_clear_itext(LodePNGInfo* info)
{
  LodePNGIText_cleanup(info);
}

unsigned lodepng_add_itext(LodePNGInfo* info, const char* key, const char* langtag,
                           const char* transkey, const char* str)
{
  char** new_keys = (char**)(lodepng_realloc(info->itext_keys, sizeof(char*) * (info->itext_num + 1)));
  char** new_langtags = (char**)(lodepng_realloc(info->itext_langtags, sizeof(char*) * (info->itext_num + 1)));
  char** new_transkeys = (char**)(lodepng_realloc(info->itext_transkeys, sizeof(char*) * (info->itext_num + 1)));
  char** new_strings = (char**)(lodepng_realloc(info->itext_strings, sizeof(char*) * (info->itext_num + 1)));
  if(!new_keys || !new_langtags || !new_transkeys || !new_strings)
  {
    lodepng_free(new_keys);
    lodepng_free(new_langtags);
    lodepng_free(new_transkeys);
    lodepng_free(new_strings);
    return 83; /*alloc fail*/
  }

  info->itext_num++;
  info->itext_keys = new_keys;
  info->itext_langtags = new_langtags;
  info->itext_transkeys = new_transkeys;
  info->itext_strings = new_strings;

  string_init(&info->itext_keys[info->itext_num - 1]);
  string_set(&info->itext_keys[info->itext_num - 1], key);

  string_init(&info->itext_langtags[info->itext_num - 1]);
  string_set(&info->itext_langtags[info->itext_num - 1], langtag);

  string_init(&info->itext_transkeys[info->itext_num - 1]);
  string_set(&info->itext_transkeys[info->itext_num - 1], transkey);

  string_init(&info->itext_strings[info->itext_num - 1]);
  string_set(&info->itext_strings[info->itext_num - 1], str);

  return 0;
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

void lodepng_info_init(LodePNGInfo* info)
{
  lodepng_color_mode_init(&info->color);
  info->interlace_method = 0;
  info->compression_method = 0;
  info->filter_method = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  info->background_defined = 0;
  info->background_r = info->background_g = info->background_b = 0;

  LodePNGText_init(info);
  LodePNGIText_init(info);

  info->time_defined = 0;
  info->phys_defined = 0;

  LodePNGUnknownChunks_init(info);
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

void lodepng_info_cleanup(LodePNGInfo* info)
{
  lodepng_color_mode_cleanup(&info->color);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  LodePNGText_cleanup(info);
  LodePNGIText_cleanup(info);

  LodePNGUnknownChunks_cleanup(info);
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

unsigned lodepng_info_copy(LodePNGInfo* dest, const LodePNGInfo* source)
{
  lodepng_info_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->color);
  CERROR_TRY_RETURN(lodepng_color_mode_copy(&dest->color, &source->color));

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  CERROR_TRY_RETURN(LodePNGText_copy(dest, source));
  CERROR_TRY_RETURN(LodePNGIText_copy(dest, source));

  LodePNGUnknownChunks_init(dest);
  CERROR_TRY_RETURN(LodePNGUnknownChunks_copy(dest, source));
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  return 0;
}

void lodepng_info_swap(LodePNGInfo* a, LodePNGInfo* b)
{
  LodePNGInfo temp = *a;
  *a = *b;
  *b = temp;
}

/* ////////////////////////////////////////////////////////////////////////// */

/*index: bitgroup index, bits: bitgroup size(1, 2 or 4, in: bitgroup value, out: octet array to add bits to*/
static void addColorBits(unsigned char* out, size_t index, unsigned bits, unsigned in)
{
  /*p = the partial index in the byte, e.g. with 4 palettebits it is 0 for first half or 1 for second half*/
  unsigned p = index % (8 / bits);
  in &= (1 << bits) - 1; /*filter out any other bits of the input value*/
  in = in << (bits * (8 / bits - p - 1));
  if(p == 0) out[index * bits / 8] = in;
  else out[index * bits / 8] |= in;
}

typedef struct ColorTree ColorTree;

/*
One node of a color tree
This is the data structure used to count the number of unique colors and to get a palette
index for a color. It's like an octree, but because the alpha channel is used too, each
node has 16 instead of 8 children.
*/
struct ColorTree
{
  ColorTree* children[16]; /*up to 16 pointers to ColorTree of next level*/
  int index; /*the payload. Only has a meaningful value if this is in the last level*/
};

static void color_tree_init(ColorTree* tree)
{
  int i;
  for(i = 0; i < 16; i++) tree->children[i] = 0;
  tree->index = -1;
}

static void color_tree_cleanup(ColorTree* tree)
{
  int i;
  for(i = 0; i < 16; i++)
  {
    if(tree->children[i])
    {
      color_tree_cleanup(tree->children[i]);
      lodepng_free(tree->children[i]);
    }
  }
}

/*returns -1 if color not present, its index otherwise*/
static int color_tree_get(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  int bit = 0;
  for(bit = 0; bit < 8; bit++)
  {
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i]) return -1;
    else tree = tree->children[i];
  }
  return tree ? tree->index : -1;
}

#ifdef LODEPNG_COMPILE_ENCODER
static int color_tree_has(ColorTree* tree, unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  return color_tree_get(tree, r, g, b, a) >= 0;
}
#endif /*LODEPNG_COMPILE_ENCODER*/

/*color is not allowed to already exist.
Index should be >= 0 (it's signed to be compatible with using -1 for "doesn't exist")*/
static void color_tree_add(ColorTree* tree,
                           unsigned char r, unsigned char g, unsigned char b, unsigned char a, int index)
{
  int bit;
  for(bit = 0; bit < 8; bit++)
  {
    int i = 8 * ((r >> bit) & 1) + 4 * ((g >> bit) & 1) + 2 * ((b >> bit) & 1) + 1 * ((a >> bit) & 1);
    if(!tree->children[i])
    {
      tree->children[i] = (ColorTree*)lodepng_malloc(sizeof(ColorTree));
      color_tree_init(tree->children[i]);
    }
    tree = tree->children[i];
  }
  tree->index = index;
}

/*put a pixel, given its RGBA color, into image of any color type*/
static unsigned rgba8ToPixel(unsigned char* out, size_t i,
                             const LodePNGColorMode* mode, ColorTree* tree /*for palette*/,
                             unsigned char r, unsigned char g, unsigned char b, unsigned char a)
{
  if(mode->colortype == LCT_GREY)
  {
    unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;
    if(mode->bitdepth == 8) out[i] = grey;
    else if(mode->bitdepth == 16) out[i * 2 + 0] = out[i * 2 + 1] = grey;
    else
    {
      /*take the most significant bits of grey*/
      grey = (grey >> (8 - mode->bitdepth)) & ((1 << mode->bitdepth) - 1);
      addColorBits(out, i, mode->bitdepth, grey);
    }
  }
  else if(mode->colortype == LCT_RGB)
  {
    if(mode->bitdepth == 8)
    {
      out[i * 3 + 0] = r;
      out[i * 3 + 1] = g;
      out[i * 3 + 2] = b;
    }
    else
    {
      out[i * 6 + 0] = out[i * 6 + 1] = r;
      out[i * 6 + 2] = out[i * 6 + 3] = g;
      out[i * 6 + 4] = out[i * 6 + 5] = b;
    }
  }
  else if(mode->colortype == LCT_PALETTE)
  {
    int index = color_tree_get(tree, r, g, b, a);
    if(index < 0) return 82; /*color not in palette*/
    if(mode->bitdepth == 8) out[i] = index;
    else addColorBits(out, i, mode->bitdepth, index);
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
    unsigned char grey = r; /*((unsigned short)r + g + b) / 3*/;
    if(mode->bitdepth == 8)
    {
      out[i * 2 + 0] = grey;
      out[i * 2 + 1] = a;
    }
    else if(mode->bitdepth == 16)
    {
      out[i * 4 + 0] = out[i * 4 + 1] = grey;
      out[i * 4 + 2] = out[i * 4 + 3] = a;
    }
  }
  else if(mode->colortype == LCT_RGBA)
  {
    if(mode->bitdepth == 8)
    {
      out[i * 4 + 0] = r;
      out[i * 4 + 1] = g;
      out[i * 4 + 2] = b;
      out[i * 4 + 3] = a;
    }
    else
    {
      out[i * 8 + 0] = out[i * 8 + 1] = r;
      out[i * 8 + 2] = out[i * 8 + 3] = g;
      out[i * 8 + 4] = out[i * 8 + 5] = b;
      out[i * 8 + 6] = out[i * 8 + 7] = a;
    }
  }

  return 0; /*no error*/
}

/*put a pixel, given its RGBA16 color, into image of any color 16-bitdepth type*/
static unsigned rgba16ToPixel(unsigned char* out, size_t i,
                              const LodePNGColorMode* mode,
                              unsigned short r, unsigned short g, unsigned short b, unsigned short a)
{
  if(mode->bitdepth != 16) return 85; /*must be 16 for this function*/
  if(mode->colortype == LCT_GREY)
  {
    unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;
    out[i * 2 + 0] = (grey >> 8) & 255;
    out[i * 2 + 1] = grey & 255;
  }
  else if(mode->colortype == LCT_RGB)
  {
    out[i * 6 + 0] = (r >> 8) & 255;
    out[i * 6 + 1] = r & 255;
    out[i * 6 + 2] = (g >> 8) & 255;
    out[i * 6 + 3] = g & 255;
    out[i * 6 + 4] = (b >> 8) & 255;
    out[i * 6 + 5] = b & 255;
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
    unsigned short grey = r; /*((unsigned)r + g + b) / 3*/;
    out[i * 4 + 0] = (grey >> 8) & 255;
    out[i * 4 + 1] = grey & 255;
    out[i * 4 + 2] = (a >> 8) & 255;
    out[i * 4 + 3] = a & 255;
  }
  else if(mode->colortype == LCT_RGBA)
  {
    out[i * 8 + 0] = (r >> 8) & 255;
    out[i * 8 + 1] = r & 255;
    out[i * 8 + 2] = (g >> 8) & 255;
    out[i * 8 + 3] = g & 255;
    out[i * 8 + 4] = (b >> 8) & 255;
    out[i * 8 + 5] = b & 255;
    out[i * 8 + 6] = (a >> 8) & 255;
    out[i * 8 + 7] = a & 255;
  }

  return 0; /*no error*/
}

/*Get RGBA8 color of pixel with index i (y * width + x) from the raw image with given color type.*/
static unsigned getPixelColorRGBA8(unsigned char* r, unsigned char* g,
                                   unsigned char* b, unsigned char* a,
                                   const unsigned char* in, size_t i,
                                   const LodePNGColorMode* mode,
                                   unsigned fix_png)
{
  if(mode->colortype == LCT_GREY)
  {
    if(mode->bitdepth == 8)
    {
      *r = *g = *b = in[i];
      if(mode->key_defined && *r == mode->key_r) *a = 0;
      else *a = 255;
    }
    else if(mode->bitdepth == 16)
    {
      *r = *g = *b = in[i * 2 + 0];
      if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
      else *a = 255;
    }
    else
    {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = i * mode->bitdepth;
      unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
      *r = *g = *b = (value * 255) / highest;
      if(mode->key_defined && value == mode->key_r) *a = 0;
      else *a = 255;
    }
  }
  else if(mode->colortype == LCT_RGB)
  {
    if(mode->bitdepth == 8)
    {
      *r = in[i * 3 + 0]; *g = in[i * 3 + 1]; *b = in[i * 3 + 2];
      if(mode->key_defined && *r == mode->key_r && *g == mode->key_g && *b == mode->key_b) *a = 0;
      else *a = 255;
    }
    else
    {
      *r = in[i * 6 + 0];
      *g = in[i * 6 + 2];
      *b = in[i * 6 + 4];
      if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
         && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
         && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
      else *a = 255;
    }
  }
  else if(mode->colortype == LCT_PALETTE)
  {
    unsigned index;
    if(mode->bitdepth == 8) index = in[i];
    else
    {
      size_t j = i * mode->bitdepth;
      index = readBitsFromReversedStream(&j, in, mode->bitdepth);
    }

    if(index >= mode->palettesize)
    {
      /*This is an error according to the PNG spec, but fix_png can ignore it*/
      if(!fix_png) return (mode->bitdepth == 8 ? 46 : 47); /*index out of palette*/
      *r = *g = *b = 0;
      *a = 255;
    }
    else
    {
      *r = mode->palette[index * 4 + 0];
      *g = mode->palette[index * 4 + 1];
      *b = mode->palette[index * 4 + 2];
      *a = mode->palette[index * 4 + 3];
    }
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
    if(mode->bitdepth == 8)
    {
      *r = *g = *b = in[i * 2 + 0];
      *a = in[i * 2 + 1];
    }
    else
    {
      *r = *g = *b = in[i * 4 + 0];
      *a = in[i * 4 + 2];
    }
  }
  else if(mode->colortype == LCT_RGBA)
  {
    if(mode->bitdepth == 8)
    {
      *r = in[i * 4 + 0];
      *g = in[i * 4 + 1];
      *b = in[i * 4 + 2];
      *a = in[i * 4 + 3];
    }
    else
    {
      *r = in[i * 8 + 0];
      *g = in[i * 8 + 2];
      *b = in[i * 8 + 4];
      *a = in[i * 8 + 6];
    }
  }

  return 0; /*no error*/
}

/*Similar to getPixelColorRGBA8, but with all the for loops inside of the color
mode test cases, optimized to convert the colors much faster, when converting
to RGBA or RGB with 8 bit per cannel. buffer must be RGBA or RGB output with
enough memory, if has_alpha is true the output is RGBA. mode has the color mode
of the input buffer.*/
static unsigned getPixelColorsRGBA8(unsigned char* buffer, size_t numpixels,
                                    unsigned has_alpha, const unsigned char* in,
                                    const LodePNGColorMode* mode,
                                    unsigned fix_png)
{
  unsigned num_channels = has_alpha ? 4 : 3;
  size_t i;
  if(mode->colortype == LCT_GREY)
  {
    if(mode->bitdepth == 8)
    {
      for(i = 0; i < numpixels; i++, buffer += num_channels)
      {
        buffer[0] = buffer[1] = buffer[2] = in[i];
        if(has_alpha) buffer[3] = mode->key_defined && in[i] == mode->key_r ? 0 : 255;
      }
    }
    else if(mode->bitdepth == 16)
    {
      for(i = 0; i < numpixels; i++, buffer += num_channels)
      {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2];
        if(has_alpha) buffer[3] = mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r ? 0 : 255;
      }
    }
    else
    {
      unsigned highest = ((1U << mode->bitdepth) - 1U); /*highest possible value for this bit depth*/
      size_t j = 0;
      for(i = 0; i < numpixels; i++, buffer += num_channels)
      {
        unsigned value = readBitsFromReversedStream(&j, in, mode->bitdepth);
        buffer[0] = buffer[1] = buffer[2] = (value * 255) / highest;
        if(has_alpha) buffer[3] = mode->key_defined && value == mode->key_r ? 0 : 255;
      }
    }
  }
  else if(mode->colortype == LCT_RGB)
  {
    if(mode->bitdepth == 8)
    {
      for(i = 0; i < numpixels; i++, buffer += num_channels)
      {
        buffer[0] = in[i * 3 + 0];
        buffer[1] = in[i * 3 + 1];
        buffer[2] = in[i * 3 + 2];
        if(has_alpha) buffer[3] = mode->key_defined && buffer[0] == mode->key_r
           && buffer[1]== mode->key_g && buffer[2] == mode->key_b ? 0 : 255;
      }
    }
    else
    {
      for(i = 0; i < numpixels; i++, buffer += num_channels)
      {
        buffer[0] = in[i * 6 + 0];
        buffer[1] = in[i * 6 + 2];
        buffer[2] = in[i * 6 + 4];
        if(has_alpha) buffer[3] = mode->key_defined
           && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
           && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
           && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b ? 0 : 255;
      }
    }
  }
  else if(mode->colortype == LCT_PALETTE)
  {
    unsigned index;
    size_t j = 0;
    for(i = 0; i < numpixels; i++, buffer += num_channels)
    {
      if(mode->bitdepth == 8) index = in[i];
      else index = readBitsFromReversedStream(&j, in, mode->bitdepth);

      if(index >= mode->palettesize)
      {
        /*This is an error according to the PNG spec, but fix_png can ignore it*/
        if(!fix_png) return (mode->bitdepth == 8 ? 46 : 47); /*index out of palette*/
        buffer[0] = buffer[1] = buffer[2] = 0;
        if(has_alpha) buffer[3] = 255;
      }
      else
      {
        buffer[0] = mode->palette[index * 4 + 0];
        buffer[1] = mode->palette[index * 4 + 1];
        buffer[2] = mode->palette[index * 4 + 2];
        if(has_alpha) buffer[3] = mode->palette[index * 4 + 3];
      }
    }
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
    if(mode->bitdepth == 8)
    {
      for(i = 0; i < numpixels; i++, buffer += num_channels)
      {
        buffer[0] = buffer[1] = buffer[2] = in[i * 2 + 0];
        if(has_alpha) buffer[3] = in[i * 2 + 1];
      }
    }
    else
    {
      for(i = 0; i < numpixels; i++, buffer += num_channels)
      {
        buffer[0] = buffer[1] = buffer[2] = in[i * 4 + 0];
        if(has_alpha) buffer[3] = in[i * 4 + 2];
      }
    }
  }
  else if(mode->colortype == LCT_RGBA)
  {
    if(mode->bitdepth == 8)
    {
      for(i = 0; i < numpixels; i++, buffer += num_channels)
      {
        buffer[0] = in[i * 4 + 0];
        buffer[1] = in[i * 4 + 1];
        buffer[2] = in[i * 4 + 2];
        if(has_alpha) buffer[3] = in[i * 4 + 3];
      }
    }
    else
    {
      for(i = 0; i < numpixels; i++, buffer += num_channels)
      {
        buffer[0] = in[i * 8 + 0];
        buffer[1] = in[i * 8 + 2];
        buffer[2] = in[i * 8 + 4];
        if(has_alpha) buffer[3] = in[i * 8 + 6];
      }
    }
  }

  return 0; /*no error*/
}

/*Get RGBA16 color of pixel with index i (y * width + x) from the raw image with
given color type, but the given color type must be 16-bit itself.*/
static unsigned getPixelColorRGBA16(unsigned short* r, unsigned short* g, unsigned short* b, unsigned short* a,
                                    const unsigned char* in, size_t i, const LodePNGColorMode* mode)
{
  if(mode->bitdepth != 16) return 85; /*error: this function only supports 16-bit input*/

  if(mode->colortype == LCT_GREY)
  {
    *r = *g = *b = 256 * in[i * 2 + 0] + in[i * 2 + 1];
    if(mode->key_defined && 256U * in[i * 2 + 0] + in[i * 2 + 1] == mode->key_r) *a = 0;
    else *a = 65535;
  }
  else if(mode->colortype == LCT_RGB)
  {
    *r = 256 * in[i * 6 + 0] + in[i * 6 + 1];
    *g = 256 * in[i * 6 + 2] + in[i * 6 + 3];
    *b = 256 * in[i * 6 + 4] + in[i * 6 + 5];
    if(mode->key_defined && 256U * in[i * 6 + 0] + in[i * 6 + 1] == mode->key_r
       && 256U * in[i * 6 + 2] + in[i * 6 + 3] == mode->key_g
       && 256U * in[i * 6 + 4] + in[i * 6 + 5] == mode->key_b) *a = 0;
    else *a = 65535;
  }
  else if(mode->colortype == LCT_GREY_ALPHA)
  {
    *r = *g = *b = 256 * in[i * 4 + 0] + in[i * 4 + 1];
    *a = 256 * in[i * 4 + 2] + in[i * 4 + 3];
  }
  else if(mode->colortype == LCT_RGBA)
  {
    *r = 256 * in[i * 8 + 0] + in[i * 8 + 1];
    *g = 256 * in[i * 8 + 2] + in[i * 8 + 3];
    *b = 256 * in[i * 8 + 4] + in[i * 8 + 5];
    *a = 256 * in[i * 8 + 6] + in[i * 8 + 7];
  }
  else return 85; /*error: this function only supports 16-bit input, not palettes*/

  return 0; /*no error*/
}

/*
converts from any color type to 24-bit or 32-bit (later maybe more supported). return value = LodePNG error code
the out buffer must have (w * h * bpp + 7) / 8 bytes, where bpp is the bits per pixel of the output color type
(lodepng_get_bpp) for < 8 bpp images, there may _not_ be padding bits at the end of scanlines.
*/
unsigned lodepng_convert(unsigned char* out, const unsigned char* in,
                         LodePNGColorMode* mode_out, LodePNGColorMode* mode_in,
                         unsigned w, unsigned h, unsigned fix_png)
{
  unsigned error = 0;
  size_t i;
  ColorTree tree;
  size_t numpixels = w * h;

  if(lodepng_color_mode_equal(mode_out, mode_in))
  {
    size_t numbytes = lodepng_get_raw_size(w, h, mode_in);
    for(i = 0; i < numbytes; i++) out[i] = in[i];
    return error;
  }

  if(mode_out->colortype == LCT_PALETTE)
  {
    size_t palsize = 1 << mode_out->bitdepth;
    if(mode_out->palettesize < palsize) palsize = mode_out->palettesize;
    color_tree_init(&tree);
    for(i = 0; i < palsize; i++)
    {
      unsigned char* p = &mode_out->palette[i * 4];
      color_tree_add(&tree, p[0], p[1], p[2], p[3], i);
    }
  }

  if(mode_in->bitdepth == 16 && mode_out->bitdepth == 16)
  {
    for(i = 0; i < numpixels; i++)
    {
      unsigned short r = 0, g = 0, b = 0, a = 0;
      error = getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode_in);
      if(error) break;
      error = rgba16ToPixel(out, i, mode_out, r, g, b, a);
      if(error) break;
    }
  }
  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGBA)
  {
    error = getPixelColorsRGBA8(out, numpixels, 1, in, mode_in, fix_png);
  }
  else if(mode_out->bitdepth == 8 && mode_out->colortype == LCT_RGB)
  {
    error = getPixelColorsRGBA8(out, numpixels, 0, in, mode_in, fix_png);
  }
  else
  {
    unsigned char r = 0, g = 0, b = 0, a = 0;
    for(i = 0; i < numpixels; i++)
    {
      error = getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode_in, fix_png);
      if(error) break;
      error = rgba8ToPixel(out, i, mode_out, &tree, r, g, b, a);
      if(error) break;
    }
  }

  if(mode_out->colortype == LCT_PALETTE)
  {
    color_tree_cleanup(&tree);
  }

  return error;
}

#ifdef LODEPNG_COMPILE_ENCODER

typedef struct ColorProfile
{
  unsigned char sixteenbit; /*needs more than 8 bits per channel*/
  unsigned char sixteenbit_done;


  unsigned char colored; /*not greyscale*/
  unsigned char colored_done;

  unsigned char key; /*a color key is required, or more*/
  unsigned short key_r; /*these values are always in 16-bit bitdepth in the profile*/
  unsigned short key_g;
  unsigned short key_b;
  unsigned char alpha; /*alpha channel, or alpha palette, required*/
  unsigned char alpha_done;

  unsigned numcolors;
  ColorTree tree; /*for listing the counted colors, up to 256*/
  unsigned char* palette; /*size 1024. Remember up to the first 256 RGBA colors*/
  unsigned maxnumcolors; /*if more than that amount counted*/
  unsigned char numcolors_done;

  unsigned greybits; /*amount of bits required for greyscale (1, 2, 4, 8). Does not take 16 bit into account.*/
  unsigned char greybits_done;

} ColorProfile;

static void color_profile_init(ColorProfile* profile, LodePNGColorMode* mode)
{
  profile->sixteenbit = 0;
  profile->sixteenbit_done = mode->bitdepth == 16 ? 0 : 1;

  profile->colored = 0;
  profile->colored_done = lodepng_is_greyscale_type(mode) ? 1 : 0;

  profile->key = 0;
  profile->alpha = 0;
  profile->alpha_done = lodepng_can_have_alpha(mode) ? 0 : 1;

  profile->numcolors = 0;
  color_tree_init(&profile->tree);
  profile->palette = (unsigned char*)lodepng_malloc(1024);
  profile->maxnumcolors = 257;
  if(lodepng_get_bpp(mode) <= 8)
  {
    int bpp = lodepng_get_bpp(mode);
    profile->maxnumcolors = bpp == 1 ? 2 : (bpp == 2 ? 4 : (bpp == 4 ? 16 : 256));
  }
  profile->numcolors_done = 0;

  profile->greybits = 1;
  profile->greybits_done = lodepng_get_bpp(mode) == 1 ? 1 : 0;
}

static void color_profile_cleanup(ColorProfile* profile)
{
  color_tree_cleanup(&profile->tree);
  lodepng_free(profile->palette);
}

/*function used for debug purposes with C++*/
/*void printColorProfile(ColorProfile* p)
{
  std::cout << "sixteenbit: " << (int)p->sixteenbit << std::endl;
  std::cout << "sixteenbit_done: " << (int)p->sixteenbit_done << std::endl;
  std::cout << "colored: " << (int)p->colored << std::endl;
  std::cout << "colored_done: " << (int)p->colored_done << std::endl;
  std::cout << "key: " << (int)p->key << std::endl;
  std::cout << "key_r: " << (int)p->key_r << std::endl;
  std::cout << "key_g: " << (int)p->key_g << std::endl;
  std::cout << "key_b: " << (int)p->key_b << std::endl;
  std::cout << "alpha: " << (int)p->alpha << std::endl;
  std::cout << "alpha_done: " << (int)p->alpha_done << std::endl;
  std::cout << "numcolors: " << (int)p->numcolors << std::endl;
  std::cout << "maxnumcolors: " << (int)p->maxnumcolors << std::endl;
  std::cout << "numcolors_done: " << (int)p->numcolors_done << std::endl;
  std::cout << "greybits: " << (int)p->greybits << std::endl;
  std::cout << "greybits_done: " << (int)p->greybits_done << std::endl;
}*/

/*Returns how many bits needed to represent given value (max 8 bit)*/
unsigned getValueRequiredBits(unsigned short value)
{
  if(value == 0 || value == 255) return 1;
  /*The scaling of 2-bit and 4-bit values uses multiples of 85 and 17*/
  if(value % 17 == 0) return value % 85 == 0 ? 2 : 4;
  return 8;
}

/*profile must already have been inited with mode.
It's ok to set some parameters of profile to done already.*/
static unsigned get_color_profile(ColorProfile* profile,
                                  const unsigned char* in,
                                  size_t numpixels /*must be full image size, for certain filesize based choices*/,
                                  LodePNGColorMode* mode,
                                  unsigned fix_png)
{
  unsigned error = 0;
  size_t i;

  if(mode->bitdepth == 16)
  {
    for(i = 0; i < numpixels; i++)
    {
      unsigned short r, g, b, a;
      error = getPixelColorRGBA16(&r, &g, &b, &a, in, i, mode);
      if(error) break;

      /*a color is considered good for 8-bit if the first byte and the second byte are equal,
        (so if it's divisible through 257), NOT necessarily if the second byte is 0*/
      if(!profile->sixteenbit_done
          && (((r & 255) != ((r >> 8) & 255))
           || ((g & 255) != ((g >> 8) & 255))
           || ((b & 255) != ((b >> 8) & 255))))
      {
        profile->sixteenbit = 1;
        profile->sixteenbit_done = 1;
        profile->greybits_done = 1; /*greybits is not applicable anymore at 16-bit*/
        profile->numcolors_done = 1; /*counting colors no longer useful, palette doesn't support 16-bit*/
      }

      if(!profile->colored_done && (r != g || r != b))
      {
        profile->colored = 1;
        profile->colored_done = 1;
        profile->greybits_done = 1; /*greybits is not applicable anymore*/
      }

      if(!profile->alpha_done && a != 65535)
      {
        /*only use color key if numpixels large enough to justify tRNS chunk size*/
        if(a == 0 && numpixels > 16 && !(profile->key && (r != profile->key_r || g != profile->key_g || b != profile->key_b)))
        {
          if(!profile->alpha && !profile->key)
          {
            profile->key = 1;
            profile->key_r = r;
            profile->key_g = g;
            profile->key_b = b;
          }
        }
        else
        {
          profile->alpha = 1;
          profile->alpha_done = 1;
          profile->greybits_done = 1; /*greybits is not applicable anymore*/
        }
      }

      /* Color key cannot be used if an opaque pixel also has that RGB color. */
      if(!profile->alpha_done && a == 65535 && profile->key
          && r == profile->key_r && g == profile->key_g && b == profile->key_b)
      {
          profile->alpha = 1;
          profile->alpha_done = 1;
          profile->greybits_done = 1; /*greybits is not applicable anymore*/
      }

      if(!profile->greybits_done)
      {
        /*assuming 8-bit r, this test does not care about 16-bit*/
        unsigned bits = getValueRequiredBits(r);
        if(bits > profile->greybits) profile->greybits = bits;
        if(profile->greybits >= 8) profile->greybits_done = 1;
      }

      if(!profile->numcolors_done)
      {
        /*assuming 8-bit rgba, this test does not care about 16-bit*/
        if(!color_tree_has(&profile->tree, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a))
        {
          color_tree_add(&profile->tree, (unsigned char)r, (unsigned char)g, (unsigned char)b, (unsigned char)a,
            profile->numcolors);
          if(profile->numcolors < 256)
          {
            unsigned char* p = profile->palette;
            unsigned i = profile->numcolors;
            p[i * 4 + 0] = (unsigned char)r;
            p[i * 4 + 1] = (unsigned char)g;
            p[i * 4 + 2] = (unsigned char)b;
            p[i * 4 + 3] = (unsigned char)a;
          }
          profile->numcolors++;
          if(profile->numcolors >= profile->maxnumcolors) profile->numcolors_done = 1;
        }
      }

      if(profile->alpha_done && profile->numcolors_done
      && profile->colored_done && profile->sixteenbit_done && profile->greybits_done)
      {
        break;
      }
    };
  }
  else /* < 16-bit */
  {
    for(i = 0; i < numpixels; i++)
    {
      unsigned char r = 0, g = 0, b = 0, a = 0;
      error = getPixelColorRGBA8(&r, &g, &b, &a, in, i, mode, fix_png);
      if(error) break;

      if(!profile->colored_done && (r != g || r != b))
      {
        profile->colored = 1;
        profile->colored_done = 1;
        profile->greybits_done = 1; /*greybits is not applicable anymore*/
      }

      if(!profile->alpha_done && a != 255)
      {
        if(a == 0 && !(profile->key && (r != profile->key_r || g != profile->key_g || b != profile->key_b)))
        {
          if(!profile->key)
          {
            profile->key = 1;
            profile->key_r = r;
            profile->key_g = g;
            profile->key_b = b;
          }
        }
        else
        {
          profile->alpha = 1;
          profile->alpha_done = 1;
          profile->greybits_done = 1; /*greybits is not applicable anymore*/
        }
      }

      /* Color key cannot be used if an opaque pixel also has that RGB color. */
      if(!profile->alpha_done && a == 255 && profile->key
          && r == profile->key_r && g == profile->key_g && b == profile->key_b)
      {
          profile->alpha = 1;
          profile->alpha_done = 1;
          profile->greybits_done = 1; /*greybits is not applicable anymore*/
      }

      if(!profile->greybits_done)
      {
        unsigned bits = getValueRequiredBits(r);
        if(bits > profile->greybits) profile->greybits = bits;
        if(profile->greybits >= 8) profile->greybits_done = 1;
      }

      if(!profile->numcolors_done)
      {
        if(!color_tree_has(&profile->tree, r, g, b, a))
        {

          color_tree_add(&profile->tree, r, g, b, a, profile->numcolors);
          if(profile->numcolors < 256)
          {
            unsigned char* p = profile->palette;
            unsigned i = profile->numcolors;
            p[i * 4 + 0] = r;
            p[i * 4 + 1] = g;
            p[i * 4 + 2] = b;
            p[i * 4 + 3] = a;
          }
          profile->numcolors++;
          if(profile->numcolors >= profile->maxnumcolors) profile->numcolors_done = 1;
        }
      }

      if(profile->alpha_done && profile->numcolors_done && profile->colored_done && profile->greybits_done)
      {
        break;
      }
    };
  }

  /*make the profile's key always 16-bit for consistency*/
  if(mode->bitdepth < 16)
  {
    /*repeat each byte twice*/
    profile->key_r *= 257;
    profile->key_g *= 257;
    profile->key_b *= 257;
  }

  return error;
}

static void setColorKeyFrom16bit(LodePNGColorMode* mode_out, unsigned r, unsigned g, unsigned b, unsigned bitdepth)
{
  unsigned mask = (1 << bitdepth) - 1;
  mode_out->key_defined = 1;
  mode_out->key_r = r & mask;
  mode_out->key_g = g & mask;
  mode_out->key_b = b & mask;
}

/*updates values of mode with a potentially smaller color model. mode_out should
contain the user chosen color model, but will be overwritten with the new chosen one.*/
static unsigned doAutoChooseColor(LodePNGColorMode* mode_out,
                                  const unsigned char* image, unsigned w, unsigned h, LodePNGColorMode* mode_in,
                                  LodePNGAutoConvert auto_convert)
{
  ColorProfile profile;
  unsigned error = 0;
  int no_nibbles = auto_convert == LAC_AUTO_NO_NIBBLES || auto_convert == LAC_AUTO_NO_NIBBLES_NO_PALETTE;
  int no_palette = auto_convert == LAC_AUTO_NO_PALETTE || auto_convert == LAC_AUTO_NO_NIBBLES_NO_PALETTE;

  if(auto_convert == LAC_ALPHA)
  {
    if(mode_out->colortype != LCT_RGBA && mode_out->colortype != LCT_GREY_ALPHA) return 0;
  }

  color_profile_init(&profile, mode_in);
  if(auto_convert == LAC_ALPHA)
  {
    profile.colored_done = 1;
    profile.greybits_done = 1;
    profile.numcolors_done = 1;
    profile.sixteenbit_done = 1;
  }
  error = get_color_profile(&profile, image, w * h, mode_in, 0 /*fix_png*/);
  if(!error && auto_convert == LAC_ALPHA)
  {
    if(!profile.alpha)
    {
      mode_out->colortype = (mode_out->colortype == LCT_RGBA ? LCT_RGB : LCT_GREY);
      if(profile.key) setColorKeyFrom16bit(mode_out, profile.key_r, profile.key_g, profile.key_b, mode_out->bitdepth);
    }
  }
  else if(!error && auto_convert != LAC_ALPHA)
  {
    mode_out->key_defined = 0;

    if(profile.sixteenbit)
    {
      mode_out->bitdepth = 16;
      if(profile.alpha)
      {
        mode_out->colortype = profile.colored ? LCT_RGBA : LCT_GREY_ALPHA;
      }
      else
      {
        mode_out->colortype = profile.colored ? LCT_RGB : LCT_GREY;
        if(profile.key) setColorKeyFrom16bit(mode_out, profile.key_r, profile.key_g, profile.key_b, mode_out->bitdepth);
      }
    }
    else /*less than 16 bits per channel*/
    {
      /*don't add palette overhead if image hasn't got a lot of pixels*/
      unsigned n = profile.numcolors;
      int palette_ok = !no_palette && n <= 256 && (n * 2 < w * h);
      unsigned palettebits = n <= 2 ? 1 : (n <= 4 ? 2 : (n <= 16 ? 4 : 8));
      int grey_ok = !profile.colored && !profile.alpha; /*grey without alpha, with potentially low bits*/
      if(palette_ok || grey_ok)
      {
        if(!palette_ok || (grey_ok && profile.greybits <= palettebits))
        {
          unsigned grey = profile.key_r;
          mode_out->colortype = LCT_GREY;
          mode_out->bitdepth = profile.greybits;
          if(profile.key) setColorKeyFrom16bit(mode_out, grey, grey, grey, mode_out->bitdepth);
        }
        else
        {
          /*fill in the palette*/
          unsigned i;
          unsigned char* p = profile.palette;
          /*remove potential earlier palette*/
          lodepng_palette_clear(mode_out);
          for(i = 0; i < profile.numcolors; i++)
          {
            error = lodepng_palette_add(mode_out, p[i * 4 + 0], p[i * 4 + 1], p[i * 4 + 2], p[i * 4 + 3]);
            if(error) break;
          }

          mode_out->colortype = LCT_PALETTE;
          mode_out->bitdepth = palettebits;
        }
      }
      else /*8-bit per channel*/
      {
        mode_out->bitdepth = 8;
        if(profile.alpha)
        {
          mode_out->colortype = profile.colored ? LCT_RGBA : LCT_GREY_ALPHA;
        }
        else
        {
          mode_out->colortype = profile.colored ? LCT_RGB : LCT_GREY /*LCT_GREY normally won't occur, already done earlier*/;
          if(profile.key) setColorKeyFrom16bit(mode_out, profile.key_r, profile.key_g, profile.key_b, mode_out->bitdepth);
        }
      }
    }
  }

  color_profile_cleanup(&profile);

  if(mode_out->colortype == LCT_PALETTE && mode_in->palettesize == mode_out->palettesize)
  {
    /*In this case keep the palette order of the input, so that the user can choose an optimal one*/
    size_t i;
    for(i = 0; i < mode_in->palettesize * 4; i++)
    {
      mode_out->palette[i] = mode_in->palette[i];
    }
  }

  if(no_nibbles && mode_out->bitdepth < 8)
  {
    /*palette can keep its small amount of colors, as long as no indices use it*/
    mode_out->bitdepth = 8;
  }

  return error;
}

#endif /* #ifdef LODEPNG_COMPILE_ENCODER */

/*
Paeth predicter, used by PNG filter type 4
The parameters are of type short, but should come from unsigned chars, the shorts
are only needed to make the paeth calculation correct.
*/
static unsigned char paethPredictor(short a, short b, short c)
{
  short pa = abs(b - c);
  short pb = abs(a - c);
  short pc = abs(a + b - c - c);

  if(pc < pa && pc < pb) return (unsigned char)c;
  else if(pb < pa) return (unsigned char)b;
  else return (unsigned char)a;
}

/*shared values used by multiple Adam7 related functions*/

static const unsigned ADAM7_IX[7] = { 0, 4, 0, 2, 0, 1, 0 }; /*x start values*/
static const unsigned ADAM7_IY[7] = { 0, 0, 4, 0, 2, 0, 1 }; /*y start values*/
static const unsigned ADAM7_DX[7] = { 8, 8, 4, 4, 2, 2, 1 }; /*x delta values*/
static const unsigned ADAM7_DY[7] = { 8, 8, 8, 4, 4, 2, 2 }; /*y delta values*/

/*
Outputs various dimensions and positions in the image related to the Adam7 reduced images.
passw: output containing the width of the 7 passes
passh: output containing the height of the 7 passes
filter_passstart: output containing the index of the start and end of each
 reduced image with filter bytes
padded_passstart output containing the index of the start and end of each
 reduced image when without filter bytes but with padded scanlines
passstart: output containing the index of the start and end of each reduced
 image without padding between scanlines, but still padding between the images
w, h: width and height of non-interlaced image
bpp: bits per pixel
"padded" is only relevant if bpp is less than 8 and a scanline or image does not
 end at a full byte
*/
static void Adam7_getpassvalues(unsigned passw[7], unsigned passh[7], size_t filter_passstart[8],
                                size_t padded_passstart[8], size_t passstart[8], unsigned w, unsigned h, unsigned bpp)
{
  /*the passstart values have 8 values: the 8th one indicates the byte after the end of the 7th (= last) pass*/
  unsigned i;

  /*calculate width and height in pixels of each pass*/
  for(i = 0; i < 7; i++)
  {
    passw[i] = (w + ADAM7_DX[i] - ADAM7_IX[i] - 1) / ADAM7_DX[i];
    passh[i] = (h + ADAM7_DY[i] - ADAM7_IY[i] - 1) / ADAM7_DY[i];
    if(passw[i] == 0) passh[i] = 0;
    if(passh[i] == 0) passw[i] = 0;
  }

  filter_passstart[0] = padded_passstart[0] = passstart[0] = 0;
  for(i = 0; i < 7; i++)
  {
    /*if passw[i] is 0, it's 0 bytes, not 1 (no filtertype-byte)*/
    filter_passstart[i + 1] = filter_passstart[i]
                            + ((passw[i] && passh[i]) ? passh[i] * (1 + (passw[i] * bpp + 7) / 8) : 0);
    /*bits padded if needed to fill full byte at end of each scanline*/
    padded_passstart[i + 1] = padded_passstart[i] + passh[i] * ((passw[i] * bpp + 7) / 8);
    /*only padded at end of reduced image*/
    passstart[i + 1] = passstart[i] + (passh[i] * passw[i] * bpp + 7) / 8;
  }
}

#ifdef LODEPNG_COMPILE_DECODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Decoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*read the information from the header and store it in the LodePNGInfo. return value is error*/
unsigned lodepng_inspect(unsigned* w, unsigned* h, LodePNGState* state,
                         const unsigned char* in, size_t insize)
{
  LodePNGInfo* info = &state->info_png;
  if(insize == 0 || in == 0)
  {
    CERROR_RETURN_ERROR(state->error, 48); /*error: the given data is empty*/
  }
  if(insize < 29)
  {
    CERROR_RETURN_ERROR(state->error, 27); /*error: the data length is smaller than the length of a PNG header*/
  }

  /*when decoding a new PNG image, make sure all parameters created after previous decoding are reset*/
  lodepng_info_cleanup(info);
  lodepng_info_init(info);

  if(in[0] != 137 || in[1] != 80 || in[2] != 78 || in[3] != 71
     || in[4] != 13 || in[5] != 10 || in[6] != 26 || in[7] != 10)
  {
    CERROR_RETURN_ERROR(state->error, 28); /*error: the first 8 bytes are not the correct PNG signature*/
  }
  if(in[12] != 'I' || in[13] != 'H' || in[14] != 'D' || in[15] != 'R')
  {
    CERROR_RETURN_ERROR(state->error, 29); /*error: it doesn't start with a IHDR chunk!*/
  }

  /*read the values given in the header*/
  *w = lodepng_read32bitInt(&in[16]);
  *h = lodepng_read32bitInt(&in[20]);
  info->color.bitdepth = in[24];
  info->color.colortype = (LodePNGColorType)in[25];
  info->compression_method = in[26];
  info->filter_method = in[27];
  info->interlace_method = in[28];

  if(!state->decoder.ignore_crc)
  {
    unsigned CRC = lodepng_read32bitInt(&in[29]);
    unsigned checksum = lodepng_crc32(&in[12], 17);
    if(CRC != checksum)
    {
      CERROR_RETURN_ERROR(state->error, 57); /*invalid CRC*/
    }
  }

  /*error: only compression method 0 is allowed in the specification*/
  if(info->compression_method != 0) CERROR_RETURN_ERROR(state->error, 32);
  /*error: only filter method 0 is allowed in the specification*/
  if(info->filter_method != 0) CERROR_RETURN_ERROR(state->error, 33);
  /*error: only interlace methods 0 and 1 exist in the specification*/
  if(info->interlace_method > 1) CERROR_RETURN_ERROR(state->error, 34);

  state->error = checkColorValidity(info->color.colortype, info->color.bitdepth);
  return state->error;
}

static unsigned unfilterScanline(unsigned char* recon, const unsigned char* scanline, const unsigned char* precon,
                                 size_t bytewidth, unsigned char filterType, size_t length)
{
  /*
  For PNG filter method 0
  unfilter a PNG image scanline by scanline. when the pixels are smaller than 1 byte,
  the filter works byte per byte (bytewidth = 1)
  precon is the previous unfiltered scanline, recon the result, scanline the current one
  the incoming scanlines do NOT include the filtertype byte, that one is given in the parameter filterType instead
  recon and scanline MAY be the same memory address! precon must be disjoint.
  */

  size_t i;
  switch(filterType)
  {
    case 0:
      for(i = 0; i < length; i++) recon[i] = scanline[i];
      break;
    case 1:
      for(i = 0; i < bytewidth; i++) recon[i] = scanline[i];
      for(i = bytewidth; i < length; i++) recon[i] = scanline[i] + recon[i - bytewidth];
      break;
    case 2:
      if(precon)
      {
        for(i = 0; i < length; i++) recon[i] = scanline[i] + precon[i];
      }
      else
      {
        for(i = 0; i < length; i++) recon[i] = scanline[i];
      }
      break;
    case 3:
      if(precon)
      {
        for(i = 0; i < bytewidth; i++) recon[i] = scanline[i] + precon[i] / 2;
        for(i = bytewidth; i < length; i++) recon[i] = scanline[i] + ((recon[i - bytewidth] + precon[i]) / 2);
      }
      else
      {
        for(i = 0; i < bytewidth; i++) recon[i] = scanline[i];
        for(i = bytewidth; i < length; i++) recon[i] = scanline[i] + recon[i - bytewidth] / 2;
      }
      break;
    case 4:
      if(precon)
      {
        for(i = 0; i < bytewidth; i++)
        {
          recon[i] = (scanline[i] + precon[i]); /*paethPredictor(0, precon[i], 0) is always precon[i]*/
        }
        for(i = bytewidth; i < length; i++)
        {
          recon[i] = (scanline[i] + paethPredictor(recon[i - bytewidth], precon[i], precon[i - bytewidth]));
        }
      }
      else
      {
        for(i = 0; i < bytewidth; i++)
        {
          recon[i] = scanline[i];
        }
        for(i = bytewidth; i < length; i++)
        {
          /*paethPredictor(recon[i - bytewidth], 0, 0) is always recon[i - bytewidth]*/
          recon[i] = (scanline[i] + recon[i - bytewidth]);
        }
      }
      break;
    default: return 36; /*error: unexisting filter type given*/
  }
  return 0;
}

static unsigned unfilter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  /*
  For PNG filter method 0
  this function unfilters a single image (e.g. without interlacing this is called once, with Adam7 seven times)
  out must have enough bytes allocated already, in must have the scanlines + 1 filtertype byte per scanline
  w and h are image dimensions or dimensions of reduced image, bpp is bits per pixel
  in and out are allowed to be the same memory address (but aren't the same size since in has the extra filter bytes)
  */

  unsigned y;
  unsigned char* prevline = 0;

  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7) / 8;
  size_t linebytes = (w * bpp + 7) / 8;

  for(y = 0; y < h; y++)
  {
    size_t outindex = linebytes * y;
    size_t inindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
    unsigned char filterType = in[inindex];

    CERROR_TRY_RETURN(unfilterScanline(&out[outindex], &in[inindex + 1], prevline, bytewidth, filterType, linebytes));

    prevline = &out[outindex];
  }

  return 0;
}

/*
in: Adam7 interlaced image, with no padding bits between scanlines, but between
 reduced images so that each reduced image starts at a byte.
out: the same pixels, but re-ordered so that they're now a non-interlaced image with size w*h
bpp: bits per pixel
out has the following size in bits: w * h * bpp.
in is possibly bigger due to padding bits between reduced images.
out must be big enough AND must be 0 everywhere if bpp < 8 in the current implementation
(because that's likely a little bit faster)
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_deinterlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8)
  {
    for(i = 0; i < 7; i++)
    {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8;
      for(y = 0; y < passh[i]; y++)
      for(x = 0; x < passw[i]; x++)
      {
        size_t pixelinstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        size_t pixeloutstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        for(b = 0; b < bytewidth; b++)
        {
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  }
  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
  {
    for(i = 0; i < 7; i++)
    {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; y++)
      for(x = 0; x < passw[i]; x++)
      {
        ibp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        obp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        for(b = 0; b < bpp; b++)
        {
          unsigned char bit = readBitFromReversedStream(&ibp, in);
          /*note that this function assumes the out buffer is completely 0, use setBitOfReversedStream otherwise*/
          setBitOfReversedStream0(&obp, out, bit);
        }
      }
    }
  }
}

static void removePaddingBits(unsigned char* out, const unsigned char* in,
                              size_t olinebits, size_t ilinebits, unsigned h)
{
  /*
  After filtering there are still padding bits if scanlines have non multiple of 8 bit amounts. They need
  to be removed (except at last scanline of (Adam7-reduced) image) before working with pure image buffers
  for the Adam7 code, the color convert code and the output to the user.
  in and out are allowed to be the same buffer, in may also be higher but still overlapping; in must
  have >= ilinebits*h bits, out must have >= olinebits*h bits, olinebits must be <= ilinebits
  also used to move bits after earlier such operations happened, e.g. in a sequence of reduced images from Adam7
  only useful if (ilinebits - olinebits) is a value in the range 1..7
  */
  unsigned y;
  size_t diff = ilinebits - olinebits;
  size_t ibp = 0, obp = 0; /*input and output bit pointers*/
  for(y = 0; y < h; y++)
  {
    size_t x;
    for(x = 0; x < olinebits; x++)
    {
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    ibp += diff;
  }
}

/*out must be buffer big enough to contain full image, and in must contain the full decompressed data from
the IDAT chunks (with filter index bytes and possible padding bits)
return value is error*/
static unsigned postProcessScanlines(unsigned char* out, unsigned char* in,
                                     unsigned w, unsigned h, const LodePNGInfo* info_png)
{
  /*
  This function converts the filtered-padded-interlaced data into pure 2D image buffer with the PNG's colortype.
  Steps:
  *) if no Adam7: 1) unfilter 2) remove padding bits (= posible extra bits per scanline if bpp < 8)
  *) if adam7: 1) 7x unfilter 2) 7x remove padding bits 3) Adam7_deinterlace
  NOTE: the in buffer will be overwritten with intermediate data!
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
  if(bpp == 0) return 31; /*error: invalid colortype*/

  if(info_png->interlace_method == 0)
  {
    if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
    {
      CERROR_TRY_RETURN(unfilter(in, in, w, h, bpp));
      removePaddingBits(out, in, w * bpp, ((w * bpp + 7) / 8) * 8, h);
    }
    /*we can immediatly filter into the out buffer, no other steps needed*/
    else CERROR_TRY_RETURN(unfilter(out, in, w, h, bpp));
  }
  else /*interlace_method is 1 (Adam7)*/
  {
    unsigned passw[7], passh[7]; size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned i;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    for(i = 0; i < 7; i++)
    {
      CERROR_TRY_RETURN(unfilter(&in[padded_passstart[i]], &in[filter_passstart[i]], passw[i], passh[i], bpp));
      /*TODO: possible efficiency improvement: if in this reduced image the bits fit nicely in 1 scanline,
      move bytes instead of bits or move not at all*/
      if(bpp < 8)
      {
        /*remove padding bits in scanlines; after this there still may be padding
        bits between the different reduced images: each reduced image still starts nicely at a byte*/
        removePaddingBits(&in[passstart[i]], &in[padded_passstart[i]], passw[i] * bpp,
                          ((passw[i] * bpp + 7) / 8) * 8, passh[i]);
      }
    }

    Adam7_deinterlace(out, in, w, h, bpp);
  }

  return 0;
}

static unsigned readChunk_PLTE(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)
{
  unsigned pos = 0, i;
  if(color->palette) lodepng_free(color->palette);
  color->palettesize = chunkLength / 3;
  color->palette = (unsigned char*)lodepng_malloc(4 * color->palettesize);
  if(!color->palette && color->palettesize)
  {
    color->palettesize = 0;
    return 83; /*alloc fail*/
  }
  if(color->palettesize > 256) return 38; /*error: palette too big*/

  for(i = 0; i < color->palettesize; i++)
  {
    color->palette[4 * i + 0] = data[pos++]; /*R*/
    color->palette[4 * i + 1] = data[pos++]; /*G*/
    color->palette[4 * i + 2] = data[pos++]; /*B*/
    color->palette[4 * i + 3] = 255; /*alpha*/
  }

  return 0; /* OK */
}

static unsigned readChunk_tRNS(LodePNGColorMode* color, const unsigned char* data, size_t chunkLength)
{
  unsigned i;
  if(color->colortype == LCT_PALETTE)
  {
    /*error: more alpha values given than there are palette entries*/
    if(chunkLength > color->palettesize) return 38;

    for(i = 0; i < chunkLength; i++) color->palette[4 * i + 3] = data[i];
  }
  else if(color->colortype == LCT_GREY)
  {
    /*error: this chunk must be 2 bytes for greyscale image*/
    if(chunkLength != 2) return 30;

    color->key_defined = 1;
    color->key_r = color->key_g = color->key_b = 256 * data[0] + data[1];
  }
  else if(color->colortype == LCT_RGB)
  {
    /*error: this chunk must be 6 bytes for RGB image*/
    if(chunkLength != 6) return 41;

    color->key_defined = 1;
    color->key_r = 256 * data[0] + data[1];
    color->key_g = 256 * data[2] + data[3];
    color->key_b = 256 * data[4] + data[5];
  }
  else return 42; /*error: tRNS chunk not allowed for other color models*/

  return 0; /* OK */
}


#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
/*background color chunk (bKGD)*/
static unsigned readChunk_bKGD(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(info->color.colortype == LCT_PALETTE)
  {
    /*error: this chunk must be 1 byte for indexed color image*/
    if(chunkLength != 1) return 43;

    info->background_defined = 1;
    info->background_r = info->background_g = info->background_b = data[0];
  }
  else if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)
  {
    /*error: this chunk must be 2 bytes for greyscale image*/
    if(chunkLength != 2) return 44;

    info->background_defined = 1;
    info->background_r = info->background_g = info->background_b
                                 = 256 * data[0] + data[1];
  }
  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)
  {
    /*error: this chunk must be 6 bytes for greyscale image*/
    if(chunkLength != 6) return 45;

    info->background_defined = 1;
    info->background_r = 256 * data[0] + data[1];
    info->background_g = 256 * data[2] + data[3];
    info->background_b = 256 * data[4] + data[5];
  }

  return 0; /* OK */
}

/*text chunk (tEXt)*/
static unsigned readChunk_tEXt(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  char *key = 0, *str = 0;
  unsigned i;

  while(!error) /*not really a while loop, only used to break on error*/
  {
    unsigned length, string2_begin;

    length = 0;
    while(length < chunkLength && data[length] != 0) length++;
    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

    key = (char*)lodepng_malloc(length + 1);
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

    key[length] = 0;
    for(i = 0; i < length; i++) key[i] = data[i];

    string2_begin = length + 1; /*skip keyword null terminator*/

    length = chunkLength < string2_begin ? 0 : chunkLength - string2_begin;
    str = (char*)lodepng_malloc(length + 1);
    if(!str) CERROR_BREAK(error, 83); /*alloc fail*/

    str[length] = 0;
    for(i = 0; i < length; i++) str[i] = data[string2_begin + i];

    error = lodepng_add_text(info, key, str);

    break;
  }

  lodepng_free(key);
  lodepng_free(str);

  return error;
}

/*compressed text chunk (zTXt)*/
static unsigned readChunk_zTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,
                               const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  unsigned i;

  unsigned length, string2_begin;
  char *key = 0;
  ucvector decoded;

  ucvector_init(&decoded);

  while(!error) /*not really a while loop, only used to break on error*/
  {
    for(length = 0; length < chunkLength && data[length] != 0; length++) ;
    if(length + 2 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

    key = (char*)lodepng_malloc(length + 1);
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

    key[length] = 0;
    for(i = 0; i < length; i++) key[i] = data[i];

    if(data[length + 1] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/

    string2_begin = length + 2;
    if(string2_begin > chunkLength) CERROR_BREAK(error, 75); /*no null termination, corrupt?*/

    length = chunkLength - string2_begin;
    /*will fail if zlib error, e.g. if length is too small*/
    error = zlib_decompress(&decoded.data, &decoded.size,
                            (unsigned char*)(&data[string2_begin]),
                            length, zlibsettings);
    if(error) break;
    ucvector_push_back(&decoded, 0);

    error = lodepng_add_text(info, key, (char*)decoded.data);

    break;
  }

  lodepng_free(key);
  ucvector_cleanup(&decoded);

  return error;
}

/*international text chunk (iTXt)*/
static unsigned readChunk_iTXt(LodePNGInfo* info, const LodePNGDecompressSettings* zlibsettings,
                               const unsigned char* data, size_t chunkLength)
{
  unsigned error = 0;
  unsigned i;

  unsigned length, begin, compressed;
  char *key = 0, *langtag = 0, *transkey = 0;
  ucvector decoded;
  ucvector_init(&decoded);

  while(!error) /*not really a while loop, only used to break on error*/
  {
    /*Quick check if the chunk length isn't too small. Even without check
    it'd still fail with other error checks below if it's too short. This just gives a different error code.*/
    if(chunkLength < 5) CERROR_BREAK(error, 30); /*iTXt chunk too short*/

    /*read the key*/
    for(length = 0; length < chunkLength && data[length] != 0; length++) ;
    if(length + 3 >= chunkLength) CERROR_BREAK(error, 75); /*no null termination char, corrupt?*/
    if(length < 1 || length > 79) CERROR_BREAK(error, 89); /*keyword too short or long*/

    key = (char*)lodepng_malloc(length + 1);
    if(!key) CERROR_BREAK(error, 83); /*alloc fail*/

    key[length] = 0;
    for(i = 0; i < length; i++) key[i] = data[i];

    /*read the compression method*/
    compressed = data[length + 1];
    if(data[length + 2] != 0) CERROR_BREAK(error, 72); /*the 0 byte indicating compression must be 0*/

    /*even though it's not allowed by the standard, no error is thrown if
    there's no null termination char, if the text is empty for the next 3 texts*/

    /*read the langtag*/
    begin = length + 3;
    length = 0;
    for(i = begin; i < chunkLength && data[i] != 0; i++) length++;

    langtag = (char*)lodepng_malloc(length + 1);
    if(!langtag) CERROR_BREAK(error, 83); /*alloc fail*/

    langtag[length] = 0;
    for(i = 0; i < length; i++) langtag[i] = data[begin + i];

    /*read the transkey*/
    begin += length + 1;
    length = 0;
    for(i = begin; i < chunkLength && data[i] != 0; i++) length++;

    transkey = (char*)lodepng_malloc(length + 1);
    if(!transkey) CERROR_BREAK(error, 83); /*alloc fail*/

    transkey[length] = 0;
    for(i = 0; i < length; i++) transkey[i] = data[begin + i];

    /*read the actual text*/
    begin += length + 1;

    length = chunkLength < begin ? 0 : chunkLength - begin;

    if(compressed)
    {
      /*will fail if zlib error, e.g. if length is too small*/
      error = zlib_decompress(&decoded.data, &decoded.size,
                              (unsigned char*)(&data[begin]),
                              length, zlibsettings);
      if(error) break;
      if(decoded.allocsize < decoded.size) decoded.allocsize = decoded.size;
      ucvector_push_back(&decoded, 0);
    }
    else
    {
      if(!ucvector_resize(&decoded, length + 1)) CERROR_BREAK(error, 83 /*alloc fail*/);

      decoded.data[length] = 0;
      for(i = 0; i < length; i++) decoded.data[i] = data[begin + i];
    }

    error = lodepng_add_itext(info, key, langtag, transkey, (char*)decoded.data);

    break;
  }

  lodepng_free(key);
  lodepng_free(langtag);
  lodepng_free(transkey);
  ucvector_cleanup(&decoded);

  return error;
}

static unsigned readChunk_tIME(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(chunkLength != 7) return 73; /*invalid tIME chunk size*/

  info->time_defined = 1;
  info->time.year = 256 * data[0] + data[+ 1];
  info->time.month = data[2];
  info->time.day = data[3];
  info->time.hour = data[4];
  info->time.minute = data[5];
  info->time.second = data[6];

  return 0; /* OK */
}

static unsigned readChunk_pHYs(LodePNGInfo* info, const unsigned char* data, size_t chunkLength)
{
  if(chunkLength != 9) return 74; /*invalid pHYs chunk size*/

  info->phys_defined = 1;
  info->phys_x = 16777216 * data[0] + 65536 * data[1] + 256 * data[2] + data[3];
  info->phys_y = 16777216 * data[4] + 65536 * data[5] + 256 * data[6] + data[7];
  info->phys_unit = data[8];

  return 0; /* OK */
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

/*read a PNG, the result will be in the same color type as the PNG (hence "generic")*/
static void decodeGeneric(unsigned char** out, unsigned* w, unsigned* h,
                          LodePNGState* state,
                          const unsigned char* in, size_t insize)
{
  unsigned char IEND = 0;
  const unsigned char* chunk;
  size_t i;
  ucvector idat; /*the data from idat chunks*/

  /*for unknown chunk order*/
  unsigned unknown = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  unsigned critical_pos = 1; /*1 = after IHDR, 2 = after PLTE, 3 = after IDAT*/
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

  /*provide some proper output values if error will happen*/
  //*out = 0;

  state->error = lodepng_inspect(w, h, state, in, insize); /*reads header and resets other parameters in state->info_png*/
  if(state->error) return;

  ucvector_init(&idat);
  chunk = &in[33]; /*first byte of the first chunk after the header*/

  /*loop through the chunks, ignoring unknown chunks and stopping at IEND chunk.
  IDAT data is put at the start of the in buffer*/
  while(!IEND && !state->error)
  {
    unsigned chunkLength;
    const unsigned char* data; /*the data in the chunk*/

    /*error: size of the in buffer too small to contain next chunk*/
    if((size_t)((chunk - in) + 12) > insize || chunk < in) CERROR_BREAK(state->error, 30);

    /*length of the data of the chunk, excluding the length bytes, chunk type and CRC bytes*/
    chunkLength = lodepng_chunk_length(chunk);
    /*error: chunk length larger than the max PNG chunk size*/
    if(chunkLength > 2147483647) CERROR_BREAK(state->error, 63);

    if((size_t)((chunk - in) + chunkLength + 12) > insize || (chunk + chunkLength + 12) < in)
    {
      CERROR_BREAK(state->error, 64); /*error: size of the in buffer too small to contain next chunk*/
    }

    data = lodepng_chunk_data_const(chunk);

    /*IDAT chunk, containing compressed image data*/
    if(lodepng_chunk_type_equals(chunk, "IDAT"))
    {
      size_t oldsize = idat.size;
      if(!ucvector_resize(&idat, oldsize + chunkLength)) CERROR_BREAK(state->error, 83 /*alloc fail*/);
      for(i = 0; i < chunkLength; i++) idat.data[oldsize + i] = data[i];
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 3;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }
    /*IEND chunk*/
    else if(lodepng_chunk_type_equals(chunk, "IEND"))
    {
      IEND = 1;
    }
    /*palette chunk (PLTE)*/
    else if(lodepng_chunk_type_equals(chunk, "PLTE"))
    {
      state->error = readChunk_PLTE(&state->info_png.color, data, chunkLength);
      if(state->error) break;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      critical_pos = 2;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }
    /*palette transparency chunk (tRNS)*/
    else if(lodepng_chunk_type_equals(chunk, "tRNS"))
    {
      state->error = readChunk_tRNS(&state->info_png.color, data, chunkLength);
      if(state->error) break;
    }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*background color chunk (bKGD)*/
    else if(lodepng_chunk_type_equals(chunk, "bKGD"))
    {
      state->error = readChunk_bKGD(&state->info_png, data, chunkLength);
      if(state->error) break;
    }
    /*text chunk (tEXt)*/
    else if(lodepng_chunk_type_equals(chunk, "tEXt"))
    {
      if(state->decoder.read_text_chunks)
      {
        state->error = readChunk_tEXt(&state->info_png, data, chunkLength);
        if(state->error) break;
      }
    }
    /*compressed text chunk (zTXt)*/
    else if(lodepng_chunk_type_equals(chunk, "zTXt"))
    {
      if(state->decoder.read_text_chunks)
      {
        state->error = readChunk_zTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
        if(state->error) break;
      }
    }
    /*international text chunk (iTXt)*/
    else if(lodepng_chunk_type_equals(chunk, "iTXt"))
    {
      if(state->decoder.read_text_chunks)
      {
        state->error = readChunk_iTXt(&state->info_png, &state->decoder.zlibsettings, data, chunkLength);
        if(state->error) break;
      }
    }
    else if(lodepng_chunk_type_equals(chunk, "tIME"))
    {
      state->error = readChunk_tIME(&state->info_png, data, chunkLength);
      if(state->error) break;
    }
    else if(lodepng_chunk_type_equals(chunk, "pHYs"))
    {
      state->error = readChunk_pHYs(&state->info_png, data, chunkLength);
      if(state->error) break;
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    else /*it's not an implemented chunk type, so ignore it: skip over the data*/
    {
      /*error: unknown critical chunk (5th bit of first byte of chunk type is 0)*/
      if(!lodepng_chunk_ancillary(chunk)) CERROR_BREAK(state->error, 69);

      unknown = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
      if(state->decoder.remember_unknown_chunks)
      {
        state->error = lodepng_chunk_append(&state->info_png.unknown_chunks_data[critical_pos - 1],
                                            &state->info_png.unknown_chunks_size[critical_pos - 1], chunk);
        if(state->error) break;
      }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    }

    if(!state->decoder.ignore_crc && !unknown) /*check CRC if wanted, only on known chunk types*/
    {
      if(lodepng_chunk_check_crc(chunk)) CERROR_BREAK(state->error, 57); /*invalid CRC*/
    }

    if(!IEND) chunk = lodepng_chunk_next_const(chunk);
  }

  if(!state->error)
  {
    ucvector scanlines;
    ucvector_init(&scanlines);

    /*maximum final image length is already reserved in the vector's length - this is not really necessary*/
    if(!ucvector_resize(&scanlines, lodepng_get_raw_size(*w, *h, &state->info_png.color) + *h))
    {
      state->error = 83; /*alloc fail*/
    }
    if(!state->error)
    {
      /*decompress with the Zlib decompressor*/
      state->error = zlib_decompress(&scanlines.data, &scanlines.size, idat.data,
                                     idat.size, &state->decoder.zlibsettings);
    }

    if(!state->error)
    {

      /*
      ucvector outv;
      ucvector_init(&outv);
      if(!ucvector_resizev(&outv,
          lodepng_get_raw_size(*w, *h, &state->info_png.color), 0)  ){
          state->error = 83; //alloc fail
      }
      if(!state->error) {
        state->error = postProcessScanlines(outv.data, scanlines.data, *w, *h, &state->info_png);
      }
      //*out = outv.data;
      */
      state->error = postProcessScanlines(*out, scanlines.data, *w, *h, &state->info_png);
    }
    ucvector_cleanup(&scanlines);
  }

  ucvector_cleanup(&idat);
}

unsigned lodepng_decode(unsigned char** out, unsigned* w, unsigned* h,
                        LodePNGState* state,
                        const unsigned char* in, size_t insize)
{
  //*out = 0;
  decodeGeneric(out, w, h, state, in, insize);
  if(state->error) return state->error;
  if(!state->decoder.color_convert || lodepng_color_mode_equal(&state->info_raw, &state->info_png.color))
  {
    /*same color type, no copying or converting of data needed*/
    /*store the info_png color settings on the info_raw so that the info_raw still reflects what colortype
    the raw image has to the end user*/
    if(!state->decoder.color_convert)
    {
      state->error = lodepng_color_mode_copy(&state->info_raw, &state->info_png.color);
      if(state->error) return state->error;
    }
  }
  else
  {
    /*color conversion needed; sort of copy of the data*/
    unsigned char* data = *out;
    size_t outsize;

    /*TODO: check if this works according to the statement in the documentation: "The converter can convert
    from greyscale input color type, to 8-bit greyscale or greyscale with alpha"*/
    if(!(state->info_raw.colortype == LCT_RGB || state->info_raw.colortype == LCT_RGBA)
       && !(state->info_raw.bitdepth == 8))
    {
      return 56; /*unsupported color mode conversion*/
    }

    outsize = lodepng_get_raw_size(*w, *h, &state->info_raw);
    //*out = (unsigned char*)lodepng_malloc(outsize);
    if(!(*out))
    {
      state->error = 83; /*alloc fail*/
    }
    else state->error = lodepng_convert(*out, data, &state->info_raw, &state->info_png.color, *w, *h, state->decoder.fix_png);
    lodepng_free(data);
  }
  return state->error;
}

unsigned lodepng_decode_memory(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in,
                               size_t insize, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
  state.info_raw.colortype = colortype;
  state.info_raw.bitdepth = bitdepth;
  error = lodepng_decode(out, w, h, &state, in, insize);
  lodepng_state_cleanup(&state);
  return error;
}

unsigned lodepng_decode32(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)
{
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGBA, 8);
}

unsigned lodepng_decode24(unsigned char** out, unsigned* w, unsigned* h, const unsigned char* in, size_t insize)
{
  return lodepng_decode_memory(out, w, h, in, insize, LCT_RGB, 8);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_decode_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename,
                             LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error;
  error = lodepng_load_file(&buffer, &buffersize, filename);
  if(!error) error = lodepng_decode_memory(out, w, h, buffer, buffersize, colortype, bitdepth);
  lodepng_free(buffer);
  return error;
}

unsigned lodepng_decode32_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)
{
  return lodepng_decode_file(out, w, h, filename, LCT_RGBA, 8);
}

unsigned lodepng_decode24_file(unsigned char** out, unsigned* w, unsigned* h, const char* filename)
{
  return lodepng_decode_file(out, w, h, filename, LCT_RGB, 8);
}
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_decoder_settings_init(LodePNGDecoderSettings* settings)
{
  settings->color_convert = 1;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->read_text_chunks = 1;
  settings->remember_unknown_chunks = 0;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
  settings->ignore_crc = 0;
  settings->fix_png = 0;
  lodepng_decompress_settings_init(&settings->zlibsettings);
}

#endif /*LODEPNG_COMPILE_DECODER*/

#if defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER)

void lodepng_state_init(LodePNGState* state)
{
#ifdef LODEPNG_COMPILE_DECODER
  lodepng_decoder_settings_init(&state->decoder);
#endif /*LODEPNG_COMPILE_DECODER*/
#ifdef LODEPNG_COMPILE_ENCODER
  lodepng_encoder_settings_init(&state->encoder);
#endif /*LODEPNG_COMPILE_ENCODER*/
  lodepng_color_mode_init(&state->info_raw);
  lodepng_info_init(&state->info_png);
  state->error = 1;
}

void lodepng_state_cleanup(LodePNGState* state)
{
  lodepng_color_mode_cleanup(&state->info_raw);
  lodepng_info_cleanup(&state->info_png);
}

void lodepng_state_copy(LodePNGState* dest, const LodePNGState* source)
{
  lodepng_state_cleanup(dest);
  *dest = *source;
  lodepng_color_mode_init(&dest->info_raw);
  lodepng_info_init(&dest->info_png);
  dest->error = lodepng_color_mode_copy(&dest->info_raw, &source->info_raw); if(dest->error) return;
  dest->error = lodepng_info_copy(&dest->info_png, &source->info_png); if(dest->error) return;
}

#endif /* defined(LODEPNG_COMPILE_DECODER) || defined(LODEPNG_COMPILE_ENCODER) */

#ifdef LODEPNG_COMPILE_ENCODER

/* ////////////////////////////////////////////////////////////////////////// */
/* / PNG Encoder                                                            / */
/* ////////////////////////////////////////////////////////////////////////// */

/*chunkName must be string of 4 characters*/
static unsigned addChunk(ucvector* out, const char* chunkName, const unsigned char* data, size_t length)
{
  CERROR_TRY_RETURN(lodepng_chunk_create(&out->data, &out->size, (unsigned)length, chunkName, data));
  out->allocsize = out->size; /*fix the allocsize again*/
  return 0;
}

static void writeSignature(ucvector* out)
{
  /*8 bytes PNG signature, aka the magic bytes*/
  ucvector_push_back(out, 137);
  ucvector_push_back(out, 80);
  ucvector_push_back(out, 78);
  ucvector_push_back(out, 71);
  ucvector_push_back(out, 13);
  ucvector_push_back(out, 10);
  ucvector_push_back(out, 26);
  ucvector_push_back(out, 10);
}

static unsigned addChunk_IHDR(ucvector* out, unsigned w, unsigned h,
                              LodePNGColorType colortype, unsigned bitdepth, unsigned interlace_method)
{
  unsigned error = 0;
  ucvector header;
  ucvector_init(&header);

  lodepng_add32bitInt(&header, w); /*width*/
  lodepng_add32bitInt(&header, h); /*height*/
  ucvector_push_back(&header, (unsigned char)bitdepth); /*bit depth*/
  ucvector_push_back(&header, (unsigned char)colortype); /*color type*/
  ucvector_push_back(&header, 0); /*compression method*/
  ucvector_push_back(&header, 0); /*filter method*/
  ucvector_push_back(&header, interlace_method); /*interlace method*/

  error = addChunk(out, "IHDR", header.data, header.size);
  ucvector_cleanup(&header);

  return error;
}

static unsigned addChunk_PLTE(ucvector* out, const LodePNGColorMode* info)
{
  unsigned error = 0;
  size_t i;
  ucvector PLTE;
  ucvector_init(&PLTE);
  for(i = 0; i < info->palettesize * 4; i++)
  {
    /*add all channels except alpha channel*/
    if(i % 4 != 3) ucvector_push_back(&PLTE, info->palette[i]);
  }
  error = addChunk(out, "PLTE", PLTE.data, PLTE.size);
  ucvector_cleanup(&PLTE);

  return error;
}

static unsigned addChunk_tRNS(ucvector* out, const LodePNGColorMode* info)
{
  unsigned error = 0;
  size_t i;
  ucvector tRNS;
  ucvector_init(&tRNS);
  if(info->colortype == LCT_PALETTE)
  {
    size_t amount = info->palettesize;
    /*the tail of palette values that all have 255 as alpha, does not have to be encoded*/
    for(i = info->palettesize; i > 0; i--)
    {
      if(info->palette[4 * (i - 1) + 3] == 255) amount--;
      else break;
    }
    /*add only alpha channel*/
    for(i = 0; i < amount; i++) ucvector_push_back(&tRNS, info->palette[4 * i + 3]);
  }
  else if(info->colortype == LCT_GREY)
  {
    if(info->key_defined)
    {
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r / 256));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r % 256));
    }
  }
  else if(info->colortype == LCT_RGB)
  {
    if(info->key_defined)
    {
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r / 256));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_r % 256));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_g / 256));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_g % 256));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_b / 256));
      ucvector_push_back(&tRNS, (unsigned char)(info->key_b % 256));
    }
  }

  error = addChunk(out, "tRNS", tRNS.data, tRNS.size);
  ucvector_cleanup(&tRNS);

  return error;
}

static unsigned addChunk_IDAT(ucvector* out, const unsigned char* data, size_t datasize,
                              LodePNGCompressSettings* zlibsettings)
{
  ucvector zlibdata;
  unsigned error = 0;

  /*compress with the Zlib compressor*/
  ucvector_init(&zlibdata);
  error = zlib_compress(&zlibdata.data, &zlibdata.size, data, datasize, zlibsettings);
  if(!error) error = addChunk(out, "IDAT", zlibdata.data, zlibdata.size);
  ucvector_cleanup(&zlibdata);

  return error;
}

static unsigned addChunk_IEND(ucvector* out)
{
  unsigned error = 0;
  error = addChunk(out, "IEND", 0, 0);
  return error;
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS

static unsigned addChunk_tEXt(ucvector* out, const char* keyword, const char* textstring)
{
  unsigned error = 0;
  size_t i;
  ucvector text;
  ucvector_init(&text);
  for(i = 0; keyword[i] != 0; i++) ucvector_push_back(&text, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&text, 0); /*0 termination char*/
  for(i = 0; textstring[i] != 0; i++) ucvector_push_back(&text, (unsigned char)textstring[i]);
  error = addChunk(out, "tEXt", text.data, text.size);
  ucvector_cleanup(&text);

  return error;
}

static unsigned addChunk_zTXt(ucvector* out, const char* keyword, const char* textstring,
                              LodePNGCompressSettings* zlibsettings)
{
  unsigned error = 0;
  ucvector data, compressed;
  size_t i, textsize = strlen(textstring);

  ucvector_init(&data);
  ucvector_init(&compressed);
  for(i = 0; keyword[i] != 0; i++) ucvector_push_back(&data, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&data, 0); /*0 termination char*/
  ucvector_push_back(&data, 0); /*compression method: 0*/

  error = zlib_compress(&compressed.data, &compressed.size,
                        (unsigned char*)textstring, textsize, zlibsettings);
  if(!error)
  {
    for(i = 0; i < compressed.size; i++) ucvector_push_back(&data, compressed.data[i]);
    error = addChunk(out, "zTXt", data.data, data.size);
  }

  ucvector_cleanup(&compressed);
  ucvector_cleanup(&data);
  return error;
}

static unsigned addChunk_iTXt(ucvector* out, unsigned compressed, const char* keyword, const char* langtag,
                              const char* transkey, const char* textstring, LodePNGCompressSettings* zlibsettings)
{
  unsigned error = 0;
  ucvector data;
  size_t i, textsize = strlen(textstring);

  ucvector_init(&data);

  for(i = 0; keyword[i] != 0; i++) ucvector_push_back(&data, (unsigned char)keyword[i]);
  if(i < 1 || i > 79) return 89; /*error: invalid keyword size*/
  ucvector_push_back(&data, 0); /*null termination char*/
  ucvector_push_back(&data, compressed ? 1 : 0); /*compression flag*/
  ucvector_push_back(&data, 0); /*compression method*/
  for(i = 0; langtag[i] != 0; i++) ucvector_push_back(&data, (unsigned char)langtag[i]);
  ucvector_push_back(&data, 0); /*null termination char*/
  for(i = 0; transkey[i] != 0; i++) ucvector_push_back(&data, (unsigned char)transkey[i]);
  ucvector_push_back(&data, 0); /*null termination char*/

  if(compressed)
  {
    ucvector compressed_data;
    ucvector_init(&compressed_data);
    error = zlib_compress(&compressed_data.data, &compressed_data.size,
                          (unsigned char*)textstring, textsize, zlibsettings);
    if(!error)
    {
      for(i = 0; i < compressed_data.size; i++) ucvector_push_back(&data, compressed_data.data[i]);
    }
    ucvector_cleanup(&compressed_data);
  }
  else /*not compressed*/
  {
    for(i = 0; textstring[i] != 0; i++) ucvector_push_back(&data, (unsigned char)textstring[i]);
  }

  if(!error) error = addChunk(out, "iTXt", data.data, data.size);
  ucvector_cleanup(&data);
  return error;
}

static unsigned addChunk_bKGD(ucvector* out, const LodePNGInfo* info)
{
  unsigned error = 0;
  ucvector bKGD;
  ucvector_init(&bKGD);
  if(info->color.colortype == LCT_GREY || info->color.colortype == LCT_GREY_ALPHA)
  {
    ucvector_push_back(&bKGD, (unsigned char)(info->background_r / 256));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256));
  }
  else if(info->color.colortype == LCT_RGB || info->color.colortype == LCT_RGBA)
  {
    ucvector_push_back(&bKGD, (unsigned char)(info->background_r / 256));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_g / 256));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_g % 256));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_b / 256));
    ucvector_push_back(&bKGD, (unsigned char)(info->background_b % 256));
  }
  else if(info->color.colortype == LCT_PALETTE)
  {
    ucvector_push_back(&bKGD, (unsigned char)(info->background_r % 256)); /*palette index*/
  }

  error = addChunk(out, "bKGD", bKGD.data, bKGD.size);
  ucvector_cleanup(&bKGD);

  return error;
}

static unsigned addChunk_tIME(ucvector* out, const LodePNGTime* time)
{
  unsigned error = 0;
  unsigned char* data = (unsigned char*)lodepng_malloc(7);
  if(!data) return 83; /*alloc fail*/
  data[0] = (unsigned char)(time->year / 256);
  data[1] = (unsigned char)(time->year % 256);
  data[2] = time->month;
  data[3] = time->day;
  data[4] = time->hour;
  data[5] = time->minute;
  data[6] = time->second;
  error = addChunk(out, "tIME", data, 7);
  lodepng_free(data);
  return error;
}

static unsigned addChunk_pHYs(ucvector* out, const LodePNGInfo* info)
{
  unsigned error = 0;
  ucvector data;
  ucvector_init(&data);

  lodepng_add32bitInt(&data, info->phys_x);
  lodepng_add32bitInt(&data, info->phys_y);
  ucvector_push_back(&data, info->phys_unit);

  error = addChunk(out, "pHYs", data.data, data.size);
  ucvector_cleanup(&data);

  return error;
}

#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

static void filterScanline(unsigned char* out, const unsigned char* scanline, const unsigned char* prevline,
                           size_t length, size_t bytewidth, unsigned char filterType)
{
  size_t i;
  switch(filterType)
  {
    case 0: /*None*/
      for(i = 0; i < length; i++) out[i] = scanline[i];
      break;
    case 1: /*Sub*/
      if(prevline)
      {
        for(i = 0; i < bytewidth; i++) out[i] = scanline[i];
        for(i = bytewidth; i < length; i++) out[i] = scanline[i] - scanline[i - bytewidth];
      }
      else
      {
        for(i = 0; i < bytewidth; i++) out[i] = scanline[i];
        for(i = bytewidth; i < length; i++) out[i] = scanline[i] - scanline[i - bytewidth];
      }
      break;
    case 2: /*Up*/
      if(prevline)
      {
        for(i = 0; i < length; i++) out[i] = scanline[i] - prevline[i];
      }
      else
      {
        for(i = 0; i < length; i++) out[i] = scanline[i];
      }
      break;
    case 3: /*Average*/
      if(prevline)
      {
        for(i = 0; i < bytewidth; i++) out[i] = scanline[i] - prevline[i] / 2;
        for(i = bytewidth; i < length; i++) out[i] = scanline[i] - ((scanline[i - bytewidth] + prevline[i]) / 2);
      }
      else
      {
        for(i = 0; i < bytewidth; i++) out[i] = scanline[i];
        for(i = bytewidth; i < length; i++) out[i] = scanline[i] - scanline[i - bytewidth] / 2;
      }
      break;
    case 4: /*Paeth*/
      if(prevline)
      {
        /*paethPredictor(0, prevline[i], 0) is always prevline[i]*/
        for(i = 0; i < bytewidth; i++) out[i] = (scanline[i] - prevline[i]);
        for(i = bytewidth; i < length; i++)
        {
          out[i] = (scanline[i] - paethPredictor(scanline[i - bytewidth], prevline[i], prevline[i - bytewidth]));
        }
      }
      else
      {
        for(i = 0; i < bytewidth; i++) out[i] = scanline[i];
        /*paethPredictor(scanline[i - bytewidth], 0, 0) is always scanline[i - bytewidth]*/
        for(i = bytewidth; i < length; i++) out[i] = (scanline[i] - scanline[i - bytewidth]);
      }
      break;
    default: return; /*unexisting filter type given*/
  }
}

/* log2 approximation. A slight bit faster than std::log. */
static float flog2(float f)
{
  float result = 0;
  while(f > 32) { result += 4; f /= 16; }
  while(f > 2) { result++; f /= 2; }
  return result + 1.442695f * (f * f * f / 3 - 3 * f * f / 2 + 3 * f - 1.83333f);
}

static unsigned filter(unsigned char* out, const unsigned char* in, unsigned w, unsigned h,
                       const LodePNGColorMode* info, const LodePNGEncoderSettings* settings)
{
  /*
  For PNG filter method 0
  out must be a buffer with as size: h + (w * h * bpp + 7) / 8, because there are
  the scanlines with 1 extra byte per scanline
  */

  unsigned bpp = lodepng_get_bpp(info);
  /*the width of a scanline in bytes, not including the filter type*/
  size_t linebytes = (w * bpp + 7) / 8;
  /*bytewidth is used for filtering, is 1 when bpp < 8, number of bytes per pixel otherwise*/
  size_t bytewidth = (bpp + 7) / 8;
  const unsigned char* prevline = 0;
  unsigned x, y;
  unsigned error = 0;
  LodePNGFilterStrategy strategy = settings->filter_strategy;

  /*
  There is a heuristic called the minimum sum of absolute differences heuristic, suggested by the PNG standard:
   *  If the image type is Palette, or the bit depth is smaller than 8, then do not filter the image (i.e.
      use fixed filtering, with the filter None).
   * (The other case) If the image type is Grayscale or RGB (with or without Alpha), and the bit depth is
     not smaller than 8, then use adaptive filtering heuristic as follows: independently for each row, apply
     all five filters and select the filter that produces the smallest sum of absolute values per row.
  This heuristic is used if filter strategy is LFS_MINSUM and filter_palette_zero is true.

  If filter_palette_zero is true and filter_strategy is not LFS_MINSUM, the above heuristic is followed,
  but for "the other case", whatever strategy filter_strategy is set to instead of the minimum sum
  heuristic is used.
  */
  if(settings->filter_palette_zero &&
     (info->colortype == LCT_PALETTE || info->bitdepth < 8)) strategy = LFS_ZERO;

  if(bpp == 0) return 31; /*error: invalid color type*/

  if(strategy == LFS_ZERO)
  {
    for(y = 0; y < h; y++)
    {
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
      size_t inindex = linebytes * y;
      out[outindex] = 0; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, 0);
      prevline = &in[inindex];
    }
  }
  else if(strategy == LFS_MINSUM)
  {
    /*adaptive filtering*/
    size_t sum[5];
    ucvector attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned type, bestType = 0;

    for(type = 0; type < 5; type++)
    {
      ucvector_init(&attempt[type]);
      if(!ucvector_resize(&attempt[type], linebytes)) return 83; /*alloc fail*/
    }

    if(!error)
    {
      for(y = 0; y < h; y++)
      {
        /*try the 5 filter types*/
        for(type = 0; type < 5; type++)
        {
          filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);

          /*calculate the sum of the result*/
          sum[type] = 0;
          if(type == 0)
          {
            for(x = 0; x < linebytes; x++) sum[type] += (unsigned char)(attempt[type].data[x]);
          }
          else
          {
            for(x = 0; x < linebytes; x++)
            {
              /*For differences, each byte should be treated as signed, values above 127 are negative
              (converted to signed char). Filtertype 0 isn't a difference though, so use unsigned there.
              This means filtertype 0 is almost never chosen, but that is justified.*/
              signed char s = (signed char)(attempt[type].data[x]);
              sum[type] += s < 0 ? -s : s;
            }
          }

          /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
          if(type == 0 || sum[type] < smallest)
          {
            bestType = type;
            smallest = sum[type];
          }
        }

        prevline = &in[y * linebytes];

        /*now fill the out values*/
        out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
        for(x = 0; x < linebytes; x++) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];
      }
    }

    for(type = 0; type < 5; type++) ucvector_cleanup(&attempt[type]);
  }
  else if(strategy == LFS_ENTROPY)
  {
    float sum[5];
    ucvector attempt[5]; /*five filtering attempts, one for each filter type*/
    float smallest = 0;
    unsigned type, bestType = 0;
    unsigned count[256];

    for(type = 0; type < 5; type++)
    {
      ucvector_init(&attempt[type]);
      if(!ucvector_resize(&attempt[type], linebytes)) return 83; /*alloc fail*/
    }

    for(y = 0; y < h; y++)
    {
      /*try the 5 filter types*/
      for(type = 0; type < 5; type++)
      {
        filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);
        for(x = 0; x < 256; x++) count[x] = 0;
        for(x = 0; x < linebytes; x++) count[attempt[type].data[x]]++;
        count[type]++; /*the filter type itself is part of the scanline*/
        sum[type] = 0;
        for(x = 0; x < 256; x++)
        {
          float p = count[x] / (float)(linebytes + 1);
          sum[type] += count[x] == 0 ? 0 : flog2(1 / p) * p;
        }
        /*check if this is smallest sum (or if type == 0 it's the first case so always store the values)*/
        if(type == 0 || sum[type] < smallest)
        {
          bestType = type;
          smallest = sum[type];
        }
      }

      prevline = &in[y * linebytes];

      /*now fill the out values*/
      out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
      for(x = 0; x < linebytes; x++) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];
    }

    for(type = 0; type < 5; type++) ucvector_cleanup(&attempt[type]);
  }
  else if(strategy == LFS_PREDEFINED)
  {
    for(y = 0; y < h; y++)
    {
      size_t outindex = (1 + linebytes) * y; /*the extra filterbyte added to each row*/
      size_t inindex = linebytes * y;
      unsigned type = settings->predefined_filters[y];
      out[outindex] = type; /*filter type byte*/
      filterScanline(&out[outindex + 1], &in[inindex], prevline, linebytes, bytewidth, type);
      prevline = &in[inindex];
    }
  }
  else if(strategy == LFS_BRUTE_FORCE)
  {
    /*brute force filter chooser.
    deflate the scanline after every filter attempt to see which one deflates best.
    This is very slow and gives only slightly smaller, sometimes even larger, result*/
    size_t size[5];
    ucvector attempt[5]; /*five filtering attempts, one for each filter type*/
    size_t smallest = 0;
    unsigned type = 0, bestType = 0;
    unsigned char* dummy;
    LodePNGCompressSettings zlibsettings = settings->zlibsettings;
    /*use fixed tree on the attempts so that the tree is not adapted to the filtertype on purpose,
    to simulate the true case where the tree is the same for the whole image. Sometimes it gives
    better result with dynamic tree anyway. Using the fixed tree sometimes gives worse, but in rare
    cases better compression. It does make this a bit less slow, so it's worth doing this.*/
    zlibsettings.btype = 1;
    /*a custom encoder likely doesn't read the btype setting and is optimized for complete PNG
    images only, so disable it*/
    zlibsettings.custom_zlib = 0;
    zlibsettings.custom_deflate = 0;
    for(type = 0; type < 5; type++)
    {
      ucvector_init(&attempt[type]);
      ucvector_resize(&attempt[type], linebytes); /*todo: give error if resize failed*/
    }
    for(y = 0; y < h; y++) /*try the 5 filter types*/
    {
      for(type = 0; type < 5; type++)
      {
        unsigned testsize = attempt[type].size;
        /*if(testsize > 8) testsize /= 8;*/ /*it already works good enough by testing a part of the row*/

        filterScanline(attempt[type].data, &in[y * linebytes], prevline, linebytes, bytewidth, type);
        size[type] = 0;
        dummy = 0;
        zlib_compress(&dummy, &size[type], attempt[type].data, testsize, &zlibsettings);
        lodepng_free(dummy);
        /*check if this is smallest size (or if type == 0 it's the first case so always store the values)*/
        if(type == 0 || size[type] < smallest)
        {
          bestType = type;
          smallest = size[type];
        }
      }
      prevline = &in[y * linebytes];
      out[y * (linebytes + 1)] = bestType; /*the first byte of a scanline will be the filter type*/
      for(x = 0; x < linebytes; x++) out[y * (linebytes + 1) + 1 + x] = attempt[bestType].data[x];
    }
    for(type = 0; type < 5; type++) ucvector_cleanup(&attempt[type]);
  }
  else return 88; /* unknown filter strategy */

  return error;
}

static void addPaddingBits(unsigned char* out, const unsigned char* in,
                           size_t olinebits, size_t ilinebits, unsigned h)
{
  /*The opposite of the removePaddingBits function
  olinebits must be >= ilinebits*/
  unsigned y;
  size_t diff = olinebits - ilinebits;
  size_t obp = 0, ibp = 0; /*bit pointers*/
  for(y = 0; y < h; y++)
  {
    size_t x;
    for(x = 0; x < ilinebits; x++)
    {
      unsigned char bit = readBitFromReversedStream(&ibp, in);
      setBitOfReversedStream(&obp, out, bit);
    }
    /*obp += diff; --> no, fill in some value in the padding bits too, to avoid
    "Use of uninitialised value of size ###" warning from valgrind*/
    for(x = 0; x < diff; x++) setBitOfReversedStream(&obp, out, 0);
  }
}

/*
in: non-interlaced image with size w*h
out: the same pixels, but re-ordered according to PNG's Adam7 interlacing, with
 no padding bits between scanlines, but between reduced images so that each
 reduced image starts at a byte.
bpp: bits per pixel
there are no padding bits, not between scanlines, not between reduced images
in has the following size in bits: w * h * bpp.
out is possibly bigger due to padding bits between reduced images
NOTE: comments about padding bits are only relevant if bpp < 8
*/
static void Adam7_interlace(unsigned char* out, const unsigned char* in, unsigned w, unsigned h, unsigned bpp)
{
  unsigned passw[7], passh[7];
  size_t filter_passstart[8], padded_passstart[8], passstart[8];
  unsigned i;

  Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

  if(bpp >= 8)
  {
    for(i = 0; i < 7; i++)
    {
      unsigned x, y, b;
      size_t bytewidth = bpp / 8;
      for(y = 0; y < passh[i]; y++)
      for(x = 0; x < passw[i]; x++)
      {
        size_t pixelinstart = ((ADAM7_IY[i] + y * ADAM7_DY[i]) * w + ADAM7_IX[i] + x * ADAM7_DX[i]) * bytewidth;
        size_t pixeloutstart = passstart[i] + (y * passw[i] + x) * bytewidth;
        for(b = 0; b < bytewidth; b++)
        {
          out[pixeloutstart + b] = in[pixelinstart + b];
        }
      }
    }
  }
  else /*bpp < 8: Adam7 with pixels < 8 bit is a bit trickier: with bit pointers*/
  {
    for(i = 0; i < 7; i++)
    {
      unsigned x, y, b;
      unsigned ilinebits = bpp * passw[i];
      unsigned olinebits = bpp * w;
      size_t obp, ibp; /*bit pointers (for out and in buffer)*/
      for(y = 0; y < passh[i]; y++)
      for(x = 0; x < passw[i]; x++)
      {
        ibp = (ADAM7_IY[i] + y * ADAM7_DY[i]) * olinebits + (ADAM7_IX[i] + x * ADAM7_DX[i]) * bpp;
        obp = (8 * passstart[i]) + (y * ilinebits + x * bpp);
        for(b = 0; b < bpp; b++)
        {
          unsigned char bit = readBitFromReversedStream(&ibp, in);
          setBitOfReversedStream(&obp, out, bit);
        }
      }
    }
  }
}

/*out must be buffer big enough to contain uncompressed IDAT chunk data, and in must contain the full image.
return value is error**/
static unsigned preProcessScanlines(unsigned char** out, size_t* outsize, const unsigned char* in,
                                    unsigned w, unsigned h,
                                    const LodePNGInfo* info_png, const LodePNGEncoderSettings* settings)
{
  /*
  This function converts the pure 2D image with the PNG's colortype, into filtered-padded-interlaced data. Steps:
  *) if no Adam7: 1) add padding bits (= posible extra bits per scanline if bpp < 8) 2) filter
  *) if adam7: 1) Adam7_interlace 2) 7x add padding bits 3) 7x filter
  */
  unsigned bpp = lodepng_get_bpp(&info_png->color);
  unsigned error = 0;

  if(info_png->interlace_method == 0)
  {
    *outsize = h + (h * ((w * bpp + 7) / 8)); /*image size plus an extra byte per scanline + possible padding bits*/
    //*out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out) && (*outsize)) error = 83; /*alloc fail*/

    if(!error)
    {
      /*non multiple of 8 bits per scanline, padding bits needed per scanline*/
      if(bpp < 8 && w * bpp != ((w * bpp + 7) / 8) * 8)
      {
        unsigned char* padded = (unsigned char*)lodepng_malloc(h * ((w * bpp + 7) / 8));
        if(!padded) error = 83; /*alloc fail*/
        if(!error)
        {
          addPaddingBits(padded, in, ((w * bpp + 7) / 8) * 8, w * bpp, h);
          error = filter(*out, padded, w, h, &info_png->color, settings);
        }
        lodepng_free(padded);
      }
      else
      {
        /*we can immediatly filter into the out buffer, no other steps needed*/
        error = filter(*out, in, w, h, &info_png->color, settings);
      }
    }
  }
  else /*interlace_method is 1 (Adam7)*/
  {
    unsigned passw[7], passh[7];
    size_t filter_passstart[8], padded_passstart[8], passstart[8];
    unsigned char* adam7;

    Adam7_getpassvalues(passw, passh, filter_passstart, padded_passstart, passstart, w, h, bpp);

    *outsize = filter_passstart[7]; /*image size plus an extra byte per scanline + possible padding bits*/
    //*out = (unsigned char*)lodepng_malloc(*outsize);
    if(!(*out)) error = 83; /*alloc fail*/

    adam7 = (unsigned char*)lodepng_malloc(passstart[7]);
    if(!adam7 && passstart[7]) error = 83; /*alloc fail*/

    if(!error)
    {
      unsigned i;

      Adam7_interlace(adam7, in, w, h, bpp);
      for(i = 0; i < 7; i++)
      {
        if(bpp < 8)
        {
          unsigned char* padded = (unsigned char*)lodepng_malloc(padded_passstart[i + 1] - padded_passstart[i]);
          if(!padded) ERROR_BREAK(83); /*alloc fail*/
          addPaddingBits(padded, &adam7[passstart[i]],
                         ((passw[i] * bpp + 7) / 8) * 8, passw[i] * bpp, passh[i]);
          error = filter(&(*out)[filter_passstart[i]], padded,
                         passw[i], passh[i], &info_png->color, settings);
          lodepng_free(padded);
        }
        else
        {
          error = filter(&(*out)[filter_passstart[i]], &adam7[padded_passstart[i]],
                         passw[i], passh[i], &info_png->color, settings);
        }

        if(error) break;
      }
    }

    lodepng_free(adam7);
  }

  return error;
}

/*
palette must have 4 * palettesize bytes allocated, and given in format RGBARGBARGBARGBA...
returns 0 if the palette is opaque,
returns 1 if the palette has a single color with alpha 0 ==> color key
returns 2 if the palette is semi-translucent.
*/
static unsigned getPaletteTranslucency(const unsigned char* palette, size_t palettesize)
{
  size_t i, key = 0;
  unsigned r = 0, g = 0, b = 0; /*the value of the color with alpha 0, so long as color keying is possible*/
  for(i = 0; i < palettesize; i++)
  {
    if(!key && palette[4 * i + 3] == 0)
    {
      r = palette[4 * i + 0]; g = palette[4 * i + 1]; b = palette[4 * i + 2];
      key = 1;
      i = (size_t)(-1); /*restart from beginning, to detect earlier opaque colors with key's value*/
    }
    else if(palette[4 * i + 3] != 255) return 2;
    /*when key, no opaque RGB may have key's RGB*/
    else if(key && r == palette[i * 4 + 0] && g == palette[i * 4 + 1] && b == palette[i * 4 + 2]) return 2;
  }
  return key;
}

#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
static unsigned addUnknownChunks(ucvector* out, unsigned char* data, size_t datasize)
{
  unsigned char* inchunk = data;
  while((size_t)(inchunk - data) < datasize)
  {
    CERROR_TRY_RETURN(lodepng_chunk_append(&out->data, &out->size, inchunk));
    out->allocsize = out->size; /*fix the allocsize again*/
    inchunk = lodepng_chunk_next(inchunk);
  }
  return 0;
}
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/

unsigned lodepng_encode(unsigned char** out, size_t* outsize,
                        const unsigned char* image, unsigned w, unsigned h,
                        LodePNGState* state)
{
  LodePNGInfo info;
  ucvector outv;
  unsigned char* data = 0; /*uncompressed version of the IDAT chunk data*/
  size_t datasize = 0;

  /*provide some proper output values if error will happen*/
  *out = 0;
  *outsize = 0;
  state->error = 0;

  lodepng_info_init(&info);
  lodepng_info_copy(&info, &state->info_png);

  if((info.color.colortype == LCT_PALETTE || state->encoder.force_palette)
      && (info.color.palettesize == 0 || info.color.palettesize > 256))
  {
    state->error = 68; /*invalid palette size, it is only allowed to be 1-256*/
    return state->error;
  }

  if(state->encoder.auto_convert != LAC_NO)
  {
    state->error = doAutoChooseColor(&info.color, image, w, h, &state->info_raw,
                                     state->encoder.auto_convert);
  }
  if(state->error) return state->error;

  if(state->encoder.zlibsettings.windowsize > 32768)
  {
    CERROR_RETURN_ERROR(state->error, 60); /*error: windowsize larger than allowed*/
  }
  if(state->encoder.zlibsettings.btype > 2)
  {
    CERROR_RETURN_ERROR(state->error, 61); /*error: unexisting btype*/
  }
  if(state->info_png.interlace_method > 1)
  {
    CERROR_RETURN_ERROR(state->error, 71); /*error: unexisting interlace mode*/
  }

  state->error = checkColorValidity(info.color.colortype, info.color.bitdepth);
  if(state->error) return state->error; /*error: unexisting color type given*/
  state->error = checkColorValidity(state->info_raw.colortype, state->info_raw.bitdepth);
  if(state->error) return state->error; /*error: unexisting color type given*/

  if(!lodepng_color_mode_equal(&state->info_raw, &info.color))
  {
    unsigned char* converted;
    size_t size = (w * h * lodepng_get_bpp(&info.color) + 7) / 8;

    converted = (unsigned char*)lodepng_malloc(size);
    if(!converted && size) state->error = 83; /*alloc fail*/
    if(!state->error)
    {
      state->error = lodepng_convert(converted, image, &info.color, &state->info_raw, w, h, 0 /*fix_png*/);
    }
    if(!state->error) preProcessScanlines(&data, &datasize, converted, w, h, &info, &state->encoder);
    lodepng_free(converted);
  }
  else preProcessScanlines(&data, &datasize, image, w, h, &info, &state->encoder);

  ucvector_init(&outv);
  while(!state->error) /*while only executed once, to break on error*/
  {
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    size_t i;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*write signature and chunks*/
    writeSignature(&outv);
    /*IHDR*/
    addChunk_IHDR(&outv, w, h, info.color.colortype, info.color.bitdepth, info.interlace_method);
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*unknown chunks between IHDR and PLTE*/
    if(info.unknown_chunks_data[0])
    {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[0], info.unknown_chunks_size[0]);
      if(state->error) break;
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*PLTE*/
    if(info.color.colortype == LCT_PALETTE)
    {
      addChunk_PLTE(&outv, &info.color);
    }
    if(state->encoder.force_palette && (info.color.colortype == LCT_RGB || info.color.colortype == LCT_RGBA))
    {
      addChunk_PLTE(&outv, &info.color);
    }
    /*tRNS*/
    if(info.color.colortype == LCT_PALETTE && getPaletteTranslucency(info.color.palette, info.color.palettesize) != 0)
    {
      addChunk_tRNS(&outv, &info.color);
    }
    if((info.color.colortype == LCT_GREY || info.color.colortype == LCT_RGB) && info.color.key_defined)
    {
      addChunk_tRNS(&outv, &info.color);
    }
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*bKGD (must come between PLTE and the IDAt chunks*/
    if(info.background_defined) addChunk_bKGD(&outv, &info);
    /*pHYs (must come before the IDAT chunks)*/
    if(info.phys_defined) addChunk_pHYs(&outv, &info);

    /*unknown chunks between PLTE and IDAT*/
    if(info.unknown_chunks_data[1])
    {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[1], info.unknown_chunks_size[1]);
      if(state->error) break;
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IDAT (multiple IDAT chunks must be consecutive)*/
    state->error = addChunk_IDAT(&outv, data, datasize, &state->encoder.zlibsettings);
    if(state->error) break;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
    /*tIME*/
    if(info.time_defined) addChunk_tIME(&outv, &info.time);
    /*tEXt and/or zTXt*/
    for(i = 0; i < info.text_num; i++)
    {
      if(strlen(info.text_keys[i]) > 79)
      {
        state->error = 66; /*text chunk too large*/
        break;
      }
      if(strlen(info.text_keys[i]) < 1)
      {
        state->error = 67; /*text chunk too small*/
        break;
      }
      if(state->encoder.text_compression)
        addChunk_zTXt(&outv, info.text_keys[i], info.text_strings[i], &state->encoder.zlibsettings);
      else
        addChunk_tEXt(&outv, info.text_keys[i], info.text_strings[i]);
    }
    /*LodePNG version id in text chunk*/
    if(state->encoder.add_id)
    {
      unsigned alread_added_id_text = 0;
      for(i = 0; i < info.text_num; i++)
      {
        if(!strcmp(info.text_keys[i], "LodePNG"))
        {
          alread_added_id_text = 1;
          break;
        }
      }
      if(alread_added_id_text == 0)
        addChunk_tEXt(&outv, "LodePNG", VERSION_STRING); /*it's shorter as tEXt than as zTXt chunk*/
    }
    /*iTXt*/
    for(i = 0; i < info.itext_num; i++)
    {
      if(strlen(info.itext_keys[i]) > 79)
      {
        state->error = 66; /*text chunk too large*/
        break;
      }
      if(strlen(info.itext_keys[i]) < 1)
      {
        state->error = 67; /*text chunk too small*/
        break;
      }
      addChunk_iTXt(&outv, state->encoder.text_compression,
                    info.itext_keys[i], info.itext_langtags[i], info.itext_transkeys[i], info.itext_strings[i],
                    &state->encoder.zlibsettings);
    }

    /*unknown chunks between IDAT and IEND*/
    if(info.unknown_chunks_data[2])
    {
      state->error = addUnknownChunks(&outv, info.unknown_chunks_data[2], info.unknown_chunks_size[2]);
      if(state->error) break;
    }
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
    /*IEND*/
    addChunk_IEND(&outv);

    break; /*this isn't really a while loop; no error happened so break out now!*/
  }

  lodepng_info_cleanup(&info);
  lodepng_free(data);
  /*instead of cleaning the vector up, give it to the output*/
  *out = outv.data;
  *outsize = outv.size;

  return state->error;
}

unsigned lodepng_encode_memory(unsigned char** out, size_t* outsize, const unsigned char* image,
                               unsigned w, unsigned h, LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned error;
  LodePNGState state;
  lodepng_state_init(&state);
  state.info_raw.colortype = colortype;
  state.info_raw.bitdepth = bitdepth;
  state.info_png.color.colortype = colortype;
  state.info_png.color.bitdepth = bitdepth;
  lodepng_encode(out, outsize, image, w, h, &state);
  error = state.error;
  lodepng_state_cleanup(&state);
  return error;
}

unsigned lodepng_encode32(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGBA, 8);
}

unsigned lodepng_encode24(unsigned char** out, size_t* outsize, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_memory(out, outsize, image, w, h, LCT_RGB, 8);
}

#ifdef LODEPNG_COMPILE_DISK
unsigned lodepng_encode_file(const char* filename, const unsigned char* image, unsigned w, unsigned h,
                             LodePNGColorType colortype, unsigned bitdepth)
{
  unsigned char* buffer;
  size_t buffersize;
  unsigned error = lodepng_encode_memory(&buffer, &buffersize, image, w, h, colortype, bitdepth);
  if(!error) error = lodepng_save_file(buffer, buffersize, filename);
  lodepng_free(buffer);
  return error;
}

unsigned lodepng_encode32_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_file(filename, image, w, h, LCT_RGBA, 8);
}

unsigned lodepng_encode24_file(const char* filename, const unsigned char* image, unsigned w, unsigned h)
{
  return lodepng_encode_file(filename, image, w, h, LCT_RGB, 8);
}
#endif /*LODEPNG_COMPILE_DISK*/

void lodepng_encoder_settings_init(LodePNGEncoderSettings* settings)
{
  lodepng_compress_settings_init(&settings->zlibsettings);
  settings->filter_palette_zero = 1;
  settings->filter_strategy = LFS_MINSUM;
  settings->auto_convert = LAC_AUTO;
  settings->force_palette = 0;
  settings->predefined_filters = 0;
#ifdef LODEPNG_COMPILE_ANCILLARY_CHUNKS
  settings->add_id = 0;
  settings->text_compression = 1;
#endif /*LODEPNG_COMPILE_ANCILLARY_CHUNKS*/
}

#endif /*LODEPNG_COMPILE_ENCODER*/
#endif /*LODEPNG_COMPILE_PNG*/

#ifdef LODEPNG_COMPILE_ERROR_TEXT
/*
This returns the description of a numerical error code in English. This is also
the documentation of all the error codes.
*/
const char* lodepng_error_text(unsigned code)
{
  switch(code)
  {
    case 0: return "no error, everything went ok";
    case 1: return "nothing done yet"; /*the Encoder/Decoder has done nothing yet, error checking makes no sense yet*/
    case 10: return "end of input memory reached without huffman end code"; /*while huffman decoding*/
    case 11: return "error in code tree made it jump outside of huffman tree"; /*while huffman decoding*/
    case 13: return "problem while processing dynamic deflate block";
    case 14: return "problem while processing dynamic deflate block";
    case 15: return "problem while processing dynamic deflate block";
    case 16: return "unexisting code while processing dynamic deflate block";
    case 17: return "end of out buffer memory reached while inflating";
    case 18: return "invalid distance code while inflating";
    case 19: return "end of out buffer memory reached while inflating";
    case 20: return "invalid deflate block BTYPE encountered while decoding";
    case 21: return "NLEN is not ones complement of LEN in a deflate block";
     /*end of out buffer memory reached while inflating:
     This can happen if the inflated deflate data is longer than the amount of bytes required to fill up
     all the pixels of the image, given the color depth and image dimensions. Something that doesn't
     happen in a normal, well encoded, PNG image.*/
    case 22: return "end of out buffer memory reached while inflating";
    case 23: return "end of in buffer memory reached while inflating";
    case 24: return "invalid FCHECK in zlib header";
    case 25: return "invalid compression method in zlib header";
    case 26: return "FDICT encountered in zlib header while it's not used for PNG";
    case 27: return "PNG file is smaller than a PNG header";
    /*Checks the magic file header, the first 8 bytes of the PNG file*/
    case 28: return "incorrect PNG signature, it's no PNG or corrupted";
    case 29: return "first chunk is not the header chunk";
    case 30: return "chunk length too large, chunk broken off at end of file";
    case 31: return "illegal PNG color type or bpp";
    case 32: return "illegal PNG compression method";
    case 33: return "illegal PNG filter method";
    case 34: return "illegal PNG interlace method";
    case 35: return "chunk length of a chunk is too large or the chunk too small";
    case 36: return "illegal PNG filter type encountered";
    case 37: return "illegal bit depth for this color type given";
    case 38: return "the palette is too big"; /*more than 256 colors*/
    case 39: return "more palette alpha values given in tRNS chunk than there are colors in the palette";
    case 40: return "tRNS chunk has wrong size for greyscale image";
    case 41: return "tRNS chunk has wrong size for RGB image";
    case 42: return "tRNS chunk appeared while it was not allowed for this color type";
    case 43: return "bKGD chunk has wrong size for palette image";
    case 44: return "bKGD chunk has wrong size for greyscale image";
    case 45: return "bKGD chunk has wrong size for RGB image";
    /*Is the palette too small?*/
    case 46: return "a value in indexed image is larger than the palette size (bitdepth = 8)";
    /*Is the palette too small?*/
    case 47: return "a value in indexed image is larger than the palette size (bitdepth < 8)";
    /*the input data is empty, maybe a PNG file doesn't exist or is in the wrong path*/
    case 48: return "empty input or file doesn't exist";
    case 49: return "jumped past memory while generating dynamic huffman tree";
    case 50: return "jumped past memory while generating dynamic huffman tree";
    case 51: return "jumped past memory while inflating huffman block";
    case 52: return "jumped past memory while inflating";
    case 53: return "size of zlib data too small";
    case 54: return "repeat symbol in tree while there was no value symbol yet";
    /*jumped past tree while generating huffman tree, this could be when the
    tree will have more leaves than symbols after generating it out of the
    given lenghts. They call this an oversubscribed dynamic bit lengths tree in zlib.*/
    case 55: return "jumped past tree while generating huffman tree";
    case 56: return "given output image colortype or bitdepth not supported for color conversion";
    case 57: return "invalid CRC encountered (checking CRC can be disabled)";
    case 58: return "invalid ADLER32 encountered (checking ADLER32 can be disabled)";
    case 59: return "requested color conversion not supported";
    case 60: return "invalid window size given in the settings of the encoder (must be 0-32768)";
    case 61: return "invalid BTYPE given in the settings of the encoder (only 0, 1 and 2 are allowed)";
    /*LodePNG leaves the choice of RGB to greyscale conversion formula to the user.*/
    case 62: return "conversion from color to greyscale not supported";
    case 63: return "length of a chunk too long, max allowed for PNG is 2147483647 bytes per chunk"; /*(2^31-1)*/
    /*this would result in the inability of a deflated block to ever contain an end code. It must be at least 1.*/
    case 64: return "the length of the END symbol 256 in the Huffman tree is 0";
    case 66: return "the length of a text chunk keyword given to the encoder is longer than the maximum of 79 bytes";
    case 67: return "the length of a text chunk keyword given to the encoder is smaller than the minimum of 1 byte";
    case 68: return "tried to encode a PLTE chunk with a palette that has less than 1 or more than 256 colors";
    case 69: return "unknown chunk type with 'critical' flag encountered by the decoder";
    case 71: return "unexisting interlace mode given to encoder (must be 0 or 1)";
    case 72: return "while decoding, unexisting compression method encountering in zTXt or iTXt chunk (it must be 0)";
    case 73: return "invalid tIME chunk size";
    case 74: return "invalid pHYs chunk size";
    /*length could be wrong, or data chopped off*/
    case 75: return "no null termination char found while decoding text chunk";
    case 76: return "iTXt chunk too short to contain required bytes";
    case 77: return "integer overflow in buffer size";
    case 78: return "failed to open file for reading"; /*file doesn't exist or couldn't be opened for reading*/
    case 79: return "failed to open file for writing";
    case 80: return "tried creating a tree of 0 symbols";
    case 81: return "lazy matching at pos 0 is impossible";
    case 82: return "color conversion to palette requested while a color isn't in palette";
    case 83: return "memory allocation failed";
    case 84: return "given image too small to contain all pixels to be encoded";
    case 85: return "internal color conversion bug";
    case 86: return "impossible offset in lz77 encoding (internal bug)";
    case 87: return "must provide custom zlib function pointer if LODEPNG_COMPILE_ZLIB is not defined";
    case 88: return "invalid filter strategy given for LodePNGEncoderSettings.filter_strategy";
    case 89: return "text chunk keyword too short or long: must have size 1-79";
  }
  return "unknown error code";
}
#endif /*LODEPNG_COMPILE_ERROR_TEXT*/



 
int traceLevel = 0; int popCount = 0;

std::string i__s(int i) {
	return std::to_string(i);
}
std::string fi__s(float f) {
	int i = f;
	return std::to_string(i);
}
std::string f__s(float f) {
	return std::to_string(f);
}

string getPaddedInt(int curInt, int maxInt) {
	string res = i__s(curInt);
	string maxRes = i__s(maxInt);
	
	while(res.size() < maxRes.size()) {
		res = '0' + res;
	}
	
	return res;
	
}


union hex_converter{
	float f_val;
	unsigned int u_val;
};
float hexToFloat(std::string* s) {
	union hex_converter hc;
	hc.u_val = (uint)strtoul(s->c_str(), NULL, 16);
	return hc.f_val;
}






std::string floatToHex( float f )
{
	// static_assert( std::numeric_limits<float>::is_iec559,
	// "native float must be an IEEE float" ) ;

	union {
		float fval;
		uint ival;
	};
	fval = f;

	std::ostringstream stm;
	stm << std::hex << std::uppercase << ival;

	return stm.str();
}

// // return 1 on error
// char FLOAT_TO_HEX_BUF[32];
// string floatToHex(float x) {
//   sprintf(FLOAT_TO_HEX_BUF, "0x%lx", (unsigned long) x);
  
//   return string(FLOAT_TO_HEX_BUF);
  
// }



std::vector<std::string> &split(const std::string &s, char delim, std::vector<std::string> &elems) {
	std::stringstream ss(s);
	std::string item;
	while(getline(ss, item, delim)) {
		elems.push_back(item);
	}
	return elems;
}
std::vector<std::string> split(const std::string &s, char delim) {
	std::vector<std::string> elems;
	return split(s, delim, elems);
}




bool pairIsEqual(intPair a, intPair b) {
	return ( (a.v0 == b.v0) && (a.v1 == b.v1)  );
}
bool pairIsNeg(intPair a) {
	return ( (a.v0 == -1) && (a.v1 == -1)  );
}

float quickDis(float x1, float y1, float x2, float y2) {
	//return abs(x1-x2) + abs(y1-y2);//
	return sqrt( (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) );
}

float coordDis(coordAndIndex* c1, coordAndIndex* c2) {
	//return abs(x1-x2) + abs(y1-y2);//

	float d1 = c1->x-c2->x;
	float d2 = c1->y-c2->y;
	return sqrt( d1*d1 + d2*d2 );
}


void bubbleSortF(floatAndIndex* num, int numLength)
{
	int i, j, flag = 1;

	floatAndIndex fiTemp;

	for(i = 1; (i <= numLength) && flag; i++) {
		flag = 0;
		for (j=0; j < (numLength -1); j++) {
			if (num[j+1].value < num[j].value) { // ascending order simply changes to <
				fiTemp = num[j];
				num[j] = num[j+1];
				num[j+1] = fiTemp;
				flag = 1;
			}
		}
	}
}





std::string intToString(int i) {
	std::string s;
	std::stringstream out;
	out << i;
	s = out.str();
	return s;
}
std::string floatToString(float f) {
	std::string s;
	std::stringstream out;
	out << f;
	s = out.str();
	return s;
}






//////////


void doTraceND(std::string traceVal0 = "", std::string traceVal1 = "",std::string traceVal2 = "",std::string traceVal3 = "",std::string traceVal4 = "",std::string traceVal5 = "", std::string traceVal6 = "",std::string traceVal7 = "",std::string traceVal8 = "",std::string traceVal9 = "",std::string traceVal10 = "") {
	
	int i;
	
	if (ND_TRACE_OFF) {
		return;
	}
	
	for (i = 0; i < traceLevel; i++) {
		std::cout << "|  ";
	}
	
	std::cout << traceVal0 << " " << traceVal1 << " " << traceVal2 << " " << traceVal3 << " " << traceVal4 << " " << traceVal5 << " " << traceVal6 << " " << traceVal7 << " " << traceVal8 << " " << traceVal9 << " " << traceVal10 << std::endl << std::flush;
	
}
void doTraceVecND(std::string traceVal0, FIVector4 *fv) {
	
	doTraceND(traceVal0, " ", f__s(fv->getFX()), " ", f__s(fv->getFY()), " ", f__s(fv->getFZ())  );
	
}
void traceBTV(std::string traceVal0, btVector3 myBTV) {
	
	doTraceND(traceVal0, " ", f__s(myBTV.getX()), " ", f__s(myBTV.getY()), " ", f__s(myBTV.getZ())  );
	
}
void doTraceVecND4(std::string traceVal0, FIVector4 *fv) {
	
	doTraceND(traceVal0, " ", f__s(fv->getFX()), " ", f__s(fv->getFY()), " ", f__s(fv->getFZ()), " ", f__s(fv->getFW())  );
	
}

void pushTraceND(std::string traceVal0 = "", std::string traceVal1 = "",std::string traceVal2 = "",std::string traceVal3 = "",std::string traceVal4 = "",std::string traceVal5 = "", std::string traceVal6 = "",std::string traceVal7 = "",std::string traceVal8 = "",std::string traceVal9 = "",std::string traceVal10 = "") {
	
	doTraceND(traceVal0,traceVal1,traceVal2,traceVal3,traceVal4,traceVal5,traceVal6,traceVal7,traceVal8,traceVal9,traceVal10);
	traceLevel++;
	popCount=0;
	

	
}
void popTraceND() {
	
	traceLevel--;
	popCount++;
	if (popCount >= 2) {
		doTraceND("END");
	}
	
}

//////////




// void doTrace(std::string traceVal0 = "", std::string traceVal1 = "",std::string traceVal2 = "",std::string traceVal3 = "",std::string traceVal4 = "",std::string traceVal5 = "", std::string traceVal6 = "",std::string traceVal7 = "",std::string traceVal8 = "",std::string traceVal9 = "",std::string traceVal10 = "") {
// 	#ifdef DEBUG_MODE
// 	int i;
	
// 	for (i = 0; i < traceLevel; i++) {
// 		std::cout << "|  ";
// 	}
	
// 	std::cout << traceVal0 << " " << traceVal1 << " " << traceVal2 << " " << traceVal3 << " " << traceVal4 << " " << traceVal5 << " " << traceVal6 << " " << traceVal7 << " " << traceVal8 << " " << traceVal9 << " " << traceVal10 << std::endl << std::flush;
// 	#endif
// }
// void doTraceVec(std::string traceVal0, FIVector4 *fv) {
// 	#ifdef DEBUG_MODE
// 	doTrace(traceVal0, " ", f__s(fv->getFX()), " ", f__s(fv->getFY()), " ", f__s(fv->getFZ())  );
// 	#endif
// }

// void pushTrace(std::string traceVal0 = "", std::string traceVal1 = "",std::string traceVal2 = "",std::string traceVal3 = "",std::string traceVal4 = "",std::string traceVal5 = "", std::string traceVal6 = "",std::string traceVal7 = "",std::string traceVal8 = "",std::string traceVal9 = "",std::string traceVal10 = "") {
// 	#ifdef DEBUG_MODE
// 	doTrace(traceVal0,traceVal1,traceVal2,traceVal3,traceVal4,traceVal5,traceVal6,traceVal7,traceVal8,traceVal9,traceVal10);
// 	traceLevel++;
// 	popCount=0;
// 	#endif

	
// }
// void popTrace() {
// 	#ifdef DEBUG_MODE
// 	traceLevel--;
// 	popCount++;
// 	if (popCount >= 2) {
// 		doTrace("END");
// 	}
// 	#endif
// }



void doTrace(std::string traceVal0 = "", std::string traceVal1 = "",std::string traceVal2 = "",std::string traceVal3 = "",std::string traceVal4 = "",std::string traceVal5 = "", std::string traceVal6 = "",std::string traceVal7 = "",std::string traceVal8 = "",std::string traceVal9 = "",std::string traceVal10 = "") {
	int i;

	if (TRACE_ON) {
		for (i = 0; i < traceLevel; i++) {
			std::cout << "|  ";
		}
		
		std::cout << traceVal0 << " " << traceVal1 << " " << traceVal2 << " " << traceVal3 << " " << traceVal4 << " " << traceVal5 << " " << traceVal6 << " " << traceVal7 << " " << traceVal8 << " " << traceVal9 << " " << traceVal10 << std::endl << std::flush;
	}
	
	
}
void doTraceVec(std::string traceVal0, FIVector4 *fv) {
	if (TRACE_ON) {
		doTrace(traceVal0, " ", f__s(fv->getFX()), " ", f__s(fv->getFY()), " ", f__s(fv->getFZ())  );
	}
	
	
}

void pushTrace(std::string traceVal0 = "", std::string traceVal1 = "",std::string traceVal2 = "",std::string traceVal3 = "",std::string traceVal4 = "",std::string traceVal5 = "", std::string traceVal6 = "",std::string traceVal7 = "",std::string traceVal8 = "",std::string traceVal9 = "",std::string traceVal10 = "") {
	
	if (TRACE_ON) {
		doTrace(traceVal0,traceVal1,traceVal2,traceVal3,traceVal4,traceVal5,traceVal6,traceVal7,traceVal8,traceVal9,traceVal10);
			traceLevel++;
			popCount=0;
	}
	
}
void popTrace() {
	
	if (TRACE_ON) {
		traceLevel--;
		popCount++;
		if (popCount >= 2) {
			doTrace("END");
		}
	}

	
	
}



 


class UniformBuffer {
public:

	

	

	// GLchar* names[] =
	// {
	// 	"SurfaceColor",
	// 	"WarmColor",
	// 	"CoolColor",
	// 	"DiffuseWarm",
	// 	"DiffuseCool"
	// };

	int uniPosition;

	GLuint bufferId, uniformBlockIndex, index, progId;
	GLsizei uniformBlockSize;
	GLint singleSize, offset;
	GLfloat* uniData;

	// GLfloat colors[] = 
	// {
	// 	0.45,0.45,1,1,
	// 	0.45,0.45,1,1,
	// 	0.75,0.75,0.75,1,
	// 	0.0,0.0,1.0,1,
	// 	0.0,1.0,0.0,1
	// };


	bool wasUpdated;
	bool wasInit;
	
	UniformBuffer() {
		wasInit = false;
		uniData = NULL;
	}

	void init(GLuint _progId, int bufNameInd)
	{

		wasInit = true;
		uniPosition = 0;
		wasUpdated = false;
		progId = _progId;
		uniData = NULL;


		//Update the uniforms using ARB_uniform_buffer_object
		glGenBuffers(1, &bufferId);


		
		//There's only one uniform block here, the 'colors0' uniform block. 
		//It contains the color info for the gooch shader.
		uniformBlockIndex = glGetUniformBlockIndex(
			progId,
			BUF_NAMES[bufNameInd]//bufName.c_str()//"colors0"
		);

		
		//We need to get the uniform block's size in order to back it with the
		//appropriate buffer
		glGetActiveUniformBlockiv(
			progId,
			uniformBlockIndex,
			GL_UNIFORM_BLOCK_DATA_SIZE,
			&uniformBlockSize
		);

		doTraceND("uniformBlockSize: ", i__s(uniformBlockSize));


		if (uniData != NULL) {
			delete[] uniData;
			uniData = NULL;
		}

		uniData = new GLfloat[uniformBlockSize/4];


		
		//Create UBO.
		glBindBuffer(
			GL_UNIFORM_BUFFER,
			bufferId
		);
		glBufferData(
			GL_UNIFORM_BUFFER,
			uniformBlockSize,
			NULL,
			GL_STATIC_DRAW//GL_DYNAMIC_DRAW
		);

		//Now we attach the buffer to UBO binding point 0...
		glBindBufferBase(
			GL_UNIFORM_BUFFER,
			0,
			bufferId
		);
		//And associate the uniform block to this binding point.
		glUniformBlockBinding(
			progId,
			uniformBlockIndex,
			0
		);


		//To update a single uniform in a uniform block, we need to get its
		//offset into the buffer.
		
		//glGetUniformIndices(progId, 1, &names[2], &index);
		//glGetActiveUniformsiv(progId, 1, &index, GL_UNIFORM_OFFSET, &offset);
		//glGetActiveUniformsiv(progId, 1, &index, GL_UNIFORM_SIZE, &singleSize);

	    
	}

	void updateUniformBlock(int numFloats) {

		int datSize = uniformBlockSize;

		if (numFloats < 0) {

		}
		else {
			datSize = numFloats*4;
		}



		if (wasUpdated) {

		}
		else {
			glBindBuffer(GL_UNIFORM_BUFFER, bufferId);
			//We can use BufferData to upload our data to the shader,
			//since we know it's in the std140 layout
			//each float is 4 bytes
			glBufferData(GL_UNIFORM_BUFFER, datSize, uniData, GL_DYNAMIC_DRAW);
			//With a non-standard layout, we'd use BufferSubData for each uniform.
			//glBufferSubData(GL_UNIFORM_BUFFER, offset, singleSize, &uniData[8]);
			
			wasUpdated = true;
		}

		

	}

	void beginUniformBlock() {
		uniPosition = 0;
	}

	void invalidateUniformBlock() {
		wasUpdated = false;
	}
	bool wasUpdatedUniformBlock() {
		return wasUpdated;
	}

	~UniformBuffer() {

		if (wasInit) {
			if (uniData) {
				delete[] uniData;
				uniData = NULL;
			}
			glDeleteBuffers(1,&bufferId);
		}
		

	}


};








 
class Timer
{
public:
    Timer(){
        #ifdef WIN32
            QueryPerformanceFrequency(&frequency);
            startCount.QuadPart = 0;
            endCount.QuadPart = 0;
        #else
            startCount.tv_sec = startCount.tv_usec = 0;
            endCount.tv_sec = endCount.tv_usec = 0;
        #endif

            stopped = 0;
            startTimeInMicroSec = 0;
            endTimeInMicroSec = 0;
        }
    ~Timer() {

    }

    void   start() {
        stopped = 0; // reset stop flag
        #ifdef WIN32
        QueryPerformanceCounter(&startCount);
        #else
        gettimeofday(&startCount, NULL);
        #endif
    }
    void   stop() {
        stopped = 1; // set timer stopped flag

        #ifdef WIN32
        QueryPerformanceCounter(&endCount);
        #else
        gettimeofday(&endCount, NULL);
        #endif
    }
    double getElapsedTime() {
        return this->getElapsedTimeInSec();
    }
    double getElapsedTimeInSec() {
        return this->getElapsedTimeInMicroSec() * 0.000001;
    }

    double getElapsedTimeInMilliSec() {
        return this->getElapsedTimeInMicroSec() * 0.001;
    }

    double getElapsedTimeInMicroSec() {
        #ifdef WIN32
        if(!stopped) {
            QueryPerformanceCounter(&endCount);
        }

        startTimeInMicroSec = startCount.QuadPart * (1000000.0 / frequency.QuadPart);
        endTimeInMicroSec = endCount.QuadPart * (1000000.0 / frequency.QuadPart);
        #else
        if(!stopped) {
            gettimeofday(&endCount, NULL);
        }

        startTimeInMicroSec = (startCount.tv_sec * 1000000.0) + startCount.tv_usec;
        endTimeInMicroSec = (endCount.tv_sec * 1000000.0) + endCount.tv_usec;
        #endif

        return endTimeInMicroSec - startTimeInMicroSec;
    }



protected:


private:
    double startTimeInMicroSec;                 // starting time in micro-second
    double endTimeInMicroSec;                   // ending time in micro-second
    int    stopped;                             // stop flag 
#ifdef WIN32
    LARGE_INTEGER frequency;                    // ticks per second
    LARGE_INTEGER startCount;                   //
    LARGE_INTEGER endCount;                     //
#else
    timeval startCount;                         //
    timeval endCount;                           //
#endif
}; 


// Multi-octave Simplex noise - multiple noise values are combined.
float simplexNoise( const float, const float, const float, const float, const float );
float simplexNoise( const float, const float, const float, const float, const float, const float );
float simplexNoise( const float, const float, const float, const float, const float, const float, const float );


// Multi-octave Scaled Simplex noise - the result will be between the two parameters passed.
float simplexScaledNoise( const float, const float, const float, const float, const float, const float, const float );
float simplexScaledNoise( const float, const float, const float, const float, const float, const float, const float, const float );
float simplexScaledNoise( const float, const float, const float, const float, const float, const float, const float, const float, const float );

// Scaled Raw Simplex noise - the result will be between the two parameters passed.
float simplexScaledRawNoise( const float, const float, const float, const float );
float simplexScaledRawNoise( const float, const float, const float, const float, const float );
float simplexScaledRawNoise( const float, const float, const float, const float, const float, const float );


// Raw Simplex noise - a single noise value.
float simplexRawNoise( const float, const float );
float simplexRawNoise( const float, const float, const float );
float simplexRawNoise( const float, const float, const float, const float );


int fastfloor( const float x ) { return x > 0 ? (int) x : (int) x - 1; }
float dot( const int* g, const float x, const float y ) { return g[0]*x + g[1]*y; }
float dot( const int* g, const float x, const float y, const float z ) { return g[0]*x + g[1]*y + g[2]*z; }
float dot( const int* g, const float x, const float y, const float z, const float w ) { return g[0]*x + g[1]*y + g[2]*z + g[3]*w; }




// The gradients are the midpoints of the vertices of a cube.
static const int grad3[12][3] = {
	{1,1,0}, {-1,1,0}, {1,-1,0}, {-1,-1,0},
	{1,0,1}, {-1,0,1}, {1,0,-1}, {-1,0,-1},
	{0,1,1}, {0,-1,1}, {0,1,-1}, {0,-1,-1}
};


// The gradients are the midpoints of the vertices of a hypercube.
static const int grad4[32][4]= {
	{0,1,1,1},  {0,1,1,-1},  {0,1,-1,1},  {0,1,-1,-1},
	{0,-1,1,1}, {0,-1,1,-1}, {0,-1,-1,1}, {0,-1,-1,-1},
	{1,0,1,1},  {1,0,1,-1},  {1,0,-1,1},  {1,0,-1,-1},
	{-1,0,1,1}, {-1,0,1,-1}, {-1,0,-1,1}, {-1,0,-1,-1},
	{1,1,0,1},  {1,1,0,-1},  {1,-1,0,1},  {1,-1,0,-1},
	{-1,1,0,1}, {-1,1,0,-1}, {-1,-1,0,1}, {-1,-1,0,-1},
	{1,1,1,0},  {1,1,-1,0},  {1,-1,1,0},  {1,-1,-1,0},
	{-1,1,1,0}, {-1,1,-1,0}, {-1,-1,1,0}, {-1,-1,-1,0}
};


// Permutation table.  The same list is repeated twice.
static const int perm[512] = {
	151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
	8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,
	35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,
	134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,
	55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,
	18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,
	250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,
	189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,
	172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,
	228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,
	107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,
	138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,

	151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,
	8,99,37,240,21,10,23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,
	35,11,32,57,177,33,88,237,149,56,87,174,20,125,136,171,168,68,175,74,165,71,
	134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,
	55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208, 89,
	18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,
	250,124,123,5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,
	189,28,42,223,183,170,213,119,248,152,2,44,154,163,70,221,153,101,155,167,43,
	172,9,129,22,39,253,19,98,108,110,79,113,224,232,178,185,112,104,218,246,97,
	228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,14,239,
	107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,
	138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
};


// A lookup table to traverse the simplex around a given point in 4D.
static const int simplex[64][4] = {
	{0,1,2,3},{0,1,3,2},{0,0,0,0},{0,2,3,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,2,3,0},
	{0,2,1,3},{0,0,0,0},{0,3,1,2},{0,3,2,1},{0,0,0,0},{0,0,0,0},{0,0,0,0},{1,3,2,0},
	{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},
	{1,2,0,3},{0,0,0,0},{1,3,0,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,3,0,1},{2,3,1,0},
	{1,0,2,3},{1,0,3,2},{0,0,0,0},{0,0,0,0},{0,0,0,0},{2,0,3,1},{0,0,0,0},{2,1,3,0},
	{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},{0,0,0,0},
	{2,0,1,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,0,1,2},{3,0,2,1},{0,0,0,0},{3,1,2,0},
	{2,1,0,3},{0,0,0,0},{0,0,0,0},{0,0,0,0},{3,1,0,2},{0,0,0,0},{3,2,0,1},{3,2,1,0}
};


// 2D Multi-octave Simplex noise.
//
// For each octave, a higher frequency/lower amplitude function will be added to the original.
// The higher the persistence [0-1], the more of each succeeding octave will be added.
float simplexNoise( const float octaves, const float persistence, const float scale, const float x, const float y ) {
	float total = 0;
	float frequency = scale;
	float amplitude = 1;

	// We have to keep track of the largest possible amplitude,
	// because each octave adds more, and we need a value in [-1, 1].
	float maxAmplitude = 0;

	for( int i=0; i < octaves; i++ ) {
		total += simplexRawNoise( x * frequency, y * frequency ) * amplitude;

		frequency *= 2;
		maxAmplitude += amplitude;
		amplitude *= persistence;
	}

	return total / maxAmplitude;
}


// 3D Multi-octave Simplex noise.
//
// For each octave, a higher frequency/lower amplitude function will be added to the original.
// The higher the persistence [0-1], the more of each succeeding octave will be added.
float simplexNoise( const float octaves, const float persistence, const float scale, const float x, const float y, const float z ) {
	float total = 0;
	float frequency = scale;
	float amplitude = 1;

	// We have to keep track of the largest possible amplitude,
	// because each octave adds more, and we need a value in [-1, 1].
	float maxAmplitude = 0;

	for( int i=0; i < octaves; i++ ) {
		total += simplexRawNoise( x * frequency, y * frequency, z * frequency ) * amplitude;

		frequency *= 2;
		maxAmplitude += amplitude;
		amplitude *= persistence;
	}

	return total / maxAmplitude;
}


// 4D Multi-octave Simplex noise.
//
// For each octave, a higher frequency/lower amplitude function will be added to the original.
// The higher the persistence [0-1], the more of each succeeding octave will be added.
float simplexNoise( const float octaves, const float persistence, const float scale, const float x, const float y, const float z, const float w ) {
	float total = 0;
	float frequency = scale;
	float amplitude = 1;

	// We have to keep track of the largest possible amplitude,
	// because each octave adds more, and we need a value in [-1, 1].
	float maxAmplitude = 0;

	for( int i=0; i < octaves; i++ ) {
		total += simplexRawNoise( x * frequency, y * frequency, z * frequency, w * frequency ) * amplitude;

		frequency *= 2;
		maxAmplitude += amplitude;
		amplitude *= persistence;
	}

	return total / maxAmplitude;
}



// 2D Scaled Multi-octave Simplex noise.
//
// Returned value will be between loBound and hiBound.
float simplexScaledNoise( const float octaves, const float persistence, const float scale, const float loBound, const float hiBound, const float x, const float y ) {
	return simplexNoise(octaves, persistence, scale, x, y) * (hiBound - loBound) / 2 + (hiBound + loBound) / 2;
}


// 3D Scaled Multi-octave Simplex noise.
//
// Returned value will be between loBound and hiBound.
float simplexScaledNoise( const float octaves, const float persistence, const float scale, const float loBound, const float hiBound, const float x, const float y, const float z ) {
	return simplexNoise(octaves, persistence, scale, x, y, z) * (hiBound - loBound) / 2 + (hiBound + loBound) / 2;
}

// 4D Scaled Multi-octave Simplex noise.
//
// Returned value will be between loBound and hiBound.
float simplexScaledNoise( const float octaves, const float persistence, const float scale, const float loBound, const float hiBound, const float x, const float y, const float z, const float w ) {
	return simplexNoise(octaves, persistence, scale, x, y, z, w) * (hiBound - loBound) / 2 + (hiBound + loBound) / 2;
}



// 2D Scaled Simplex raw noise.
//
// Returned value will be between loBound and hiBound.
float simplexScaledRawNoise( const float loBound, const float hiBound, const float x, const float y ) {
	return simplexRawNoise(x, y) * (hiBound - loBound) / 2 + (hiBound + loBound) / 2;
}


// 3D Scaled Simplex raw noise.
//
// Returned value will be between loBound and hiBound.
float simplexScaledRawNoise( const float loBound, const float hiBound, const float x, const float y, const float z ) {
	return simplexRawNoise(x, y, z) * (hiBound - loBound) / 2 + (hiBound + loBound) / 2;
}

// 4D Scaled Simplex raw noise.
//
// Returned value will be between loBound and hiBound.
float simplexScaledRawNoise( const float loBound, const float hiBound, const float x, const float y, const float z, const float w ) {
	return simplexRawNoise(x, y, z, w) * (hiBound - loBound) / 2 + (hiBound + loBound) / 2;
}



// 2D raw Simplex noise
float simplexRawNoise( const float x, const float y ) {
	// Noise contributions from the three corners
	float n0, n1, n2;

	// Skew the input space to determine which simplex cell we're in
	float F2 = 0.5 * (sqrtf(3.0) - 1.0);
	// Hairy factor for 2D
	float s = (x + y) * F2;
	int i = fastfloor( x + s );
	int j = fastfloor( y + s );

	float G2 = (3.0 - sqrtf(3.0)) / 6.0;
	float t = (i + j) * G2;
	// Unskew the cell origin back to (x,y) space
	float X0 = i-t;
	float Y0 = j-t;
	// The x,y distances from the cell origin
	float x0 = x-X0;
	float y0 = y-Y0;

	// For the 2D case, the simplex shape is an equilateral triangle.
	// Determine which simplex we are in.
	int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
	if(x0>y0) {i1=1; j1=0;} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
	else {i1=0; j1=1;} // upper triangle, YX order: (0,0)->(0,1)->(1,1)

	// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
	// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
	// c = (3-sqrt(3))/6
	float x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
	float y1 = y0 - j1 + G2;
	float x2 = x0 - 1.0 + 2.0 * G2; // Offsets for last corner in (x,y) unskewed coords
	float y2 = y0 - 1.0 + 2.0 * G2;

	// Work out the hashed gradient indices of the three simplex corners
	int ii = i & 255;
	int jj = j & 255;
	int gi0 = perm[ii+perm[jj]] % 12;
	int gi1 = perm[ii+i1+perm[jj+j1]] % 12;
	int gi2 = perm[ii+1+perm[jj+1]] % 12;

	// Calculate the contribution from the three corners
	float t0 = 0.5 - x0*x0-y0*y0;
	if(t0<0) n0 = 0.0;
	else {
	t0 *= t0;
	n0 = t0 * t0 * dot(grad3[gi0], x0, y0); // (x,y) of grad3 used for 2D gradient
	}

	float t1 = 0.5 - x1*x1-y1*y1;
	if(t1<0) n1 = 0.0;
	else {
	t1 *= t1;
	n1 = t1 * t1 * dot(grad3[gi1], x1, y1);
	}

	float t2 = 0.5 - x2*x2-y2*y2;
	if(t2<0) n2 = 0.0;
	else {
	t2 *= t2;
	n2 = t2 * t2 * dot(grad3[gi2], x2, y2);
	}

	// Add contributions from each corner to get the final noise value.
	// The result is scaled to return values in the interval [-1,1].
	return 70.0 * (n0 + n1 + n2);
}


// 3D raw Simplex noise
float simplexRawNoise( const float x, const float y, const float z ) {
	float n0, n1, n2, n3; // Noise contributions from the four corners

	// Skew the input space to determine which simplex cell we're in
	float F3 = 1.0/3.0;
	float s = (x+y+z)*F3; // Very nice and simple skew factor for 3D
	int i = fastfloor(x+s);
	int j = fastfloor(y+s);
	int k = fastfloor(z+s);

	float G3 = 1.0/6.0; // Very nice and simple unskew factor, too
	float t = (i+j+k)*G3;
	float X0 = i-t; // Unskew the cell origin back to (x,y,z) space
	float Y0 = j-t;
	float Z0 = k-t;
	float x0 = x-X0; // The x,y,z distances from the cell origin
	float y0 = y-Y0;
	float z0 = z-Z0;

	// For the 3D case, the simplex shape is a slightly irregular tetrahedron.
	// Determine which simplex we are in.
	int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
	int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords

	if(x0>=y0) {
	if(y0>=z0)
	{ i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; } // X Y Z order
	else if(x0>=z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; } // X Z Y order
	else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; } // Z X Y order
	}
	else { // x0<y0
	if(y0<z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; } // Z Y X order
	else if(x0<z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; } // Y Z X order
	else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; } // Y X Z order
	}

	// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
	// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
	// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
	// c = 1/6.
	float x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
	float y1 = y0 - j1 + G3;
	float z1 = z0 - k1 + G3;
	float x2 = x0 - i2 + 2.0*G3; // Offsets for third corner in (x,y,z) coords
	float y2 = y0 - j2 + 2.0*G3;
	float z2 = z0 - k2 + 2.0*G3;
	float x3 = x0 - 1.0 + 3.0*G3; // Offsets for last corner in (x,y,z) coords
	float y3 = y0 - 1.0 + 3.0*G3;
	float z3 = z0 - 1.0 + 3.0*G3;

	// Work out the hashed gradient indices of the four simplex corners
	int ii = i & 255;
	int jj = j & 255;
	int kk = k & 255;
	int gi0 = perm[ii+perm[jj+perm[kk]]] % 12;
	int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1]]] % 12;
	int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2]]] % 12;
	int gi3 = perm[ii+1+perm[jj+1+perm[kk+1]]] % 12;

	// Calculate the contribution from the four corners
	float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
	if(t0<0) n0 = 0.0;
	else {
	t0 *= t0;
	n0 = t0 * t0 * dot(grad3[gi0], x0, y0, z0);
	}

	float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
	if(t1<0) n1 = 0.0;
	else {
	t1 *= t1;
	n1 = t1 * t1 * dot(grad3[gi1], x1, y1, z1);
	}

	float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
	if(t2<0) n2 = 0.0;
	else {
	t2 *= t2;
	n2 = t2 * t2 * dot(grad3[gi2], x2, y2, z2);
	}

	float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
	if(t3<0) n3 = 0.0;
	else {
	t3 *= t3;
	n3 = t3 * t3 * dot(grad3[gi3], x3, y3, z3);
	}

	// Add contributions from each corner to get the final noise value.
	// The result is scaled to stay just inside [-1,1]
	return 32.0*(n0 + n1 + n2 + n3);
}


// 4D raw Simplex noise
float simplexRawNoise( const float x, const float y, const float z, const float w ) {
	// The skewing and unskewing factors are hairy again for the 4D case
	float F4 = (sqrtf(5.0)-1.0)/4.0;
	float G4 = (5.0-sqrtf(5.0))/20.0;
	float n0, n1, n2, n3, n4; // Noise contributions from the five corners

	// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
	float s = (x + y + z + w) * F4; // Factor for 4D skewing
	int i = fastfloor(x + s);
	int j = fastfloor(y + s);
	int k = fastfloor(z + s);
	int l = fastfloor(w + s);
	float t = (i + j + k + l) * G4; // Factor for 4D unskewing
	float X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
	float Y0 = j - t;
	float Z0 = k - t;
	float W0 = l - t;

	float x0 = x - X0; // The x,y,z,w distances from the cell origin
	float y0 = y - Y0;
	float z0 = z - Z0;
	float w0 = w - W0;

	// For the 4D case, the simplex is a 4D shape I won't even try to describe.
	// To find out which of the 24 possible simplices we're in, we need to
	// determine the magnitude ordering of x0, y0, z0 and w0.
	// The method below is a good way of finding the ordering of x,y,z,w and
	// then find the correct traversal order for the simplex we're in.
	// First, six pair-wise comparisons are performed between each possible pair
	// of the four coordinates, and the results are used to add up binary bits
	// for an integer index.
	int c1 = (x0 > y0) ? 32 : 0;
	int c2 = (x0 > z0) ? 16 : 0;
	int c3 = (y0 > z0) ? 8 : 0;
	int c4 = (x0 > w0) ? 4 : 0;
	int c5 = (y0 > w0) ? 2 : 0;
	int c6 = (z0 > w0) ? 1 : 0;
	int c = c1 + c2 + c3 + c4 + c5 + c6;

	int i1, j1, k1, l1; // The integer offsets for the second simplex corner
	int i2, j2, k2, l2; // The integer offsets for the third simplex corner
	int i3, j3, k3, l3; // The integer offsets for the fourth simplex corner

	// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
	// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
	// impossible. Only the 24 indices which have non-zero entries make any sense.
	// We use a thresholding to set the coordinates in turn from the largest magnitude.
	// The number 3 in the "simplex" array is at the position of the largest coordinate.
	i1 = simplex[c][0]>=3 ? 1 : 0;
	j1 = simplex[c][1]>=3 ? 1 : 0;
	k1 = simplex[c][2]>=3 ? 1 : 0;
	l1 = simplex[c][3]>=3 ? 1 : 0;
	// The number 2 in the "simplex" array is at the second largest coordinate.
	i2 = simplex[c][0]>=2 ? 1 : 0;
	j2 = simplex[c][1]>=2 ? 1 : 0;
	k2 = simplex[c][2]>=2 ? 1 : 0;
	l2 = simplex[c][3]>=2 ? 1 : 0;
	// The number 1 in the "simplex" array is at the second smallest coordinate.
	i3 = simplex[c][0]>=1 ? 1 : 0;
	j3 = simplex[c][1]>=1 ? 1 : 0;
	k3 = simplex[c][2]>=1 ? 1 : 0;
	l3 = simplex[c][3]>=1 ? 1 : 0;
	// The fifth corner has all coordinate offsets = 1, so no need to look that up.

	float x1 = x0 - i1 + G4; // Offsets for second corner in (x,y,z,w) coords
	float y1 = y0 - j1 + G4;
	float z1 = z0 - k1 + G4;
	float w1 = w0 - l1 + G4;
	float x2 = x0 - i2 + 2.0*G4; // Offsets for third corner in (x,y,z,w) coords
	float y2 = y0 - j2 + 2.0*G4;
	float z2 = z0 - k2 + 2.0*G4;
	float w2 = w0 - l2 + 2.0*G4;
	float x3 = x0 - i3 + 3.0*G4; // Offsets for fourth corner in (x,y,z,w) coords
	float y3 = y0 - j3 + 3.0*G4;
	float z3 = z0 - k3 + 3.0*G4;
	float w3 = w0 - l3 + 3.0*G4;
	float x4 = x0 - 1.0 + 4.0*G4; // Offsets for last corner in (x,y,z,w) coords
	float y4 = y0 - 1.0 + 4.0*G4;
	float z4 = z0 - 1.0 + 4.0*G4;
	float w4 = w0 - 1.0 + 4.0*G4;

	// Work out the hashed gradient indices of the five simplex corners
	int ii = i & 255;
	int jj = j & 255;
	int kk = k & 255;
	int ll = l & 255;
	int gi0 = perm[ii+perm[jj+perm[kk+perm[ll]]]] % 32;
	int gi1 = perm[ii+i1+perm[jj+j1+perm[kk+k1+perm[ll+l1]]]] % 32;
	int gi2 = perm[ii+i2+perm[jj+j2+perm[kk+k2+perm[ll+l2]]]] % 32;
	int gi3 = perm[ii+i3+perm[jj+j3+perm[kk+k3+perm[ll+l3]]]] % 32;
	int gi4 = perm[ii+1+perm[jj+1+perm[kk+1+perm[ll+1]]]] % 32;

	// Calculate the contribution from the five corners
	float t0 = 0.6 - x0*x0 - y0*y0 - z0*z0 - w0*w0;
	if(t0<0) n0 = 0.0;
	else {
	t0 *= t0;
	n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);
	}

	float t1 = 0.6 - x1*x1 - y1*y1 - z1*z1 - w1*w1;
	if(t1<0) n1 = 0.0;
	else {
	t1 *= t1;
	n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);
	}

	float t2 = 0.6 - x2*x2 - y2*y2 - z2*z2 - w2*w2;
	if(t2<0) n2 = 0.0;
	else {
	t2 *= t2;
	n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);
	}

	float t3 = 0.6 - x3*x3 - y3*y3 - z3*z3 - w3*w3;
	if(t3<0) n3 = 0.0;
	else {
	t3 *= t3;
	n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);
	}

	float t4 = 0.6 - x4*x4 - y4*y4 - z4*z4 - w4*w4;
	if(t4<0) n4 = 0.0;
	else {
	t4 *= t4;
	n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);
	}

	// Sum up and scale the result to cover the range [-1,1]
	return 27.0 * (n0 + n1 + n2 + n3 + n4);
}
 


//Converts a four-character array to an integer, using little-endian form
int toInt(const char* bytes) {
	return (int)(((unsigned char)bytes[3] << 24) |
				 ((unsigned char)bytes[2] << 16) |
				 ((unsigned char)bytes[1] << 8) |
				 (unsigned char)bytes[0]);
}

//Converts a two-character array to a short, using little-endian form
short toShort(const char* bytes) {
	return (short)(((unsigned char)bytes[1] << 8) |
				   (unsigned char)bytes[0]);
}

//Reads the next four bytes as an integer, using little-endian form
int readInt(ifstream &input) {
	char buffer[4];
	input.read(buffer, 4);
	return toInt(buffer);
}

//Reads the next two bytes as a short, using little-endian form
short readShort(ifstream &input) {
	char buffer[2];
	input.read(buffer, 2);
	return toShort(buffer);
}



//Just like auto_ptr, but for arrays
template<class T>
class auto_array {
	private:
		T* array;
		mutable bool isReleased;
	public:
		explicit auto_array(T* array_ = NULL) :
			array(array_), isReleased(false) {
		}
		
		auto_array(const auto_array<T> &aarray) {
			array = aarray.array;
			isReleased = aarray.isReleased;
			aarray.isReleased = true;
		}
		
		~auto_array() {
			if (!isReleased && array != NULL) {
				delete[] array;
			}
		}
		
		T* get() const {
			return array;
		}
		
		T &operator*() const {
			return *array;
		}
		
		void operator=(const auto_array<T> &aarray) {
			if (!isReleased && array != NULL) {
				delete[] array;
			}
			array = aarray.array;
			isReleased = aarray.isReleased;
			aarray.isReleased = true;
		}
		
		T* operator->() const {
			return array;
		}
		
		T* release() {
			isReleased = true;
			return array;
		}
		
		void reset(T* array_ = NULL) {
			if (!isReleased && array != NULL) {
				delete[] array;
			}
			array = array_;
		}
		
		T* operator+(int i) {
			return array + i;
		}
		
		T &operator[](int i) {
			return array[i];
		}
};

//Represents an image
class Image {
public:
		
	/* An array of the form (R1, G1, B1, R2, G2, B2, ...) indicating the
	 * color of each pixel in image.  Color components range from 0 to 255.
	 * The array starts the bottom-left pixel, then moves right to the end
	 * of the row, then moves up to the next column, and so on.  This is the
	 * format in which OpenGL likes images.
	 */
	unsigned char* pixels;
	int width;
	int height;
	GLuint tid;

	int getValue(int x, int y, int c) {
		return pixels[3 * (width * y + x) + c];
	}

	void setValue(int x, int y, int c, int v) {
		pixels[3 * (width * y + x) + c] = v;
	}

	void setAllValues(int c, int v) {
		
		int i;
		int j;

		for (j = 0; j < height; j++) {
			for (i = 0; i < width; i++) {
				pixels[3 * (width * j + i) + c] = v;
			}
		}
		
	}

	Image(unsigned char* ps, int w, int h) : pixels(ps), width(w), height(h) {
		
	}

	~Image() {
		delete[] pixels;
	}

	void getTextureId(GLenum filterType) {
		
		glGenTextures(1, &tid);
		glBindTexture(GL_TEXTURE_2D, tid);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filterType);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filterType);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

		glTexImage2D(GL_TEXTURE_2D,
					 0,
					 GL_RGB,
					 width, height,
					 0,
					 GL_RGB,
					 GL_UNSIGNED_BYTE,
					 pixels);
	}


};


Image* loadBMP(string fnString) {
	const char* filename = fnString.c_str();
	ifstream input;
	input.open(filename, ifstream::binary);
	assert(!input.fail() || !"Could not find file");
	char buffer[2];
	input.read(buffer, 2);
	assert(buffer[0] == 'B' && buffer[1] == 'M' || !"Not a bitmap file");
	input.ignore(8);
	int dataOffset = readInt(input);
	
	//Read the header
	int headerSize = readInt(input);
	int width;
	int height;
	switch(headerSize) {
		case 40:
			//V3
			width = readInt(input);
			height = readInt(input);
			input.ignore(2);
			assert(readShort(input) == 24 || !"Image is not 24 bits per pixel");
			assert(readShort(input) == 0 || !"Image is compressed");
			break;
		case 12:
			//OS/2 V1
			width = readShort(input);
			height = readShort(input);
			input.ignore(2);
			assert(readShort(input) == 24 || !"Image is not 24 bits per pixel");
			break;
		case 64:
			//OS/2 V2
			assert(!"Can't load OS/2 V2 bitmaps");
			break;
		case 108:
			//Windows V4
			assert(!"Can't load Windows V4 bitmaps");
			break;
		case 124:
			//Windows V5
			assert(!"Can't load Windows V5 bitmaps");
			break;
		default:
			assert(!"Unknown bitmap format");
	}
	
	//Read the data
	int bytesPerRow = ((width * 3 + 3) / 4) * 4 - (width * 3 % 4);
	int size = bytesPerRow * height;
	auto_array<char> pixels(new char[size]);
	input.seekg(dataOffset, ios_base::beg);
	input.read(pixels.get(), size);
	
	//Get the data into the right format
	auto_array<unsigned char> pixels2(new unsigned char[width * height * 3]);

	
	for(int y = 0; y < height; y++) {
		for(int x = 0; x < width; x++) {
			for(int c = 0; c < 3; c++) {
				pixels2[3 * (width * y + x) + c] =
					pixels[bytesPerRow * y + 3 * x + (2 - c)];
			}
		}
	}
	
	input.close();
	return new Image(pixels2.release(), width, height);
}

 
class FBOWrapper
{
public:

	uint color_tex;

	//uint color_buf;
	//uint depth_buf;
	uint slot;
	int width;
	int height;
	int bytesPerChannel;
	int numMips;
	bool hasMipMap;
	//bool hasDepth;

	GLint numBytes;
	GLint internalFormat;

	uint *pixelsUINT;
	unsigned char *pixelsChar;
	unsigned char **pixelsCharMippedMin;
	unsigned char **pixelsCharMippedMax;
	unsigned char **pixelsCharMippedAvg;
	int *mipWidths;

	float *pixelsFloat;
	bool isFloat;

	FBOWrapper() {}
	~FBOWrapper() {}
	int init(
		int _width,
		int _height,
		int _bytesPerChannel,
		int _slot,
		int filterEnum,
		int clampEnum,
		bool isMultisample = false
	) {
		numBytes = 0;
		pixelsUINT = NULL;
		
		width = _width;
		height = _height;
		bytesPerChannel = _bytesPerChannel;
		//hasDepth = _hasDepth;

		pixelsCharMippedMin = NULL;
		pixelsCharMippedMax = NULL;
		pixelsCharMippedAvg = NULL;

		int w = width;
		int h = height;
		int num_samples = 4;
		numMips = 0;

		isFloat = false;

		pixelsChar = NULL;
		pixelsFloat = NULL;


		slot = GL_COLOR_ATTACHMENT0_EXT;

		switch (_slot) {
		case 0:
			slot = GL_COLOR_ATTACHMENT0_EXT;
			break;
		case 1:
			slot = GL_COLOR_ATTACHMENT1_EXT;
			break;
		case 2:
			slot = GL_COLOR_ATTACHMENT2_EXT;
			break;
		case 3:
			slot = GL_COLOR_ATTACHMENT3_EXT;
			break;
		case 4:
			slot = GL_COLOR_ATTACHMENT4_EXT;
			break;
		case 5:
			slot = GL_COLOR_ATTACHMENT5_EXT;
			break;
		case 6:
			slot = GL_COLOR_ATTACHMENT6_EXT;
			break;
		case 7:
			slot = GL_COLOR_ATTACHMENT7_EXT;
			break;
		}


		if (isMultisample) {
			glGenTextures(1, &color_tex);
			glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, color_tex);
			glTexParameteri(GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_MIN_FILTER, filterEnum);
			glTexParameteri(GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_MAG_FILTER, filterEnum);
			glTexParameteri(GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_WRAP_S, clampEnum);
			glTexParameteri(GL_TEXTURE_2D_MULTISAMPLE, GL_TEXTURE_WRAP_T, clampEnum);

			switch (bytesPerChannel) {
			case 1:
				internalFormat = GL_RGBA8;
				
				break;
			case 2:
				internalFormat = GL_RGBA16;
				
				break;
			case 4:
				internalFormat = GL_RGBA32F;
				isFloat = true;

				break;
			}
			
			glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, num_samples, internalFormat, w, h, false );
			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, slot, GL_TEXTURE_2D_MULTISAMPLE, color_tex, 0);
			glBindTexture(GL_TEXTURE_2D_MULTISAMPLE, 0);
		}
		else {
			glGenTextures(1, &color_tex);
			glBindTexture(GL_TEXTURE_2D, color_tex);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, filterEnum);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, filterEnum);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, clampEnum);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, clampEnum);

			switch (bytesPerChannel) {
			case 1:
				internalFormat = GL_RGBA8;
				glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, w, h, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);

				break;
			case 2:
				internalFormat = GL_RGBA16;
				glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, w, h, 0, GL_RGBA, GL_UNSIGNED_SHORT, 0);

				break;
			case 4:
				internalFormat = GL_RGBA32F;
				glTexImage2D(
					GL_TEXTURE_2D,
					0,
					internalFormat,
					w,
					h,
					0,
					GL_RGBA,
					GL_FLOAT,
					0
				);
				isFloat = true;

				break;
			}

			glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, slot, GL_TEXTURE_2D, color_tex, 0);
			glBindTexture(GL_TEXTURE_2D, 0);
		}

		
		
		
		
		
	TOT_GPU_MEM_USAGE += ((float)(w * h * bytesPerChannel * 4)) / (1024.0f * 1024.0f);

	return 1;





		//
		/*
		if (hasDepth) {
		  glGenRenderbuffersEXT(1, &depth_rb);
		  glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, depth_rb);
		  glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, w, h);
		  glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, depth_rb);
		}
		*/


		//

	}


	void cpuToGPU() {

		if (pixelsChar == NULL) {
			doTrace("error: null pointer pixelsChar");
			return;
		}

		switch (bytesPerChannel) {
		case 1:

			glBindTexture(GL_TEXTURE_2D, color_tex);
			/*
			glTexSubImage2D(
			  GL_TEXTURE_2D,
			  0,

			  0,
			  0,
			  width,
			  height,

			  GL_RGBA,
			  GL_UNSIGNED_BYTE,
			  pixelsChar
			 );
			 */


			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_BASE_LEVEL, 0);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAX_LEVEL, 0);
			glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixelsChar);

			glBindTexture(GL_TEXTURE_2D, 0);

			break;
		case 2:
			doTrace("TODO: implement 16 bit");
			break;
		case 4:
			doTrace("TODO: implement 32 bit");
			break;
		}



	}



	void getPixelAtF(FIVector4 *fv, int x, int y) {

		if (isFloat) {

			
			if ( (pixelsFloat == NULL) ) {
				getPixels();
			}

			//a
			//b
			//g
			//r

			fv->setFX(pixelsFloat[ (x + y * width) * 4 + 0 ]);
			fv->setFY(pixelsFloat[ (x + y * width) * 4 + 1 ]);
			fv->setFZ(pixelsFloat[ (x + y * width) * 4 + 2 ]);
			fv->setFW(pixelsFloat[ (x + y * width) * 4 + 3 ]);

		}
		else {
			doTraceND("Attempted to call getPixelAtF on char buffer.");
		}

	}

	void setAllPixels(int channel, int value) {
		int i;
		int j;
		int x;
		int y;

		for (j = 0; j < height; j++) {
			for (i = 0; i < width; i++) {
				x = i;
				y = j;
				pixelsChar[ (x + y * width) * 4 + channel ] = value;
			}
		}
	}

	void setPixelAtC(int x, int y, int channel, unsigned char value) {
		pixelsChar[ (x + y * width) * 4 + channel ] = value;
	}


	int getIndex(int xs, int ys) {
		int x = xs;
		int y = ys;

		while (x < 0) {
			x += width;
		}
		while (y < 0) {
			y += height;
		}

		x = x % width;
		y = y % height;

		return x + y * width;
	}

	void setPixelAtWrapped(int xs, int ys, int channel, int val) {

		int x = xs;
		int y = ys;

		while (x < 0) {
			x += width;
		}
		while (y < 0) {
			y += height;
		}

		x = x % width;
		y = y % height;

		int ind = x + y * width;

		pixelsChar[ind * 4 + channel] = val;
	}

	int getPixelAtWrapped(int xs, int ys, int channel) {

		int x = xs;
		int y = ys;

		while (x < 0) {
			x += width;
		}
		while (y < 0) {
			y += height;
		}

		x = x % width;
		y = y % height;

		int ind = x + y * width;

		return pixelsChar[ind * 4 + channel];
	}


	

	int getPixelAtIndex(int ind, int channel) {
		
		return pixelsChar[ind * 4 + channel];
		
	}
	void setPixelAtIndex(int ind, int channel, int val) {
		pixelsChar[ind * 4 + channel] = val;
	}
	void orPixelAtIndex(int ind, int channel, int val) {
		pixelsChar[ind * 4 + channel] |= val;
	}
	void andPixelAtIndex(int ind, int channel, int val) {
		pixelsChar[ind * 4 + channel] &= val;
	}

	int getPixelAtC(int x, int y, int channel) {

		if (!isFloat) {
			if ( (pixelsChar == NULL) ) {
				getPixels();
			}

			return (int)pixelsChar[ (x + y * width) * 4 + channel ];

		}
		else {
			doTrace("Attempted to call getPixelAtC on float buffer.");
			return 0;
		}

	}

	float getPixelAtLinear(float xf, float yf, int channel) {
		int x[2];
		int y[2];

		x[0] = floor(xf);
		y[0] = floor(yf);
		x[1] = x[0] + 1;
		y[1] = y[0] + 1;

		float percX = xf - x[0];
		float percY = yf - y[0];
		float percXI = 1.0f - percX;
		float percYI = 1.0f - percY;


		float v0, v1;
		float v2, v3;

		int i;

		for (i = 0; i < 2; i++) {

			while (x[i] < 0) {
				x[i] += width;
			}
			while (y[i] < 0) {
				y[i] += height;
			}

			x[i] = x[i] % width;
			y[i] = y[i] % height;
		}

		v0 = getPixelAtC(x[0], y[0], channel) / 255.0f;
		v1 = getPixelAtC(x[1], y[0], channel) / 255.0f;
		v2 = getPixelAtC(x[0], y[1], channel) / 255.0f;
		v3 = getPixelAtC(x[1], y[1], channel) / 255.0f;

		float vFinal = (v0 * percXI + v1 * percX) * percYI + (v2 * percXI + v3 * percX) * percY;

		return vFinal;

	}


	int getMipVal(
		int x,
		int y,
		int mipLev,
		int channel,
		int minMaxAvg,
		int val = -1,
		int ox = 0,
		int oy = 0
	) {

		int w = mipWidths[mipLev];
		int curWidth = mipWidths[mipLev];
		int mipPitch = 1 << mipLev;
		int xv;
		int yv;

		float t1;
		float t2;
		float t3;

		xv = intDiv(x * curWidth, mipWidths[0]) + ox;
		yv = intDiv(y * curWidth, mipWidths[0]) + oy;


		while (xv < 0) {
			xv += curWidth;
		}
		while (xv >= curWidth) {
			xv -= curWidth;
		}
		while (yv < 0) {
			yv += curWidth;
		}
		while (yv >= curWidth) {
			yv -= curWidth;
		}

		int ind = xv + yv * curWidth;
		int res = 0;
		int resInd = (ind) * 4 + channel;

		if (val != -1) {
			switch (minMaxAvg) {
			case 0:
				(pixelsCharMippedMin[mipLev][resInd]) = val;
				break;
			case 1:
				(pixelsCharMippedMax[mipLev][resInd]) = val;
				break;
			case 2:
				(pixelsCharMippedAvg[mipLev][resInd]) = val;
				break;
			}
		}

		switch (minMaxAvg) {
		case 0:
			res = (int) (pixelsCharMippedMin[mipLev][resInd]);
			break;
		case 1:
			res = (int) (pixelsCharMippedMax[mipLev][resInd]);
			break;
		case 2:
			res = (int) (pixelsCharMippedAvg[mipLev][resInd]);
			break;
		}



		return res;

	}

	int getMipAtIndex(int ind, int mipLev, int channel, int minMaxAvg) {
		int res = 0;
		int resInd = ind * 4 + channel;

		switch (minMaxAvg) {
		case 0:
			res = (int) (pixelsCharMippedMin[mipLev][resInd]);
			break;
		case 1:
			res = (int) (pixelsCharMippedMax[mipLev][resInd]);
			break;
		case 2:
			res = (int) (pixelsCharMippedAvg[mipLev][resInd]);
			break;
		}

		return res;
	}

	int getMipInd(int x, int y, int mipLev) {
		int w = mipWidths[mipLev];

		return ((x * mipWidths[mipLev]) / mipWidths[0]) + ((y * mipWidths[mipLev]) / mipWidths[0]) * mipWidths[mipLev];
	}

	void updateMips() {

		int i;
		int j;
		int k;
		int m;

		int ind, ind0, ind1, ind2, ind3;

		int mRead;
		int mWrite;

		if (pixelsCharMippedAvg == NULL) {
			doTrace("Error: no mip maps, first call getPixels()");
			return;
		}
		else {
			for (m = 0; m < numMips - 1; m++) {

				mRead = m;
				mWrite = m + 1;

				for (k = 0; k < 4; k++) { // channels

					for (i = 0; i < mipWidths[mWrite]; i++) {
						for (j = 0; j < mipWidths[mWrite]; j++) {

							ind = (i + j * mipWidths[mWrite]) * 4 + k;

							ind0 = ( (i * 2 + 0) + (j * 2 + 0) * mipWidths[mRead] ) * 4 + k; //
							ind1 = ( (i * 2 + 1) + (j * 2 + 0) * mipWidths[mRead] ) * 4 + k; //
							ind2 = ( (i * 2 + 0) + (j * 2 + 1) * mipWidths[mRead] ) * 4 + k; //
							ind3 = ( (i * 2 + 1) + (j * 2 + 1) * mipWidths[mRead] ) * 4 + k; //

							pixelsCharMippedAvg[ mWrite ][ ind ] = (
									pixelsCharMippedAvg[ mRead ][ind0] +
									pixelsCharMippedAvg[ mRead ][ind1] +
									pixelsCharMippedAvg[ mRead ][ind2] +
									pixelsCharMippedAvg[ mRead ][ind3]
																										 ) / 4;

							pixelsCharMippedMin[ mWrite ][ ind ] = min(
									min(
										pixelsCharMippedMin[ mRead ][ind0],
										pixelsCharMippedMin[ mRead ][ind1]
									),
									min(
										pixelsCharMippedMin[ mRead ][ind2],
										pixelsCharMippedMin[ mRead ][ind3]
									)
																										 );

							pixelsCharMippedMax[ mWrite ][ ind ] = max(
									max(
										pixelsCharMippedMax[ mRead ][ind0],
										pixelsCharMippedMax[ mRead ][ind1]
									),
									max(
										pixelsCharMippedMax[ mRead ][ind2],
										pixelsCharMippedMax[ mRead ][ind3]
									)
																										 );




						}
					}

				}
			}
		}
	}
	
	

	int getPixelAtIndex3DMip(int ind, int channel, int mval, int mipLev) {
		
		int newInd = ind * 4 + channel;
		
		switch (mval) {
			case 0: // min
				return pixelsCharMippedMax[mipLev][newInd];
			break;
			
			case 1: // max
				return pixelsCharMippedMax[mipLev][newInd];
			break;
			
			case 2: // avg
				return pixelsCharMippedMax[mipLev][newInd];
			break;
			
			case 3: // no mip
				return pixelsChar[newInd];
			break;
		}
		
		return 0;
	}
		
	void updateMips3D(int basePitch) {

		int i;
		int j;
		int k;
		int m;
		
		int c;

		int dest, ind0, ind1, ind2, ind3, ind4, ind5, ind6, ind7;

		int mRead;
		int mWrite;
		
		
		int mrPitch = basePitch;
		int mwPitch = basePitch/2;
		
		int mrPitch2;
		
		pixelsCharMippedAvg[0] = pixelsChar;
		pixelsCharMippedMax[0] = pixelsChar;
		pixelsCharMippedMin[0] = pixelsChar;
		

		if (pixelsCharMippedAvg == NULL) {
			doTrace("Error: no mip maps, first call getPixels()");
			return;
		}
		else {
			
			for (m = 0; m < (MAX_MIP_LEV-1); m++) { //m < numMips - 1

				mRead = m;
				mWrite = m + 1;
				
				
				
				 // channels

				for (k = 0; k < mwPitch; k++) {
					for (j = 0; j < mwPitch; j++) {
						for (i = 0; i < mwPitch; i++) {
						

							for (c = 0; c < 4; c++) {
								dest = (i + j * mwPitch + k*mwPitch*mwPitch) * 4 + c;
								
								mrPitch2 = mrPitch*mrPitch;

								ind0 = ( (i * 2 + 0) + (j * 2 + 0) * mrPitch + (k * 2 + 0) * mrPitch2) * 4 + c;
								ind1 = ( (i * 2 + 1) + (j * 2 + 0) * mrPitch + (k * 2 + 0) * mrPitch2) * 4 + c;
								ind2 = ( (i * 2 + 0) + (j * 2 + 1) * mrPitch + (k * 2 + 0) * mrPitch2) * 4 + c;
								ind3 = ( (i * 2 + 1) + (j * 2 + 1) * mrPitch + (k * 2 + 0) * mrPitch2) * 4 + c;
								ind4 = ( (i * 2 + 0) + (j * 2 + 0) * mrPitch + (k * 2 + 1) * mrPitch2) * 4 + c;
								ind5 = ( (i * 2 + 1) + (j * 2 + 0) * mrPitch + (k * 2 + 1) * mrPitch2) * 4 + c;
								ind6 = ( (i * 2 + 0) + (j * 2 + 1) * mrPitch + (k * 2 + 1) * mrPitch2) * 4 + c;
								ind7 = ( (i * 2 + 1) + (j * 2 + 1) * mrPitch + (k * 2 + 1) * mrPitch2) * 4 + c;

								

								
								
								// pixelsCharMippedMin[ mWrite ][ dest ] = pixelsCharMippedMin[ mRead ][ind0];
								// pixelsCharMippedMax[ mWrite ][ dest ] = pixelsCharMippedMax[ mRead ][ind0];
								// pixelsCharMippedAvg[ mWrite ][ dest ] = pixelsCharMippedAvg[ mRead ][ind0];
								
								
								pixelsCharMippedAvg[ mWrite ][ dest ] = (
										pixelsCharMippedAvg[ mRead ][ind0] +
										pixelsCharMippedAvg[ mRead ][ind1] +
										pixelsCharMippedAvg[ mRead ][ind2] +
										pixelsCharMippedAvg[ mRead ][ind3] + 
										pixelsCharMippedAvg[ mRead ][ind4] + 
										pixelsCharMippedAvg[ mRead ][ind5] + 
										pixelsCharMippedAvg[ mRead ][ind6] + 
										pixelsCharMippedAvg[ mRead ][ind7]
								) / 8;

								pixelsCharMippedMax[ mWrite ][ dest ] =
								
								max(
										max(
											max(
												pixelsCharMippedMax[ mRead ][ind0],
												pixelsCharMippedMax[ mRead ][ind1]
											),
											max(
												pixelsCharMippedMax[ mRead ][ind2],
												pixelsCharMippedMax[ mRead ][ind3]
											)
										),
										max(
											max(
												pixelsCharMippedMax[ mRead ][ind4],
												pixelsCharMippedMax[ mRead ][ind5]
											),
											max(
												pixelsCharMippedMax[ mRead ][ind6],
												pixelsCharMippedMax[ mRead ][ind7]
											)							
										)
								);
								
								
								// pixelsCharMippedMin[ mWrite ][ dest ] = min(
								// 		min(
								// 			min(
								// 				pixelsCharMippedMax[ mRead ][ind0],
								// 				pixelsCharMippedMax[ mRead ][ind1]
								// 			),
								// 			min(
								// 				pixelsCharMippedMax[ mRead ][ind2],
								// 				pixelsCharMippedMax[ mRead ][ind3]
								// 			)
								// 		),
								// 		min(
								// 			min(
								// 				pixelsCharMippedMax[ mRead ][ind4],
								// 				pixelsCharMippedMax[ mRead ][ind5]
								// 			),
								// 			min(
								// 				pixelsCharMippedMax[ mRead ][ind6],
								// 				pixelsCharMippedMax[ mRead ][ind7]
								// 			)							
								// 		)
								// );
								
								
								
								
							}							

							
						}
					}
				}

								
				

				
				
				
				mrPitch = mrPitch/2;
				mwPitch = mwPitch/2;
				
				
			}
			
			
			
			
		}
	}
	


	void getPixelsFast() {



		glBindTexture(GL_TEXTURE_2D, color_tex);
		int totalWidth;
		int curBytes;

		numBytes = width * height;

		if (pixelsUINT == NULL) {
			pixelsUINT = new uint[numBytes];
		}
		glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixelsUINT);
		glBindTexture(GL_TEXTURE_2D, 0);

	}
	
	// assumed that remoteBuffer is allocated
	void getPixelsFastRemote(uint* remoteBuffer) {


		glBindTexture(GL_TEXTURE_2D, color_tex);
		int totalWidth;
		int curBytes;
		numBytes = width * height;
		glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, remoteBuffer);
		glBindTexture(GL_TEXTURE_2D, 0);

	}


	void getPixels(bool _hasMipMap = false) {



		glBindTexture(GL_TEXTURE_2D, color_tex);
		

		int targetlevel = 0;
		int index;
		int i;
		int totalWidth;
		int curBytes;

		//GLint intForm;
		//glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_COMPONENTS, &intForm); // get internal format type of GL texture


		switch (internalFormat) // determine what type GL texture has...
		{
		case GL_RGB:
			numBytes = width * height * 3;
			break;
		case GL_RGBA:
			numBytes = width * height * 4;
			break;
		case GL_RGBA8:
			numBytes = width * height * 4;
			break;
			//case GL_RGBA16:
			//
			//break;
		case GL_RGBA32F:
			numBytes = width * height * 4;
			break;

		default:
			doTrace("Unsupported Format Type");
			return;
			break;
		}

		if (numBytes) {

			if (isFloat) {

				if (pixelsFloat == NULL) {
					pixelsFloat = new float[numBytes];//(float*)malloc(numBytes);
				}

				glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_FLOAT, pixelsFloat);
			}
			else {

				if (pixelsChar == NULL) {
					pixelsChar = new unsigned char[numBytes];


					if (_hasMipMap) {

						hasMipMap = _hasMipMap;
						
					}


					index = width;
					if (index == 0) {
						doTrace("Error: width of 0");
						return;
					}
					else {
						while (index >>= 1) {
							++targetlevel;
						}
						numMips = targetlevel;

					}

					pixelsCharMippedAvg = new unsigned char*[numMips];
					pixelsCharMippedMax = new unsigned char*[numMips];
					pixelsCharMippedMin = new unsigned char*[numMips];
					mipWidths = new int[numMips];


					pixelsCharMippedAvg[0] = pixelsChar;
					pixelsCharMippedMax[0] = pixelsChar;
					pixelsCharMippedMin[0] = pixelsChar;

					mipWidths[0] = width;

					if (hasMipMap) {

						totalWidth = width / 2;
						curBytes = numBytes / 2;

						for (i = 1; i < numMips; i++) {
							pixelsCharMippedMin[i] = new unsigned char[curBytes];
							pixelsCharMippedMax[i] = new unsigned char[curBytes];
							pixelsCharMippedAvg[i] = new unsigned char[curBytes];
							mipWidths[i] = totalWidth;

							totalWidth = totalWidth / 2;
							curBytes = curBytes / 2;
						}
					}

				}
				glGetTexImage(GL_TEXTURE_2D, 0, GL_RGBA, GL_UNSIGNED_BYTE, pixelsChar);
			}


		}

		glBindTexture(GL_TEXTURE_2D, 0);


	}


};


class FBOSet
{
public:
	int numBufs;
	int width;
	int height;
	int bytesPerChannel;

	uint depth_rb;

	GLuint mFBO;

	FBOWrapper *fbos;

	bool isReady;
	bool hasDepth;

	FBOSet() {}
	~FBOSet() {}

	FBOWrapper *getFBOWrapper(int offset) {
		return &(fbos[offset]);
	}

	void init(
		int _numBufs,
		int _width,
		int _height,
		int _bytesPerChannel,
		bool _hasDepth,
		int filterEnum = GL_NEAREST,
		int clampEnum = GL_CLAMP_TO_EDGE,
		bool isMultisample = false
	) {
		int i;

		hasDepth = _hasDepth;

		numBufs = _numBufs;
		height = _height;
		width = _width;
		
		// cout << width << "," << height <<"\n";
		
		bytesPerChannel = _bytesPerChannel;

		fbos = new FBOWrapper[numBufs];
		
		isReady = true;

		glGenFramebuffersEXT(1, &mFBO);
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, mFBO);

		for (i = 0; i < numBufs; i++) {
			fbos[i].init(width, height, bytesPerChannel, i, filterEnum, clampEnum, isMultisample);
		}


		if (hasDepth) {
			glGenRenderbuffersEXT(1, &depth_rb);
			glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, depth_rb);
			glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT, GL_DEPTH_COMPONENT24, width, height);
			glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT, GL_DEPTH_ATTACHMENT_EXT, GL_RENDERBUFFER_EXT, depth_rb);
		}


		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
	}
	void bind(int doClear) {

		//setWH(width, height);

		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, mFBO);

		glDrawBuffers(numBufs, bufNames);

		if (doClear) {
			glClearColor(0.0, 0.0, 0.0, 0.0);
			glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		}

	}
	void copyFromMem(int ind, unsigned char *dat) {

		//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, mFBO);

		glBindTexture(GL_TEXTURE_2D, fbos[ind].color_tex);

		//glTexSubImage2D(GLenum target​, GLint level​, GLint xoffset​, GLint yoffset​, GLsizei width​, GLsizei height​, GLenum format​, GLenum type​, const GLvoid * data​);

		glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, width, height, GL_RGBA, GL_UNSIGNED_BYTE, dat);
		//glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT, fbos[ind].slot, GL_TEXTURE_2D, fbos[ind].color_tex, 0);
		//glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		//glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		glBindTexture(GL_TEXTURE_2D, 0);

		//glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
	}
};

 

// class WebSocketRequestHandler;
// class WebSocketServer;
// class RequestHandlerFactory;
class Singleton;
class Shader;
class GameSound;
class GameMusic;
class FontWrapper;
class UIComponent;
class GameGUI;
class GameOctree;
class GameAI;
class GameNetwork;
class GameFluid;
class GameOrgNode;
class GameOrg;
class GamePlantNode;
class GamePlant;
class GameEnt;
class GamePhysRig;
class GameEntManager;
class GameBlock;
class GamePageHolder;
class VolumeWrapper;
class ThreadPoolWrapper;
class GameLogic;
class MyGLHelper;
class GamePhysics;
class GameWorld;
class DynBuffer;
 
// f00293_gamesound.e
//

#ifndef LZZ_f00293_gamesound_e
#define LZZ_f00293_gamesound_e
#define LZZ_INLINE inline
class GameSound
{
public:
  sf::SoundBuffer buffer;
  sf::Sound sound;
  float curVolume;
  GameSound ();
  void init (string path);
  void setPitch (float val);
  void setPositionAndMinDis (float x, float y, float z, float w);
  void setLoop (bool val);
  void stop ();
  void setVolumeSmooth (float volume = 1.0f, float decay = 0.01f);
  void setVolume (float volume = 1.0f);
  void play (float volume = 1.0f);
};
#undef LZZ_INLINE
#endif
// f00294_gamemusic.e
//

#ifndef LZZ_f00294_gamemusic_e
#define LZZ_f00294_gamemusic_e
#define LZZ_INLINE inline
class GameMusic
{
public:
  sf::Music sound;
  float volume;
  GameMusic ();
  void init (string path);
  void setLoop (bool val);
  void stop ();
  void setVolume (float _volume = 1.0f);
  void play (float _volume = 1.0f);
};
#undef LZZ_INLINE
#endif
// f00300_singleton.e
//

#ifndef LZZ_f00300_singleton_e
#define LZZ_f00300_singleton_e
#define LZZ_INLINE inline
class Singleton
{
private:
  FIVector4 * cameraPos;
  FIVector4 tempLerpPos;
  FIVector4 camLerpPos;
  FIVector4 resultCameraPos;
  FIVector4 targetCameraPos;
  FIVector4 baseCameraPos;
public:
  struct UIQuad
  {
    fBoundingBox hitBounds;
    CharStruct * cs;
    int fontId;
  };
  struct UICont
  {
    UIQuad bg;
    std::vector <UIQuad> charVec;
  };
  struct JSONStruct
  {
    JSONValue * jv;
  };
  struct UICStruct
  {
    int nodeId;
  };
  struct CompStruct
  {
    bool isValid;
    UIComponent * data;
  };
  DynBuffer * myDynBuffer;
  struct CompareStruct
  {
    bool operator () (string const & first, string const & second);
  };
  CompareStruct compareStruct;
  typedef map <string, UICStruct>::iterator itUICStruct;
  typedef map <string, JSONStruct>::iterator itJSStruct;
  bool (keysPressed) [MAX_KEYS];
  double (keyDownTimes) [MAX_KEYS];
  unsigned char (keyMap) [KEYMAP_LENGTH];
  bool (keyMapResultZipped) [KEYMAP_LENGTH];
  bool (keyMapResultUnzipped) [KEYMAP_LENGTH];
  int (keyMapCoolDown) [KEYMAP_LENGTH];
  int (keyMapMaxCoolDown) [KEYMAP_LENGTH];
  GLdouble (viewMatrixD) [16];
  float (viewMatrixDI) [16];
  GLdouble (projMatrixD) [16];
  Matrix4 identMatrix;
  Matrix4 viewMatrix;
  Matrix4 projMatrix;
  std::vector <Matrix4> objMatrixStack;
  Matrix4 curObjMatrix;
  Matrix4 curMVP;
  Matrix3 curObjMatrix3;
  Matrix4 tempObjMatrix;
  GLint (viewport) [4];
  E_OBJ activeObject;
  E_OBJ tempObj;
  eProgramState programState;
  eProgramAction (progActionsDown) [E_PS_SIZE * 256];
  eProgramAction (progActionsUp) [E_PS_SIZE * 256];
  EntSelection nearestLights;
  EntSelection highlightedEnts;
  EntSelection selectedEnts;
  GameEnt * selectedEnt;
  GameEnt * highlightedEnt;
  PatternStruct (patterns) [E_PAT_LENGTH*4];
  TBOWrapper limbTBO;
  float (limbTBOData) [MAX_LIMB_DATA_IN_BYTES];
  int destructCount;
  bool sphereMapOn;
  bool waitingOnDestruction;
  bool renderingOctBounds;
  bool renderingOct;
  bool placingPattern;
  bool drawTargPaths;
  bool gridOn;
  bool physicsOn;
  bool isPressingMove;
  bool fxaaOn;
  bool doPathReport;
  bool refreshPaths;
  bool placingTemplate;
  bool smoothMove;
  bool waterBulletOn;
  bool ignoreFrameLimit;
  bool autoMove;
  bool allInit;
  bool updateMatFlag;
  bool matVolLock;
  bool isMoving;
  bool perspectiveOn;
  bool lastPersp;
  bool (isInteractiveEnt) [E_CT_LENGTH];
  bool inputOn;
  bool pathfindingOn;
  bool pathfindingGen;
  bool pathfindingTestOn;
  bool placingGeom;
  bool isMacro;
  bool cavesOn;
  bool bakeParamsOn;
  bool dragging;
  bool mouseMoved;
  bool hitGUI;
  bool draggingMap;
  bool guiDirty;
  bool applyToChildren;
  bool bShiftOld;
  bool bCtrlOld;
  bool bCtrl;
  bool bShift;
  bool testOn;
  bool testOn2;
  bool emptyVDNotReady;
  bool radiosityOn;
  bool updateLock;
  bool isFullScreen;
  bool mapInvalid;
  bool wsBufferInvalid;
  bool forceGetPD;
  bool mouseLeftDown;
  bool mouseRightDown;
  bool pboSupported;
  bool notQuit;
  bool timerNotSet;
  bool lbDown;
  bool abDown;
  bool rbDown;
  bool mbDown;
  bool isBare;
  bool showMap;
  bool traceOn;
  bool waterOn;
  bool treesOn;
  bool firstRun;
  bool rotOn;
  bool doPageRender;
  bool markerFound;
  bool updateHolders;
  bool fpsTest;
  bool frameMouseMove;
  bool depthInvalidRotate;
  bool depthInvalidMove;
  bool lastDepthInvalidMove;
  bool drawOrient;
  int curPrimTemplate;
  int geomStep;
  int earthMod;
  int currentTick;
  int curPattern;
  int curPatternRot;
  int tbTicks;
  int tempCounter;
  int actorCount;
  int polyCount;
  int fdWritePos;
  int fdReadPos;
  int fpsCountMax;
  int fpsCount;
  int medianCount;
  int maxHolderDis;
  int fieldCallback;
  int mouseState;
  int lastW;
  int lastH;
  int maxLayerOver;
  int pathFindingStep;
  int baseW;
  int baseH;
  int scaleFactor;
  int numDynLights;
  int iNumSteps;
  int curOrgId;
  int extraRad;
  int defaultWinW;
  int defaultWinH;
  int guiWinW;
  int guiWinH;
  int shadersAreLoaded;
  int readyToRecompile;
  int lastPosX;
  int lastPosY;
  int frameCount;
  int screenWidth;
  int screenHeight;
  int mouseMovingSize;
  int mouseMovingLoc;
  int mouseMovingStepsBack;
  int mouseCount;
  int lastMouseX;
  int lastMouseY;
  int cellsPerNodeXY;
  int terDataVisPitchXY;
  int terDataBufPitchXY;
  int terDataBufPitchScaledXY;
  int cellsPerNodeZ;
  int terDataVisPitchZ;
  int terDataBufPitchZ;
  int terDataBufPitchScaledZ;
  int terDataBufAmount;
  int terDataVisSize;
  int terDataBufSize;
  int terDataTexScale;
  int terDataBufSizeScaled;
  int iNodeDivsPerHolder;
  int matVolSize;
  int escCount;
  int mapPitch;
  int lastNodeId;
  int diagCount;
  int frameSkip;
  int frameSkipCount;
  int cellsPerHolder;
  int cellsPerBlock;
  int holdersPerBlock;
  int cellsPerWorld;
  int holdersPerWorld;
  int blocksPerWorld;
  intPair (entIdArr) [1024];
  uint palWidth;
  uint palHeight;
  uint blockShift;
  uint * terDataScaled;
  GLfloat (camRotation) [2];
  GLfloat (curCamRotation) [2];
  bool timeMod;
  uint (naUintData) [8];
  int (naIntData) [8];
  float (naFloatData) [8];
  float (conVals) [E_CONST_LENGTH];
  float lastMouseOrigX;
  float lastMouseOrigY;
  float globWheelDelta;
  float amountInvalidMove;
  float amountInvalidRotate;
  float sphereMapPrec;
  float heightMapMaxInCells;
  float resultShake;
  float cameraShake;
  float lastx;
  float lasty;
  float FOV;
  float focalLength;
  float zoomDelta;
  float subjectDelta;
  float subjectZoom;
  float targetSubjectZoom;
  float cameraZoom;
  float targetZoom;
  float fogOn;
  float mapSampScale;
  float curBrushRad;
  float timeOfDay;
  float targetTimeOfDay;
  float origWinW;
  float origWinH;
  float guiX;
  float guiY;
  float aspectRatio;
  float currentFBOResolutionX;
  float currentFBOResolutionY;
  float curPrimMod;
  float mouseX;
  float mouseY;
  float mouseXUp;
  float mouseYUp;
  float holderSizeMB;
  float bestNodeDis;
  float heightOfNearPlane;
  float scrollDiv;
  float curMoveSpeed;
  float curMoveAccel;
  float masterVolume;
  float ambientVolume;
  float guiVolume;
  float musicVolume;
  float fxVolume;
  float * paramArr;
  float * paramArrGeom;
  float * splashArr;
  float * explodeArr;
  float * voroArr;
  float * matCountArr;
  float * paramArrMap;
  float (clipDist) [2];
  float MAX_TRAVEL_DIS;
  double timeDelta;
  double curTime;
  float smoothTime;
  double pauseTime;
  double clickTime;
  double mdTime;
  double muTime;
  double (clickTimeLR) [2];
  double (mdTimeLR) [2];
  double (muTimeLR) [2];
  FIVector4 (geomPoints) [E_GEOM_POINTS_LENGTH];
  FIVector4 (colVecs) [16];
  FIVector4 geomOrigOffset;
  FIVector4 lastSend;
  FIVector4 lastHolderPos;
  FIVector4 lightVec;
  FIVector4 lightVecOrig;
  FIVector4 (dirVecs) [6];
  FIVector4 lastCellPos;
  FIVector4 worldMarker;
  FIVector4 lookAtVec;
  FIVector4 lookAtVec2D;
  FIVector4 baseScrollPos;
  FIVector4 mouseUpPD;
  FIVector4 mouseUpOPD;
  FIVector4 spaceUpPD;
  FIVector4 mouseDownPD;
  FIVector4 mouseDownOPD;
  FIVector4 mouseMovePD;
  FIVector4 mouseMoveOPD;
  FIVector4 tempVec1;
  FIVector4 tempVec2;
  FIVector4 tempVec3;
  FIVector4 (voroVecArr) [125];
  floatAndIndex (indexArr) [125];
  FIVector4 mouseStart;
  FIVector4 mouseEnd;
  FIVector4 mouseMoveVec;
  FIVector4 mapFreqs;
  FIVector4 mapAmps;
  FIVector4 * mouseMoving;
  FIVector4 bufferDim;
  FIVector4 bufferDimTarg;
  FIVector4 bufferDimHalf;
  FIVector4 bufferModDim;
  FIVector4 bufferRenderDim;
  FIVector4 origin;
  FIVector4 panMod;
  FIVector4 dMod;
  FIVector4 modXYZ;
  FIVector4 matVolDim;
  uint * matVol;
  ThreadWrapper threadNetSend;
  ThreadWrapper threadNetRecv;
  std::list <KeyStackEvent> keyStack;
  std::vector <ExplodeStruct> explodeStack;
  std::vector <DebrisStruct> debrisStack;
  std::vector <FIVector4> primTemplateStack;
  std::vector <SphereStruct> sphereStack;
  std::vector <int> (guiLayers) [MAX_UI_LAYERS];
  std::vector <RotationInfo> rotMatStack;
  std::vector <DynObject *> dynObjects;
  VBOWrapper fsQuad;
  float floorHeightInCells;
  float roofHeightInCells;
  float wallRadInCells;
  Image * imageHM0;
  Image * imageHM1;
  Image * cloudImage;
  GamePageHolder * closestHolder;
  GamePlant * (gamePlants) [E_PT_LENGTH/2];
  Shader * curShaderPtr;
  string jsonPostString;
  string currentFieldString;
  string curShader;
  string allText;
  string stringBuf;
  string curCallback;
  string (cbDataStrings) [10];
  string guiSaveLoc;
  VolumeWrapper * (volumeWrappers) [E_VW_LENGTH];
  vector <CompStruct> compStack;
  vector <int> emptyStack;
  vector <string> jsonPostStack;
  vector <string> splitStrings;
  vector <string> shaderStrings;
  vector <string> shaderTextureIds;
  map <string, Shader*> shaderMap;
  map <string, UICStruct> compMap;
  map <string, string> includeMap;
  map <string, FBOSet> fboMap;
  GLuint fsqDL;
  GLuint volIdMat;
  GLuint volGenId;
  uint * lookup2to3;
  unsigned char * resultImage;
  materialNode * matSlice0;
  materialNode * matSlice1;
  materialNode * matSlice2;
  charArr nullBuffer;
  charArr lastImageBuffer;
  charArr lastJSONBufferGUI;
  JSONValue * rootObjJS;
  JSONValue * guiRootJS;
  JSONValue * constRootJS;
  HPClock bulletTimer;
  Timer fpsTimer;
  Timer shakeTimer;
  Timer myTimer;
  Timer scrollTimer;
  Timer moveTimer;
  GameOctree * gameOct;
  GameWorld * gw;
  GameEntManager * gem;
  GamePhysics * gamePhysics;
  GameFluid * (gameFluid) [E_FID_LENGTH];
  GameLogic * gameLogic;
  GameNetwork * gameNetwork;
  GameAI * gameAI;
  float (lightArr) [MAX_LIGHTS * 16];
  int numLights;
  bool multiLights;
  int * rbStack;
  int * rbHeightStack;
  TerTexture (terTextures) [MAX_TER_TEX];
  GameGUI * mainGUI;
  UIComponent * mapComp;
  UIComponent * (menuList) [E_FM_LENGTH];
  UIComponent * contMenuBar;
  UIComponent * ddMenuBar;
  UIComponent * fieldText;
  FontWrapper * (fontWrappers) [EFW_LENGTH];
  GameMusic * (music) [EML_LENGTH];
  map <string, GameSound> soundMap;
  map <string, StyleSheet> styleSheetMap;
  map <string, JSONStruct> externalJSON;
  Singleton ();
  FIVector4 btvConv;
  FIVector4 * BTV2FIV (btVector3 btv);
  void init (int _defaultWinW, int _defaultWinH, int _scaleFactor);
  void applyPat (int patInd, int patShape, int rot, int x, int y, int val, int rad);
  void generatePatterns ();
  int placeInStack ();
  int placeInLayer (int nodeId, int layer);
  void initAllMatrices ();
  void funcNT2 ();
  void startNT2 ();
  bool stopNT2 ();
  void funcNT ();
  void startNT ();
  bool stopNT ();
  void prepSound (string soundName);
  void playSoundEnt (string soundName, BaseObj * ge = NULL, float variance = 0.0f, float volume = 1.0f, bool doLoop = false);
  void playSoundPosAndPitch (string soundName, FIVector4 * listenerPos, FIVector4 * soundPos, float variance = 0.0f, float volume = 1.0f, bool doLoop = false);
  void updateSoundPosAndPitch (string soundName, FIVector4 * listenerPos, FIVector4 * soundPos, float volume = 1.0f, float decay = 0.01f);
  void playSound (string soundName, float volume = 1.0f);
  void playSoundEvent (char const * eventName, bool suppress = false);
  void updateMatVol ();
  void toggleDDMenu (int x, int y, bool toggled);
  void dispatchEvent (int button, int state, float x, float y, UIComponent * comp, bool automated = false, bool preventRefresh = false);
  StyleSheet * getNewStyleSheet (string ssName);
  void initStyleSheet ();
  static void qNormalizeAngle (int & angle);
  ~ Singleton ();
  void setProgAction (eProgramState ps, unsigned char kc, eProgramAction pa, bool isDown);
  void setProgActionAll (unsigned char kc, eProgramAction pa, bool isDown);
  void drawCrossHairs (FIVector4 originVec, float radius);
  void drawLine (FIVector4 * p0, FIVector4 * p1);
  void drawCubeCentered (FIVector4 * originVec, float radius);
  void drawBoxUp (FIVector4 originVec, float radiusX, float radiusY, float diamZ);
  void drawBoxMinMax (btVector3 v0, btVector3 v1);
  void drawBoxRad (btVector3 v0, btVector3 v1);
  void drawBox (FIVector4 * v0, FIVector4 * v1, int faceFlag = 2);
  void getMaterialString ();
  bool getPrimTemplateString ();
  void refreshIncludeMap ();
  void doShaderRefresh (bool doBake);
  void setWH (int w, int h);
  void sampleFBODirect (FBOSet * fbos, int offset = 0, int _minOff = 0, int _maxOff = -1 /* read max */);
  void unsampleFBODirect (FBOSet * fbos, int offset = 0, int _minOff = 0, int _maxOff = -1 /* read max */);
  void bindFBODirect (FBOSet * fbos, int doClear = 1);
  FBOSet * getFBOByName (string & fboName);
  void sampleFBO (string fboName, int offset = 0, int swapFlag = -1, int minOff = 0, int maxOff = -1);
  void unsampleFBO (string fboName, int offset = 0, int swapFlag = -1, int minOff = 0, int maxOff = -1);
  FBOSet * getFBOSet (string fboName);
  FBOWrapper * getFBOWrapper (string fboName, int offset);
  void copyFBO (string src, string dest, int num = 0);
  void copyFBO2 (string src, string dest, int num1 = 0, int num2 = 1);
  void bindFBO (string fboName, int swapFlag = -1, int doClear = 1);
  void unbindFBO ();
  void bindShader (string shaderName);
  void unbindShader ();
  void setShaderArrayfVec3 (string paramName, float * x, int count);
  void setShaderArrayfVec4 (string paramName, float * x, int count);
  void setShaderMatrix4x4 (string paramName, float * x, int count);
  void setShaderMatrix3x3 (string paramName, float * x, int count);
  void setShaderArray (string paramName, float * x, int count);
  GLint getShaderLoc (string paramName);
  void setShaderFloat (string paramName, float x);
  void setShaderInt (string paramName, int x);
  void setShaderfVec2 (string paramName, FIVector4 * v);
  void setShaderVec2 (string paramName, float x, float y);
  void setShaderVec3 (string paramName, float x, float y, float z);
  void setShaderfVec3 (string paramName, FIVector4 * v);
  void setShaderbtVec3 (string paramName, btVector3 v);
  void setShaderVec4 (string paramName, float x, float y, float z, float w);
  void setShaderfVec4 (string paramName, FIVector4 * v);
  void setShaderFloatUB (string paramName, float x);
  void setShaderfVec4UB (string paramName, FIVector4 * v);
  void updateUniformBlock (int ubIndex, int ubDataSize = -1);
  void invalidateUniformBlock (int ubIndex);
  void beginUniformBlock (int ubIndex);
  bool wasUpdatedUniformBlock (int ubIndex);
  void setShaderTBO (int multitexNumber, GLuint tbo_tex, GLuint tbo_buf, bool isFloat);
  void setShaderTexture (int multitexNumber, uint texId);
  void setShaderTexture3D (int multitexNumber, uint texId);
  bool shiftDown ();
  bool ctrlDown ();
  bool altDown ();
  void drawQuadWithCoords (FIVector4 * p0, FIVector4 * p1, FIVector4 * p2, FIVector4 * p3, float tx1, float ty1, float tx2, float ty2);
  void drawQuadBounds (float fx1, float fy1, float fx2, float fy2, float fz);
  void drawFSQuad ();
  void drawFSQuadOffset (float xOff, float yOff, float zm);
  void drawFBO (string fboName, int ind, float zm, int swapFlag = -1);
  void drawFBOOffsetDirect (FBOSet * fbos, int ind, float xOff, float yOff, float zm);
  void drawFBOOffset (string fboName, int ind, float xOff, float yOff, float zm);
  float getTerHeightScaled (float val);
  float getSLNormalized ();
  float getSeaHeightScaled ();
  float getHeightAtPixelPos (float x, float y, bool dd = false);
  void angleToVec (FIVector4 * fv, float xr, float yr);
  void vecToAngle (FIVector4 * fv, FIVector4 * ta);
  void syncObjects ();
  void updateCamVals ();
  void moveCamera (FIVector4 * pModXYZ);
  GLfloat getCamRot (int ind);
  void moveObject (float dx, float dy);
  void updateMultiLights ();
  void toggleFullScreen ();
  void setCameraToElevation ();
  btVector3 screenToWorld (float mx, float my, float camAng);
  btVector3 getRayTo (float x, float y);
  void runReport ();
  void updateCS ();
  void getMarkerPos (int x, int y);
  void resetGeom ();
  void processInput (unsigned char key, bool keyDown, int x, int y);
  void getPixData (FIVector4 * toVector, int _xv, int _yv, bool forceUpdate, bool isObj);
  float getMinGeom (int baseIndex);
  void setFXYZWGeom (int baseIndex, FIVector4 * baseVec);
  void setFXYGeom (int baseIndex, float xv, float yv);
  void setFXGeom (int baseIndex, float xv);
  void setFYGeom (int baseIndex, float yv);
  void setFZGeom (int baseIndex, float zv);
  void setFWGeom (int baseIndex, float wv);
  float getFXGeom (int baseIndex);
  float getFYGeom (int baseIndex);
  float getFZGeom (int baseIndex);
  float getFWGeom (int baseIndex);
  void processSpecialKeys (int key, int _x, int _y);
  void keyboardUp (unsigned char key, int _x, int _y);
  void keyboardDown (unsigned char key, int _x, int _y);
  void updateCurGeom (int x, int y);
  void mouseMove (int _x, int _y);
  void mouseClick (int button, int state, int _x, int _y);
  bool feetContact (BaseObj * ge);
  void flushKeyStack ();
  void applyKeyAction (bool isReq, int actorId, uint keyFlags, float camRotX, float camRotY);
  void gatherKeyActions ();
  void handleMovement ();
  bool anyMenuVisible ();
  void performCamShake (BaseObj * ge, float fp);
  void explodeBullet (BaseObj * ge);
  void getJVNodeByString (JSONValue * rootNode, JSONValue * * resultNode, string stringToSplit);
  string makePretty (string sourceString, string remString);
  void cleanJVPointer (JSONValue * * jv);
  void getSpecialData (int datEnum, string datString);
  void updateStatGUI ();
  void updateStatusHUD ();
  void showHudMenu (bool visible);
  void showStatMenu (bool visible);
  void refreshContainers (bool onMousePos);
  JSONValue * fetchJSONData (string dataFile, bool doClean, JSONValue * params = NULL);
  bool processJSONFromString (string * sourceBuffer, JSONValue * * destObj);
  void specialReplace (string & allTextString, string preDelim, string pstDelim);
  void jsonPostProc ();
  bool processJSON (charArr * sourceBuffer, charArr * saveBuffer, JSONValue * * destObj);
  void doAlert ();
  bool loadJSON (string path, JSONValue * * destObj);
  void setGUIText (string key, string stringValue, float floatValue = 0.0f, bool applyVal = false, bool applyString = true);
  float getGUIValue (string key);
  UIComponent * getGUIComp (string key);
  void setGUIValue (string key, float floatValue, bool dispatchEvent = false, bool preventRefresh = false);
  void loadValuesGUI (bool applyValues = false);
  void saveExternalJSON ();
  void saveGUIValues ();
  void updateGUI ();
  void beginFieldInput (string defString, int cb);
  void processFieldInput (unsigned char key);
  void endFieldInput (bool success);
  void saveOrg ();
  void loadOrg ();
  float getConst (string conName);
  int iGetConst (int ev);
  void loadConstants ();
  void loadGUI ();
  string loadFileString (string fnString);
  std::ifstream::pos_type filesize (char const * filename);
  bool loadFile (string fnString, charArr * dest);
  bool saveFileString (string fileName, string * source);
  bool saveFile (char * fileName, charArr * source);
  float getUnderWater ();
  void updateAmbientSounds ();
  void frameUpdate ();
  FIVector4 * cameraGetPos ();
  FIVector4 * cameraGetPosNoShake ();
  float getTargetTimeOfDay ();
  void updateBullets ();
  void display (bool doFrameRender);
  bool gluInvertMatrix (double const (m) [16], float (invOut) [16]);
  int getMatrixInd (int col, int row);
  void ComputeFOVProjection (float * result, float fov, float aspect, float nearDist, float farDist, bool leftHanded);
  void setMatrices (int w, int h);
  void reshape (int w, int h);
};
#undef LZZ_INLINE
#endif
// f00305_shader.e
//

#ifndef LZZ_f00305_shader_e
#define LZZ_f00305_shader_e
#define LZZ_INLINE inline
class Shader
{
private:
  unsigned int shader_id;
  unsigned int shader_vp;
  unsigned int shader_fp;
public:
  int curUBIndex;
  map <string, float> paramMap;
  map <string, float> paramMapTemp;
  vector <string> paramVec;
  vector <UniformBuffer> uniVec;
  Singleton * singleton;
  string localString;
  Shader (Singleton * _singleton);
  static char * textFileRead (char const * fileName);
  static void validateShader (GLuint shader, char const * file = 0);
  static int validateProgram (GLuint program);
  int countOc (string * src, string testStr);
  void init (string shaderName, bool doBake, map <string, string> * includeMap);
  ~ Shader ();
  unsigned int id ();
  void bind ();
  void updateUniformBlock (int ubIndex, int ubDataSize);
  void invalidateUniformBlock (int ubIndex);
  void beginUniformBlock (int ubIndex);
  bool wasUpdatedUniformBlock (int ubIndex);
  void unbind ();
  void setTexture (GLchar const * name, int texUnit, int texId);
  void setVec (GLchar const * name, GLfloat const * vecData, int vecSize);
  void setVecString (string name, GLfloat const * vecData, int vecSize);
  void setShaderMatrix4x4 (string paramName, float * x, int count);
  void setShaderMatrix3x3 (string paramName, float * x, int count);
  void setShaderArrayfVec4 (string paramName, float * x, int count);
  void setShaderArrayfVec3 (string paramName, float * x, int count);
  void setShaderArray (string paramName, float * x, int count);
  GLint getShaderLoc (string paramName);
  void setShaderFloat (string paramName, float x);
  void setShaderVec2 (string paramName, float x, float y);
  void setShaderVec3 (string paramName, float x, float y, float z);
  void setShaderVec4 (string paramName, float x, float y, float z, float w);
  void setShaderInt (string paramName, int x);
  void setShaderfVec2 (string paramName, FIVector4 * f);
  void setShaderfVec3 (string paramName, FIVector4 * f);
  void setShaderfVec4 (string paramName, FIVector4 * f);
  void setShaderbtVec3 (string paramName, btVector3 f);
  void setShaderFloatUB (string paramName, float x);
  void setShaderfVec4UB (string paramName, FIVector4 * f);
};
#undef LZZ_INLINE
#endif
// f00307_dynbuffer.e
//

#ifndef LZZ_f00307_dynbuffer_e
#define LZZ_f00307_dynbuffer_e
#define LZZ_INLINE inline
class DynBuffer
{
public:
  int SCREEN_WIDTH;
  int SCREEN_HEIGHT;
  float CAMERA_DISTANCE;
  int TEXT_WIDTH;
  int TEXT_HEIGHT;
  int IMAGE_WIDTH;
  int IMAGE_HEIGHT;
  int CHANNEL_COUNT;
  int DATA_SIZE;
  void * font;
  GLuint (pboIds) [2];
  GLuint textureId;
  GLubyte * imageData;
  int screenWidth;
  int screenHeight;
  bool mouseLeftDown;
  bool mouseRightDown;
  float mouseX;
  float mouseY;
  float cameraAngleX;
  float cameraAngleY;
  float cameraDistance;
  bool pboSupported;
  int pboMode;
  int drawMode;
  DynBuffer ();
  ~ DynBuffer ();
  bool initSharedMem ();
  void clearSharedMem ();
  void initLights ();
  void setCamera (float posX, float posY, float posZ, float targetX, float targetY, float targetZ);
  void updatePixels (GLubyte * dst, int size);
  void showTransferRate ();
  void toOrtho ();
  void toPerspective ();
  void displayCB ();
  void reshapeCB (int width, int height);
  void idleCB ();
  void keyboardCB (unsigned char key, int x, int y);
  void mouseCB (int button, int state, int x, int y);
  void mouseMotionCB (int x, int y);
};
#undef LZZ_INLINE
#endif
// f00320_fontwrapper.e
//

#ifndef LZZ_f00320_fontwrapper_e
#define LZZ_f00320_fontwrapper_e
#define LZZ_INLINE inline
class FontWrapper
{
public:
  Singleton * singleton;
  charArr lastJSONBuffer;
  JSONValue * jsRoot;
  Image * fontImage;
  float ascender;
  float descender;
  float fontHeight;
  float maxWidth;
  float fontScale;
  float additionalOffset;
  bool isIcons;
  CharStruct (charVals) [4096];
  FontWrapper ();
  void init (Singleton * _singleton, string fontName, bool _isIcons, float _fontScale, float _additionalOffset = 0.0f);
};
#undef LZZ_INLINE
#endif
// f00323_gameoctree.e
//

#ifndef LZZ_f00323_gameoctree_e
#define LZZ_f00323_gameoctree_e
#define LZZ_INLINE inline
class GameOctree
{
public:
  Singleton * singleton;
  uint * data;
  int dimInVoxels;
  int maxDepth;
  int maxSize;
  int nullPtr;
  int rootPtr;
  int nodeSize;
  int nextOpen;
  int renderLevel;
  bool hasTBO;
  TBOWrapper octTBO;
  GameOctree ();
  void init (Singleton * _singleton, int _dimInVoxels, bool _hasTBO, int _maxSize = -1, int _nodeSize = -1);
  void updateTBO ();
  void captureBuffer ();
  void modRenderLevel (int modVal);
  void addNode (int x, int y, int z, uint col);
  void remNode (uint index);
  void startRender ();
  void renderBB (int baseX, int baseY, int baseZ, int startIndex, int curLevel, int curDiv);
};
#undef LZZ_INLINE
#endif
// f00325_uicomponent.e
//

#ifndef LZZ_f00325_uicomponent_e
#define LZZ_f00325_uicomponent_e
#define LZZ_INLINE inline
class UIComponent
{
private:
  UIComponent * valuePtr;
  float privValueX;
  float privValueY;
  std::vector <int> _children;
  std::vector <int> _floatingChildren;
public:
  Singleton * singleton;
  Singleton::UICont uiCont;
  string uid;
  string ss;
  string text;
  string label;
  string dataFile;
  string dataRef;
  string dataKey;
  string valRef;
  int matCode;
  int parentId;
  int nodeId;
  int index;
  int fillDir;
  int layer;
  int layerId;
  int hoverType;
  int guiClass;
  bool forceDragUpdate;
  bool selected;
  bool foundParent;
  bool foundValuePtr;
  bool visible;
  bool enabled;
  iVector2 align;
  FIVector4 valVec;
  FIVector4 valVecMask;
  JSONValue * jvNodeNoTemplate;
  fVector2 scrollMaskY;
  fVector2 dragStart;
  fVector2 lastDrag;
  fVector2 dragOffset;
  fVector2 totOffset;
  fVector2 targScrollOffset;
  fVector2 scrollOffset;
  fVector2 floatOffset;
  fVector2 originPos;
  fVector2 resultDimInPixels;
  fVector2 textDimInPixels;
  fVector2 rmDimInPixels;
  fVector2 minDimInPixels;
  fVector2 maxDimInPixels;
  fVector2 fillRatioDim;
  FontWrapper * curFont;
  FontWrapper * curFontIcons;
  bool dragging;
  bool overChild;
  bool overSelf;
  bool singleLine;
  bool hasBackground;
  bool mouseOver;
  bool mouseDown;
  bool wasHit;
  bool isDirty;
  bool isFloating;
  bool dataLoaded;
  uint flags;
  float divisions;
  float paddingInPixels;
  float borderInPixels;
  float marginInPixels;
  float spaceForCharsInPixels;
  iVector2 spacing;
  std::vector <string> lineVec;
  std::vector < std::vector<string> > wordVec;
  std::vector <float> linePitchVec;
  fBoundingBox hitBounds;
  StyleSheetResult resSS;
  UIComponent ();
  void init (Singleton * _singleton, int _parentId, int _nodeId, int _index, JSONValue * _jvNodeNoTemplate, bool _isFloating, string * stringVals, double * floatVals);
  void clearChildren ();
  UIComponent * getChild (int ind);
  UIComponent * getFloatingChild (int ind);
  int getChildCount ();
  int getFloatingChildCount ();
  float getDimYClamped (float val);
  float getResultDimYClamped ();
  string findKeyString (int valEnum);
  void updateLinkedValues (bool isRead = false);
  void setValueIndex (int ind, float val);
  float getValueIndex (int ind);
  float getValueIndexPtr (int ind);
  void updateTextNumber ();
  void setValue (float _value, bool doEventDispatch = false, bool preventRefresh = false);
  float getValue ();
  void setValueY (float _value, bool doEventDispatch = false, bool preventRefresh = false);
  float getValueY ();
  UIComponent * getParent ();
  UIComponent * findParentByUID (string parUID);
  UIComponent * getValuePtr ();
  UIComponent * findNodeByString (string _uid);
  float getMinWidth ();
  float getMinHeight ();
  int addChild (int _lastIndex, int _parentId, string * stringVals, double * floatVals, bool _isFloating, JSONValue * _jvNodeNoTemplate);
  void setOrigPos ();
  void applyHeight ();
  void applyWidth ();
  void gatherDirty (vector <UIComponent*> * dirtyVec);
  void clearDirty ();
  void alignToComp (UIComponent * myComp);
  void layout ();
  void updateOffset ();
  void updateValue (float x, float y);
  void runReport ();
  void clearOver ();
  bool findMaxLayer (float x, float y, float xTransformed, float yTransformed);
  void testOver (float x, float y);
  bool testHit (int button, int state, float x, float y);
  UIComponent * getHighestCont (UIComponent * curNode, int genCount);
  void setText (string _text);
  void updateVecs ();
  void renderAll ();
  void updateSS ();
  float getLineOffset (int lineCount);
  float lengthOfWord (int i, int j, bool isIcon);
  int maxCharsForWord (int i, int j);
  void renderText (bool getDimensions);
};
#undef LZZ_INLINE
#endif
// f00330_gamegui.e
//

#ifndef LZZ_f00330_gamegui_e
#define LZZ_f00330_gamegui_e
#define LZZ_INLINE inline
class GameGUI
{
private:
public:
  Singleton * singleton;
  JSONValue * jvRoot;
  JSONValue * jvTemplates;
  JSONValue * jvSounds;
  bool isReady;
  bool isLoaded;
  fVector2 mouseTrans;
  int guiRenderCount;
  vector <UIComponent*> dirtyVec;
  string (tempStrings) [10];
  string (stringVals) [E_GST_LENGTH];
  double (floatVals) [E_GFT_LENGTH];
  GameGUI ();
  void init (Singleton * _singleton);
  JSONValue * findNearestKey (JSONValue * jv, string key);
  void addChildFromJSON (int lastIndex, JSONValue * jv, int curParentId, bool isFloating = false);
  void deleteJSONNodes (JSONValue * jv);
  void clearRenderOrder ();
  void deleteNodes (UIComponent * curNode);
  void refreshNode (UIComponent * oldNode);
  void guiFromJSON (JSONValue * jv);
  void doRefresh ();
  void testOver (int x, int y);
  bool testHit (int button, int state, int x, int y);
  UIComponent * findNodeByString (string _uid);
  void renderCharAt (UIComponent * uiComp, CharStruct * cs, FontWrapper * activeFont, float px, float py, float shadowOffset);
  void renderQuad (UIComponent * uiComp, fBoundingBox fbb, float shadowOffset);
  void renderQuadDirect (UIComponent * uiComp);
  void runReport ();
  void renderGUI ();
};
#undef LZZ_INLINE
#endif
// f00332_gamenetwork.e
//

#ifndef LZZ_f00332_gamenetwork_e
#define LZZ_f00332_gamenetwork_e
#define LZZ_INLINE inline
class GameNetwork
{
public:
  Singleton * singleton;
  static int const FRAME_SIZE_IN_BYTES = 256;
  static int const TOT_BUFFER_SIZE = FRAME_SIZE_IN_BYTES*256;
  FIVector4 (tempVecs) [8];
  WSADATA wsaData;
  SOCKET ConnectSocket;
  int recvPosInBytes;
  int sendPosInBytes;
  int recvConsumedInBytes;
  int sendConsumedInBytes;
  uint * (uintPtr) [8];
  int * (intPtr) [8];
  float * (floatPtr) [8];
  char (recvbuf) [TOT_BUFFER_SIZE];
  char (sendbuf) [TOT_BUFFER_SIZE];
  bool isConnected;
  std::vector <NetworkAction> netSendStack;
  GameNetwork ();
  void init (Singleton * _singleton);
  void getIntFloatLen (int opCode, int * uintLen, int * intLen, int * floatLen);
  void addNetworkAction (int opCode, uint * naUintData, int * naIntData, float * naFloatData);
  void addNetworkActionForSend (NetworkAction * na);
  void applyNetworkActions ();
  int socketConnect (bool doConnect);
  void socketRecv ();
  void socketSend ();
  void checkBufferLengthSend ();
  void checkBufferLengthRecv ();
  void flushNetworkActions ();
  void updateSend ();
  void updateRecv ();
};
#undef LZZ_INLINE
#endif
// f00335_gameai.e
//

#ifndef LZZ_f00335_gameai_e
#define LZZ_f00335_gameai_e
#define LZZ_INLINE inline
class GameAI
{
public:
  Singleton * singleton;
  std::vector <intVec> tokenToRules;
  std::vector <VToken> intToVToken;
  std::vector <VNode*> tokenIndexToVar;
  std::vector <AssignStruct> assignStack;
  map <string,int> stringToVTokenIndex;
  string tempVarStr;
  VNode * kbCompiled;
  VNode * qbCompiled;
  JSONValue * jvKB;
  GameAI ();
  void init (Singleton * _singleton);
  string getResolvedString (VNode * tempNode);
  bool setEqualTo (VNode * destNodeFinal, VNode * srceNodeFinal, int curGen);
  void rollBack (int curGen);
  bool attemptUnify (VNode * nodeToUnify, VNode * testNode, int curGen);
  VNode * drillDown (VNode * curVar);
  bool testEqual (VNode * testNode);
  bool isBetween (VNode * testNode);
  bool searchToUnify (VNode * nodeToUnifyBase, int curGen, int curOffset = 0);
  void printChain (VNode * curVar);
  void runQueries ();
  bool compileVocab (JSONValue * uncompiledNode, VNode * curVNode);
  bool checkVocab (JSONValue * jv);
  void buildRule (VNode * curNode, int ruleNumber, bool isIfThen);
  void buildRuleSet (VNode * curNode);
  void numberRule (VNode * curNode, int ruleNumber);
  int numberRuleSet (VNode * curNode, int offset);
  void printRule (VNode * curNode, int offset);
  void printRuleSet (VNode * curNode);
  bool parseKB ();
  void traceRules ();
  void getKB ();
};
#undef LZZ_INLINE
#endif
// f00337_gamefluid.e
//

#ifndef LZZ_f00337_gamefluid_e
#define LZZ_f00337_gamefluid_e
#define LZZ_INLINE inline
class GameFluid
{
public:
  Singleton * singleton;
  uint * (volDataPrim) [E_PL_LENGTH];
  int forceFullRefresh;
  int volSizePrim;
  int volSizePrimBuf;
  int bufAmount;
  int vspMin;
  int vspMax;
  int * fluidData;
  int * extraData;
  int shrinkCount;
  int immobileHeight;
  int immobileInd;
  int maxWaterHeight;
  int maxWaterInd;
  std::vector <int> indexStack;
  int curGeomCount;
  int UNIT_MIN;
  int UNIT_MAX;
  int UNIT_INSIDE;
  int watchMinX;
  int watchMaxX;
  int watchMinY;
  int watchMaxY;
  int watchMinZ;
  int watchMaxZ;
  int totSize;
  FIVector4 readMIP;
  FIVector4 writeMIP;
  FIVector4 dirtyMin;
  FIVector4 dirtyMax;
  FIVector4 tempMin;
  FIVector4 tempMax;
  FIVector4 tempMin2;
  FIVector4 tempMax2;
  FIVector4 minV;
  FIVector4 maxV;
  bool fluidChanged;
  bool posShifted;
  bool hasRead;
  bool invalidated;
  float F_UNIT_MAX;
  float F_UNIT_MIN;
  std::vector <FluidStruct> fsVec;
  std::vector <ModUnitStruct> modStack;
  int * fluidIds;
  int * idealCellIds;
  FluidPlane fluidPlane;
  bool waterTickReady;
  bool cycleTerminated;
  bool readyForTermination;
  bool fluidReading;
  bool proceedingToRead;
  bool modifiedUnit;
  bool modifiedGeom;
  bool readyForTBOUpdate;
  bool firstVPUpdate;
  int volSizePrimMacro;
  int floatsInPrimMacro;
  int floatsPerPrimEntry;
  int primsPerMacro;
  int primDiv;
  int waterTick;
  int waterTickMax;
  int waterTickMaxDiv;
  int cellsPerHolder;
  int cellsPerBlock;
  int internalPrimFormat;
  int precPrimFormat;
  int mainId;
  int (volSizes) [E_FID_LENGTH];
  int (mipSizes) [E_FID_LENGTH];
  float waterLerp;
  float * tboData;
  GLuint (volIdPrim) [E_PL_LENGTH];
  TBOWrapper tboWrapper;
  std::vector <PushModStruct> pmStack;
  FIVector4 volMinInPixels;
  FIVector4 volMaxInPixels;
  FIVector4 volMinReadyInPixels;
  FIVector4 volMaxReadyInPixels;
  FIVector4 camPosVP;
  FIVector4 campPosVPDump;
  FIVector4 newCamPos;
  FIVector4 lastCamPos;
  FIVector4 camPosVPInPixels;
  FIVector4 lastCamPosVP;
  FIVector4 curDirtyMax;
  FIVector4 curDirtyMin;
  FIVector4 curWaterMax;
  FIVector4 curWaterMin;
  FIVector4 tempBoundsMin;
  FIVector4 tempBoundsMax;
  ThreadWrapper threadLoader;
  ThreadWrapper threadTex;
  ThreadWrapper threadFluid;
  int getFluidId (int groupNum, int ind);
  int getFIDSize (int groupNum);
  void fidPushBack (int groupNum, int val);
  int * fidGetBeg (int groupNum);
  int * fidGetEnd (int groupNum);
  int getIdealCellId (int groupNum, int ind);
  int getICISize (int groupNum);
  void iciPushBack (int groupNum, int val);
  GameFluid ();
  void init (Singleton * _singleton, int _mainId);
  void flushActionStack ();
  void pushExplodeBullet (bool isReq, FIVector4 * newPos, int waterBulletOn, float newRad);
  void pushModifyUnit (bool isReq, FIVector4 * mp, int buttonNum, int earthMod, int curBrushRad);
  void pushPlaceTemplate (bool isReq, FIVector4 * newPos, int pt);
  bool addPrimObj (FIVector4 * pos, int tempId, int uid);
  void addGeom (FIVector4 * newPos, int templateId);
  void fetchGeom ();
  void setupPrimTexture ();
  bool tryToEndRead ();
  bool anyThreadsRunning ();
  bool updateAll ();
  void copyPrimTexture (int ox, int oy, int oz, int dim, uint * * myData);
  void fillAllGeom ();
  void updateTBOData (bool firstTime, bool reloadTemplates);
  void terminateCycle ();
  void beginFluidRead (FIVector4 * _campPosVPDump);
  void proceedWithRead ();
  void endFluidRead ();
  void shiftRegion ();
  void funcFT ();
  void startFT ();
  bool stopFT ();
  void funcTL ();
  void startTL ();
  bool stopTL ();
  void funcTT ();
  void startTT ();
  bool stopTT ();
  void getPrimData (int n);
  void writeFluidData ();
  void prereadFluidData ();
  void readFluidData ();
  void applyMods ();
  bool passesCheck (int n);
  bool updateFluidData ();
  bool findStableRegions (int startInd, int newId);
  bool floodFillId (int startInd, int newId);
  bool inBounds (int i, int j, int k);
  void modifyUnit (FIVector4 * fPixelWorldCoordsBase, int brushAction, int modType, int radius);
  void roundBox (FIVector4 * absVecFromCenter, FIVector4 * innerBoxRad, FIVector4 * cornerDisThicknessPower, bool & isInObj, bool & isInside);
  void clearAllGeom ();
  void clearInsideValues ();
  void fillCurrentGeom (int templateId, FIVector4 * templatePos);
  void resetDirtyRegion ();
  void shrinkDirtyRegion ();
  void maxDirtyRegion ();
  void applyUnitModification (FIVector4 * fPixelWorldCoordsBase, int brushAction, int modType, int radius);
};
#undef LZZ_INLINE
#endif
// f00338_gameorgnode.e
//

#ifndef LZZ_f00338_gameorgnode_e
#define LZZ_f00338_gameorgnode_e
#define LZZ_INLINE inline
class GameOrgNode
{
private:
public:
  int nodeName;
  GameOrgNode * parent;
  std::vector <GameOrgNode*> children;
  FIVector4 (orgVecs) [E_OV_LENGTH];
  FIVector4 tempFI;
  btVector3 tbnOffset;
  btVector3 tempOffset;
  FIVector4 * readTBN;
  FIVector4 * writeTBN;
  FIVector4 (tbnBaseTrans) [3];
  FIVector4 (tbnRotA) [3];
  FIVector4 (tbnRotB) [3];
  FIVector4 (tbnRotC) [3];
  FIVector4 (tbnTrans) [3];
  FIVector4 (orgTrans) [3];
  GameOrgNode (GameOrgNode * _parent, int _nodeName, float _material, float _rotThe, float _rotPhi, float _rotRho, float _tanLengthInCells0, float _bitLengthInCells0, float _norLengthInCells0, float _tanLengthInCells1, float _bitLengthInCells1, float _norLengthInCells1, float _tanX, float _tanY, float _tanZ, float _bitX, float _bitY, float _bitZ, float _norX, float _norY, float _norZ);
  GameOrgNode * addChild (int _nodeName, float _material, float _rotThe, float _rotPhi, float _rotRho, float _tanLengthInCells0, float _bitLengthInCells0, float _norLengthInCells0, float _tanLengthInCells1, float _bitLengthInCells1, float _norLengthInCells1, float _tanX, float _tanY, float _tanZ, float _bitX, float _bitY, float _bitZ, float _norX, float _norY, float _norZ);
  GameOrgNode * getNode (int _nodeName);
  void flipOrient (float newVal);
  void doTransform (Singleton * singleton, GameOrgNode * tempParent);
};
#undef LZZ_INLINE
#endif
// f00339_gameorg.e
//

#ifndef LZZ_f00339_gameorg_e
#define LZZ_f00339_gameorg_e
#define LZZ_INLINE inline
class GameOrg
{
public:
  Singleton * singleton;
  GameOrgNode * baseNode;
  GameOrgNode * (allNodes) [E_BONE_C_END];
  float (wepLengths) [E_BONE_C_END];
  FIVector4 basePosition;
  JSONValue * rootObj;
  PoseKey basePose;
  PoseKey targetPose;
  int ownerUID;
  int entType;
  int subType;
  int stepCount;
  double totTime;
  float defVecLength;
  float gv (float * vals);
  static float const baseMat;
  GameOrg ();
  void init (Singleton * _singleton, int _ownerUID, int _entType, int _subType);
  void jsonToNode (JSONValue * * parentObj, GameOrgNode * curNode, bool notThePose);
  void setBinding (int actorId, bool val);
  int getPoseUID ();
  void loadOrgFromFile (string fileName, bool notThePose);
  void saveOrgToFile (string fileName);
  BaseObj * getOwner ();
  void setTPG (int _targetPoseGroup, int _targetPoseRLBN);
  void setToPose (GameOrg * otherOrg, float lerpAmount, int boneId = -1);
  void updatePose (double curTimeStep);
  void nodeToJSON (JSONValue * * parentObj, GameOrgNode * curNode);
  void updateHandleOffset ();
  void initWeapon ();
  void initHuman ();
};
#undef LZZ_INLINE
#endif
// f00340_gameplantnode.e
//

#ifndef LZZ_f00340_gameplantnode_e
#define LZZ_f00340_gameplantnode_e
#define LZZ_INLINE inline
class GamePlantNode
{
public:
  FIVector4 begPoint;
  FIVector4 endPoint;
  FIVector4 tangent;
  FIVector4 baseShoot;
  float shootLength;
  float begThickness;
  float endThickness;
  float midThickness;
  float sphereRad;
  FIVector4 startEndWidth;
  FIVector4 upVec;
  GamePlantNode * parent;
  GamePlantNode * children;
  int maxChildren;
  int numChildren;
  GamePlantNode ();
  void updateTangent (float angleInRadians);
  void init (GamePlantNode * _parent, int _maxChildren, int _numChildren);
};
#undef LZZ_INLINE
#endif
// f00341_gameplant.e
//

#ifndef LZZ_f00341_gameplant_e
#define LZZ_f00341_gameplant_e
#define LZZ_INLINE inline
class GamePlant
{
public:
  Singleton * singleton;
  FIVector4 origin;
  FIVector4 tempv0;
  FIVector4 tempv1;
  FIVector4 tempv2;
  FIVector4 tempv3;
  FIVector4 rootVec;
  FIVector4 trunkVec;
  GamePlantNode * trunkNode;
  GamePlantNode * rootsNode;
  PlantRules * rootRules;
  PlantRules * trunkRules;
  static PlantRules (allPlantRules) [E_PT_LENGTH];
  static void initAllPlants (Singleton * _singleton);
  float gv (float * vals);
  GamePlant ();
  void init (Singleton * _singleton, PlantRules * _rootRules, PlantRules * _trunkRules, FIVector4 * _origin);
  void initBase (PlantRules * rules, GamePlantNode * curNode, FIVector4 * baseVec);
  void applyRules (PlantRules * rules, GamePlantNode * curParent, int curGen, int maxGen, float totLength, float maxLength);
};
#undef LZZ_INLINE
#endif
// f00347_gamephysrig.e
//

#ifndef LZZ_f00347_gamephysrig_e
#define LZZ_f00347_gamephysrig_e
#define LZZ_INLINE inline
class GamePhysRig
{
public:
  Singleton * singleton;
  btDynamicsWorld * m_ownerWorld;
  std::vector <RigJointStruct> rigJoints;
  int geId;
  btVector3 origOffset;
  GameOrg * baseOrg;
  BaseObj * baseEnt;
  void updatePivot (int jointId);
  int addJoint (int nodeName, int parentId, int jointType, float mass, GameOrgNode * curNode);
  void initFromOrg (GameOrgNode * curNode, int curParent);
  void reinit ();
  GamePhysRig (Singleton * _singleton, int _geId, btDynamicsWorld * ownerWorld, btVector3 const & positionOffset);
  void removeAllBodies ();
  virtual ~ GamePhysRig ();
};
#undef LZZ_INLINE
#endif
// f00349_gameentmanager.e
//

#ifndef LZZ_f00349_gameentmanager_e
#define LZZ_f00349_gameentmanager_e
#define LZZ_INLINE inline
class GameEntManager
{
public:
  Singleton * singleton;
  bool curActorNeedsRefresh;
  bool destroyTerrain;
  bool mirrorOn;
  bool combatOn;
  bool turnBased;
  bool editPose;
  bool orgOn;
  bool isDraggingObject;
  bool firstPerson;
  bool showHealth;
  bool takingTurn;
  int weaponToPlace;
  int activeActorUID;
  int curActorUID;
  int curPoseType;
  int highlightedLimb;
  int highlightedLimb2;
  int gameObjCounter;
  int lastObjInd;
  int selObjInd;
  int actObjInd;
  int draggingFromInd;
  int draggingToInd;
  int draggingFromType;
  int draggingToType;
  int turnListInd;
  float subjectDistance;
  float lastSubjectDistance;
  FIVector4 tempVec1;
  FIVector4 tempVec2;
  FIVector4 tempVec3;
  map <BaseObjType, BaseObj> gameObjects;
  vector <BaseObjType> visObjects;
  vector <int> turnList;
  GameOrgNode * bestNode;
  GameOrgNode * selectedNode;
  GameOrgNode * lastSelNode;
  GameOrgNode * activeNode;
  std::vector <GamePhysRig*> gamePhysRigs;
  std::vector <GameOrg*> gameOrgs;
  std::vector <GameOrg*> gamePoses;
  PoseInfo (gamePoseInfo) [E_PG_LENGTH];
  PoseKey (curPose) [E_ENTTYPE_LENGTH];
  EntPool (entPoolStack) [E_ENTTYPE_LENGTH];
  JSONValue * poseRootJS;
  int (entIdToIcon) [MAX_OBJ_TYPES];
  int (iconToEntId) [MAX_ICON_ID];
  bool (isContainer) [MAX_OBJ_TYPES];
  string (objStrings) [MAX_OBJ_TYPES];
  GameEntManager ();
  void init (Singleton * _singleton);
  BaseObj * getCurActor ();
  BaseObj * getActiveActor ();
  void refreshActiveId ();
  void endHumanTurn ();
  void cycleTurn ();
  void nextTurn ();
  void refreshTurnList ();
  void setTurnBased (bool newVal);
  void checkActorRefresh ();
  void closeAllContainers ();
  bool anyContainerOpen ();
  void togglePoseEdit ();
  void loadDefaultPose (int actorId);
  void applyNonPoseData ();
  void setFirstPerson (bool _newVal);
  int getCurActorUID ();
  void updateOrgMat (UIComponent * comp);
  void doDrag ();
  void endDrag (int upInd);
  bool handleGUI (UIComponent * comp, bool mouseUpEvent, bool mouseDownEvent, bool noTravel, bool wasDoubleClick);
  BaseObj * getEquipped (BaseObj * parentObj);
  void updateDragInfo (int bestInd, bool lbDown, bool wasDoubleClick);
  int getRandomContId ();
  int getRandomNPCId ();
  int getRandomMonsterId ();
  int getRandomObjId ();
  void fillWithRandomObjects (int parentUID, int gen);
  void removeEntity (bool isReq, int ind);
  bool isRecycledFunc (int poolId);
  BaseObjType placeNewEnt (bool isReq, int et, FIVector4 * cellPos, bool isHidden = false);
  void performDrag (bool isReq, int _draggingFromInd, int _draggingFromType, int _draggingToInd, int _draggingToType, FIVector4 * _worldMarker);
  void setCurActor (int newUID);
  void toggleFirstPerson ();
  void toggleActorSel ();
  void setSelInd (int ind);
  void closeContainer (int i);
  void toggleCont (int contIndex, bool onMousePos);
  void addVisObject (BaseObjType _uid, bool isRecycled);
  bool removeVisObject (BaseObjType _uid, bool isRecycled);
  bool areEnemies (int actorUID1, int actorUID2);
  bool areFriends (int actorUID1, int actorUID2);
  int getUnitDisXY (btVector3 p1, btVector3 p2);
  btVector3 getUnitDistance (int actorUID1, int actorUID2);
  int getClosestActor (int actorId, int objType, float maxDis, uint flags);
  GameOrg * getCurOrg ();
  BaseObj * getActorRef (int uid);
  bool combatMode ();
  bool isSwingingWeapon (int actorId, int handNum);
  bool isPunching (int actorId, int handNum);
  bool isKicking (int actorId, int handNum);
  void setSwing (float _mx, float _my, int actorId, int handNum, bool isKick);
  void nextSwing (int actorId, int handNum);
  void makeShoot (int actorId, int bulletType);
  void bindPose (int actorId, int handNum, bool bindOn);
  void makeGrab (int actorId, int _handNum);
  void makeDropAll (int actorId);
  void makeThrow (int actorId, int _handNum);
  void changeStatus (int actorId, int status, int modVal);
  void makeSwing (int actorId, int handNum);
  void makeTurnTowardsTB (int actorId, btVector3 actorTargVec);
  BaseObj * getEntAtUnitPos (btVector3 pos);
  void makeTurnTB (int actorId, int modVal);
  btVector3 getOffsetTB (btVector3 orig, int dir, float amount);
  bool makeMoveTB (int actorId, int modVal);
  void makeTurn (int actorId, float dirFactor);
  void makeMoveVec (int actorId, btVector3 moveVec);
  void makeMove (int actorId, btVector3 moveDir, bool relative, bool delayed);
  void makeJump (int actorId, int isUp, float jumpFactor);
  void makeHit (bool tb, int attackerId, int victimId, int weaponId);
  GameOrgNode * getMirroredNode (GameOrgNode * curNode);
  void refreshActor (int actorId);
  void applyNodeChanges (GameOrgNode * _curNode, float dx, float dy);
  void transformOrg (GameOrg * curOrg, GameOrgNode * tempParent);
  void resetActiveNode ();
  bool updateNearestOrgNode (bool setActive, FIVector4 * mousePosWS);
  void saveOrgFromMenu (string currentFieldString);
  void loadOrgFromMenu (string currentFieldString);
  void makeDirty ();
  void setSelNode (GameOrgNode * newNode);
  bool hasRLBN (int rlbnRes, int k);
  void loadPoseInfo (bool justRefresh);
  GameOrg * getPose (int targPoseGroup, int targRLBN, int targStep);
  string getPoseString (int targPoseGroup, int targRLBN, int targStep);
  GameOrg * getCurrentPose ();
  string getCurrentPoseString ();
  int getActionStateFromPose (int poseNum);
  void changePose (int amount);
  void saveCurrentPose ();
  void getIndexForPose (PoseKey * tempPose);
  void setPoseFromIndex (int i);
  int getPoseType (int poseIndex);
  void saveEveryPose ();
  void loadNonPoseData (int npdPose, int npdSide, int npdStep);
  void loadCurrentPose ();
  int numberIcons (int pCurCount, int x1, int y1, int x2, int y2);
  string getStringForObjectId (int objectId);
  void initAllObjects ();
};
#undef LZZ_INLINE
#endif
// f00351_gamepageholder.e
//

#ifndef LZZ_f00351_gamepageholder_e
#define LZZ_f00351_gamepageholder_e
#define LZZ_INLINE inline
class GamePageHolder
{
private:
  int * pathData;
  int * cellData;
  int * extrData;
public:
  bool preGenList;
  bool listGenerated;
  bool listEmpty;
  bool hasData;
  bool hasPath;
  bool lockWrite;
  bool lockRead;
  VBOWrapper vboWrapper;
  VolumeWrapper * terVW;
  int blockId;
  int holderId;
  bool isBlockHolder;
  int pathSize;
  int totIdealNodes;
  int totGroupIds;
  int cellDataSize;
  int cellsPerHolder;
  int visitId;
  bool pathsInvalid;
  bool idealPathsInvalid;
  bool pathsReady;
  bool idealPathsReady;
  uint holderFlags;
  std::vector <int> indexStack;
  std::vector <GroupIdStruct> groupIdStack;
  std::vector <GroupInfoStruct> groupInfoStack;
  std::vector <ConnectingNodeStruct> bestConnectingNodes;
  std::vector <btScalar> vertexVec;
  std::vector <unsigned short> indexVec;
  std::vector <int> collideIndices;
  std::vector <GameEnt *> entityGeom;
  int entityGeomCounter;
  FIVector4 offsetInHolders;
  FIVector4 gphMinInPixels;
  FIVector4 gphMaxInPixels;
  FIVector4 gphCenInPixels;
  FIVector4 origOffset;
  Singleton * singleton;
  intPairVec (containsEntIds) [E_ET_LENGTH];
  bool wasGenerated;
  btTriangleIndexVertexArray * meshInterface;
  btIndexedMesh part;
  btRigidBody * body;
  btBvhTriangleMeshShape * trimeshShape;
  btBoxShape * boxShape;
  GamePageHolder ();
  void init (Singleton * _singleton, int _blockId, int _holderId, int trueX, int trueY, int trueZ, bool _isBlockHolder = false);
  int getCellAtCoordsLocal (int xx, int yy, int zz);
  int getCellAtInd (int ind);
  void getArrAtInd (int ind, int * tempCellData, int * tempCellData2);
  void setArrAtInd (int ind, int * tempCellData = NULL, int * tempCellData2 = NULL);
  void clearPathPreserve ();
  void clearPathSizes ();
  void checkData (bool checkPath);
  void clearGroupFlags (int targId);
  int floodFillAtInd (int firstInd, int newId, bool findCenter, GroupInfoStruct * curGI);
  void findIdealNodes ();
  int getGroupId (int pathDataIndex);
  int getInfoPD (int pathDataIndex);
  GroupIdStruct * getInfo (int pathDataIndex);
  void getInfoReport (int pathDataIndex);
  btVector3 holderIndToBTV (GamePageHolder * curPointHolder, int curPointIndex);
  void sortConNodes (GamePageHolder * endHolder, int endInd);
  void linkRegions ();
  bool prepPathRefresh (int rad);
  void refreshPaths ();
  void genCellData ();
  void getIndVal (int procCount);
  void getIndVal2 (int procCount);
  void getPixVal (float xb, float yb, float zb, int xm, int ym, int zm, int * mv);
  void createMesh ();
  void fillVBO ();
  void generateList ();
};
LZZ_INLINE void GamePageHolder::getIndVal (int procCount)
                                             {
		indexVec.push_back(0+procCount*4);
		indexVec.push_back(1+procCount*4);
		indexVec.push_back(2+procCount*4);
		indexVec.push_back(2+procCount*4);
		indexVec.push_back(1+procCount*4);
		indexVec.push_back(3+procCount*4);
	}
LZZ_INLINE void GamePageHolder::getIndVal2 (int procCount)
                                              {
		indexVec.push_back(2+procCount*4);
		indexVec.push_back(1+procCount*4);
		indexVec.push_back(0+procCount*4);
		indexVec.push_back(3+procCount*4);
		indexVec.push_back(1+procCount*4);
		indexVec.push_back(2+procCount*4);
	}
LZZ_INLINE void GamePageHolder::getPixVal (float xb, float yb, float zb, int xm, int ym, int zm, int * mv)
          {
		int maskInd = xm + ym*2 + zm*4;
		
		vertexVec.push_back(xb+xm+NET_MASKS[mv[maskInd]].getX());
		vertexVec.push_back(yb+ym+NET_MASKS[mv[maskInd]].getY());
		vertexVec.push_back(zb+zm+NET_MASKS[mv[maskInd]].getZ());
		//vertexVec.push_back(1.0f);
		
		// vertexVec.push_back(xb+xm);
		// vertexVec.push_back(yb+ym);
		// vertexVec.push_back(zb+zm);
		//vertexVec.push_back(1.0f);
		
		
		
		
		// glMultiTexCoord3f(
		// 	GL_TEXTURE0,
		// 	xb+xm,
		// 	yb+ym,
		// 	zb+zm
		// );
		// glMultiTexCoord4f(
		// 	GL_TEXTURE1,
		// 	fbow1->getPixelAtIndex(ind,R_CHANNEL)/255.0f,
		// 	fbow1->getPixelAtIndex(ind,G_CHANNEL)/255.0f,
		// 	fbow1->getPixelAtIndex(ind,B_CHANNEL)/255.0f,
			
		// 	fbow0->getPixelAtIndex(ind,B_CHANNEL) +
		// 	fbow0->getPixelAtIndex(ind,A_CHANNEL)*256
			
		// );
		
		//glVertex3f(xb+xm,yb+ym,zb+zm);
	}
#undef LZZ_INLINE
#endif
// f00352_gameblock.e
//

#ifndef LZZ_f00352_gameblock_e
#define LZZ_f00352_gameblock_e
#define LZZ_INLINE inline
class GameBlock
{
public:
  Singleton * singleton;
  int blockId;
  int holdersPerBlock;
  int terDataBufAmount;
  bool forceUpdate;
  float (trilin) [8];
  int terDataVisPitchXY;
  float fTerDataVisPitchXY;
  int terDataBufPitchXY;
  int terDataBufPitchScaledXY;
  int terDataVisPitchZ;
  float fTerDataVisPitchZ;
  int terDataBufPitchZ;
  int terDataBufPitchScaledZ;
  float plantScale;
  int terDataTexScale;
  int terDataVisSize;
  int terDataBufSize;
  int cellsPerBlock;
  int iHolderSize;
  int maxFloors;
  float fCellsPerBlock;
  int (dirModX) [6];
  int (dirModY) [6];
  int (dirModZ) [6];
  int (opDir) [6];
  float floorHeightInCells;
  float floorHeight;
  float roofHeight;
  bool (isBuilding) [E_CT_LENGTH];
  bool (isRoad) [E_CT_LENGTH];
  bool (isRoom) [E_CT_LENGTH];
  bool (isBase) [E_CT_LENGTH];
  bool (isTraversable) [E_CT_LENGTH];
  int (ctClasses) [E_CT_LENGTH];
  int (layerHash) [E_CT_LENGTH];
  FIVector4 anchorPoint;
  FIVector4 p1;
  FIVector4 p2;
  FIVector4 newP1;
  FIVector4 newP2;
  FIVector4 rad;
  FIVector4 visInsetFromMin;
  FIVector4 visInsetFromMax;
  FIVector4 cornerRad;
  FIVector4 thickVals;
  FIVector4 powerVals;
  FIVector4 powerVals2;
  FIVector4 matParams;
  FIVector4 centerPoint;
  FIVector4 lightVec;
  FIVector4 offsetInBlocks;
  FIVector4 offsetInBlocksWrapped;
  FIVector4 origin;
  FIVector4 blockMinBufInPixels;
  FIVector4 blockMaxBufInPixels;
  FIVector4 tempVec;
  FIVector4 tempVec2;
  FIVector4 tempVec3;
  FIVector4 tempVec4;
  FIVector4 tempVecB;
  FIVector4 tempVecB2;
  FIVector4 tempVecB3;
  GameEnt baseEnt;
  EntVec (gameEnts) [E_ET_LENGTH];
  GameWorld * gw;
  GamePageHolder * * holderData;
  BuildingNode * buildingData;
  MapNode * mapData;
  uint * terData;
  BuildingCon * curCon;
  GameBlock ();
  void init (Singleton * _singleton, int _blockId, int _x, int _y, int _z, int _xw, int _yw, int _zw);
  int getNodeIndexClamped (int _x, int _y, int _z);
  int getNodeIndex (int x, int y, int z, int bufAmount);
  int touchesPlanarBN (int x, int y, int z, int buildingType, int bufAmount);
  int touchesPlanarClass (int x, int y, int z, int classType, int bufAmount);
  int touchesPlanarClass2 (int x, int y, int z, int classType, int bufAmount);
  bool isLCorner (int x, int y, int z, int classType, bool includeSingle);
  void applyWingValues (int _x1, int _y1, int _z1, int _x2, int _y2, int _z2, int cnum, bool isWingBeg, bool isWingEnd, float multiplier);
  void addPlantNodes (GamePlantNode * curPlantNode, FIVector4 * orig, float scale);
  void addNewGeom (int _curBT, int _curAlign, float _baseOffset, FIVector4 * _p1, FIVector4 * _p2, FIVector4 * _rad, FIVector4 * _cornerRad, FIVector4 * _visInsetFromMin, FIVector4 * _visInsetFromMax, FIVector4 * _powerVals, FIVector4 * _powerVals2, FIVector4 * _thickVals, FIVector4 * _matParams, FIVector4 * _anchorPoint, int _minRot, int _maxRot);
  void connectNodes (int _x1, int _y1, int _z1, int _x2, int _y2, int _z2, int ct, int id = -1, int _heightDelta = 0, int _direction = 0, float _wallRadInCells = -1.0f, unsigned int _nodeFlags = 0);
  int getMapNodeIndex (int x, int y, int bufAmount);
  int touchesMap (int x, int y, int buildingType, int bufAmount);
  int touchesWithinRadMap (int x, int y, int buildingType, int rad, int bufAmount);
  int touches2Map (int x, int y, int buildingType, int bufAmount);
  void connectMapNodes (int _x1, int _y1, int _x2, int _y2, int buildingType, int id, int bufAmount);
  int getAdjustedHeightInHolders (int xInHolders, int yInHolders);
  float fIsNearTerrain (FIVector4 * worldMinVisInPixels);
  void modifyTerrain (FIVector4 * worldPos, bool doSub);
  int isNearTerrain (FIVector4 * worldPosInPix);
  int findNearestNode (FIVector4 * worldPositionInPixelsIn, FIVector4 * posInNodesOut, FIVector4 * posInPixelsOut);
  void nodeIndexToWorldSpaceInPixels (int ind, FIVector4 * posInPixelsOut);
  bool hasTerrainBelow (int i, int j, int k, int conDir, bool bothEnds);
  bool hasRoomBelow (int i, int j, int k, int conDir);
  bool isSupportedBelow (int i, int j, int k, int conDir, bool bothEnds);
  bool touchesRoomOnLevel (int i, int j, int k);
  bool touchesBaseOnLevel (int i, int j, int k, int layer);
  bool buildingAbove (int x, int y, int z);
  void makeMazeUG ();
};
#undef LZZ_INLINE
#endif
// f00355_volumewrapper.e
//

#ifndef LZZ_f00355_volumewrapper_e
#define LZZ_f00355_volumewrapper_e
#define LZZ_INLINE inline
class VolumeWrapper
{
public:
  FBOSet fboSet;
  GLuint volId;
  FIVector4 terGenDim;
  FIVector4 genPosMin;
  FIVector4 genPosMax;
  bool isFloat;
  bool isReady;
  VolumeWrapper ();
  void init (int z, GLenum clampMethod, bool _isFloat, int filterType);
  void copyFloatArr (float * floatArr);
  void copyCharArr (unsigned char * charArr);
};
#undef LZZ_INLINE
#endif
// f00360_threadpoolwrapper.e
//

#ifndef LZZ_f00360_threadpoolwrapper_e
#define LZZ_f00360_threadpoolwrapper_e
#define LZZ_INLINE inline
class ThreadPoolWrapper
{
public:
  int maxThreads;
  int (intData) [THREAD_DATA_COUNT];
  ThreadWrapper * threadPool;
  Singleton * singleton;
  bool singleThreaded;
  std::vector <int> availIds;
  ThreadPoolWrapper ();
  void init (Singleton * _singleton, int _maxThreads, bool _singleThreaded);
  void funcTP (int threadId);
  void startTP (int threadId);
  bool stopTP (int threadId);
  bool startThread ();
  bool anyRunning ();
  void stopAll ();
  ~ ThreadPoolWrapper ();
};
#undef LZZ_INLINE
#endif
// f00370_gamelogic.e
//

#ifndef LZZ_f00370_gamelogic_e
#define LZZ_f00370_gamelogic_e
#define LZZ_INLINE inline
class GameLogic
{
public:
  Singleton * singleton;
  std::vector <PathResult> pathSearchStack;
  std::vector <PathResult> pathFinalStack;
  ThreadPoolWrapper * threadPoolPath;
  ThreadPoolWrapper * threadPoolList;
  FIVector4 minv;
  FIVector4 maxv;
  PathInfo testPath;
  std::vector <btVector3> tempStack;
  int idCounter;
  GamePageHolder * globEndHolder;
  int globEndGroupId;
  bool globFoundTarg;
  GameLogic ();
  void setEntTargPath (int sourceUID, int destUID);
  void init (Singleton * _singleton);
  void applyTBBehavior ();
  void applyBehavior ();
  GamePageHolder * getHolderById (int blockId, int holderId);
  GamePageHolder * getHolderByPR (PathResult * pr);
  bool holdersEqual (GamePageHolder * h0, GamePageHolder * h1);
  void addHolderToStack (GamePageHolder * curHolder);
  void remHolderFromStack (int opCode);
  void fillAllPaths (GamePageHolder * begHolder, GamePageHolder * endHolder, int begInd, int endInd, int opCode);
  bool addGroupToStack (ConnectingNodeStruct * testConNode, GamePageHolder * curHolder, int groupId, GamePageHolder * lastHolder, int lastGroupId, int lastIndex);
  void remGroupFromStack (int opCode);
  void fillAllGroups (GamePageHolder * begHolder, GamePageHolder * endHolder, int begInd, int endInd, int opCode);
  bool findNaivePath (PathInfo * pathInfo);
  bool findBestPath (PathInfo * pathInfo, GamePageHolder * closestHolder, GamePageHolder * closestHolder2, int bestInd, int bestInd2);
  void drawFinalPath (PathInfo * pathInfo);
  void getPath (PathInfo * pathInfo);
  void update ();
  void drawLineAtIndices (GamePageHolder * curPointHolder, int curPointIndex, GamePageHolder * curPointHolder2, int curPointIndex2);
  btVector3 holderIndToBTV (GamePageHolder * curPointHolder, int curPointIndex, bool addHalfOff);
  void drawPointAtIndex (GamePageHolder * curPointHolder, int curPointIndex, int r, int g, int b, float rad);
  void getPointsForPath (GamePageHolder * curHolderFrom, int _curInd, PathInfo * pathInfo, bool reverseOrder);
  void drawRegions (int offX, int offY, int offZ);
  int getClosestPathRad (btVector3 cpBTV, GamePageHolder * & closestHolder);
  void loadNearestHolders ();
};
#undef LZZ_INLINE
#endif
// f00373_myshapedrawer.e
//

#ifndef LZZ_f00373_myshapedrawer_e
#define LZZ_f00373_myshapedrawer_e
#define LZZ_INLINE inline
class MyShapeDrawer
{
public:
  btAlignedObjectArray <ShapeCache*> m_shapecaches;
  Singleton * singleton;
  MyShapeDrawer (Singleton * _singleton);
  void init ();
  bool enableTexture (bool enable);
  bool hasTextureEnabled () const;
  void drawCoordSystem ();
  void drawSphere (btScalar radius, int lats, int longs);
  ShapeCache * cache (btConvexShape * shape);
  void renderSquareA (float x, float y, float z);
  void glDrawVector (btVector3 const & v);
  void setId (int bodyUID, int limbUID);
  void updateMat2 ();
  void updateMat ();
  void pushNewMat (btScalar * m);
  void popMat ();
  void drawOrient (int uid);
  void drawOpenGL (btScalar * m, btCollisionShape const * shape, btVector3 const & color, int debugMode, btVector3 const & worldBoundsMin, btVector3 const & worldBoundsMax, int uid);
  ~ MyShapeDrawer ();
  void drawSceneInternal (btDiscreteDynamicsWorld const * dynamicsWorld, int pass);
  void drawScene (btDiscreteDynamicsWorld const * dynamicsWorld, bool useShadows);
};
LZZ_INLINE void MyShapeDrawer::glDrawVector (btVector3 const & v)
                                                             { glVertex3d(v[0], v[1], v[2]); }
#undef LZZ_INLINE
#endif
// f00374_myglhelper.e
//

#ifndef LZZ_f00374_myglhelper_e
#define LZZ_f00374_myglhelper_e
#define LZZ_INLINE inline
class MyGLHelper : public GUIHelperInterface
{
public:
  MyGLHelperInternalData * m_data;
  Singleton * singleton;
  MyGLHelper (Singleton * _singleton, CommonGraphicsApp * glApp);
  ~ MyGLHelper ();
  struct CommonRenderInterface * getRenderInterface ();
  void createRigidBodyGraphicsObject (btRigidBody * body, btVector3 const & color);
  void createCollisionObjectGraphicsObject (btCollisionObject * body, btVector3 const & color);
  int registerGraphicsShape (float const * vertices, int numvertices, int const * indices, int numIndices);
  int registerGraphicsInstance (int shapeIndex, float const * position, float const * quaternion, float const * color, float const * scaling);
  static void createCollisionShapeGraphicsObjectInternal (btCollisionShape * collisionShape, btTransform const & parentTransform, btAlignedObjectArray <GLInstanceVertex> & verticesOut, btAlignedObjectArray <int> & indicesOut);
  void createCollisionShapeGraphicsObject (btCollisionShape * collisionShape);
  void syncPhysicsToGraphics (btDiscreteDynamicsWorld const * rbWorld);
  void render (btDiscreteDynamicsWorld const * rbWorld);
  void createPhysicsDebugDrawer (btDiscreteDynamicsWorld * rbWorld);
  struct Common2dCanvasInterface * get2dCanvasInterface ();
  CommonParameterInterface * getParameterInterface ();
  void setUpAxis (int axis);
  void resetCamera (float camDist, float pitch, float yaw, float camPosX, float camPosY, float camPosZ);
  void autogenerateGraphicsObjects (btDiscreteDynamicsWorld * rbWorld);
  void drawText3D (char const * txt, float posX, float posY, float posZ, float size);
  struct CommonGraphicsApp * getAppInterface ();
};
#undef LZZ_INLINE
#endif
// f00375_gamephysics.e
//

#ifndef LZZ_f00375_gamephysics_e
#define LZZ_f00375_gamephysics_e
#define LZZ_INLINE inline
class GamePhysics
{
public:
  Singleton * singleton;
  BenchmarkDemo * example;
  MyOGLApp * myOGLApp;
  GUIHelperInterface * guiHelper;
  float (myMat) [16];
  float BASE_ENT_HEIGHT;
  float BASE_ENT_RAD;
  float CONTACT_THRESH;
  Matrix4 myMatrix4;
  Vector4 myVector4;
  Vector4 resVector4;
  btRigidBody * lastBodyPick;
  int lastBodyUID;
  btVector3 orig;
  btVector3 xyMask;
  btVector3 zMask;
  GamePhysics ();
  void init (Singleton * _singleton);
  void pickBody (FIVector4 * mouseMoveOPD);
  void collectDebris ();
  void beginDrop ();
  void remBoxFromObj (BaseObjType _uid);
  void addBoxFromObj (BaseObjType _uid, bool refreshLimbs);
  void flushImpulses ();
  void procCol (BaseObj * * geArr, BodyStruct * * curBodyArr);
  void collideWithWorld (double curStepTime);
  void remFarAway ();
  void updateAll ();
  ~ GamePhysics ();
};
#undef LZZ_INLINE
#endif
// f00380_gameworld.e
//

#ifndef LZZ_f00380_gameworld_e
#define LZZ_f00380_gameworld_e
#define LZZ_INLINE inline
class GameWorld
{
public:
  int numProvinces;
  int seaLevel;
  int seaSlack;
  int pageCount;
  int mapSwapFlag;
  int holdersPerBlock;
  int shiftCounter;
  int renderCount;
  float invalidCount;
  float invalidCountMax;
  int iBlockSize;
  int renderMethod;
  int iBufferSize;
  int maxThreads;
  int availThreads;
  int lightCount;
  int MIN_MIP;
  int MAX_MIP;
  int AVG_MIP;
  int blockMip;
  int hmChannel;
  int idChannel;
  int densityChannel;
  int blockChannel;
  int stChannel;
  int btChannel;
  int pathChannel;
  int houseChannel;
  float mapWidth;
  float mapHeight;
  int * curDiagram;
  int * provinceGrid;
  int * provinceX;
  int * provinceY;
  bool doDrawFBO;
  bool mapLockOn;
  bool foundPath;
  float mapStep;
  int (dirFlags) [4];
  int (dirFlagsOp) [4];
  int (dirFlagsO) [4];
  int (dirFlagsOpO) [4];
  int (dirModX) [6];
  int (dirModY) [6];
  int (dirModZ) [6];
  int (opDir) [4];
  GameEnt * (activeLights) [MAX_EVAL_LIGHTS];
  int dirFlagClear;
  int visFlag;
  int visFlagO;
  int activeFBO;
  bool noiseGenerated;
  std::vector <coordAndIndex> roadCoords;
  std::vector <int> ocThreads;
  btVector3 (offsetVal) [4];
  string (curTargFBO) [3];
  string (curDepthFBO) [3];
  GamePageHolder * blockHolder;
  FIVector4 lScreenCoords;
  FIVector4 cScreenCoords;
  int cellsPerWorld;
  int holdersPerWorld;
  int blocksPerWorld;
  FIVector4 entMin;
  FIVector4 entMax;
  FIVector4 camHolderPos;
  FIVector4 camBlockPos;
  FIVector4 iPixelWorldCoords;
  FIVector4 pagePos;
  FIVector4 unitPos;
  FIVector4 lastUnitPos;
  FIVector4 tempVec1;
  FIVector4 tempVec2;
  FIVector4 tempVec3;
  FIVector4 tempVec4;
  FIVector4 (blockPos) [2];
  FIVector4 (nodePos) [2];
  FIVector4 (nodePosInPixels) [2];
  FIVector4 (lineSeg) [2];
  int (nodeInd) [2];
  GameBlock * (blockRef) [2];
  FIVector4 minv;
  FIVector4 maxv;
  FIVector4 tempVec;
  FIVector4 unitPosMin;
  FIVector4 unitPosMax;
  FIVector4 unitPosCenter;
  FIVector4 startBounds;
  FIVector4 endBounds;
  FIVector4 * lightPos;
  FIVector4 * globLightPos;
  FIVector4 lightPosBase;
  FIVector4 * curBoxPos;
  FIVector4 tv0;
  FIVector4 tv1;
  FIVector4 tv2;
  FIVector4 tv3;
  FIVector4 tv4;
  FIVector4 tv5;
  Singleton * singleton;
  GameBlock * * blockData;
  FBOWrapper * curFBO;
  FBOWrapper * curFBO2;
  BaseObjType lastHitObjUID;
  GameWorld ();
  void init (Singleton * _singleton);
  GameBlock * getBlockAtCoords (int xInBlocks, int yInBlocks, int zInBlocks, bool createOnNull = false);
  GamePageHolder * getHolderAtCoords (int x, int y, int z, bool createOnNull = false);
  GamePageHolder * getHolderAtId (int blockId, int holderId);
  GameBlock * getBlockAtId (int id);
  int getCellInd (btVector3 cParam, GamePageHolder * & curHolder);
  int getCellInd (GamePageHolder * & curHolder, int xv, int yv, int zv);
  int getCellAtCoords (int xv, int yv, int zv);
  float getCellAtCoordsLin (btVector3 pos);
  btVector3 getNormalAtCoord (btVector3 coord, float * cellVal);
  void setArrAtCoords (int xv, int yv, int zv, int * tempCellData, int * tempCellData2);
  void getArrAtCoords (int xv, int yv, int zv, int * tempCellData, int * tempCellData2);
  void fireEvent (BaseObjType uid, int opCode, float fParam);
  void generateBlockHolder ();
  void update ();
  void toggleVis (GameEnt * se);
  void ensureBlocks ();
  void findNearestEnt (EntSelection * entSelection, int entType, int maxLoadRad, int radStep, FIVector4 * testPoint, bool onlyInteractive = false, bool ignoreDistance = false);
  void drawVol (VolumeWrapper * curVW, FIVector4 * minc, FIVector4 * maxc, bool copyToTex, bool forceFinish, bool getVoro = false, bool getBlockHolders = false);
  void updateLimbTBOData (bool showLimbs);
  void drawPrim (bool doSphereMap, bool doTer, bool doPoly);
  void drawOrg (GameOrg * curOrg, bool drawAll);
  void drawNodeEnt (GameOrgNode * curNode, FIVector4 * basePosition, float scale, int drawMode, bool drawAll);
  void polyCombine ();
  void drawPolys (string fboName, int minPeel, int maxPeel, bool isBlockHolder);
  void rasterPolysWorld ();
  void rasterPolys (int minPeel, int maxPeel, int extraRad = 0);
  void renderGeom ();
  void updateMouseCoords (FIVector4 * fPixelWorldCoordsBase);
  float weighPath (float x1, float y1, float x2, float y2, float rad, bool doSet, bool isOcean);
  float findBestPath (float x1, float y1, float x2, float y2, int generation, int roadIndex, bool doSet, bool isOcean);
  void initMap ();
  void drawMap ();
  void doBlur (string fboName, int _baseFBO = 0);
  void updateLights ();
  void renderOct (GameOctree * gameOct);
  void renderDebug ();
  void postProcess ();
  ~ GameWorld ();
};
#undef LZZ_INLINE
#endif
 
// f00293_gamesound.h
//

#include "f00293_gamesound.e"
#define LZZ_INLINE inline
GameSound::GameSound ()
                            {
			curVolume = 0.0;
		}
void GameSound::init (string path)
                                       {
			if (!buffer.loadFromFile(path)) {
				cout << "error loading sound";
				return;
			}
			
			sound.setBuffer(buffer);
			
		}
void GameSound::setPitch (float val)
                                         {
			sound.setPitch(val);
		}
void GameSound::setPositionAndMinDis (float x, float y, float z, float w)
                  {
			sound.setMinDistance(w);
			sound.setPosition(x,y,z);
		}
void GameSound::setLoop (bool val)
                                       {
			sound.setLoop(val);
		}
void GameSound::stop ()
                            {
			
		}
void GameSound::setVolumeSmooth (float volume, float decay)
                {
			
			curVolume += (volume-curVolume)*decay;
			
			
			int intVol = curVolume*100.0f;
			sound.setVolume(intVol);
					
		}
void GameSound::setVolume (float volume)
                {
			curVolume = volume;
			int intVol = volume*100.0f;
			sound.setVolume(intVol);			
		}
void GameSound::play (float volume)
                {
			curVolume = volume;
			int intVol = volume*100.0f;
			
			sound.setVolume(intVol);
			sound.play();
			
		}
#undef LZZ_INLINE
 
// f00294_gamemusic.h
//

#include "f00294_gamemusic.e"
#define LZZ_INLINE inline
GameMusic::GameMusic ()
                            {
			
		}
void GameMusic::init (string path)
                                       {
			if ( !sound.openFromFile(path) ) {
				cout << "error loading music";
				return;
			}
			
		}
void GameMusic::setLoop (bool val)
                                       {
			sound.setLoop(val);
		}
void GameMusic::stop ()
                            {
			sound.stop();
		}
void GameMusic::setVolume (float _volume)
                                                   {
			volume = _volume;
			int intVol = _volume*100.0f;
			sound.setVolume(intVol);
		}
void GameMusic::play (float _volume)
                {
			setVolume(_volume);
			sound.play();
		}
#undef LZZ_INLINE
 
// f00300_singleton.h
//

#include "f00300_singleton.e"
#define LZZ_INLINE inline
bool Singleton::CompareStruct::operator () (string const & first, string const & second)
                                                                       {
	        return first.compare(second) < 0;//first.size() < second.size();
	    }
Singleton::Singleton ()
        {
		gamePhysics = NULL;
		allInit = false;
		
		fboMap.clear();
		shaderMap.clear();
		soundMap.clear();
		styleSheetMap.clear();
		
		mainGUI = NULL;
		gw = NULL;
		
		
		
		
		// #ifdef USE_POCO
		// 	myWS = NULL;
		// #endif
		
	}
FIVector4 * Singleton::BTV2FIV (btVector3 btv)
                                          {
		btvConv.setFXYZ(btv.getX(),btv.getY(),btv.getZ());
		return &btvConv;
	}
void Singleton::init (int _defaultWinW, int _defaultWinH, int _scaleFactor)
          {

		pushTrace("Singleton init");
		int i;
		int j;
		int k;
		int m;
		int ind;
		float tempf;
		
		RUN_COUNT = 0;
		TEMP_DEBUG = false;
		
		initNetMasks();
		
		
		if (DO_RANDOMIZE) {
			// todo: get rid of this for random seeds, causes desync
			srand(time(NULL));
			RAND_COUNTER = rand();
			RAND_COUNTER2 = rand();
		}
		
		
		// todo: mem leak, should delete?
		
		for (i = 0; i < E_SDT_LENGTH; i++) {
			externalJSON[E_SPECIAL_DATA_TYPE_STRINGS[i]].jv = NULL;
		}
		
		externalJSON["kb.js"].jv = NULL;
		
		
		for (i = 0; i < EML_LENGTH; i++) {
			music[i] = new GameMusic();
			music[i]->init("..\\data\\music\\"+musicStrings[i]+".ogg");
			music[i]->setLoop(true);
		}
		
		for (i = 0; i < 6; i++) {
			dirVecs[i].setFXYZ(
				DIR_VECS[i][0],
				DIR_VECS[i][1],
				DIR_VECS[i][2]
			);
		}
		
		
		
		initAllMatrices();
		
		fsQuad.init(vertexDataQuad, 32, indexDataQuad, 6);
		
		colVecs[0].setFXYZ(255,0,0);
		colVecs[1].setFXYZ(0,255,0);
		colVecs[2].setFXYZ(0,0,255);
		colVecs[3].setFXYZ(255,255,0);
		colVecs[4].setFXYZ(255,0,255);
		colVecs[5].setFXYZ(0,255,255);
		colVecs[6].setFXYZ(128,0,0);
		colVecs[7].setFXYZ(0,128,0);
		colVecs[8].setFXYZ(0,0,128);
		colVecs[9].setFXYZ(128,128,0);
		colVecs[10].setFXYZ(128,0,128);
		colVecs[11].setFXYZ(0,128,128);
		colVecs[12].setFXYZ(255,128,128);
		colVecs[13].setFXYZ(128,255,128);
		colVecs[14].setFXYZ(128,128,255);
		colVecs[15].setFXYZ(255,255,128);
		
		
		camRotation[0] = 0.0f;
		camRotation[1] = M_PI/2.0f;
		
		curCamRotation[0] = camRotation[0];
		curCamRotation[1] = camRotation[1];
		
		
		for (i = 0; i < KEYMAP_LENGTH; i++) {
			keyMapCoolDown[i] = 0;
			keyMapMaxCoolDown[i] = 0;
		}
		
		
		for (i = 0; i < E_CT_LENGTH; i++) {
			isInteractiveEnt[i] = false;
		}
		isInteractiveEnt[E_CT_WINDOW] = true;
		isInteractiveEnt[E_CT_DOOR] = true;
		isInteractiveEnt[E_CT_LANTERN] = true;
		
		
		
		lightVec.setFXYZ(0.3f,0.4f,-1.0f);
		lightVec.normalize();
		lightVecOrig.copyFrom(&lightVec);
		
		//totTimePassedGraphics = 0;
		//totTimePassedPhysics = 0;
		
		identMatrix.identity();
		
		
		destructCount = 0;
		
		sphereMapOn = false;
		waitingOnDestruction = false;
		
		physicsOn = true;
		isPressingMove = false;
		fxaaOn = false;
		doPathReport = false;
		refreshPaths = false;
		placingTemplate = true;
		smoothMove = true;
		waterBulletOn = false;
		ignoreFrameLimit = false;
		autoMove = false;
		inputOn = false;
		isMacro = false;
		
		cavesOn = false;
		bakeParamsOn = true;
		dragging = false;
		mouseMoved = false;
		hitGUI = false;
		guiDirty = true;
		
		
		lastMouseOrigX = 0.0f;
		lastMouseOrigY = 0.0f;
		
		threadNetSend.init();
		threadNetRecv.init();
		
		
		for (i = 0; i < E_FM_LENGTH; i++) {
			menuList[i] = NULL;
		}
		
		mapComp = NULL;
		fieldText = NULL;
		selectedEnt = NULL;
		highlightedEnt = NULL;
		draggingMap = false;
		
		MAX_TRAVEL_DIS = 10.0f;
		FOV = 45.0f;
		focalLength = 1.0f / tan(FOV / 2.0f);

		totalPointCount = 0;
		
		
		
		curOrgId = 0;
		
		rootObjJS = NULL;
		guiRootJS = NULL;
		constRootJS = NULL;
		rbStack = NULL;
		rbHeightStack = NULL;

		multiLights = false;
		numDynLights = E_OBJ_LENGTH - E_OBJ_LIGHT0;
		updateMultiLights();

		maxLayerOver = -1;

		iNumSteps = 16;
		pathFindingStep = 0;

		srand(time(NULL));

		timeOfDay = 1.0f;
		targetTimeOfDay = 1.0f;
		
		guiSaveLoc = "..\\data\\saves\\save0\\compMap.txt";

		//invItems = loadBMP("..\\data\\invitems.bmp");
		imageHM0 = loadBMP("..\\data\\hm0.bmp");
		imageHM1 = loadBMP("..\\data\\hm1.bmp");
		cloudImage = loadBMP("..\\data\\clouds.bmp");

		//invItems->getTextureId(GL_NEAREST);
		imageHM0->getTextureId(GL_NEAREST);
		imageHM1->getTextureId(GL_NEAREST);
		cloudImage->getTextureId(GL_LINEAR);

		
		limbTBO.init(true, limbTBOData, NULL, MAX_LIMB_DATA_IN_BYTES);
		
		numLights = MAX_LIGHTS;//min(MAX_LIGHTS,E_OBJ_LENGTH-E_OBJ_LIGHT0);


		//////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////

		

		lastNodeId = 0;
		escCount = 0;

		initStyleSheet();

		curMoveSpeed = 0.0f;
		curMoveAccel = 0.0f;
		
		masterVolume = 0.0f;
		ambientVolume = 0.0f;
		guiVolume = 0.0f;
		musicVolume = 0.0f;
		fxVolume = 0.0f;
		
		curPrimMod = 0.0f;
		curPrimTemplate = 1;
		geomStep = 0;

		drawOrient = false;
		applyToChildren = false;
		//guiOn = false;
		bCtrlOld = false;
		bShiftOld = false;
		bCtrl = false;
		bShift = false;
		emptyVDNotReady = true;
		firstRun = true;
		waterOn = (MAX_LAYERS == 2);
		treesOn = true;
		rotOn = false;
		markerFound = false;
		doPageRender = true;
		placingGeom = false;
		
		
		
		
		
		/////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////
		
				
		// IMPORTANT: Maximum height must be less than 2^16, max world pitch must be less than 2^32
		
		medianCount = 0;
		currentTick = 0;
		earthMod = E_PTT_TER;
		
		moveTimer.start();
		
		
		matVolDim.setIXYZ(64,64,256);
		matVolSize = matVolDim.getIX()*matVolDim.getIY()*matVolDim.getIZ();
		matVol = new uint[matVolSize];
		matSlice0 = new materialNode[matVolDim.getIX()*matVolDim.getIY()];
		matSlice1 = new materialNode[matVolDim.getIX()*matVolDim.getIY()];
		matSlice2 = new materialNode[matVolDim.getIX()*matVolDim.getIY()];
		
		for (i = 0; i < matVolSize; i++) {
			matVol[i] = 0;
		}
		
		
		diagCount = 0;
		
		
		
		// qqqqqq
		
		// was doing: lerp from start to end postions, worlspace per pixel
		
		// was doing: exmaine why fluidchange 66 33
		
		// was doing: silouhette rendering?
		
		// todo: compress volumes into stacks of lines
		// todo: rasterize voxels with tris for depth cache
		// todo - generate silouhette by expanding position of edges with high differential
		// map right in the center of these edges to inexpensively determine silouhette
		
		// todo: probe area ahead of current ray step to see if near edge
		
		
		
		
		
		curPattern = E_PAT_5X5DIAMOND;
		curPatternRot = 0;
		
		generatePatterns();
		
		tbTicks = 0;
		tempCounter = 0;
		actorCount = 0;
		polyCount = 0;
		fpsCountMax = 500;
		
		fpsTest = false;
		pathfindingOn = true;
		pathfindingGen = false;
		pathfindingTestOn = false;
		updateHolders = false;
		
		
		maxHolderDis = 32;
		heightOfNearPlane = 1.0f;
		scrollDiv = 2.0;
		frameSkip = 32;
		frameSkipCount = 0;
		
		int bufferDiv = 1;
		
		if (DO_POINTS) {
			glEnable(GL_POINT_SPRITE);
			glEnable(GL_VERTEX_PROGRAM_POINT_SIZE);
		}
		
		glLineWidth(4.0f);
		
		// This var determines how high the z val can go,
		// but also increases load times for each block
		
		
		
		heightMapMaxInCells = 8192.0f;
		mapSampScale = 2.0f;
		int newPitch = (imageHM0->width) * mapSampScale; //*2;
		mapPitch = (imageHM0->width); //newPitch;// //
		
		cellsPerHolder = 32;
		holdersPerBlock = 8;
		
		holdersPerWorld = newPitch;
		cellsPerWorld = holdersPerWorld*cellsPerHolder;
		cellsPerBlock = holdersPerBlock * cellsPerHolder;
		blocksPerWorld = holdersPerWorld/holdersPerBlock;
		
		if (blocksPerWorld > 256) {
			cout << "Too many blocks in world, change holdersPerBlock\n";
			exit(0);
		}
		
		
		
		
		globWheelDelta = 0.0f;
		amountInvalidMove = 0.0f;
		amountInvalidRotate = 0.0f;
		sphereMapPrec = 0.0f;
		
		cellsPerNodeXY = 16;
		cellsPerNodeZ = 8;
		
		
		
		clipDist[0] = 1.0f;
		clipDist[1] = 512.0f;
		
		terDataTexScale = 1;
		
		terDataVisPitchXY = cellsPerBlock / cellsPerNodeXY;
		iNodeDivsPerHolder = terDataVisPitchXY / holdersPerBlock;
		terDataBufAmount = iNodeDivsPerHolder; // pad with one extra lot
		
		floorHeightInCells = (float)cellsPerNodeZ;
		roofHeightInCells = ((float)cellsPerNodeXY)/4.0f;
		wallRadInCells = ((float)cellsPerNodeXY)/4.0f;
		
		
		terDataBufPitchXY = terDataVisPitchXY + terDataBufAmount * 2;
		terDataBufPitchScaledXY = terDataBufPitchXY * terDataTexScale;
		
		terDataVisPitchZ = cellsPerBlock / cellsPerNodeZ;
		terDataBufPitchZ = terDataVisPitchZ + terDataBufAmount * 2;
		terDataBufPitchScaledZ = terDataBufPitchZ * terDataTexScale;

		terDataVisSize = terDataVisPitchXY * terDataVisPitchXY * terDataVisPitchZ;
		terDataBufSize = terDataBufPitchXY * terDataBufPitchXY * terDataBufPitchZ;
		terDataBufSizeScaled = terDataBufPitchScaledXY * terDataBufPitchScaledXY * terDataBufPitchScaledZ;


		terDataScaled = new uint[terDataBufSizeScaled];
		rbStack = new int[terDataBufSize];
		rbHeightStack = new int[terDataBufSize];


		
		
		timeDelta = 0.0;
		
		mdTimeLR[0] = 0.0f;
		mdTimeLR[1] = 0.0f;
		clickTimeLR[0] = 0.0f;
		clickTimeLR[1] = 0.0f;
		
		
		
		
		
		
		


		
		blockShift = intLogB2(holdersPerBlock * holdersPerBlock * holdersPerBlock);
		holderSizeMB = 0;







		cout << "\n\n\n\n\n\n";


		
		cout << "cellsPerNodeXY: " << cellsPerNodeXY << "\n";
		cout << "cellsPerNodeZ: " << cellsPerNodeZ << "\n";
		
		cout << "holdersPerBlock: " << holdersPerBlock << "\n";
		cout << "cellsPerBlock: " << cellsPerBlock << "\n";
		cout << "terDataBufPitchScaledXY " << terDataBufPitchScaledXY << "\n";
		cout << "cellsPerHolder: " << cellsPerHolder << "\n";

		cout << "cellsPerWorld: " << cellsPerWorld << "\n";
		cout << "blocksPerWorld: " << blocksPerWorld << "\n";


		GLint glQuery;
		glGetIntegerv(GL_MAX_UNIFORM_LOCATIONS, &glQuery);
		cout << "MAX_UNIFORMS: " << glQuery << "\n";

		cout << "\n\n\n\n\n\n";


		mapFreqs.setFXYZW(
			1.0f,
			4.0f,
			16.0f,
			32.0f
		);
		mapAmps.setFXYZW(
			16.0f/16.0f,
			2.0f/16.0f,
			1.0f/16.0f,
			0.25f/16.0f
		); //0.0f, 0.0f, 0.0f);//


		


		//////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////
		//////////////////////////////////////////////////////////////
		radiosityOn = true;
		testOn = false;
		testOn2 = false;
		updateLock = false;
		traceOn = false;
		frameMouseMove = false;
		depthInvalidMove = true;
		lastDepthInvalidMove = true;
		depthInvalidRotate = true;
		drawTargPaths = false;
		renderingOct = false;
		renderingOctBounds = false;
		placingPattern = false;
		gridOn = false;
		fogOn = 1.0f;
		cameraZoom = 1.0f;
		targetZoom = cameraZoom;
		

		zoomDelta = 0.0f;
		subjectDelta = 0.0f;
		subjectZoom = 1.0f;
		targetSubjectZoom = 1.0f;

		int ccr = 0;
		int ccg = 0;
		int ccb = 0;
		int curFilter;

		
		
		gameNetwork = new GameNetwork();
		gameNetwork->init(this);
		
		//if (!(gameNetwork->isConnected)) {
		//if (DO_CONNECT) {
			gameNetwork->socketConnect(true);
		//}
		
		
		for (i = 0; i < E_FID_LENGTH; i++) {
			gameFluid[i] = new GameFluid();
			gameFluid[i]->init(this, i);
		}
		
		
		// must be done after all are init
		for (i = 0; i < E_FID_LENGTH; i++) {
			gameFluid[i]->updateTBOData(true, false);
		}
		
		
		
		
		
		gameLogic = new GameLogic();
		gameLogic->init(this);


		// for (i = 0; i < MAX_TER_TEX; i++)
		// {

		// 	terTextures[i].usedByBlockId = -1;
		// 	terTextures[i].alreadyBound = false;


		// 	// glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA32F, w, h, 0, GL_RGBA, GL_FLOAT, 0);

		// 	glGenTextures(1, &(terTextures[i].texId));
		// 	glBindTexture(GL_TEXTURE_3D, terTextures[i].texId);
		// 	glTexImage3D(
		// 		GL_TEXTURE_3D,
		// 		0,
		// 		GL_RGBA,
		// 		terDataBufPitchScaledXY,
		// 		terDataBufPitchScaledXY,
		// 		terDataBufPitchScaledZ,
		// 		0,
		// 		GL_RGBA,
		// 		GL_UNSIGNED_BYTE,
		// 		0
		// 	);
		// 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		// 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		// 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_BORDER_COLOR, 0);
		// 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		// 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		// 	glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
		// 	glBindTexture(GL_TEXTURE_3D, 0);

		// 	TOT_GPU_MEM_USAGE += ((float)(terDataBufSizeScaled * 4)) / (1024.0f * 1024.0f);
		// }

		


		glGenTextures(1, &volIdMat);
		glBindTexture(GL_TEXTURE_3D, volIdMat);
		glTexImage3D(GL_TEXTURE_3D, 0, GL_RGBA, matVolDim.getIX(), matVolDim.getIY(), matVolDim.getIZ(), 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
		//glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_BORDER_COLOR, 0);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
		glBindTexture(GL_TEXTURE_3D, 0);

		
		paramArr = new float[4096];
		paramArrGeom = new float[128];
		splashArr = new float[MAX_SPLASHES*4];
		explodeArr = new float[MAX_EXPLODES*4];
		voroArr = new float[27 * 4];
		matCountArr = new float[256];
		paramArrMap = new float[4096];

		
		
		


		showMap = true;



		lastImageBuffer.data = NULL;
		lastImageBuffer.size = 0;

		//lastJSONBuffer.data = NULL;
		//lastJSONBuffer.size = 0;
		
		lastJSONBufferGUI.data = NULL;
		lastJSONBufferGUI.size = 0;
		

		nullBuffer.data = new char[1];
		nullBuffer.data[0] = '\0';
		nullBuffer.size = 0;



		palWidth = 256;
		palHeight = 256;

		resultImage = new unsigned char[palWidth * palHeight * 4];

		mouseMovingSize = 100;
		mouseMovingLoc = 0;
		mouseCount = 0;
		mouseMovingStepsBack = 20;
		mouseMoving = new FIVector4[mouseMovingSize];
		
		// #ifdef USE_POCO
		// 	myWS = _myWS;
		// #endif
		

		

		isBare = true;



		defaultWinW = _defaultWinW / _scaleFactor;
		defaultWinH = _defaultWinH / _scaleFactor;
		scaleFactor = _scaleFactor;
		aspectRatio = ((float)_defaultWinW)/((float)_defaultWinH);
		
		guiWinW = _defaultWinW / UI_SCALE_FACTOR;
		guiWinH = _defaultWinH / UI_SCALE_FACTOR;

		origWinW = _defaultWinW;
		origWinH = _defaultWinH;

		curBrushRad = 2.0f;
		mouseState = E_MOUSE_STATE_MOVE;








		wsBufferInvalid = true;

		// x*y must == z*z*z
		

		bufferDim.setIXY(defaultWinW, defaultWinH);
		bufferDimTarg.setIXY(defaultWinW, defaultWinH);
		
		bufferDimHalf.setIXY(defaultWinW / 2, defaultWinH / 2);
		bufferModDim.copyIntMult(&bufferDim,1);
		bufferRenderDim.copyIntDiv(&bufferDimTarg,RENDER_SCALE_FACTOR);

		myTimer.start();


		activeObject = E_OBJ_CAMERA;

		extraRad = 0;
		//lastTime = 0.0;





		mbDown = false;
		lbDown = false;
		rbDown = false;
		abDown = false;



		isFullScreen = false;
		shadersAreLoaded = 0;
		readyToRecompile = 0;

		programState = E_PS_IN_GAME;


		for (i = 0; i < E_OBJ_LENGTH; i++)
		{
			dynObjects.push_back(new DynObject());
		}

		dynObjects[E_OBJ_CAMERA]->init(0, 0, 0, 0, 0, 0, false, E_MT_NONE, NULL, 4.0f );

		for (i = E_OBJ_LIGHT0; i < E_OBJ_LENGTH; i++)
		{

			j = i - E_OBJ_LIGHT0;

			switch (j)
			{
			case 0:
				ccr = 255;
				ccg = 255;
				ccb = 255;
				break;

			case 1:
				ccr = 255;
				ccg = 0;
				ccb = 0;

				break;

			case 2:
				ccr = 255;
				ccg = 128;
				ccb = 0;

				break;

			case 3:
				ccr = 0;
				ccg = 255;
				ccb = 0;

				break;

			case 4:
				ccr = 0;
				ccg = 128;
				ccb = 255;

				break;
			case 5:
				ccr = 128;
				ccg = 0;
				ccb = 255;

				break;
			}

			if (i == E_OBJ_LIGHT0) {
				tempf = 128.0f;
			}
			else {
				tempf = 16.0f;
			}

			dynObjects[i]->init(
				-16 + i * 2,
				-16 + i * 2,
				4,
				ccr, ccg, ccb,
				true,
				E_MT_RELATIVE,
				&(dynObjects[E_OBJ_CAMERA]->pos),
				0.125f,
				tempf
			);



		}
		
		dynObjects[E_OBJ_LIGHT0]->moveType = E_MT_TRACKBALL;
		
		
		// dynObjects[E_OBJ_LIMBTARG0]->init(
		// 	-16 + 3 * 2,
		// 	-16 + 3 * 2,
		// 	4,
		// 	255, 0, 0,
		// 	true,
		// 	E_MT_TRACKBALL,
		// 	&(dynObjects[E_OBJ_CAMERA]->pos),
		// 	0.5f,
		// 	16.0f
		// );
		
		
		cameraPos = &(dynObjects[E_OBJ_CAMERA]->pos);
		
		
		//dynObjects[E_OBJ_FOG]->init(-1024*2, -1024*2, -1024/2,   0, 0, 255,     true, E_MT_RELATIVE, &(dynObjects[E_OBJ_CAMERA]->pos), 64.0f );
		//dynObjects[E_OBJ_CUTAWAY]->init(4096*4 - 256, 4096*4 - 256 + 2048, 4096*4,   0, 255, 0,     true, E_MT_RELATIVE, &(dynObjects[E_OBJ_CAMERA]->pos), 64.0f );
		//dynObjects[E_OBJ_HUMAN]->init(2048, 2048, -1024,   0, 255, 255,     true, E_MT_TRACKBALL, &(dynObjects[E_OBJ_CAMERA]->pos), 64.0f );

		// dynObjects[E_OBJ_P0]->init(512-256,1024-256,2048,   128,0,0,    true, true, &(dynObjects[E_OBJ_CAMERA]->pos), 64.0f );
		// dynObjects[E_OBJ_P1]->init(512,1024,2048,      255,0,0,  true, true, &(dynObjects[E_OBJ_CAMERA]->pos), 64.0f );
		// dynObjects[E_OBJ_P2]->init(1024,512,2048,      0,255,255,  true, true, &(dynObjects[E_OBJ_CAMERA]->pos), 64.0f );



		mouseX = 0.0f;
		mouseY = 0.0f;
		mouseXUp = 0.0f;
		mouseYUp = 0.0f;

		geomOrigOffset.setFXYZ(0.0f);






		
		frameCount = 0;
		forceGetPD = false;
		mapInvalid = true;
		notQuit = true;
		timerNotSet = true;
		screenWidth = defaultWinW;
		screenHeight = defaultWinH;
		mouseLeftDown = mouseRightDown = false;
		mouseX = mouseY = 0;



		
		glDepthFunc(GL_LESS);
		glCullFace(GL_BACK);
		glDisable(GL_CULL_FACE);
		

		
		glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
		glEnable(GL_TEXTURE_2D);
		glDisable(GL_DEPTH_TEST);
		glDisable(GL_LIGHTING);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glDisable(GL_BLEND);
		
		
		fsqDL = glGenLists(1);
		glNewList(fsqDL, GL_COMPILE);
		drawFSQuadOffset(0.0f, 0.0f, 1.0f);
		glEndList();
		
		
		if (USE_SPHERE_MAP) {
			shaderStrings.push_back("PrimShader_330_DOTER_USESPHEREMAP");
		}
		else {
			//shaderStrings.push_back("PrimShader_330_DOTER_DOPOLY");
			shaderStrings.push_back("PrimShader_330_DOTER");
		}
		shaderStrings.push_back("PrimShader_330_DOPRIM");
		
		
		
		shaderStrings.push_back("SolidCombineShader");
		shaderStrings.push_back("CylBBShader");
		shaderStrings.push_back("FXAAShader");
		shaderStrings.push_back("TerGenShader");
		shaderStrings.push_back("GUIShader");
		shaderStrings.push_back("MedianShader");
		shaderStrings.push_back("MergeShader");
		shaderStrings.push_back("TopoShader");
		shaderStrings.push_back("PointShader");
		shaderStrings.push_back("RoadShader");
		shaderStrings.push_back("SkeletonShader");
		shaderStrings.push_back("DilateShader");
		shaderStrings.push_back("TerrainMix");
		shaderStrings.push_back("Simplex2D");
		shaderStrings.push_back("WaveHeightShader");
		shaderStrings.push_back("WaterShader");
		shaderStrings.push_back("WaterShaderCombine");
		shaderStrings.push_back("CopyShader");
		shaderStrings.push_back("CopyShader2");
		shaderStrings.push_back("NoiseShader");
		shaderStrings.push_back("MapBorderShader");
		shaderStrings.push_back("BillboardShader");
		shaderStrings.push_back("PreLightingShader");
		shaderStrings.push_back("PostLightingShader");
		shaderStrings.push_back("BlurShader");
		shaderStrings.push_back("RadiosityShader");
		shaderStrings.push_back("RadiosityCombineShader");
		shaderStrings.push_back("FogShader");
		shaderStrings.push_back("OctShader");
		shaderStrings.push_back("GeomShader");
		shaderStrings.push_back("BoxShader");
		shaderStrings.push_back("PolyShader");
		shaderStrings.push_back("PolyCombineShader");
		//shaderStrings.push_back("SphereShader");
		//shaderStrings.push_back("BlitPointShader");
		//shaderStrings.push_back("HDRShader");
		//shaderStrings.push_back("DownScaleShader");
		//shaderStrings.push_back("CombineShader");
		//shaderStrings.push_back("GenerateVolume");
		//shaderStrings.push_back("GenerateVolumeEnt");
		//shaderStrings.push_back("RenderVolume");

		std::sort(shaderStrings.begin(), shaderStrings.end(), compareStruct);
		stringBuf.reserve(shaderStrings.size()*256);


		shaderTextureIds.push_back("Texture0");
		shaderTextureIds.push_back("Texture1");
		shaderTextureIds.push_back("Texture2");
		shaderTextureIds.push_back("Texture3");
		shaderTextureIds.push_back("Texture4");
		shaderTextureIds.push_back("Texture5");
		shaderTextureIds.push_back("Texture6");
		shaderTextureIds.push_back("Texture7");
		shaderTextureIds.push_back("Texture8");
		shaderTextureIds.push_back("Texture9");
		shaderTextureIds.push_back("Texture10");
		shaderTextureIds.push_back("Texture11");
		shaderTextureIds.push_back("Texture12");
		shaderTextureIds.push_back("Texture13");
		shaderTextureIds.push_back("Texture14");
		shaderTextureIds.push_back("Texture15");

		//setupLookups();

		for (i = 0; i < shaderStrings.size(); i++)
		{
			shaderMap.insert(  pair<string, Shader*>(shaderStrings[i], new Shader(this))  );
		}
		
		doShaderRefresh(false);
		
		int faceDim = 256;
		
		
		
		/////////////////////////
		/////////////////////////
		
		smoothTime = 0.0f;
		timeMod = true;
		resultShake = 0.0f;
		cameraShake = 0.0f;
		lastx = 0;
		lasty = 0;
		isMoving = false;
		updateMatFlag = false;
		matVolLock = false;
		perspectiveOn = false;
		lastPersp = false;


		for (i = 0; i < MAX_KEYS; i++) {
			keysPressed[i] = false;
			keyDownTimes[i] = 0.0;
			//keyUpTimes[i] = 0.0;
		}

		keyMap[KEYMAP_UP] = 'a';
		keyMapMaxCoolDown[KEYMAP_UP] = 3;
		keyMap[KEYMAP_DOWN] = 'z';
		keyMapMaxCoolDown[KEYMAP_DOWN] = 3;
		keyMap[KEYMAP_FORWARD] = 'e';
		keyMap[KEYMAP_BACKWARD] = 'd';
		keyMap[KEYMAP_LEFT] = 's';
		keyMap[KEYMAP_RIGHT] = 'f';
		keyMap[KEYMAP_FIRE_PRIMARY] = '6';
		keyMapMaxCoolDown[KEYMAP_FIRE_PRIMARY] = 20;
		keyMap[KEYMAP_GRAB] = 'w';
		keyMapMaxCoolDown[KEYMAP_GRAB] = 200;
		keyMap[KEYMAP_THROW] = 'y';
		keyMapMaxCoolDown[KEYMAP_THROW] = 200;
		
		/////////////////////////
		/////////////////////////
		
		
		
		
		/* (
				int _numBufs,
				int _width,
				int _height,
				int _bytesPerChannel,
				bool _hasDepth,
				int filterEnum = GL_NEAREST,
				int clampEnum = GL_CLAMP_TO_EDGE,
				bool isMultisample = false
		)*/
		
		
		//TODO: get rid of these
		//GL_LINEAR
		//fboMap["worldSpaceFBO"].init(4, bufferDim.getIX(), bufferDim.getIY(), 4, false, GL_NEAREST);
		//fboMap["wavesWorldSpaceFBO"].init(1, bufferDim.getIX(), bufferDim.getIY(), 4, false, GL_NEAREST);
		
		//fboMap["worldSpaceBlurFBO0"].init(1, bufferDim.getIX()/2, bufferDim.getIY()/2, 4, false, GL_LINEAR);
		//fboMap["worldSpaceBlurFBO1"].init(1, bufferDim.getIX()/2, bufferDim.getIY()/2, 4, false, GL_LINEAR);
		
		// fboMap["frontFaceFBO"].init(1, faceDim, faceDim, 4, false, GL_NEAREST);
		// fboMap["backFaceFBO"].init(1, faceDim, faceDim, 4, false, GL_NEAREST);
		// fboMap["frontFaceMapFBO"].init(1, bufferDim.getIX(), bufferDim.getIY(), 4, false, GL_NEAREST);
		// fboMap["backFaceMapFBO"].init(1, bufferDim.getIX(), bufferDim.getIY(), 4, false, GL_NEAREST);
		//fboMap["palFBO"].init(1, palWidth, palHeight, 1, false, GL_LINEAR);
		
		bool fboHasDepth = true;
		int numChannels = 4;
		int numMaps = 2;
		
		int tx = 0;
		int ty = 0;
		int tz = 0;
		int clampType;
		
		int vwChan = 1;
		bool doProc;
		int filterType;
		
		for (i = 0; i < E_VW_LENGTH; i++) {
			
			filterType = GL_LINEAR;
			vwChan = 1;
			doProc = true;
			
			switch (i) {
				
				// tx = 4096;
				// ty = 4096;
				// tz = 256;
				
				// tx = 2048;
				// ty = 1024;
				// tz = 128;
				case E_VW_HOLDER:
					tz = cellsPerHolder;
					clampType = GL_CLAMP_TO_EDGE; //GL_CLAMP_TO_BORDER
				break;
				case E_VW_WORLD:
					vwChan = 4;
					filterType = GL_NEAREST,
					tz = blocksPerWorld;
					clampType = GL_REPEAT; //GL_CLAMP_TO_BORDER
					if (!GEN_POLYS_WORLD) {
						doProc = false;
					}
				break;
				// case E_VW_TERGEN:
				// 	tz = 128;
				// 	clampType = GL_CLAMP_TO_EDGE;//GL_CLAMP_TO_BORDER
				// break;
				case E_VW_VORO:
					tz = 128;
					clampType = GL_REPEAT;
				break;
			}
			
			if (doProc) {
				volumeWrappers[i] = new VolumeWrapper();
				volumeWrappers[i]->init(tz, clampType, (vwChan==4), filterType ); //volumeWrapperStrings[i]
				//fboMap[volumeWrapperStrings[i]].init(1, tx, ty, vwChan, false);
			}
			
		}
		
		
		
		
		fboMap["prelightFBO"].init(4, bufferDimTarg.getIX(), bufferDimTarg.getIY(), 1, false, GL_LINEAR);
		
		// fboMap["allTargFBO"].init(6, bufferRenderDim.getIX(), bufferRenderDim.getIY(), numChannels, fboHasDepth);
		// fboMap["allDepthFBO"].init(numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, fboHasDepth, GL_LINEAR);
		
		
		fboMap["prmTargFBO"].init(8, bufferRenderDim.getIX(), bufferRenderDim.getIY(), numChannels, fboHasDepth);
		fboMap["prmDepthFBO"].init(numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, fboHasDepth, GL_LINEAR);
		
		fboMap["terTargFBO"].init(8, bufferRenderDim.getIX(), bufferRenderDim.getIY(), numChannels, fboHasDepth);
		fboMap["limbFBO"].init(1, bufferRenderDim.getIX(), bufferRenderDim.getIY(), numChannels, fboHasDepth);
		fboMap["terDepthFBO"].init(numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, fboHasDepth, GL_LINEAR);
		
		for (i = 0; i <= NUM_POLY_STRINGS; i++) {
			fboMap[polyFBOStrings[i]].init(1, bufferRenderDim.getIX(), bufferRenderDim.getIY(), 4, true);
		}
		
		
		
		if (USE_SPHERE_MAP) {
			fboMap["sphTargFBO"].init(8, bufferRenderDim.getIX()*SPHEREMAP_SCALE_FACTOR, bufferRenderDim.getIY()*SPHEREMAP_SCALE_FACTOR, numChannels, fboHasDepth);
			fboMap["sphDepthFBO"].init(numMaps, bufferDimTarg.getIX()*SPHEREMAP_SCALE_FACTOR, bufferDimTarg.getIY()*SPHEREMAP_SCALE_FACTOR, numChannels, fboHasDepth, GL_LINEAR, GL_REPEAT);
		}
		
		
		fboMap["solidBaseTargFBO"].init(numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, fboHasDepth);
		fboMap["solidTargFBO"].init(numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, fboHasDepth);
		
		
		fboMap["waterTargFBO"].init(numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, fboHasDepth);
		
		
		
		fboMap["swapTargFBO0"].init(numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, false);
		fboMap["swapTargFBO1"].init(numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, false);
		
		
		fboMap["geomBaseTargFBO"].init( numMaps+1, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, true);
		fboMap["geomTargFBO"].init(     numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, true);
		fboMap["combineWithWaterTargFBO"].init(numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, fboHasDepth);
		
		fboMap["debugTargFBO"].init(     numMaps, bufferDimTarg.getIX(), bufferDimTarg.getIY(), numChannels, true);
		
		
		
		
		// fboMap["noiseFBO"].init(1, 1024, 1024, 1, false, GL_NEAREST, GL_REPEAT);
		// fboMap["noiseFBOLinear"].init(1, 1024, 1024, 1, false, GL_LINEAR, GL_REPEAT);
		
		fboMap["noiseFBO"].init(1, bufferDim.getIX(), bufferDim.getIY(), 1, false, GL_NEAREST, GL_REPEAT);
		fboMap["noiseFBOLinear"].init(1, bufferDim.getIX(), bufferDim.getIY(), 1, false, GL_LINEAR, GL_REPEAT);
		//fboMap["guiFBO"].init(1, guiWinW, guiWinH, 1, false, GL_LINEAR);
		fboMap["resultFBO0"].init(1, bufferDim.getIX(), bufferDim.getIY(), 1, false, GL_NEAREST);
		fboMap["resultFBO1"].init(1, bufferDim.getIX(), bufferDim.getIY(), 1, false, GL_NEAREST);
		fboMap["lastFBO"].init(1, bufferDim.getIX(), bufferDim.getIY(), 1, false, GL_NEAREST);
		//fboMap["waveFBO"].init(1, bufferDim.getIX()/2, bufferDim.getIY()/2, 1, false, GL_LINEAR, GL_MIRRORED_REPEAT);
		fboMap["swapFBOLin0"].init(1, bufferDim.getIX(), bufferDim.getIY(), 1, false, GL_LINEAR);
		fboMap["swapFBOLin1"].init(1, bufferDim.getIX(), bufferDim.getIY(), 1, false, GL_LINEAR);
		fboMap["swapFBOBLin0"].init(1, bufferDim.getIX() / bufferDiv, bufferDim.getIY() / bufferDiv, 1, false, GL_LINEAR);
		fboMap["swapFBOBLin1"].init(1, bufferDim.getIX() / bufferDiv, bufferDim.getIY() / bufferDiv, 1, false, GL_LINEAR);
		fboMap["swapFBOLinHalf0"].init(1, bufferDim.getIX() / bufferDiv, bufferDim.getIY() / bufferDiv, 1, false, GL_LINEAR);
		fboMap["swapFBOLinHalf1"].init(1, bufferDim.getIX() / bufferDiv, bufferDim.getIY() / bufferDiv, 1, false, GL_LINEAR);
		fboMap["cityFBO"].init(1, newPitch, newPitch, 1, false, GL_NEAREST, GL_REPEAT);
		fboMap["hmFBO"].init(1, newPitch, newPitch, 1, false, GL_NEAREST, GL_REPEAT);
		fboMap["hmFBOLinear"].init(1, newPitch, newPitch, 1, false, GL_LINEAR, GL_REPEAT);
		fboMap["hmFBOLinearBig"].init(1, mapPitch, mapPitch, 1, false, GL_NEAREST, GL_REPEAT);
		fboMap["simplexFBO"].init(1, newPitch, newPitch, 1, false, GL_LINEAR, GL_REPEAT);
		fboMap["swapFBO0"].init(1, newPitch, newPitch, 1, false, GL_NEAREST, GL_REPEAT);
		fboMap["swapFBO1"].init(1, newPitch, newPitch, 1, false, GL_NEAREST, GL_REPEAT);
		
		
		loadConstants();
		
		// LEAVE THIS IN FOR VSYNC
		myDynBuffer = new DynBuffer();


		fontWrappers[EFW_ICONS] = new FontWrapper();
		fontWrappers[EFW_ICONS]->init(this, "icons", true, 1.0f, 0.0f);
		
		fontWrappers[EFW_TEXT] = new FontWrapper();
		fontWrappers[EFW_TEXT]->init(this, "arial_regular_14", false, 1.0f);

		mainGUI = new GameGUI();
		mainGUI->init(this);


		//loadAllData();

		GamePlant::initAllPlants(this);
		for (i = 0; i < E_PT_LENGTH/2; i++) {
			gamePlants[i] = new GamePlant();
		}


		gameOct = new GameOctree();
		gameOct->init(this,cellsPerWorld,true);

		gem = new GameEntManager();
		gem->init(this);
		gw = new GameWorld();
		
		
		
		
		//TODO: fix this for proper angle alignment to model
		//orientRotation();
		
		
		gw->init(this);
		gw->initMap();
		
		
		
		//bulletTest();
		
		gameAI = new GameAI();
		gameAI->init(this);
		
		
		// gem->gameObjects[E_OBJ_CAMERA] = BaseObj();
		// gem->gameObjects[E_OBJ_CAMERA].init(
		// 	E_OBJ_CAMERA,
		// 	0,
		// 	0,
		// 	1,
		// 	&lastCellPos,
		// 	5,5,5
		// );
		
		
		music[EML_BIRDSONG0]->play();
		music[EML_CRICKETS0]->play();
		music[EML_OCEANWAVES0]->play();
		music[EML_UNDERWATER0]->play();
		
		loadGUI();
		loadValuesGUI();
		
		if (bakeParamsOn) {
			doShaderRefresh(true);
		}
		
		
		
		
		
		
		

		allInit = true;
		
		doTraceND("GW DONE");


		popTrace();



	}
void Singleton::applyPat (int patInd, int patShape, int rot, int x, int y, int val, int rad)
          {
		int i;
		int j;
		int ind;
		
		bool doProc = false;
		
		int cenX;
		int cenY;
		
		switch(rot) {
			case 0:
				cenX = PATTERN_CENTER + x;
				cenY = PATTERN_CENTER + y;
			break;
			case 1:
				cenX = PATTERN_CENTER - y;
				cenY = PATTERN_CENTER + x;
			break;
			case 2:
				cenX = PATTERN_CENTER - x;
				cenY = PATTERN_CENTER - y;
			break;
			case 3:
				cenX = PATTERN_CENTER + y;
				cenY = PATTERN_CENTER - x;
			break;
		}
		
		cout << "\n\n";
		
		for (j = 0; j < PATTERN_SIZE; j++) {
			cout << "\n";
			for (i = 0; i < PATTERN_SIZE; i++) {
				ind = i + j*PATTERN_SIZE;
				
				doProc = false;
				switch (patShape) {
					case E_PATSHAPE_SQUARE:
						doProc = (
							(abs(i-cenX) <= rad) &&
							(abs(j-cenY) <= rad)
						);
					break;
					case E_PATSHAPE_DIAMOND:
						doProc = (
							(
								abs(i-cenX) +
								abs(j-cenY)	
							) <= rad
						);
					break;
				}
				
				if (doProc) {
					patterns[patInd*4+rot].patternVals[ind] = val;
					cout << "X";
				}
				else {
					cout << "O";
				}
			}
		}
		
	}
void Singleton::generatePatterns ()
                                {
		int q;
		
		int i;
		int j;
		int k;
		
		int xb;
		int yb;
		
		for (k = 0; k < 4; k++) {
			for (q = 0; q < E_PAT_LENGTH; q++) {
				switch (q) {
					case E_PAT_1X1SQUARE:
						applyPat(q,E_PATSHAPE_SQUARE,k,0,0,1,0);
					break;
					case E_PAT_3X3SQUARE:
						applyPat(q,E_PATSHAPE_SQUARE,k,0,0,1,1);
					break;
					case E_PAT_5X5SQUARE:
						applyPat(q,E_PATSHAPE_SQUARE,k,0,0,1,2);
					break;
					case E_PAT_1X1DIAMOND:
						applyPat(q,E_PATSHAPE_DIAMOND,k,0,0,1,0);
					break;
					case E_PAT_3X3DIAMOND:
						applyPat(q,E_PATSHAPE_DIAMOND,k,0,0,1,1);
					break;
					case E_PAT_5X5DIAMOND:
						applyPat(q,E_PATSHAPE_DIAMOND,k,0,0,1,2);
					break;
					
				}
			}
		}
		
		
		
		
	}
int Singleton::placeInStack ()
                           {
		int curId;
		int stackSize = emptyStack.size();
		if (stackSize > 0) {
			curId = emptyStack.back();
			emptyStack.pop_back();
			//compStack[curId].data = new UIComponent();
			compStack[curId].isValid = true;
			
			
			return curId;
		}
		else {
			compStack.push_back( CompStruct() );
			compStack.back().data = new UIComponent();
			compStack.back().isValid = true;
			
			
			return compStack.size() - 1;
			
		}
	}
int Singleton::placeInLayer (int nodeId, int layer)
                                                {
		// int curId;
		// if (emptyLayers[layer].size() > 0) {
		// 	curId = emptyLayers[layer].back();
		// 	emptyLayers[layer].pop_back();
		// 	guiLayers[layer][curId] = nodeId;
			
		// 	return curId;
		// }
		// else {
			guiLayers[layer].push_back(nodeId);	
			return guiLayers[layer].size() - 1;
			
		//}
	}
void Singleton::initAllMatrices ()
                               {
		int i;
		int j;
		int k;
		int m;
		int curOffset;
		
		for (k = 0; k < NUM_ORIENTATIONS; k++) {
			for (j = 0; j < NUM_ORIENTATIONS; j++) {
				for (i = 0; i < NUM_ORIENTATIONS; i++) {
					curOffset = (k*NUM_ORIENTATIONS*NUM_ORIENTATIONS + j*NUM_ORIENTATIONS + i)*16;
					
					for (m = 0; m < 16; m++) {
						ALL_ROT[curOffset+m] = 0.0f;
					}
					ALL_ROT[curOffset+15] = 1.0f;
					
					for (m = 0; m < 3; m++) {
						ALL_ROT[curOffset+0+m] = DIR_VECS[i][m];
						ALL_ROT[curOffset+4+m] = DIR_VECS[j][m];
						ALL_ROT[curOffset+8+m] = DIR_VECS[k][m];
					}
					
					
					
				}
			}
		}
		
	}
void Singleton::funcNT2 ()
                       {
		threadNetRecv.setRunningLocked(true);
		gameNetwork->updateRecv();
		threadNetRecv.setRunningLocked(false);
	}
void Singleton::startNT2 ()
                        {
		if (threadNetRecv.threadRunning) {
			
		}
		else {
			threadNetRecv.threadRunning = true;
			threadNetRecv.threadMain = std::thread(&Singleton::funcNT2, this);
		}
	}
bool Singleton::stopNT2 ()
                       {
		bool didStop = false;
		if (threadNetRecv.threadRunning) {
			threadNetRecv.threadMain.join();
			threadNetRecv.threadRunning = false;
			didStop = true;
		}
		return didStop;
	}
void Singleton::funcNT ()
                      {
		threadNetSend.setRunningLocked(true);
		gameNetwork->updateSend();
		threadNetSend.setRunningLocked(false);
	}
void Singleton::startNT ()
                       {
		if (threadNetSend.threadRunning) {
			
		}
		else {
			threadNetSend.threadRunning = true;
			threadNetSend.threadMain = std::thread(&Singleton::funcNT, this);
		}
	}
bool Singleton::stopNT ()
                      {
		bool didStop = false;
		
		if (threadNetSend.threadRunning) {
			threadNetSend.threadMain.join();
			threadNetSend.threadRunning = false;
			didStop = true;
		}
		return didStop;
		
	}
void Singleton::prepSound (string soundName)
                                         {
		if (soundMap.find( soundName ) == soundMap.end()) {
			soundMap.insert( pair<string, GameSound>(soundName, GameSound()) );
			soundMap[soundName].init("..\\data\\sounds\\"+soundName+".wav");
		}
	}
void Singleton::playSoundEnt (string soundName, BaseObj * ge, float variance, float volume, bool doLoop)
          {
		
		if (ge == NULL) {
			playSoundPosAndPitch(soundName,cameraGetPosNoShake(),cameraGetPosNoShake(),variance,volume,doLoop);
		}
		else {
			if (
				(ge->entType == E_ENTTYPE_TRACE) ||
				(ge->isHidden)	
			) {
				
			}
			else {
				playSoundPosAndPitch(soundName,cameraGetPosNoShake(),BTV2FIV(ge->getCenterPoint(E_BDG_CENTER)),variance,volume,doLoop);
			}
		}
		
		
		
		
	}
void Singleton::playSoundPosAndPitch (string soundName, FIVector4 * listenerPos, FIVector4 * soundPos, float variance, float volume, bool doLoop)
          {
		
		
		FIVector4 res;
		
		prepSound(soundName);
		
		res.setFXYZRef(soundPos);
		res.addXYZRef(listenerPos,-1.0f);
		
		soundMap[soundName].setPitch(
			(fGenRand()-0.5f)*2.0*variance + 1.0f
		);
		
		soundMap[soundName].setPositionAndMinDis(
			res.getFX(),
			res.getFY(),
			res.getFZ(),
			32.0f
		);
		
		soundMap[soundName].setLoop(doLoop);
		soundMap[soundName].play(volume*fxVolume*masterVolume);
	}
void Singleton::updateSoundPosAndPitch (string soundName, FIVector4 * listenerPos, FIVector4 * soundPos, float volume, float decay)
          {
		
		
		FIVector4 res;
		
		prepSound(soundName);
		
		res.setFXYZRef(soundPos);
		res.addXYZRef(listenerPos,-1.0f);
		
		
		soundMap[soundName].setPositionAndMinDis(
			res.getFX(),
			res.getFY(),
			res.getFZ(),
			32.0f
		);
		
		soundMap[soundName].setVolumeSmooth(volume,decay);
		
	}
void Singleton::playSound (string soundName, float volume)
                                                            {
		prepSound(soundName);
		soundMap[soundName].play(volume);
	}
void Singleton::playSoundEvent (char const * eventName, bool suppress)
                                                                          {
		
		if (suppress) {
			return;
		}
		
		string tempString;
		float volume;
		
		if (mainGUI != NULL) {
			if (mainGUI->isReady) {
				tempString = mainGUI->jvSounds->Child(eventName)->Child("name")->string_value;
				volume = mainGUI->jvSounds->Child(eventName)->Child("vol")->number_value;
				
				if (tempString.size() > 0) {
					playSound( tempString, masterVolume*volume*guiVolume );
				}
			}
		}
		
		
	}
void Singleton::updateMatVol ()
                            {
		
		
		
		matVolLock = true;
		
		JSONValue* jv = fetchJSONData("materials.js", false);
		JSONValue* curJV = NULL;
		JSONValue* curK = NULL;
		JSONValue* curJ = NULL;
		JSONValue* curI = NULL;
		JSONValue* curCol = NULL;
		
		int i;
		int j;
		int k;
		int m;
		int n;
		int p;
		int totN;
		
		int curInd0;
		int curInd0Prev;
		int curInd0Next;
		int curInd1;
		
		int mvInd;
		
		uint rv, gv, bv;
		
		joi_type itI;
		joi_type itJ;
		joi_type itK;
		
		float totRatio;
		float curLerp;
		float curLerpNoPower;
		float curPower;
		float curLerpWithPower;
		float curRatio;
		
		int mvx = matVolDim.getIX();
		int mvy = matVolDim.getIY();
		int mvz = matVolDim.getIZ();
		
		if (jv != NULL) {
			
			
			
			
			
			curJV = jv->Child("materials");
			
			k = 0;
			for (itK = curJV->object_value.begin(); itK != curJV->object_value.end(); itK++) {
				curK = itK->second;
				
				j = 0;
				for (itJ = curK->object_value.begin(); itJ != curK->object_value.end(); itJ++) {
					curJ = itJ->second;
					
					i = 0;
					totRatio = 0.0f;
					for (itI = curJ->object_value.begin(); itI != curJ->object_value.end(); itI++) {
						curI = itI->second;
						
						curInd0 = i+j*mvx;
						curCol = curI->Child("i0_color");
						
						
						matSlice0[curInd0].h = curCol->Child(0)->number_value;
						matSlice0[curInd0].s = curCol->Child(1)->number_value;
						matSlice0[curInd0].l = curCol->Child(2)->number_value;
						
						hsv2rgb(&(matSlice0[curInd0]));
						
						matSlice0[curInd0].power = curI->Child("i1_power")->number_value;
						matSlice0[curInd0].ratio = curI->Child("i2_ratio")->number_value;
						
						if (matSlice0[curInd0].ratio <= 0.0f) {
							matSlice0[curInd0].ratio = 1.0f/(mvx-1.0f);
						}
						
						totRatio += matSlice0[curInd0].ratio;
						
						i++;
					}
					
					
					if (i == 0) {
						
					}
					else {
						for (m = 0; m < i; m++) {
							curInd0 = m+j*mvx;
							matSlice0[curInd0].ratio = matSlice0[curInd0].ratio*(matVolDim.getFX()-1.0f)/totRatio;
						}
						
						
						totN = 0;
						for (m = 0; m < i; m++) {
							curInd0 = m+j*mvx;
							
							if (i == 1) {
								curInd0Prev = curInd0;
								curInd0Next = curInd0;
							}
							else {
								curInd0Prev = (m-1)+j*mvx;
								curInd0Next = (m+1)+j*mvx;
							}
							
							
							
							curRatio = matSlice0[curInd0].ratio;
							
							for (n = 0; (n < (curRatio+0.1f) )&&(totN < mvx); n++) {
								curLerp = ((float)n)/curRatio;
								curInd1 = totN + j*mvx;
								
								if (m == 0) {
									
									curLerpNoPower = curLerp*0.5f;
									curPower = mixf(matSlice0[curInd0].power,matSlice0[curInd0Next].power,curLerpNoPower);
									curLerpWithPower = pow(curLerpNoPower,curPower*8.0f);
									
									matSlice1[curInd1].r = mixf(matSlice0[curInd0].r,matSlice0[curInd0Next].r,curLerpWithPower);
									matSlice1[curInd1].g = mixf(matSlice0[curInd0].g,matSlice0[curInd0Next].g,curLerpWithPower);
									matSlice1[curInd1].b = mixf(matSlice0[curInd0].b,matSlice0[curInd0Next].b,curLerpWithPower);
								}
								else if (m == (i-1)) {
									curLerpNoPower = curLerp*0.5f+0.5f;
									curPower = mixf(matSlice0[curInd0Prev].power,matSlice0[curInd0].power,curLerpNoPower);
									curLerpWithPower = pow(curLerpNoPower,curPower*8.0f);
									
									matSlice1[curInd1].r = mixf(matSlice0[curInd0Prev].r,matSlice0[curInd0].r,curLerpWithPower);
									matSlice1[curInd1].g = mixf(matSlice0[curInd0Prev].g,matSlice0[curInd0].g,curLerpWithPower);
									matSlice1[curInd1].b = mixf(matSlice0[curInd0Prev].b,matSlice0[curInd0].b,curLerpWithPower);
								}
								else {
									
									
									if (curLerp < 0.5f) {
										curLerpNoPower = curLerp + 0.5f;
										curPower = mixf(matSlice0[curInd0Prev].power,matSlice0[curInd0].power,curLerpNoPower);
										curLerpWithPower = pow(curLerpNoPower,curPower*8.0f);
										
										matSlice1[curInd1].r = mixf(matSlice0[curInd0Prev].r,matSlice0[curInd0].r,curLerpWithPower);
										matSlice1[curInd1].g = mixf(matSlice0[curInd0Prev].g,matSlice0[curInd0].g,curLerpWithPower);
										matSlice1[curInd1].b = mixf(matSlice0[curInd0Prev].b,matSlice0[curInd0].b,curLerpWithPower);
									}
									else {
										curLerpNoPower = curLerp - 0.5f;
										curPower = mixf(matSlice0[curInd0].power,matSlice0[curInd0Next].power,curLerpNoPower);
										curLerpWithPower = pow(curLerpNoPower,curPower*8.0f);
										
										matSlice1[curInd1].r = mixf(matSlice0[curInd0].r,matSlice0[curInd0Next].r,curLerpWithPower);
										matSlice1[curInd1].g = mixf(matSlice0[curInd0].g,matSlice0[curInd0Next].g,curLerpWithPower);
										matSlice1[curInd1].b = mixf(matSlice0[curInd0].b,matSlice0[curInd0Next].b,curLerpWithPower);											
										
									}
									
									
									
								}
								
								
								
								totN++;
							}
							
							
						}
					}
						
					
					
					
					
					j++;
					
				}
				
				
				
				
				
				////////////////////
				
				
				
				
				
				for (p = 0; p < mvx; p++) {
					
					totN = 0;
					for (m = 0; m < j; m++) {
						curInd0 = p + m*mvx;
						
						if (j == 1) {
							curInd0Prev = curInd0;
							curInd0Next = curInd0;
						}
						else {
							curInd0Prev = p + (m-1)*mvx;
							curInd0Next = p + (m+1)*mvx;
						}
						
						
						
						if (j == 0) {
							curRatio = (float(mvy));
						}
						else {
							curRatio = (float(mvy))/(float(j));
						}
						
						
						for (n = 0; (n < (curRatio+0.1f))&&(totN < mvy); n++) {
							curLerp = ((float)n)/curRatio;
							curInd1 = p + totN*mvx;
							
							if (m == 0) {
								
								curLerpWithPower = curLerp*0.5f;
								
								matSlice2[curInd1].r = mixf(matSlice1[curInd0].r,matSlice1[curInd0Next].r,curLerpWithPower);
								matSlice2[curInd1].g = mixf(matSlice1[curInd0].g,matSlice1[curInd0Next].g,curLerpWithPower);
								matSlice2[curInd1].b = mixf(matSlice1[curInd0].b,matSlice1[curInd0Next].b,curLerpWithPower);
							}
							else if (m == (j-1)) {
								curLerpWithPower = curLerp*0.5f+0.5f;
								
								matSlice2[curInd1].r = mixf(matSlice1[curInd0Prev].r,matSlice1[curInd0].r,curLerpWithPower);
								matSlice2[curInd1].g = mixf(matSlice1[curInd0Prev].g,matSlice1[curInd0].g,curLerpWithPower);
								matSlice2[curInd1].b = mixf(matSlice1[curInd0Prev].b,matSlice1[curInd0].b,curLerpWithPower);
							}
							else {
								
								
								if (curLerp < 0.5f) {
									curLerpWithPower = curLerp + 0.5f;
									
									matSlice2[curInd1].r = mixf(matSlice1[curInd0Prev].r,matSlice1[curInd0].r,curLerpWithPower);
									matSlice2[curInd1].g = mixf(matSlice1[curInd0Prev].g,matSlice1[curInd0].g,curLerpWithPower);
									matSlice2[curInd1].b = mixf(matSlice1[curInd0Prev].b,matSlice1[curInd0].b,curLerpWithPower);
								}
								else {
									curLerpWithPower = curLerp - 0.5f;
									
									matSlice2[curInd1].r = mixf(matSlice1[curInd0].r,matSlice1[curInd0Next].r,curLerpWithPower);
									matSlice2[curInd1].g = mixf(matSlice1[curInd0].g,matSlice1[curInd0Next].g,curLerpWithPower);
									matSlice2[curInd1].b = mixf(matSlice1[curInd0].b,matSlice1[curInd0Next].b,curLerpWithPower);											
									
								}
								
								
								
							}
							
							
							
							mvInd = curInd1 + k*mvx*mvy;
							rv = matSlice2[curInd1].r*255.0f;
							gv = matSlice2[curInd1].g*255.0f;
							bv = matSlice2[curInd1].b*255.0f;
							matVol[mvInd] = (0 << 24) | (bv << 16) | (gv << 8) | (rv);
							
							
							
							
							totN++;
						}
						
						
					}
				}
				
				
				
				
				////////////////////
				
				
				
				
				
				
				
				
				
				
				k++;
			}
			
			
			
			glBindTexture(GL_TEXTURE_3D, 0);
			glBindTexture(GL_TEXTURE_3D, volIdMat);
			glTexSubImage3D(
				GL_TEXTURE_3D,
				0,

				0,
				0,
				0,

				mvx,
				mvy,
				mvz,

				GL_RGBA,
				GL_UNSIGNED_BYTE,

				matVol
			);
			glBindTexture(GL_TEXTURE_3D, 0);
			
			
			
		}
		
		
		
		matVolLock = false;	
		
	}
void Singleton::toggleDDMenu (int x, int y, bool toggled)
                                                      {
		
		if (placingGeom||gem->combatMode()) {
			return;
		}
		
		int ind = 0;
		bool objTargeted = false;
		bool actOnSel = false;
		UIComponent* tempComp;
		
		if (toggled) {
			
			ind = mouseDownOPD.getFW();
			
			objTargeted = ind >= E_OBJ_LENGTH;	
			
			
			
			if (objTargeted) {
				gem->setSelInd(ind);				
			}
			else {
				getMarkerPos(x, y);
				markerFound = true;
				gem->setSelInd(0);
			}
			
			
			actOnSel = 
				objTargeted &&
				(gem->selObjInd != gem->actObjInd) &&
				(gem->actObjInd >= E_OBJ_LENGTH);
			
			tempComp = getGUIComp("ddMenu.placeEntity");
			if (tempComp != NULL) {tempComp->enabled = !objTargeted;}
			tempComp = getGUIComp("ddMenu.removeEntity");
			if (tempComp != NULL) {tempComp->enabled = objTargeted;}
			tempComp = getGUIComp("ddMenu.editEntity");
			if (tempComp != NULL) {tempComp->enabled = objTargeted;}
			tempComp = getGUIComp("ddMenu.changeMaterial");
			if (tempComp != NULL) {tempComp->enabled = objTargeted;}
			
			tempComp = getGUIComp("ddMenu.attack");
			if (tempComp != NULL) {tempComp->enabled = actOnSel;}
			tempComp = getGUIComp("ddMenu.talkTo");
			if (tempComp != NULL) {tempComp->enabled = actOnSel;}
			tempComp = getGUIComp("ddMenu.engageWith");
			if (tempComp != NULL) {tempComp->enabled = actOnSel;}
			tempComp = getGUIComp("ddMenu.pickPocket");
			if (tempComp != NULL) {tempComp->enabled = actOnSel;}
			tempComp = getGUIComp("ddMenu.tradeWith");
			if (tempComp != NULL) {tempComp->enabled = actOnSel;}
			
			
			
			tempComp = getGUIComp("ddMenu.menuBar");
			if (tempComp != NULL) {
				if (objTargeted) {
					tempComp->setText(gem->objStrings[gem->gameObjects[gem->selObjInd].objectType ]);
				}
				else {
					tempComp->setText("Context Menu");
				}
				
			}
			
			menuList[E_FM_DDMENU]->isDirty = true;
			menuList[E_FM_DDMENU]->visible = true;
			ddMenuBar = menuList[E_FM_DDMENU]->getChild(0)->getChild(0);
			ddMenuBar->lastDrag.x = (guiX);
			ddMenuBar->lastDrag.y = min((float)(guiY), (float)( (guiWinH - menuList[E_FM_DDMENU]->getChild(0)->resultDimInPixels.y) ));
			ddMenuBar->forceDragUpdate = true;
		}
		else {
			menuList[E_FM_DDMENU]->visible = false;
			markerFound = false;
		}
	}
void Singleton::dispatchEvent (int button, int state, float x, float y, UIComponent * comp, bool automated, bool preventRefresh)
          {
		
		UIComponent* tempComp;
		
		
		BaseObj* tmpObj = NULL;
		
		StatSheet* curStatSheet;
		
		bool hitPicker = false;
		bool wasDoubleClick = false;
		
		float wheelDelta = 0.0f;
		
		double tempTime = myTimer.getElapsedTimeInMilliSec();
		
		int i;
		int j;
		
		int cbDataCount;
		JSONValue* cbData = NULL;
		
		bool doSPUpdate = false;
		bool mouseUpEvent = false;
		bool mouseDownEvent = false;
		
		float curValue = comp->getValue();
		float curValueY = comp->getValueY();
		
		draggingMap = false;
		
		bool noTravel = false;
		bool isInteractiveComp = false;
		bool suppressSound = false;
		
		float newVal;
		float oldVal;
		float difVal;
		
		
		switch (comp->guiClass) {
			case E_GT_SLIDER:
			case E_GT_BUTTON:
			case E_GT_RADIO:
			case E_GT_CHECK:
			case E_GT_DRAGPAD:
					isInteractiveComp = true;
			break;
			default:
				if (comp->jvNodeNoTemplate->HasChild("interactive")) {
					isInteractiveComp = true;
				}
			break;
		}
		
		suppressSound = automated||(!isInteractiveComp);
		
		
		switch(button) {
			case GLUT_NO_BUTTON:
			
				
				
				switch(state) {
					case GLUT_OVER:
						playSoundEvent("mouseOver",suppressSound);
					break;
					case GLUT_OUT:
						playSoundEvent("mouseOut",suppressSound);
					break;
					case GLUT_CHANGING:
						if (comp->guiClass == E_GT_DRAGPAD) {
							
							if (comp->uid.compare("map.mapHolder") == 0) {
								cameraPos->setFXYZRef(&baseCameraPos);
								
								cameraPos->addXYZ(
									-(x - comp->dragStart.x)*((float)cellsPerWorld)/(cameraZoom*comp->resultDimInPixels.x),
									-(y - comp->dragStart.y)*((float)cellsPerWorld)/(cameraZoom*comp->resultDimInPixels.y),
									0.0f
								);
								
								camLerpPos.copyFrom(cameraPos);
								
								
								
								
								draggingMap = true;
							}
							
						}
						else {
							doSPUpdate = true;
						}
						
					break;
				}
				
			break;
			case GLUT_LEFT_BUTTON:
			
			
				if (state == GLUT_DOWN) {
					playSoundEvent("mouseDown",suppressSound);
					
					if (comp->uid.compare("map.mapHolder") == 0) {
						baseCameraPos.setFXYZRef(cameraPos);
					}
					
					mouseDownEvent = true;
					mdTime = myTimer.getElapsedTimeInMilliSec();
				}
				else {
					playSoundEvent("mouseUp",suppressSound);
					
					if (comp->guiClass == E_GT_DRAGPAD) {
						
					}
					else {
						doSPUpdate = true;
						mouseUpEvent = true;
					}
					
					
				}
			break;
			
			case 3: // wheel up
				frameMouseMove = true;
				wheelDelta = 1.0f / 20.0f;
				break;

			case 4: // wheel down
				frameMouseMove = true;
				wheelDelta = -1.0f / 20.0f;
				break;
			
			
		}
		
		if (mouseUpEvent) {
			if (!automated) {
				noTravel = mouseEnd.distance(&mouseStart) < MAX_TRAVEL_DIS;
				
				if (lastNodeId == comp->nodeId) {
					
					if ( (tempTime-clickTime) < 500 ) {
						wasDoubleClick = true;
					}
					
				}
				
				clickTime = tempTime;
				lastNodeId = comp->nodeId;
			}
		}
		
		
		
		if (comp->uid.compare("map.mapHolder") == 0) {
			
			
			zoomDelta += wheelDelta;
			
			if (zoomDelta < 0.0) {
				zoomDelta = 0.0;
			}
			
			
			targetZoom = pow(2.0, zoomDelta);
			if (!ignoreFrameLimit) {
				cameraZoom = targetZoom;
			}
			
		}
		
		if (gem->handleGUI(
			comp, mouseUpEvent, mouseDownEvent, noTravel, wasDoubleClick	
		)) {
			goto DISPATCH_EVENT_END;
		}
		
		
		
		
		
		
		if (mouseUpEvent) {
			
			
			if (comp->uid.compare("charEdit.savePose") == 0) {
				saveOrg();
			}
			else if (comp->uid.compare("charEdit.loadPose") == 0) {
				loadOrg();
			}
			else if (comp->uid.compare("$charEdit.orgOn") == 0) {
				gem->orgOn = curValue != 0.0f;
			}
			else if (comp->uid.compare("$charEdit.pathfindingOn") == 0) {
				//pathfindingOn = curValue != 0.0f;
			}
			else if (comp->uid.compare("$charEdit.editPose") == 0) {
				gem->editPose = curValue != 0.0f;
				EDIT_POSE = gem->editPose;
			}
			else if (comp->uid.compare("$charEdit.mirrorOn") == 0) {
				gem->mirrorOn = curValue != 0.0f;
			}
			else if (comp->uid.compare("$charEdit.applyToChildren") == 0) {
				applyToChildren = curValue != 0.0f;
			}
			else if (comp->uid.compare("fieldMenu.ok") == 0) {
				endFieldInput(true);
			}
			else if (comp->uid.compare("fieldMenu.cancel") == 0) {
				endFieldInput(false);
			}
			else if (comp->uid.compare("#materialPicker") == 0) {
				gem->updateOrgMat(comp);
			}
			else if (comp->uid.compare("statMenu.apply") == 0) {
				if (gem->getCurActor() != NULL) {	
					curStatSheet = &(gem->getCurActor()->statSheet);
					
					for (i = 0; i < E_CS_LENGTH; i++) {
						curStatSheet->baseStats[i] = curStatSheet->unapplyedStats[i];
					}
					
				}
			}
			else if (comp->uid.compare("statMenu.reset") == 0) {
				if (gem->getCurActor() != NULL) {
					curStatSheet = &(gem->getCurActor()->statSheet);
					
					
					
					for (i = 0; i < E_CS_LENGTH; i++) {
						
						while (curStatSheet->unapplyedStats[i] > curStatSheet->baseStats[i]) {
							curStatSheet->unapplyedStats[i] -= 1;
							curStatSheet->availPoints += 1;
						}
						
						tempComp = getGUIComp("statMenu.statParent")->getChild(i);
						tempComp->setValue(
							curStatSheet->unapplyedStats[i]/tempComp->divisions
						);
						
					}
					
					tempComp = getGUIComp("statMenu.availPoints");
					tempComp->setValue(
						curStatSheet->availPoints/tempComp->divisions
					);
					
					
				}
			}
			
			if (comp->guiClass == E_GT_BUTTON) {
				toggleDDMenu(x,y,false);
			}
			
		}
		
		
		if (comp->uid.compare("$options.sound.masterVolume") == 0) {
			
			masterVolume = curValue;
			
		}
		else if (comp->uid.compare("$options.sound.ambientVolume") == 0) {
			ambientVolume = curValue;
		}
		else if (comp->uid.compare("$options.sound.guiVolume") == 0) {
			guiVolume = curValue;
		}
		else if (comp->uid.compare("$options.sound.musicVolume") == 0) {
			musicVolume = curValue;
		}
		else if (comp->uid.compare("$options.sound.fxVolume") == 0) {
			fxVolume = curValue;
		}
		else if (comp->uid.compare("$options.graphics.clipDist") == 0) {
			
			clipDist[1] = curValue*4096.0f*4.0;
			
		}
		else if (comp->uid.compare("$options.graphics.maxHeight") == 0) {
			
			//heightMapMaxInCells = curValue*8192.0f;
			
		}
		else if (comp->uid.compare("$options.graphics.fov") == 0) {
			FOV = mixf(5.0f,120.0f,curValue);
			focalLength = 1.0f / tan(FOV / 2.0f);
			
		}
		else if (comp->uid.compare("$options.graphics.sphereMapPrec") == 0) {
			sphereMapPrec = mixf(0.0f,200.0f,curValue);
		}
		else if (comp->uid.compare("#statMenu.stat") == 0) {
			if (gem->getCurActor() != NULL) {
				
				curStatSheet = &(gem->getCurActor()->statSheet);
				
				oldVal = curStatSheet->unapplyedStats[comp->index];
				newVal = roundVal(curValue*comp->divisions);
				difVal = newVal-oldVal;
				
				tempComp = getGUIComp("statMenu.availPoints");
				
				curStatSheet->availPoints -= difVal;
				curStatSheet->unapplyedStats[comp->index] = newVal;
				
				while (curStatSheet->availPoints < 0) {
					curStatSheet->availPoints += 1;
					curStatSheet->unapplyedStats[comp->index] -= 1;
				}
				
				while (curStatSheet->unapplyedStats[comp->index] < curStatSheet->baseStats[comp->index]) {
					curStatSheet->availPoints -= 1;
					curStatSheet->unapplyedStats[comp->index] += 1;
				}
				
				
				comp->setValue(
					curStatSheet->unapplyedStats[comp->index]/comp->divisions
				);
				tempComp->setValue(
					curStatSheet->availPoints/tempComp->divisions
				);
				
				
				
				
				
			}
			
		}
		
		
		
		if (
			(button == GLUT_LEFT_BUTTON) ||
			(state == GLUT_CHANGING)	
		) {
			if (comp->uid.compare("#materialVal") == 0) {
				updateMatFlag = true;
			}
			
		}
		
		
		
		
		
		
		
		
		
		if (comp->jvNodeNoTemplate != NULL) {
			if (comp->jvNodeNoTemplate->HasChild("callback")) {
				curCallback = comp->jvNodeNoTemplate->Child("callback")->string_value;
				
				if (comp->jvNodeNoTemplate->HasChild("callbackData")) {
					
					cbData = comp->jvNodeNoTemplate->Child("callbackData");
				
					// cbDataCount = cbData->CountChildren();
					// for (i = 0; i < cbDataCount; i++) {
					// 	cbDataStrings[i] = cbData->Child(i)->string_value;
					// }
				
				}
				
				if (doSPUpdate) {
					if (curCallback.compare("updateShaderParam") == 0) {
						
						if (cbData != NULL) {
							
							
							cbDataStrings[0] = cbData->Child("shaderName")->string_value;
							cbDataStrings[1] = cbData->Child("paramName")->string_value;
							
							
							
							shaderMap[cbDataStrings[0]]->paramMap[cbDataStrings[1]] = curValue;
							
							
							
						}
					}
				}
				
				
			}
		}
		
DISPATCH_EVENT_END:
		
		if (mouseMoved) {
			mouseMoved = false;
		}
		if (mouseUpEvent) {
			gem->isDraggingObject = false;
		}
	}
StyleSheet * Singleton::getNewStyleSheet (string ssName)
                                                    {
		styleSheetMap[ssName].init();
		return &(styleSheetMap[ssName]);
	}
void Singleton::initStyleSheet ()
                              {
		
		int i;
		int j;
		
		StyleSheet* mainSS = getNewStyleSheet("defaultSS");
		StyleSheetState* curState = &(mainSS->compStates[E_COMP_UP]);
		
		
		
		curState->setVal(E_SS_BGCOL0_R, 0.2f, 0.15f, 0.1f, 1.0f);
		curState->setVal(E_SS_BGCOL1_R, 0.1f, 0.075f, 0.05f, 0.5f);
		curState->setVal(E_SS_FGCOL0_R, 0.0f, 0.0f, 0.0f, 0.0f);
		curState->setVal(E_SS_FGCOL1_R, 0.0f, 0.0f, 0.0f, 0.0f);
		curState->setVal(E_SS_TGCOL0_R, 1.0f, 0.75f, 0.0f, 1.0f);
		curState->setVal(E_SS_TGCOL1_R, 1.0f, 0.25f, 0.0f, 0.5f);
		curState->setVal(E_SS_BGCOLTEXT0_R, 0.0f, 0.0f, 0.0f, 0.0f);
		curState->setVal(E_SS_BGCOLTEXT1_R, 0.0f, 0.0f, 0.0f, 0.0f);
		curState->setVal(E_SS_FGCOLTEXT0_R, 1.0f, 1.0f, 1.0f, 1.0f);
		curState->setVal(E_SS_FGCOLTEXT1_R, 1.0f, 0.8f, 0.7f, 1.0f);
		curState->setVal(E_SS_BDCOL_R, 1.0f, 1.0f, 1.0f, 0.5f);

		curState->props[E_SS_PADDING] = 2.0f;
		curState->props[E_SS_BORDER] = 1.0f;
		curState->props[E_SS_MARGIN] = 2.0f;
		curState->props[E_SS_CORNERRAD] = 4.0f;
		curState->props[E_SS_ROUNDNESS] = 1.0f;

		mainSS->compStates[E_COMP_OVER].copyFrom(& (mainSS->compStates[E_COMP_UP]) );
		mainSS->compStates[E_COMP_DOWN].copyFrom(& (mainSS->compStates[E_COMP_UP]) );

		
		
		curState = &(mainSS->compStates[E_COMP_OVER]);
		
		
		curState->setVal(E_SS_FGCOLTEXT0_R, 1.0f, 1.0f, 1.0f, 1.0f);
		curState->setVal(E_SS_FGCOLTEXT1_R, 1.0f, 1.0f, 1.0f, 1.0f);
		curState->props[E_SS_BDCOL_A] = 1.0f;
		
		curState->setVal(E_SS_BGCOL0_R, 0.1f, 0.075f, 0.05f, 1.0);
		curState->setVal(E_SS_BGCOL1_R, 0.05f, 0.025f, 0.0125f, 0.5);
		
		
		
		curState = &(mainSS->compStates[E_COMP_DOWN]);
		
		
		curState->setVal(E_SS_FGCOLTEXT0_R, 1.0f, 0.8f, 0.7f, 1.0f);
		curState->setVal(E_SS_FGCOLTEXT1_R, 1.0f, 1.0f, 1.0f, 1.0f);
		curState->props[E_SS_BDCOL_A] = 1.0f;
		curState->props[E_SS_BORDER] = 2.0f;

		curState->setVal(E_SS_BGCOL0_R, 0.05f, 0.025f, 0.0125f, 0.5f);	
		curState->setVal(E_SS_BGCOL1_R, 0.1f, 0.075f, 0.05f, 1.0f);	
		
		
		
		StyleSheet* tooltipSS = getNewStyleSheet("tooltipSS");
		tooltipSS->copyFrom(mainSS);
		
		curState = &(tooltipSS->compStates[E_COMP_UP]);
		curState->setVal(E_SS_BGCOL0_R, 0.0f, 0.0f, 0.0f, 1.0f);
		curState->setVal(E_SS_BGCOL1_R, 0.0f, 0.0f, 0.0f, 1.0f);
		curState->setVal(E_SS_FGCOLTEXT0_R, 1.0f, 0.75f, 0.0f, 1.0f);
		curState->setVal(E_SS_FGCOLTEXT1_R, 1.0f, 0.75f, 0.0f, 1.0f);
		curState->setVal(E_SS_BDCOL_R, 1.0f, 0.75f, 0.0f, 1.0f);
		tooltipSS->compStates[E_COMP_OVER].copyFrom(& (tooltipSS->compStates[E_COMP_UP]) );
		tooltipSS->compStates[E_COMP_DOWN].copyFrom(& (tooltipSS->compStates[E_COMP_UP]) );

		curState = &(tooltipSS->compStates[E_COMP_OVER]);
		curState = &(tooltipSS->compStates[E_COMP_DOWN]);
		
		
		
		
		StyleSheet* headerSS = getNewStyleSheet("headerSS");
		headerSS->copyFrom(mainSS);
		
		curState = &(headerSS->compStates[E_COMP_UP]);
		curState->setVal(E_SS_BGCOL0_R, 0.2f, 0.1f, 0.0f, 1.0f);
		curState->setVal(E_SS_BGCOL1_R, 0.1f, 0.05f, 0.0f, 1.0f);
		curState->setVal(E_SS_FGCOLTEXT0_R, 1.0f, 0.75f, 0.0f, 1.0f);
		curState->setVal(E_SS_FGCOLTEXT1_R, 1.0f, 0.75f, 0.0f, 1.0f);
		curState->setVal(E_SS_BDCOL_R, 1.0f, 0.75f, 0.0f, 1.0f);
		headerSS->compStates[E_COMP_OVER].copyFrom(& (headerSS->compStates[E_COMP_UP]) );
		headerSS->compStates[E_COMP_DOWN].copyFrom(& (headerSS->compStates[E_COMP_UP]) );

		curState = &(headerSS->compStates[E_COMP_OVER]);
		curState = &(headerSS->compStates[E_COMP_DOWN]);
		
		
		
		StyleSheet* sectionSS = getNewStyleSheet("sectionSS");
		sectionSS->copyFrom(mainSS);
		
		for (i = 0; i < E_COMP_TOTAL; i++) {
			curState = &(sectionSS->compStates[i]);
			curState->setVal(E_SS_FGCOLTEXT0_R, 0.5f, 0.5f, 0.5f, 1.0f);
			curState->setVal(E_SS_FGCOLTEXT1_R, 0.4f, 0.4f, 0.4f, 1.0f);
			curState->setVal(E_SS_BGCOL0_R, 0.2f, 0.2f, 0.2f, 1.0f);
			curState->setVal(E_SS_BGCOL1_R, 0.1f, 0.1f, 0.1f, 0.5f);
		}
		
		StyleSheet* redSS = getNewStyleSheet("redSS");
		redSS->copyFrom(mainSS);
		
		for (i = 0; i < E_COMP_TOTAL; i++) {
			curState = &(redSS->compStates[i]);
			curState->setVal(E_SS_BGCOL0_R, 1.0f, 0.1f, 0.2f, 1.0f);
			curState->setVal(E_SS_BGCOL1_R, 0.8f, 0.05f, 0.1f, 0.75f);
		}
		
		
		
		StyleSheet* greenSS = getNewStyleSheet("greenSS");
		greenSS->copyFrom(mainSS);
		
		for (i = 0; i < E_COMP_TOTAL; i++) {
			curState = &(greenSS->compStates[i]);
			curState->setVal(E_SS_BGCOL0_R, 0.0f, 1.0f, 0.5f, 1.0f);
			curState->setVal(E_SS_BGCOL1_R, 0.0f, 0.8f, 0.8f, 0.5f);
		}
		
		
		StyleSheet* spacerSS = getNewStyleSheet("spacerSS");
		spacerSS->copyFrom(mainSS);
		
		for (i = 0; i < E_COMP_TOTAL; i++) {
			curState = &(spacerSS->compStates[i]);
			
			for (j = 0; j <= E_SS_BDCOL_R; j += 4) {
				curState->setVal(j, 0.0f, 0.0f, 0.0f, 0.0f);
			}
			
		}
		
		
		
	}
void Singleton::qNormalizeAngle (int & angle)
        {
		while (angle < 0)
		{
			angle += 360 * 16;
		}
		while (angle > 360 * 16)
		{
			angle -= 360 * 16;
		}
	}
Singleton::~ Singleton ()
        {
		if (gw)
		{
			delete gw;
		}
	}
void Singleton::setProgAction (eProgramState ps, unsigned char kc, eProgramAction pa, bool isDown)
        {

		if (isDown)
		{
			progActionsDown[ps * 256 + kc] = pa;
		}
		else
		{
			progActionsUp[ps * 256 + kc] = pa;
		}
	}
void Singleton::setProgActionAll (unsigned char kc, eProgramAction pa, bool isDown)
        {
		int i;

		for (i = 0; i < E_PS_SIZE; i++)
		{
			setProgAction((eProgramState)i, kc, pa, isDown);
		}

	}
void Singleton::drawCrossHairs (FIVector4 originVec, float radius)
        {
		FIVector4 minV;
		FIVector4 maxV;

		float xm;
		float ym;
		float zm;

		float maxRad = 4096.0f;

		int i;
		for (i = 0; i < 3; i++)
		{

			switch (i)
			{
			case 0:
				xm = maxRad;
				ym = radius;
				zm = radius;
				break;
			case 1:
				xm = radius;
				ym = maxRad;
				zm = radius;
				break;
			case 2:
				xm = radius;
				ym = radius;
				zm = maxRad;
				break;
			}

			minV.setFXYZ(
				originVec.getFX() - xm,
				originVec.getFY() - ym,
				originVec.getFZ() - zm
			);

			maxV.setFXYZ(
				originVec.getFX() + xm,
				originVec.getFY() + ym,
				originVec.getFZ() + zm
			);

			drawBox(&minV, &maxV);
		}


	}
void Singleton::drawLine (FIVector4 * p0, FIVector4 * p1)
        {
		

		glBegin(GL_LINES);
		glMultiTexCoord3f(GL_TEXTURE0, 0.0f, 0.0f, 0.0f);
		glVertex3f(p0->getFX(), p0->getFY(), p0->getFZ());
		glMultiTexCoord3f(GL_TEXTURE0, 0.0f, 0.0f, 1.0f);
		glVertex3f(p1->getFX(), p1->getFY(), p1->getFZ());
		glEnd();
	}
void Singleton::drawCubeCentered (FIVector4 * originVec, float radius)
        {
		FIVector4 minV;
		FIVector4 maxV;

		minV.setFXYZ(
			originVec->getFX() - radius,
			originVec->getFY() - radius,
			originVec->getFZ() - radius
		);

		maxV.setFXYZ(
			originVec->getFX() + radius,
			originVec->getFY() + radius,
			originVec->getFZ() + radius
		);

		drawBox(&minV, &maxV);
	}
void Singleton::drawBoxUp (FIVector4 originVec, float radiusX, float radiusY, float diamZ)
        {
		FIVector4 minV;
		FIVector4 maxV;

		minV.setFXYZ(
			originVec.getFX() - radiusX,
			originVec.getFY() - radiusY,
			originVec.getFZ()
		);

		maxV.setFXYZ(
			originVec.getFX() + radiusX,
			originVec.getFY() + radiusY,
			originVec.getFZ() + diamZ
		);

		drawBox(&minV, &maxV);
	}
void Singleton::drawBoxMinMax (btVector3 v0, btVector3 v1)
          {
		tempVec1.setBTV(v0);
		tempVec2.setBTV(v1);
		drawBox(&tempVec1,&tempVec2);
	}
void Singleton::drawBoxRad (btVector3 v0, btVector3 v1)
          {
		tempVec1.setBTV(v0-v1);
		tempVec2.setBTV(v0+v1);
		drawBox(&tempVec1,&tempVec2);
	}
void Singleton::drawBox (FIVector4 * v0, FIVector4 * v1, int faceFlag)
          {


		float minX = min(v0->getFX(),v1->getFX());
		float minY = min(v0->getFY(),v1->getFY());
		float minZ = min(v0->getFZ(),v1->getFZ());

		float maxX = max(v0->getFX(),v1->getFX());
		float maxY = max(v0->getFY(),v1->getFY());
		float maxZ = max(v0->getFZ(),v1->getFZ());


		bool drawFront = false;
		bool drawBack = false;
		
		switch(faceFlag) {
			case 0:
				drawBack = true;
			break;
			case 1:
				drawFront = true;
			break;
			case 2:
				drawBack = true;
				drawFront = true;
			break;
		}

		glBegin(GL_QUADS);


		if (drawFront) {
			// front
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, -1.0f, 1.0f);
			glVertex3f(minX, minY, maxZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, -1.0f, 1.0f);
			glVertex3f(maxX, minY, maxZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, 1.0f, 1.0f);
			glVertex3f(maxX, maxY, maxZ);
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, 1.0f, 1.0f);
			glVertex3f(minX, maxY, maxZ);
			// right
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, -1.0f, 1.0f);
			glVertex3f(maxX, minY, maxZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, -1.0f, -1.0f);
			glVertex3f(maxX, minY, minZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, 1.0f, -1.0f);
			glVertex3f(maxX, maxY, minZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, 1.0f, 1.0f);
			glVertex3f(maxX, maxY, maxZ);
			// top
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, 1.0f, 1.0f);
			glVertex3f(minX, maxY, maxZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, 1.0f, 1.0f);
			glVertex3f(maxX, maxY, maxZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, 1.0f, -1.0f);
			glVertex3f(maxX, maxY, minZ);
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, 1.0f, -1.0f);
			glVertex3f(minX, maxY, minZ);
		}
		
		
		if (drawBack) {
			// back
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, -1.0f, -1.0f);
			glVertex3f(minX, minY, minZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, -1.0f, -1.0f);
			glVertex3f(maxX, minY, minZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, 1.0f, -1.0f);
			glVertex3f(maxX, maxY, minZ);
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, 1.0f, -1.0f);
			glVertex3f(minX, maxY, minZ);
			// left
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, -1.0f, 1.0f);
			glVertex3f(minX, minY, maxZ);
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, -1.0f, -1.0f);
			glVertex3f(minX, minY, minZ);
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, 1.0f, -1.0f);
			glVertex3f(minX, maxY, minZ);
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, 1.0f, 1.0f);
			glVertex3f(minX, maxY, maxZ);
			// bottom
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, -1.0f, 1.0f);
			glVertex3f(minX, minY, maxZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, -1.0f, 1.0f);
			glVertex3f(maxX, minY, maxZ);
			glMultiTexCoord3f(GL_TEXTURE0, 1.0f, -1.0f, -1.0f);
			glVertex3f(maxX, minY, minZ);
			glMultiTexCoord3f(GL_TEXTURE0, -1.0f, -1.0f, -1.0f);
			glVertex3f(minX, minY, minZ);
		}
		
		

		glEnd();
	}
void Singleton::getMaterialString ()
                                 {
		string resString = "\n";
		
		JSONValue* jv = fetchJSONData("materials.js", false);
		
		if (jv != NULL) {
			JSONValue* jv2 = jv->Child("materials");
			JSONValue* curChild;
			
			int numChildren = jv2->CountChildren();
			int i;
			
			string lastKey;
			
			for (i = 0; i < numChildren; i++) {
				curChild = jv2->Child(i);
				lastKey = jv2->lastKey;
				
				splitStrings.clear();
				splitStrings = split(lastKey, '_');
				
				resString.append("const float TEX_"+splitStrings[1]+"="+i__s(i)+".0/255.0;\n");
				
			}
			
			resString.append("\n");
			
			includeMap["materials"] = resString;
			
		}
		
	}
bool Singleton::getPrimTemplateString ()
                                     {
		
		primTemplateStack.clear();
		
		JSONValue* jv = fetchJSONData("primTemplates.js",true);		
		JSONValue* jv2 = jv->Child("primTemplates");
		JSONValue* jv3 = NULL;
		JSONValue* jv4 = NULL;
		
		int i;
		int j;
		int k;
		
		int tempInd;
		
		int numTemplates = jv2->CountChildren();
		int numProps = 0;
		int numFields = 0;
		
		int propCount = 0;
		int maxProps = numTemplates*E_PRIMTEMP_LENGTH;
		
		float curNumber;
		
		string resString = "";
		resString.append("const int PRIMS_PER_MACRO = " + i__s(gameFluid[E_FID_BIG]->primsPerMacro) + ";\n");
		resString.append("const int VECS_PER_PRIM = " + i__s(gameFluid[E_FID_BIG]->floatsPerPrimEntry/4) + ";\n");
		resString.append("const float PRIM_DIV = " + i__s(gameFluid[E_FID_BIG]->primDiv) + ".0;\n");
		
		
		for (i = 0; i < numTemplates; i++) {
			jv3 = jv2->Child(i);
			numProps = jv3->CountChildren() - 1; //minus one for comment
			if (numProps != E_PRIMTEMP_LENGTH) {
				cout << "ERROR: invalid number of properties\n";
				return false;
			}
			
			tempInd = propCount;
			
			for (j = 0; j < numProps; j++) {
				jv4 = jv3->Child(j);
				numFields = jv4->CountChildren();
				if (numFields != 4) {
					cout << "ERROR: invalid number of fields\n";
					return false;
				}
				
				primTemplateStack.push_back(FIVector4());
								
				for (k = 0; k < numFields; k++) {
					curNumber = jv4->Child(k)->number_value;
					primTemplateStack.back().setIndex(k, curNumber);
				}
				
				propCount++;
				
			}
			
			primTemplateStack[tempInd + E_PRIMTEMP_VISMIN].multXYZRef(
					&(primTemplateStack[tempInd + E_PRIMTEMP_BOUNDSMIN])
			);
			primTemplateStack[tempInd + E_PRIMTEMP_VISMAX].multXYZRef(
					&(primTemplateStack[tempInd + E_PRIMTEMP_BOUNDSMAX])
			);
			
			
		}
		
		resString.append("const vec4 primTemp[" + i__s(numTemplates*E_PRIMTEMP_LENGTH) + "] = vec4[](\n");
		
		numFields = 4;
		
		for (i = 0; i < primTemplateStack.size(); i++) {
			resString.append("vec4(");
			for (k = 0; k < numFields; k++) {
				curNumber = primTemplateStack[i][k];
				resString.append( f__s(curNumber) );
				if (k < numFields-1) {
					resString.append(",");
				}
			}
			resString.append(")");
			
			if (i < (primTemplateStack.size()-1) ) {
				resString.append(",");
			}
			
			resString.append("\n");
		}
		
		resString.append(");\n");
		
		//cout << resString << "\n";
		
		includeMap["primTemplates"] = resString;
		
		return true;
	}
void Singleton::refreshIncludeMap ()
                                 {
		getMaterialString();
		getPrimTemplateString();
	}
void Singleton::doShaderRefresh (bool doBake)
        {

		loadConstants();

		LAST_COMPILE_ERROR = false;

		readyToRecompile = 0;

		int i;
		int j;
		
		Shader* curShader;
		
		refreshIncludeMap();


		// this is expensive
		for (i = 0; i < shaderStrings.size(); i++) {
			shaderMap[ shaderStrings[i] ]->init(shaderStrings[i] , doBake, &includeMap);
		}
		
		//"../src/glsl/" + shaderStrings[i] + ".c"
		
		if (DO_SHADER_DUMP) {
			cout << "SHADER_DUMP\n";
			saveFileString("..\\data\\temp.txt", &globString);
		}
		
		
		shadersAreLoaded = 1;
		readyToRecompile = 1;
		
		if (LAST_COMPILE_ERROR) {
			
		}
		else {
			
			// load saved data (if exists)
			// merge saved data with existing data (if exists)
			// save merged data to saved data
			
			
			
			stringBuf = "{\n\t\"params\":[\n";
			
			
			
			for (i = 0; i < shaderStrings.size(); i++) {
				curShader = shaderMap[ shaderStrings[i] ];
				
				std::sort(curShader->paramVec.begin(), curShader->paramVec.end(), compareStruct);
				
				for (j = 0; j < curShader->paramVec.size(); j++) {
					stringBuf.append("\t\t{");
					stringBuf.append("\"shaderName\":\""+shaderStrings[i]+"\",");
					stringBuf.append("\"paramName\":\""+curShader->paramVec[j]+"\",");
					stringBuf.append("\"uid\":\"$shaderParams."+shaderStrings[i]+"."+curShader->paramVec[j]+"\"");
					stringBuf.append("},\n");
				}
			}
			
			stringBuf[stringBuf.size()-2] = ' ';
			
			
			stringBuf.append("\t]\n}\n\n");
			
			// this should automatically clear the key
			// and deallocate existing entries
			
			processJSONFromString(
				&stringBuf,
				&(externalJSON["E_SDT_SHADERPARAMS"].jv)
			);
			
			
			
		}
		

	}
void Singleton::setWH (int w, int h)
        {

		baseW = w;
		baseH = h;
	}
void Singleton::sampleFBODirect (FBOSet * fbos, int offset, int _minOff, int _maxOff)
          {
		int i;
		
		int minOff = _minOff;
		int maxOff = _maxOff;
		if (maxOff == -1) {
			maxOff = fbos->numBufs;
		}
		
		if (shadersAreLoaded) {
			for (i = minOff; i < maxOff; i++) {
				setShaderTexture(i - minOff + offset, fbos->fbos[i].color_tex);
			}
		}
	}
void Singleton::unsampleFBODirect (FBOSet * fbos, int offset, int _minOff, int _maxOff)
          {
		int i;
		
		int minOff = _minOff;
		int maxOff = _maxOff;
		if (maxOff == -1) {
			maxOff = fbos->numBufs;
		}
		
		if (shadersAreLoaded) {
			for (i = maxOff - 1; i >= minOff; i--) {
				setShaderTexture(i - minOff + offset, 0);
			}
		}
	}
void Singleton::bindFBODirect (FBOSet * fbos, int doClear)
        {
		setMatrices(fbos->width, fbos->height);
		
		fbos->bind(doClear);
		currentFBOResolutionX = fbos->width;
		currentFBOResolutionY = fbos->height;
	}
FBOSet * Singleton::getFBOByName (string & fboName)
                                              {
		
		if (fboMap.find( fboName ) == fboMap.end()) {
			cout << "invalid key " << fboName << "\n";
			exit(0);
		}
		
		return &(fboMap[fboName]);
	}
void Singleton::sampleFBO (string fboName, int offset, int swapFlag, int minOff, int maxOff)
          {
		FBOSet *fbos;

		if (swapFlag == -1)
		{
			fbos = getFBOByName(fboName);//&(fboMap[fboName]);
		}
		else
		{

			if (swapFlag == 0)
			{
				fbos = getFBOByName(fboName + "0");
			}
			else
			{
				fbos = getFBOByName(fboName + "1");
			}

		}

		if (fbos)
		{
			sampleFBODirect(fbos, offset, minOff, maxOff);
		}
		else
		{
			doTrace("sampleFBO: Invalid FBO Name");
		}


	}
void Singleton::unsampleFBO (string fboName, int offset, int swapFlag, int minOff, int maxOff)
                {

		FBOSet *fbos;

		if (swapFlag == -1)
		{
			fbos = getFBOByName(fboName);
		}
		else
		{

			if (swapFlag == 0)
			{
				fbos = getFBOByName(fboName + "0");
			}
			else
			{
				fbos = getFBOByName(fboName + "1");
			}

		}

		if (fbos)
		{
			unsampleFBODirect(fbos, offset, minOff, maxOff);
		}
		else
		{
			doTrace("unsampleFBO: Invalid FBO Name");
		}

	}
FBOSet * Singleton::getFBOSet (string fboName)
        {
		return getFBOByName(fboName);
	}
FBOWrapper * Singleton::getFBOWrapper (string fboName, int offset)
        {
		FBOSet *fbos = getFBOByName(fboName);
		return fbos->getFBOWrapper(offset);
	}
void Singleton::copyFBO (string src, string dest, int num)
        {
		bindShader("CopyShader");
		bindFBO(dest);
		//sampleFBO(src, 0);
		setShaderTexture(0, getFBOWrapper(src,num)->color_tex);
		drawFSQuad();
		setShaderTexture(0, 0);
		unbindFBO();
		unbindShader();
	}
void Singleton::copyFBO2 (string src, string dest, int num1, int num2)
        {
		bindShader("CopyShader2");
		bindFBO(dest);
		setShaderTexture(0, getFBOWrapper(src,num1)->color_tex);
		setShaderTexture(1, getFBOWrapper(src,num2)->color_tex);
		drawFSQuad();
		setShaderTexture(1, 0);
		setShaderTexture(0, 0);
		unbindFBO();
		unbindShader();
	}
void Singleton::bindFBO (string fboName, int swapFlag, int doClear)
        {

		FBOSet *fbos;

		if (swapFlag == -1)
		{
			fbos = getFBOByName(fboName);
		}
		else
		{

			if (swapFlag == 0)
			{
				fbos = getFBOByName(fboName + "1");
			}
			else
			{
				fbos = getFBOByName(fboName + "0");
			}

		}

		if (fbos)
		{
			bindFBODirect(fbos, doClear);
		}
		else
		{
			doTrace("bindFBO: Invalid FBO Name");
		}


	}
void Singleton::unbindFBO ()
        {
		
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
		setMatrices(baseW, baseH);

	}
void Singleton::bindShader (string shaderName)
        {
		
		int i;
		int totSize;


		if (shaderMap.find( shaderName ) == shaderMap.end()) {
			cout << "invalid shader name " << shaderName << "\n";
			exit(0);
		}

		if (shadersAreLoaded)
		{
			curShader = shaderName;
			curShaderPtr = shaderMap[curShader];
			curShaderPtr->bind();
			
			totSize = curShaderPtr->paramVec.size();
			
			if (bakeParamsOn) {
				
			}
			else {
				for (i = 0; i < totSize; i++) {
					
					// if (curShaderPtr->paramVec[i].compare("lightColBNight")) {
					// 	cout << curShaderPtr->paramMap[curShaderPtr->paramVec[i]] << "\n";
					// }
					
					setShaderFloat(
						curShaderPtr->paramVec[i],
						curShaderPtr->paramMap[curShaderPtr->paramVec[i]]
					);
				}
			}
			
		}

	}
void Singleton::unbindShader ()
        {
		if (shadersAreLoaded)
		{
			curShaderPtr->unbind();
		}
	}
void Singleton::setShaderArrayfVec3 (string paramName, float * x, int count)
        {
		curShaderPtr->setShaderArrayfVec3(paramName, x, count);
	}
void Singleton::setShaderArrayfVec4 (string paramName, float * x, int count)
        {
		curShaderPtr->setShaderArrayfVec4(paramName, x, count);
	}
void Singleton::setShaderMatrix4x4 (string paramName, float * x, int count)
        {
		curShaderPtr->setShaderMatrix4x4(paramName, x, count);
	}
void Singleton::setShaderMatrix3x3 (string paramName, float * x, int count)
        {
		curShaderPtr->setShaderMatrix3x3(paramName, x, count);
	}
void Singleton::setShaderArray (string paramName, float * x, int count)
        {
		curShaderPtr->setShaderArray(paramName, x, count);
	}
GLint Singleton::getShaderLoc (string paramName)
                                             {
		return curShaderPtr->getShaderLoc(paramName);
	}
void Singleton::setShaderFloat (string paramName, float x)
        {
		curShaderPtr->setShaderFloat(paramName, x);
	}
void Singleton::setShaderInt (string paramName, int x)
        {
		curShaderPtr->setShaderInt(paramName, x);
	}
void Singleton::setShaderfVec2 (string paramName, FIVector4 * v)
        {
		curShaderPtr->setShaderfVec2(paramName, v);
	}
void Singleton::setShaderVec2 (string paramName, float x, float y)
        {
		curShaderPtr->setShaderVec2(paramName, x, y);
	}
void Singleton::setShaderVec3 (string paramName, float x, float y, float z)
        {
		curShaderPtr->setShaderVec3(paramName, x, y, z);
	}
void Singleton::setShaderfVec3 (string paramName, FIVector4 * v)
        {
		curShaderPtr->setShaderfVec3(paramName, v);
	}
void Singleton::setShaderbtVec3 (string paramName, btVector3 v)
        {
		curShaderPtr->setShaderbtVec3(paramName, v);
	}
void Singleton::setShaderVec4 (string paramName, float x, float y, float z, float w)
        {
		curShaderPtr->setShaderVec4(paramName, x, y, z, w);
	}
void Singleton::setShaderfVec4 (string paramName, FIVector4 * v)
        {
		curShaderPtr->setShaderfVec4(paramName, v);
	}
void Singleton::setShaderFloatUB (string paramName, float x)
        {
		curShaderPtr->setShaderFloatUB(paramName, x);
	}
void Singleton::setShaderfVec4UB (string paramName, FIVector4 * v)
        {
		curShaderPtr->setShaderfVec4UB(paramName, v);
	}
void Singleton::updateUniformBlock (int ubIndex, int ubDataSize)
        {
		curShaderPtr->updateUniformBlock(ubIndex, ubDataSize);
	}
void Singleton::invalidateUniformBlock (int ubIndex)
        {
		curShaderPtr->invalidateUniformBlock(ubIndex);
	}
void Singleton::beginUniformBlock (int ubIndex)
        {
		curShaderPtr->beginUniformBlock(ubIndex);
	}
bool Singleton::wasUpdatedUniformBlock (int ubIndex)
        {

		return curShaderPtr->wasUpdatedUniformBlock(ubIndex);

	}
void Singleton::setShaderTBO (int multitexNumber, GLuint tbo_tex, GLuint tbo_buf, bool isFloat)
        {
		if (shadersAreLoaded)
		{
			glActiveTexture(GL_TEXTURE0 + multitexNumber);
			glBindTexture(GL_TEXTURE_2D, tbo_tex);
			if (tbo_tex != 0) {
				if (isFloat) {
					glTexBuffer(GL_TEXTURE_BUFFER, GL_RGBA32F, tbo_buf);
				}
				else {
					glTexBuffer(GL_TEXTURE_BUFFER, GL_RGBA32UI, tbo_buf);
				}
				
			}
			curShaderPtr->setShaderInt(shaderTextureIds[multitexNumber] , multitexNumber);
		}
	}
void Singleton::setShaderTexture (int multitexNumber, uint texId)
        {
		if (shadersAreLoaded)
		{
			glActiveTexture(GL_TEXTURE0 + multitexNumber);
			glBindTexture(GL_TEXTURE_2D, texId);
			curShaderPtr->setShaderInt(shaderTextureIds[multitexNumber] , multitexNumber);
		}
	}
void Singleton::setShaderTexture3D (int multitexNumber, uint texId)
        {
		if (shadersAreLoaded)
		{
			glActiveTexture(GL_TEXTURE0 + multitexNumber);
			glBindTexture(GL_TEXTURE_3D, texId);
			curShaderPtr->setShaderInt(shaderTextureIds[multitexNumber], multitexNumber);
		}
	}
bool Singleton::shiftDown ()
        {
		return (bool)(glutGetModifiers()&GLUT_ACTIVE_SHIFT);
	}
bool Singleton::ctrlDown ()
        {
		return (bool)(glutGetModifiers()&GLUT_ACTIVE_CTRL);
	}
bool Singleton::altDown ()
        {
		return (bool)(glutGetModifiers()&GLUT_ACTIVE_ALT);
	}
void Singleton::drawQuadWithCoords (FIVector4 * p0, FIVector4 * p1, FIVector4 * p2, FIVector4 * p3, float tx1, float ty1, float tx2, float ty2)
          {
		//glColor4f(1, 1, 1, 1);
		//glNormal3f(0, 0, 1);
		
		glBegin(GL_QUADS);

		glTexCoord2f(tx1, ty1);
		glVertex3f(p0->getFX(), p0->getFY(), p0->getFZ());

		glTexCoord2f(tx2, ty1);
		glVertex3f(p1->getFX(), p1->getFY(), p1->getFZ());

		glTexCoord2f(tx2, ty2);
		glVertex3f(p2->getFX(), p2->getFY(), p2->getFZ());

		glTexCoord2f(tx1, ty2);
		glVertex3f(p3->getFX(), p3->getFY(), p3->getFZ());

		glEnd();
	}
void Singleton::drawQuadBounds (float fx1, float fy1, float fx2, float fy2, float fz)
          {
		//glColor4f(1, 1, 1, 1);
		//glNormal3f(0, 0, 1);
		
		glBegin(GL_QUADS);

		glTexCoord2f(0.0f, 0.0f);
		glVertex3f(fx1, fy1, fz);

		glTexCoord2f(1.0f, 0.0f);
		glVertex3f(fx2, fy1, fz);

		glTexCoord2f(1.0f, 1.0f);
		glVertex3f(fx2, fy2, fz);

		glTexCoord2f(0.0f, 1.0f);
		glVertex3f(fx1, fy2, fz);

		glEnd();
	}
void Singleton::drawFSQuad ()
        {
		glCallList(fsqDL);
	}
void Singleton::drawFSQuadOffset (float xOff, float yOff, float zm)
        {
		float fx0 = (xOff - 1.0f) * zm;
		float fy0 = (yOff - 1.0f) * zm;
		float fx1 = (xOff + 1.0f) * zm;
		float fy1 = (yOff + 1.0f) * zm;

		glBegin(GL_QUADS);
		//glColor4f(1, 1, 1, 1);
		//glNormal3f(0, 0, 1);

		glTexCoord2f(0.0f, 0.0f);
		glVertex3f(fx0, fy0, 0.0f);

		glTexCoord2f(1.0f, 0.0f);
		glVertex3f(fx1, fy0, 0.0f);

		glTexCoord2f(1.0f, 1.0f);
		glVertex3f(fx1, fy1, 0.0f);

		glTexCoord2f(0.0f, 1.0f);
		glVertex3f(fx0, fy1, 0.0f);

		glEnd();
	}
void Singleton::drawFBO (string fboName, int ind, float zm, int swapFlag)
        {
		if (swapFlag == -1)
		{
			drawFBOOffset(fboName, ind, 0.0f, 0.0f, zm);
		}
		else
		{
			if (swapFlag == 0)
			{
				drawFBOOffset(fboName + "1", ind, 0.0f, 0.0f, zm);
			}
			else
			{
				drawFBOOffset(fboName + "0", ind, 0.0f, 0.0f, zm);
			}

		}
	}
void Singleton::drawFBOOffsetDirect (FBOSet * fbos, int ind, float xOff, float yOff, float zm)
        {

		glBindTexture(GL_TEXTURE_2D, fbos->fbos[ind].color_tex);
		//glClearColor(0.2,0.2,0.2,0.0);
		//glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		drawFSQuadOffset(xOff, yOff, zm);
		glBindTexture(GL_TEXTURE_2D, 0);
	}
void Singleton::drawFBOOffset (string fboName, int ind, float xOff, float yOff, float zm)
        {
		FBOSet *fbos = getFBOByName(fboName);

		if (fbos)
		{
			drawFBOOffsetDirect(fbos, ind, xOff, yOff, zm);
		}
		else
		{
			doTrace("drawFBOOffsetDirect: Invalid FBO Name");
		}

	}
float Singleton::getTerHeightScaled (float val)
        {
		return val*heightMapMaxInCells;
	}
float Singleton::getSLNormalized ()
        {
		return (((float)gw->seaLevel) / 255.0f);
	}
float Singleton::getSeaHeightScaled ()
        {
		return getSLNormalized()*heightMapMaxInCells;
	}
float Singleton::getHeightAtPixelPos (float x, float y, bool dd)
        {
		FBOWrapper *fbow;
		float xc;
		float yc;

		int channel = 0;

		float testHeight;
		
		float v0 = 0.0f;
		float v1 = 0.0f;
		float v2 = 0.0f;
		float v3 = 0.0f;
		
		
		if (mapInvalid)
		{

			cout << "mapInvalid\n";
			return 0.0f;

		}
		else
		{
			FBOWrapper *fbow = getFBOWrapper("hmFBO", 0);

			xc = (x / ((float)cellsPerWorld)) * ((float)fbow->width);
			yc = (y / ((float)cellsPerWorld)) * ((float)fbow->height);

			v0 = fbow->getPixelAtLinear((xc * mapFreqs.getFX()), (yc * mapFreqs.getFX()), channel);
			v1 = fbow->getPixelAtLinear((xc * mapFreqs.getFY()), (yc * mapFreqs.getFY()), channel);
			v2 = fbow->getPixelAtLinear((xc * mapFreqs.getFZ()), (yc * mapFreqs.getFZ()), channel);
			v3 = fbow->getPixelAtLinear((xc * mapFreqs.getFW()), (yc * mapFreqs.getFW()), channel);

			



			if (dd) {
				//cout << "hmvals: " << v0 << ", " << v1 << ", " << v2 << ", " << v3 << "\n";
			}
			

			testHeight = 
				  v0 * mapAmps.getFX()
				+ v1 * mapAmps.getFY()
				+ v2 * mapAmps.getFZ()
				+ v3 * mapAmps.getFW()
				
				// - v1 * mapAmps.getFY()*0.5f
				// - v2 * mapAmps.getFZ()*0.5f
				// - v3 * mapAmps.getFW()*0.5f
				
			;
			
			if (dd) {
				//cout << "testHeight " << testHeight << "\n";
			}

			testHeight = clampf(testHeight,0.0f,1.0f);

			return getTerHeightScaled(testHeight);



		}



	}
void Singleton::angleToVec (FIVector4 * fv, float xr, float yr)
                                                           {
		fv->setFXYZ(
			cos(xr)*sin(yr),
			sin(xr)*sin(yr),
			cos(yr)
		);
		fv->normalize();
	}
void Singleton::vecToAngle (FIVector4 * fv, FIVector4 * ta)
                                                       {
		
		ta->setFXYZ(
			atan2(fv->getFY(),fv->getFX()),
			acos(fv->getFZ()),
			0.0f	
		);
	}
void Singleton::syncObjects ()
                           {
		int i;
		float xrp;
		float yrp;
		
		float xrotrad = getCamRot(0);
		float yrotrad = getCamRot(1);
		
		
		
		for (i = 1; i < E_OBJ_LENGTH; i++)
		{

			if (dynObjects[i]->moveType == E_MT_TRACKBALL) {
				
				xrp = xrotrad +	dynObjects[i]->posTrackball.getFX()/200.0f;
				yrp = yrotrad + dynObjects[i]->posTrackball.getFY()/200.0f;
				
				angleToVec(&tempVec1,xrp,yrp);
				tempVec1.multXYZ(dynObjects[i]->posTrackball.getFZ()*0.5f + 2.0f);
				
				
				dynObjects[i]->pos.copyFrom(cameraGetPosNoShake());
				dynObjects[i]->pos.addXYZRef( &(tempVec1) );
				
			}
			else {
				if (dynObjects[i]->moveType == E_MT_RELATIVE) {
					dynObjects[i]->pos.copyFrom(cameraGetPosNoShake());
					dynObjects[i]->pos.addXYZRef( &(dynObjects[i]->posRel) );
				}
			}
		}
		
		
		
	}
void Singleton::updateCamVals ()
                             {
		
		
		if (camLerpPos.getFX() > ((float)cellsPerWorld) / 2.0)
		{
			camLerpPos.setFX( camLerpPos.getFX() - ((float)cellsPerWorld) );
		}
		if (camLerpPos.getFX() < -((float)cellsPerWorld) / 2.0)
		{
			camLerpPos.setFX( camLerpPos.getFX() + ((float)cellsPerWorld) );
		}
		if (camLerpPos.getFY() > ((float)cellsPerWorld) / 2.0)
		{
			camLerpPos.setFY( camLerpPos.getFY() - ((float)cellsPerWorld) );
		}
		if (camLerpPos.getFY() < -((float)cellsPerWorld) / 2.0)
		{
			camLerpPos.setFY( camLerpPos.getFY() + ((float)cellsPerWorld) );
		}
		
		
		if (cameraPos->getFX() > ((float)cellsPerWorld) / 2.0)
		{
			cameraPos->setFX( cameraPos->getFX() - ((float)cellsPerWorld) );
		}
		if (cameraPos->getFX() < -((float)cellsPerWorld) / 2.0)
		{
			cameraPos->setFX( cameraPos->getFX() + ((float)cellsPerWorld) );
		}
		if (cameraPos->getFY() > ((float)cellsPerWorld) / 2.0)
		{
			cameraPos->setFY( cameraPos->getFY() - ((float)cellsPerWorld) );
		}
		if (cameraPos->getFY() < -((float)cellsPerWorld) / 2.0)
		{
			cameraPos->setFY( cameraPos->getFY() + ((float)cellsPerWorld) );
		}
		
		if (smoothMove) {
			
			
			// tempLerpPos.copyFrom(cameraPos);
			// tempLerpPos.lerpXYZ(&camLerpPos,0.1f);
			
			//&camLerpPos);
			// tempLerpPos.addXYZRef(cameraPos,-1.0f);
			// tempLerpPos.multXYZ(timeDelta*8.0f);
			
			cameraPos->lerpXYZ(&camLerpPos,conVals[E_CONST_CAM_LERP_AMOUNT]);
			
			amountInvalidMove = camLerpPos.length();
			depthInvalidMove = amountInvalidMove > 0.01f;
			
			//cameraPos->addXYZRef(&tempLerpPos);
			
		}
		else {
			cameraPos->copyFrom(&camLerpPos);
		}
		
		
		lastHolderPos.copyIntDiv(cameraPos,cellsPerHolder);
		
		
		resultShake = -cameraShake*sin(shakeTimer.getElapsedTimeInMilliSec()/20.0f);
		
		resultCameraPos.copyFrom(cameraPos);
		resultCameraPos.addXYZ(0.0f,0.0f,resultShake*0.5f);
		
		cameraShake += (0.0f - cameraShake)*timeDelta*8.0f;
		

	}
void Singleton::moveCamera (FIVector4 * pModXYZ)
        {
		
		int i;
		
		if (
				(pModXYZ->getFX() != 0.0) ||
				(pModXYZ->getFY() != 0.0) ||
				(pModXYZ->getFZ() != 0.0)
		) {
			
			if (!smoothMove) {
				amountInvalidMove = pModXYZ->length();
				depthInvalidMove = amountInvalidMove > 0.01f;
			}
			
			wsBufferInvalid = true;
		}
		
		camLerpPos.addXYZRef(pModXYZ);
		
		//cameraPos->addXYZRef(pModXYZ);

		//pModXYZ->setFZ(0.0f);
		
		
		
	}
GLfloat Singleton::getCamRot (int ind)
                                   {
		
		return curCamRotation[ind];
		
	}
void Singleton::moveObject (float dx, float dy)
        {
		

		int i;
		int j;
		int diffx;
		int diffy;
		
		
		GameOrgNode* curNode;


		float deltaMod = 1.0f/32.0f;
		
		modXYZ.setFXYZ(0.0f,0.0f,0.0f);

		float dxZM = dx;
		float dyZM = dy;

		bool doDefault = false;
		
		
		
		
		//////////
		
		
		float xmod = 0.0f;
		float ymod = 0.0f;
		float zmod = 0.0f;
		float xrotrad = getCamRot(0);
		float yrotrad = getCamRot(1);
		
		

		
		
		
		
		//////////
		
		
		
		
				

		if (abDown) {
			
			if ( shiftDown() ) { //rbDown || 
				zmod += dy;

			}
			else {
				
				xmod += float(sin(yrotrad))*dy;
				ymod += float(cos(yrotrad))*dy;
				//zmod -= float(cos(xrotrad))*dy;

				xmod += float(cos(yrotrad))*(dx); //??
				ymod -= float(sin(yrotrad))*(dx);
			}
			
			modXYZ.setFXYZ(
				xmod*4.0f,
				ymod*4.0f,
				zmod*4.0f
			);
			



		}
		
		
		if (
			(gem->orgOn) && 
			(gem->activeNode != NULL) &&
			gem->editPose
		) {
			gem->applyNodeChanges(gem->activeNode, dx, dy);
		}
		else {
			if (
				shiftDown() && 
				(mouseState == E_MOUSE_STATE_BRUSH) && 
				lbDown
			) {
				
				curBrushRad -= modXYZ.getFZ() / 50.0f;
				if (curBrushRad < 0.0f)
				{
					curBrushRad = 0.0f;
				}

			}
			else {
				if (mouseState == E_MOUSE_STATE_BRUSH) {
					doDefault = true;
				}
				else {

					if (activeObject == E_OBJ_CAMERA) {
						doDefault = true;
					}
					else {
						
						if (dynObjects[activeObject]->moveType == E_MT_TRACKBALL) {
							if (lbDown&&rbDown) {
								dynObjects[activeObject]->posTrackball.addXYZ(0.0f,0.0f,dy*deltaMod);
							}
							else {
								dynObjects[activeObject]->posTrackball.addXYZ(dx,dy,0.0f);
							}
							
						}
						else {
							if (dynObjects[activeObject]->moveType == E_MT_RELATIVE) {
								dynObjects[activeObject]->posRel.addXYZRef(&modXYZ, -1.0f);
							}
							else {
								dynObjects[activeObject]->pos.addXYZRef(&modXYZ, -1.0f);
							}
						}
						
					}
				}

				if (doDefault)
				{
					
					
					if (
						rbDown
						//&&( (gem->getCurActor()==NULL) || (gem->editPose)	)
					) {
						
						camRotation[0] -= dx*0.01f;
						camRotation[1] += dy*0.01f;
					}
					
				}
				


			}
		}
		


		






	}
void Singleton::updateMultiLights ()
        {
		if (multiLights)
		{
			numDynLights = E_OBJ_LENGTH - E_OBJ_LIGHT0;
		}
		else
		{
			numDynLights = 1;
		}
	}
void Singleton::toggleFullScreen ()
        {
		isFullScreen = !isFullScreen;
		if (isFullScreen)
		{
			glutFullScreen();
		}
		else
		{
			glutPositionWindow(250, 50);
		}
	}
void Singleton::setCameraToElevation ()
                                    {

		float newHeight = getHeightAtPixelPos(cameraGetPosNoShake()->getFX(), cameraGetPosNoShake()->getFY());
		
		newHeight = max(newHeight,getSeaHeightScaled()+64.0f);
		
		float curHeight = cameraGetPosNoShake()->getFZ();

		cout << "curHeight " << curHeight << " newHeight " << newHeight << "\n";

		modXYZ.setFXYZ(
			0.0,
			0.0,
			128.0f + newHeight - curHeight
		);
		
		moveCamera(&modXYZ);
		cameraGetPosNoShake()->copyFrom(&camLerpPos);

	}
btVector3 Singleton::screenToWorld (float mx, float my, float camAng)
          {
		
		//Matrix4 matProjection = viewMatrix*projMatrix;
		//Matrix4 matInverse = matProjection.invert();

		// Matrix4 matInverse(viewMatrixDI);

		// Vector4 vIn = Vector4(
		// 	(2.0f*mx)-1.0f,
		// 	1.0f-(2.0f*my),
		// 	0.5, //2.0f*mz-1.0f;
		// 	1.0f
		// );
		
		float baseAng = atan2(1.0f-(2.0f*my),(2.0f*mx)-1.0f);
		baseAng += camAng + M_PI/2.0f;
		
		
		
		
		// Vector4 pos = matInverse * vIn;

		// pos.w = 1.0 / pos.w;
		// pos.x *= pos.w;
		// pos.y *= pos.w;
		// pos.z *= pos.w;
		
		//return btVector3(pos.x, pos.y, pos.z);

		return btVector3(cos(baseAng),sin(baseAng),0.0f);

	}
btVector3 Singleton::getRayTo (float x, float y)
                                             {

		//float top = 1.f;
		//float bottom = -1.f;
		//float nearPlane = 1.f;
		// float tanFov = //(top-bottom)*0.5f / nearPlane;
		// float fov = FOV//btScalar(2.0) * btAtan(tanFov);

		//btVector3 camPos,camTarget;
		

		btVector3 rayFrom = cameraGetPosNoShake()->getBTV();
		btVector3 rayForward = lookAtVec.getBTV();
		rayForward.normalize();
		float farPlane = clipDist[1];// 10000.f;
		rayForward*= farPlane;

		btVector3 rightOffset;
		btVector3 cameraUp=btVector3(0,0,1);

		btVector3 vertical = cameraUp;

		btVector3 hor;
		hor = rayForward.cross(vertical);
		hor.safeNormalize();
		vertical = hor.cross(rayForward);
		vertical.safeNormalize();

		float tanfov = tanf(0.5f*FOV);


		hor *= 2.f * farPlane * tanfov;
		vertical *= 2.f * farPlane * tanfov;

		btScalar aspect;
		float width = origWinW;
		float height = origWinH;

		aspect =  width / height;

		hor*=aspect;


		btVector3 rayToCenter = rayFrom + rayForward;
		btVector3 dHor = hor * 1.f/width;
		btVector3 dVert = vertical * 1.f/height;


		btVector3 rayTo = rayToCenter - 0.5f * hor + 0.5f * vertical;
		//rayTo += btScalar(x) * dHor;
		//rayTo -= btScalar(y) * dVert;
		return rayTo;
	}
void Singleton::runReport ()
                         {
		
		//cout << "pathFinalStack.size() " << gameLogic->pathFinalStack.size() << "\n";
		
		//tempCounter++;
		
		
		doPathReport = true;
		
		// if (tempCounter >= gameLogic->pathFinalStack.size()) {
		// 	tempCounter = 0;
		// }
		
		//mainGUI->runReport();
		
		
		// cout << "lastMouseX" << lastMouseX << "\n";
		// cout << "lastMouseY" << lastMouseY << "\n";
		
		// cout << "polyCount " << polyCount << "\n";
		
		// doTraceVecND("cameraPos ", cameraGetPosNoShake());
		// doTraceVecND("lookAtVec ", &lookAtVec);
		// cout << "\n";
		
		// cout << "lightCount: " << gw->lightCount << "\n";
		//cout << "TOT GPU MEM USED (MB): " << TOT_GPU_MEM_USAGE << "\n";
		// cout << "HolderSize (MB): " << holderSizeMB << "\n";
		// cout << "totalPointCount: " << totalPointCount << "\n";
	}
void Singleton::updateCS ()
                        {
		if (
			(bCtrl != bCtrlOld) ||
			(bShift != bShiftOld)
		) {
			forceGetPD = true;
			wsBufferInvalid = true;
		}
		bCtrlOld = bCtrl;
		bShiftOld = bShift;
	}
void Singleton::getMarkerPos (int x, int y)
                                        {
		getPixData(&spaceUpPD, x, y, true, false);
		worldMarker.copyFrom(&spaceUpPD);
		lastCellPos.copyFrom(&(worldMarker));
	}
void Singleton::resetGeom ()
                         {
		int i;
		geomStep = 0;
		geomOrigOffset.setFXYZ(0.0f);
		geomPoints[0].setFXYZ(0.0f,0.0f,0.0f);
		
		for (i = 0; i < FLOATS_PER_TEMPLATE; i++) {
			paramArrGeom[i] = defaultTemplate[i];
		}
	}
void Singleton::processInput (unsigned char key, bool keyDown, int x, int y)
                                                                         {
		
		int i;
		int tempType = E_ENTTYPE_NPC;
		
		GamePageHolder* curHolder;
		
		if (inputOn) {
			if (keyDown) {
				
			}
			else {
				processFieldInput(key);	
			}
			return;
		}
		
		unsigned char newKey = key;
		
		if (
			(key >= 'A') &&
			(key <= 'Z')
		) {
			newKey += 32;
		}
		
		keysPressed[newKey] = keyDown;
		
		GameOrg* testOrg = gem->getCurOrg();
		
		
		if (keyDown) {
			
		}		
		else {
			switch (key) {

				



			
			// case 'a':
			// 	// selectedNode->material += 1.0f;
			// 	// curNode = getMirroredNode(selectedNode);
			// 	// if (curNode != NULL) {
			// 	// 	curNode->material += 1.0f;
			// 	// }
			// 	// makeDirty();
			// break;
			// case 'z':
			// 	// selectedNode->material -= 1.0f;
			// 	// curNode = getMirroredNode(selectedNode);
			// 	// if (curNode != NULL) {
			// 	// 	curNode->material -= 1.0f;
			// 	// }
			// 	// makeDirty();
				
			// break;


				
				
				case '1':
				case '2':
				case '3':
				
					switch(key) {
						case '1':
							tempType = E_ENTTYPE_NPC;
						break;
						case '2':
							tempType = E_ENTTYPE_WEAPON;
						break;
						case '3':
							tempType = E_ENTTYPE_WEAPON;
							gem->weaponToPlace = E_PG_WPSPEAR;
						break;
					}
				
					if (updateHolders) {
						getMarkerPos(x, y);
						gem->placeNewEnt(gameNetwork->isConnected,tempType,&lastCellPos);
						
						if (key == '2') {
							gem->weaponToPlace++;
							if (gem->weaponToPlace > E_PG_WPSPEAR) {
								gem->weaponToPlace = E_PG_WPSWORD;
							}
						}
						
						gem->refreshTurnList();
						
					}
					else {
						cout << "Turn On Holder Update (u)\n";
						doAlert();
					}
					
				break;
				//case '0':
					
				//break;
				
				
				case '9':
					renderingOctBounds = !renderingOctBounds;
				break;
				case '/':
					gameOct->captureBuffer();
					gameOct->updateTBO();
				break;
				case '*':
					renderingOct = !renderingOct;
				break;
				case '-':
					gameOct->modRenderLevel(-1);
				break;
				case '+':
					gameOct->modRenderLevel(1);
				break;
				
				case '`':
					placingGeom = !placingGeom;
					if (placingGeom) {
						resetGeom();
					}
					else {
						
					}
				break;
				
				
				case 'i':
						
						ignoreFrameLimit = !ignoreFrameLimit;
						cout << "ignoreFrameLimit: " << ignoreFrameLimit << "\n";
					break;
				case 19: //ctrl-s
					saveExternalJSON();
					saveGUIValues();
					gem->saveCurrentPose();
					//cout << "Use s key in web editor to save\n";
					break;

				case 15: //ctrl-o
					//loadAllData();
					loadValuesGUI();

					break;

				case '[':
					iNumSteps /= 2;
					if (iNumSteps < 16)
					{
						iNumSteps = 16;
					}
					doTraceND("iNumSteps: ", i__s(iNumSteps));

					break;
				case ']':
					iNumSteps *= 2;
					if (iNumSteps > 256)
					{
						iNumSteps = 256;
					}
					doTraceND("iNumSteps: ", i__s(iNumSteps));

					break;


				case 'u':
					
					// if (updateHolders) {
					// 	if (pathfindingOn) {
					// 		updateHolders = false;
					// 		pathfindingOn = false;
					// 	}
					// 	else {
					// 		pathfindingOn = true;
					// 	}
					// }
					// else {
					// 	updateHolders = true;
					// }
				
					updateHolders = !updateHolders;
					pathfindingGen = updateHolders;
					
					
					cout << "\n";
					cout << "updateHolders " << updateHolders << "\n";
					
					
					
				break;
				
				
				case 'Q':
					gem->toggleFirstPerson();
				break;
				
				case 'q':
					
					gem->toggleActorSel();
					
					break;

				
				case 'W':
					cout << "start FPS timer\n";
					fpsTest = true;
					fpsCount = 0;
					fpsTimer.start();
				break;
				

				case 27: // esc
					//std::exit(0);
					
					if (menuList[E_FM_DDMENU]->visible || menuList[E_FM_CONTMENU]->visible) {
						toggleDDMenu(x,y,false);
						menuList[E_FM_CONTMENU]->visible = false;
						gem->closeAllContainers();
						escCount = 0;
					}
					else {
						
						escCount++;
						if (escCount >= 3) {
							std::exit(0);
						}
					}
					
					//pickerMenu->visible = false;
					
					
					
					break;

				case 'b':
				
					bakeParamsOn = !bakeParamsOn;
					cout << "bakeParamsOn: " << bakeParamsOn << "\n";
					doShaderRefresh(bakeParamsOn);
					
					
					
				
					//radiosityOn = !radiosityOn;
					break;


				case 'R':
				
					//loadValuesGUI(false);
					gw->noiseGenerated = false;
					gw->blockHolder->wasGenerated = false;
					
					loadGUI();
					loadValuesGUI();
					gem->loadPoseInfo(true);
					
				break;
				case 'r':
					
					
					
					doShaderRefresh(bakeParamsOn);
					cout << "Shaders Refreshed\n";

					
					
					break;
				
				case 'n':
					//gem->nextSwing(gem->getCurActorUID(),RLBN_LEFT);
					//gem->nextSwing(gem->getCurActorUID(),RLBN_RIGT);
					runReport();
					
					
				break;
				
				case 'N':
					gem->saveEveryPose();
				break;
				
				case 'j':
				
					pathfindingTestOn = !pathfindingTestOn;
					cout << "pathfindingTestOn: " << pathfindingTestOn << "\n";
				
					//gem->resetActiveNode();
				
					// 
					// doShaderRefresh(bakeParamsOn);
					// mapInvalid = true;
					// gw->initMap();
				break;

				case 'J':
				
					doShaderRefresh(bakeParamsOn);
					mapInvalid = true;
					gw->initMap();
				
				break;

				case 'G':
				
					
				
					gridOn = !gridOn;
					cout << "Grid On: " << gridOn << "\n";

					break;


				case 'g':
				
					mouseState++;

					
					if (mouseState == E_MOUSE_STATE_PICKING) {
						
						mouseState = E_MOUSE_STATE_BRUSH;
						
						if (earthMod == E_PTT_WAT) {
							mouseState = 0;
							earthMod = E_PTT_TER;
						}
						else {
							earthMod = E_PTT_WAT;
						}
						
					}
					

					
					
					cout << mouseStateStrings[mouseState] << "\n";


					wsBufferInvalid = true;
					forceGetPD = true;
				
					
				break;
				
				case 'k':
					gem->destroyTerrain = !(gem->destroyTerrain);
					cout << "destroyTerrain: " << gem->destroyTerrain << "\n";
					//gameAI->getKB();
				break;
				
				case 'l':

					multiLights = !multiLights;
					updateMultiLights();


					forceGetPD = true;

					break;

				case ';':
					physicsOn = !physicsOn;
					cout << "physicsOn: " << physicsOn << "\n";
				break;
				case 'p':
				
					curPattern++;
					if (curPattern >= E_PAT_LENGTH) {
						curPattern = 0;
					}
				
					
				break;
				case 'P':
				
					placingPattern = !placingPattern;
					cout << "placingPattern: " << placingPattern << "\n";
				
					//toggleFullScreen();
				break;
				case '\\':
					toggleFullScreen();
				break;
				
				case 'o':
					//targetTimeOfDay = 1.0f-targetTimeOfDay;
					sphereMapOn = !sphereMapOn;
					
					break;

				case 'h':
					
					// diagCount++;
					
					// if (diagCount >= 9) {
					// 	diagCount = 0;
					// }
					
					//gameFluid[E_FID_SML]->updateTBOData(false,true);
					//gameFluid[E_FID_BIG]->updateTBOData(false,true);
					
					gem->showHealth = !(gem->showHealth);
					
					break;
					
				case 'y':
					// throw
				break;
				case 'T':
					testOn = !testOn;
					
				break;
				case 't':
					//testOn2 = !testOn2;
					
					pathfindingTestOn = !pathfindingTestOn;
					
				break;
				// case 'o':
				// 	//rotOn = !rotOn;
				// 	break;
					

				case '\t':
				
					if (menuList[E_FM_DDMENU]->visible || menuList[E_FM_CONTMENU]->visible) {
						toggleDDMenu(x,y,false);
						menuList[E_FM_CONTMENU]->visible = false;
						gem->closeAllContainers();
						
						escCount = 0;
					}
					else {
						if (mainGUI->isReady) {
							if (menuList[E_FM_MAINMENU] == NULL) {
								
							}
							else {
								if (menuList[E_FM_MAINMENU]->visible) {
									playSoundEvent("hideGUI");
								}
								
								menuList[E_FM_MAINMENU]->visible = !(menuList[E_FM_MAINMENU]->visible);
								
								if (menuList[E_FM_MAINMENU]->visible) {
									playSoundEvent("showGUI");
								}
							}
						}
					}
					
					break;

				case ' ':
					
					
					
				
					//timeMod = !timeMod;
					// if (mouseState == E_MOUSE_STATE_PICKING) {
					// 	selectedEnts.cycleEnts();
					// }
					
					showHudMenu( !(menuList[E_FM_HUDMENU]->visible) );
					
					//showStatMenu( !(menuList[E_FM_STATMENU]->visible) );
					
					//cout << makePretty("E_TEST_STRING_VALUE", "E_TEST_") << "\n";
					
					
				break;
				
				
				case 'C':
				
					
				break;
				case 'c':
					
					
					gem->setTurnBased(!(gem->turnBased));
					gem->combatOn = (gem->turnBased);
					gridOn = gem->combatOn;
					//gem->combatOn = !(gem->combatOn);
					//cout << "gem->combatOn " << gem->combatOn << "\n";
					
					
					//setCameraToElevation();
				
					//doShaderRefresh(bakeParamsOn);

					break;
					
				case 'v':
					gem->togglePoseEdit();
					
					
					//waterBulletOn = !waterBulletOn;
					//gw->toggleVis(selectedEnts.getSelectedEnt());
					break;
					
				case 'V':
					gem->applyNonPoseData();
				break;
				

				case 'X':
					//fogOn = 1.0 - fogOn;
					//cout << "fog on " << fogOn << "\n";
					gem->changePose(-1);
					break;
					
				case 'x':
					gem->changePose(1);
					
					//fxaaOn = !fxaaOn;
					//cout << "fxaaOn " << fxaaOn << "\n";
					break;

				case 'm':


					gem->mirrorOn = !gem->mirrorOn;
					cout << "gem->mirrorOn " << gem->mirrorOn << "\n";
					
					// doPathReport = true;

					// medianCount++;					
					// if (medianCount == 4) {
					// 	medianCount = 0;
					// }
					
					//
					
					// refreshPaths = true;
					

					break;
				case 'M':
					smoothMove = !smoothMove;
				break;
				

				

				case 'A':
				case 'Z':
				case 'S':
				case 'F':
				case 'E':
				case 'D':
				case 'a':
				case 'z':
				case 's':
				case 'f':
				case 'e':
				case 'd':
					// reserved for movement
				break;
				
				// 127 del
				// 8 backspace

				default:
					cout << "No code for key: " << ((int)key) << "\n";
					break;
			}
			
			
			if (gem->turnBased&&(gem->getCurActor() != NULL)) {
				switch(key) {
					case 'a':
						
					break;
					case 'z':
						
					break;
					
					case 'w':
						gem->makeGrab(gem->getCurActor()->uid, -1);
					break;
					case 'y':
						gem->makeThrow(gem->getCurActor()->uid,-1);
					break;
					
					case 's':
						gem->makeTurnTB(gem->getCurActor()->uid, 1);
						
					break;
					case 'f':
						gem->makeTurnTB(gem->getCurActor()->uid, -1);
						
					break;
					
					case 'e':
						if (gem->makeMoveTB(gem->getCurActor()->uid, 1)) {
							gem->endHumanTurn();
						}
					break;
					case 'd':
						if (gem->makeMoveTB(gem->getCurActor()->uid, -1)) {
							gem->endHumanTurn();
						}
					break;
				}
			}
			
		}
		
		
	}
void Singleton::getPixData (FIVector4 * toVector, int _xv, int _yv, bool forceUpdate, bool isObj)
        {

		

		if (fpsTest) {
			return;
		}

		FBOWrapper *fbow;
		int newX;
		int newY;
		
		float xv = _xv;
		float yv = _yv;
		
		float bufx;
		float bufy;

		if (isObj) {
			//fbow = getFBOWrapper("geomBaseTargFBO",2);
			fbow = getFBOWrapper("limbFBO", 0);
		}
		else {
			fbow = getFBOWrapper("solidTargFBO", 0);
		}
		
		float srcW = fbow->width;
		float srcH = fbow->height;
		
		bufx = xv/bufferDim.getFX();
		bufy = 1.0f-yv/bufferDim.getFY();

		if (wsBufferInvalid || forceUpdate || forceGetPD) {
			
			// glFlush();
			// glFinish();
			
			fbow->getPixels();
			
			// glFlush();
			// glFinish();
			
		}

		// newX = clamp(xv, 0, bufx - 1);
		// newY = clamp(yv, 0, bufy - 1);

		fbow->getPixelAtF(
			toVector, 
			bufx*srcW,
			bufy*srcH
		);
			//newX, ((bufy - 1) - newY));

		wsBufferInvalid = false;
		forceGetPD = false;
		
	}
float Singleton::getMinGeom (int baseIndex)
                                        {
		int newIndex = baseIndex*4;
		
		return min(
			min(
				paramArrGeom[newIndex + 0],
				paramArrGeom[newIndex + 1]
			),
			paramArrGeom[newIndex + 2]
		);
		
	}
void Singleton::setFXYZWGeom (int baseIndex, FIVector4 * baseVec)
                                                             {
		int newIndex = baseIndex*4;
		int i;
		
		for (i = 0; i < 4; i++) {
			paramArrGeom[newIndex + i] = baseVec->getIndex(i);
		}
		
	}
void Singleton::setFXYGeom (int baseIndex, float xv, float yv)
                                                           {
		int newIndex = baseIndex*4;
		paramArrGeom[newIndex + 0] = xv;
		paramArrGeom[newIndex + 1] = yv;
	}
void Singleton::setFXGeom (int baseIndex, float xv)
                                                {
		int newIndex = baseIndex*4;
		paramArrGeom[newIndex + 0] = xv;
	}
void Singleton::setFYGeom (int baseIndex, float yv)
                                                {
		int newIndex = baseIndex*4;
		paramArrGeom[newIndex + 1] = yv;
	}
void Singleton::setFZGeom (int baseIndex, float zv)
                                                {
		int newIndex = baseIndex*4;
		paramArrGeom[newIndex + 2] = zv;
	}
void Singleton::setFWGeom (int baseIndex, float wv)
                                                {
		int newIndex = baseIndex*4;
		paramArrGeom[newIndex + 3] = wv;
	}
float Singleton::getFXGeom (int baseIndex)
                                       {
		int newIndex = baseIndex*4;
		return paramArrGeom[newIndex + 0];
	}
float Singleton::getFYGeom (int baseIndex)
                                       {
		int newIndex = baseIndex*4;
		return paramArrGeom[newIndex + 1];
	}
float Singleton::getFZGeom (int baseIndex)
                                       {
		int newIndex = baseIndex*4;
		return paramArrGeom[newIndex + 2];
	}
float Singleton::getFWGeom (int baseIndex)
                                       {
		int newIndex = baseIndex*4;
		return paramArrGeom[newIndex + 3];
	}
void Singleton::processSpecialKeys (int key, int _x, int _y)
        {

		int x = _x / scaleFactor;
		int y = _y / scaleFactor;

		switch (key)
		{
		case GLUT_KEY_F1 :

			break;
		case GLUT_KEY_F2 :

			break;
		case GLUT_KEY_F3 :

			break;
		}
	}
void Singleton::keyboardUp (unsigned char key, int _x, int _y)
        {
		int x = _x / scaleFactor;
		int y = _y / scaleFactor;
		
		frameMouseMove = true;
		
		GameOrgNode* curNode;
		
		
		

		
		bShift = shiftDown();
		bCtrl = ctrlDown();
		updateCS();


		if (key == 17) {
			glutLeaveMainLoop();
		}

		keyStack.push_back(KeyStackEvent());
		keyStack.back().key = key;
		keyStack.back().keyDown = false;
		keyStack.back().x = x;
		keyStack.back().y = y;

		//processInput(key, false, x, y);


	}
void Singleton::keyboardDown (unsigned char key, int _x, int _y)
        {
		int x = _x / scaleFactor;
		int y = _y / scaleFactor;
		
		frameMouseMove = true;
		
		
		
		
		
		bShift = shiftDown();
		bCtrl = ctrlDown();
		updateCS();

		keyStack.push_back(KeyStackEvent());
		keyStack.back().key = key;
		keyStack.back().keyDown = true;
		keyStack.back().x = x;
		keyStack.back().y = y;
		//processInput(key, true, x, y);
	}
void Singleton::updateCurGeom (int x, int y)
                                         {
		
		float maxDis = 30.0;
		
		int i;
		int j;
		
		float xv;
		float yv;
		float xv2;
		float yv2;
		float minCornerDis;
		float maxCornerDis;
		
		int baseInd;
		
		if (geomStep == 0) {
			geomPoints[geomStep].setFXYZRef(&mouseMovePD);
			geomPoints[geomStep].setFW(-1.0f);
			geomPoints[geomStep].floorXYZ();
			geomStep++;
		}
		//else {
			geomPoints[geomStep].setFXYZ(
				((float)x)/bufferDim.getFX(),
				((float)y)/bufferDim.getFY(),
				0.0f
			);
		//}
		
		
		float xrotrad = getCamRot(0);
		float yrotrad = getCamRot(1);
		
		for (i = 0; i <= geomStep; i++) {
			
			xv = (geomPoints[i][0]-0.5f)*2.0f;
			yv = (geomPoints[i][1]-0.5f)*2.0f;
			
			xv2 = xv;
			yv2 = yv;
			
			xv = abs(xv);
			yv = abs(yv);
			
			xv *= maxDis;
			yv *= maxDis;
			yv2 *= maxDis;
			xv2 *= maxDis;
			
			
			if (placingTemplate) {
				switch(i) {
					case E_GEOM_POINTS_TEMP_ORIGIN:
						// wheel (no longer) changes template
						
						
					
					break;
					case E_GEOM_POINTS_TEMP_OFFSET:
					
					//rrrrr
					//xmod += float(cos(xrotrad));
					//ymod -= float(sin(xrotrad));
					
					
					
						geomOrigOffset.setFXYZ(
							-signedFloor(
								cos(xrotrad)*yv2 + -sin(xrotrad)*xv2
							),
							-signedFloor(
								sin(xrotrad)*yv2 + cos(xrotrad)*xv2
							),
							signedFloor(curPrimMod)
						);
					break;
				}
				
				baseInd = curPrimTemplate*E_PRIMTEMP_LENGTH;
				
				for (j = 0; j < E_PRIMTEMP_LENGTH; j++) {
					setFXYZWGeom(j, &(primTemplateStack[baseInd+j]) );
				}
			}
			else {
				switch (i) {
					case E_GEOM_POINTS_ORIGIN:
						
					break;
					case E_GEOM_POINTS_RAD_XYZ:
						setFXYGeom(E_PRIMTEMP_BOUNDSMIN, signedFloor(-xv), signedFloor(-yv));
						setFXYGeom(E_PRIMTEMP_BOUNDSMAX, signedFloor( xv), signedFloor( yv));
						
						setFXYGeom(E_PRIMTEMP_VISMIN, signedFloor(-xv), signedFloor(-yv));
						setFXYGeom(E_PRIMTEMP_VISMAX, signedFloor( xv), signedFloor( yv));
						
						setFZGeom(E_PRIMTEMP_BOUNDSMIN, signedFloor(-curPrimMod));
						setFZGeom(E_PRIMTEMP_BOUNDSMAX, signedFloor( curPrimMod));
						
						setFZGeom(E_PRIMTEMP_VISMIN, signedFloor(-curPrimMod));
						setFZGeom(E_PRIMTEMP_VISMAX, signedFloor( curPrimMod));
						
					break;
					case E_GEOM_POINTS_OFFSET:
						geomOrigOffset.setFXYZ(
							signedFloor(xv2),
							signedFloor(yv2),
							signedFloor(curPrimMod)
						);
					break;
					case E_GEOM_POINTS_CORNER:
					
						minCornerDis = 0.1;
						maxCornerDis = getMinGeom(E_PRIMTEMP_BOUNDSMAX);
						
						setFXGeom(E_PRIMTEMP_CORNERDIS, 
							signedFloor(mixf(
								minCornerDis,
								maxCornerDis,
								clampfZO(yv/(maxDis*0.5f))	
							))
						);
					break;
					case E_GEOM_POINTS_POWER_VALS:
						setFZGeom(E_PRIMTEMP_CORNERDIS, xv + 1.0f);
						setFWGeom(E_PRIMTEMP_CORNERDIS, yv + 1.0f);
					break;
					case E_GEOM_POINTS_NEG_RAD_XY:
						setFXYGeom(E_PRIMTEMP_VISMIN, 
							signedFloor(max(xv2,getFXGeom(E_PRIMTEMP_BOUNDSMIN))),
							signedFloor(max(yv2,getFYGeom(E_PRIMTEMP_BOUNDSMIN)))
						);
					break;
					case E_GEOM_POINTS_POS_RAD_XY:						
						setFXYGeom(E_PRIMTEMP_VISMAX, 
							signedFloor(min(xv2,getFXGeom(E_PRIMTEMP_BOUNDSMAX))),
							signedFloor(min(yv2,getFYGeom(E_PRIMTEMP_BOUNDSMAX)))
						);
					
					break;
					case E_GEOM_POINTS_NEG_RAD_Z:
						setFZGeom(E_PRIMTEMP_VISMIN, signedFloor(max(yv2,getFZGeom(E_PRIMTEMP_BOUNDSMIN))) );
					break;
					case E_GEOM_POINTS_POS_RAD_Z:
						setFZGeom(E_PRIMTEMP_VISMAX, signedFloor(min(yv2,getFZGeom(E_PRIMTEMP_BOUNDSMAX))) );
					break;
					case E_GEOM_POINTS_THICKNESS:
						setFYGeom(E_PRIMTEMP_CORNERDIS, signedFloor(yv));
					break;
				}
			}
			
			
		}
		
		
	}
void Singleton::mouseMove (int _x, int _y)
        {

		int i;
		int j;

		

		frameMouseMove = true;

		mouseMoved = true;

		lastMouseOrigX = _x;
		lastMouseOrigY = _y;

		int x = _x / scaleFactor;
		int y = _y / scaleFactor;

		int dx = _x - lastPosX;
		int dy = _y - lastPosY;
		
		guiX = _x/UI_SCALE_FACTOR;
		guiY = _y/UI_SCALE_FACTOR;

		bShift = shiftDown();
		bCtrl = ctrlDown();
		updateCS();

		lastMouseX = x;
		lastMouseY = y;

		mouseXUp = x;
		mouseYUp = y;

		bool ddVis = false;
		bool noTravel = false;
		
		if (menuList[E_FM_DDMENU] != NULL) {
			ddVis = menuList[E_FM_DDMENU]->visible;
		}
		
		float fx = ((float)x)*M_PI*2.0f / bufferDim[0];
		float fy = ((float)y)*M_PI / bufferDim[1];
		
		
		if (hitGUI) {
			return;
		}
		
		
		if ((gem->highlightedLimb==-1)&&mbDown) {
			angleToVec(&lightVec, fx*2.0, fy*2.0);
			lightVecOrig.copyFrom(&lightVec);
			lightVec.setFZ(-abs(lightVec.getFZ()));
		}
		
		
		if (abDown)
		{
			
			// if (bCtrl&&(mouseState == E_MOUSE_STATE_BRUSH)) {
				
			// }
			// else {
				
			// }
			
			moveObject((float)dx, (float)dy);
			
		}
		else
		{
			
			// if (
			// 	(gem->getCurActor() != NULL) && (!gem->editPose)	
			// ) {
			// 	camRotation[0] -= dx*0.02f;
			// 	camRotation[1] += dy*0.02f;
			// }
			
			
			

			if ( placingPattern||placingGeom||RT_TRANSFORM||gem->editPose||pathfindingTestOn||(mouseState != E_MOUSE_STATE_MOVE)) {
			//if (true) {
				getPixData(&mouseMovePD, x, y, false, false);
				getPixData(&mouseMoveOPD, x, y, true, true);
			}
			

			gw->updateMouseCoords(&mouseMovePD);
			
			if (pathfindingTestOn) {
				
				if (gameLogic->getClosestPathRad(mouseMovePD.getBTV(), closestHolder) > -1) {
					
					if (pathFindingStep < 2) {
						gameLogic->testPath.points[pathFindingStep] = mouseMovePD.getBTV();
					}
				}
				
				
			}
			

			//////////////

			

			if (
				gem->orgOn &&
				gem->editPose
				&& (!ddVis)
			) {
				gem->updateNearestOrgNode(false, &mouseMovePD);
			}
			else {
				if (!ddVis) {
					gem->activeNode = NULL;
					gem->setSelNode(NULL);
				}
				
			}
			
			if (placingGeom) {
				updateCurGeom(x, y);
			}
			else {
				
				gw->findNearestEnt(
					&highlightedEnts,
					E_ET_GEOM,
					2,
					1,
					&mouseMovePD
				);
				highlightedEnt = highlightedEnts.getSelectedEnt();


			}
			

			

			//////////////


		}

		lastPosX = _x;
		lastPosY = _y;

		
	}
void Singleton::mouseClick (int button, int state, int _x, int _y)
                                                               {
		
		int tempInt;

		FIVector4 newPos;

		int x = _x / scaleFactor;
		int y = _y / scaleFactor;

		float mx = ((float)_x)/origWinW;
		float my = ((float)_y)/origWinH;

		lastPosX = _x;
		lastPosY = _y;
		
		guiX = _x/UI_SCALE_FACTOR;
		guiY = _y/UI_SCALE_FACTOR;

		GameBlock *curBlock;

		int buttonInt = 0;

		int res;
		int i;
		int j;
		int k;
		int ii;
		int jj;
		int bestInd;
		int upInd;
		float bestDis;
		float curDis;
		bool findObject = false;
		bool hitObject = false;
		bool wasDoubleClick[2];
		wasDoubleClick[0] = false;
		wasDoubleClick[1] = false;
		
		bool ddVis = false;
		if (menuList[E_FM_DDMENU] != NULL) {
			ddVis = menuList[E_FM_DDMENU]->visible;
		}

		float wheelDelta = 0.0f;
		int wheelDeltaInt = 0;
		bool mbClicked = false;
		bool rbClicked = false;
		bool lbClicked = false;

		int mouseMovingStart;

		FIVector4 testVec;
		FIVector4 oneVec;
		oneVec.setFXYZ(1.0f, 1.0f, 1.0f);
		oneVec.normalize();

		bool doProc = false;
		bool noTravel = false;
		bool abClicked = false;
		
		hitGUI = false;
		bool longClick = false;
		
		
		
		switch (button)
		{
		case GLUT_LEFT_BUTTON:
			lbDown = (state == GLUT_DOWN);
			lbClicked = (state == GLUT_UP);

			break;
		case GLUT_RIGHT_BUTTON:
			rbDown = (state == GLUT_DOWN);
			rbClicked = (state == GLUT_UP);

			break;
		case GLUT_MIDDLE_BUTTON:
			mbDown = (state == GLUT_DOWN);
			mbClicked = (state == GLUT_UP);

			break;

		
		}

		abDown = lbDown || rbDown || mbDown;
		abClicked = lbClicked || rbClicked || mbClicked;
		
		
		if (mbClicked) {
			gem->checkActorRefresh();
		}
		
		if (abDown) {
			mdTime = myTimer.getElapsedTimeInMilliSec();
			
			
		}
		else {
			muTime = myTimer.getElapsedTimeInMilliSec();
			longClick = (muTime - mdTime) > 300.0f;
		}
		
		int curHand = -1;
		
		
		
		
		if (lbClicked) {
			curHand = RLBN_LEFT;
			
		}
		if (rbClicked) {
			curHand = RLBN_RIGT;	
		}
		
		if (state == GLUT_UP) {
			if (curHand > -1) {
				mdTimeLR[curHand] = myTimer.getElapsedTimeInMilliSec();
				
				if ( (mdTimeLR[curHand]-clickTimeLR[curHand]) < 500 ) {
					wasDoubleClick[curHand] = true;
				}
				
				
				clickTimeLR[curHand] = mdTimeLR[curHand];
			}
		}
		
		
		
		
		
		
		if (abDown) {
			mouseStart.setIXY(x, y);
		}
		if (abClicked) {
			mouseEnd.setIXY(x, y);
			noTravel = mouseEnd.distance(&mouseStart) < MAX_TRAVEL_DIS;	
		}
		
		if (anyMenuVisible()) {
			hitGUI = mainGUI->testHit(button, state, guiX, guiY);
		}
		

		if (hitGUI) {
			return;
		}
		
		
		if (gem->combatMode()) {
			
			if (lbClicked) {
				gem->setSwing(
					mx*2.0f - 1.0f,
					my*2.0f - 1.0f,
					gem->getCurActor()->uid,
					RLBN_LEFT,
					bCtrl
				);
				gem->makeSwing(gem->getCurActor()->uid, RLBN_LEFT);
				if (gem->turnBased) {gem->endHumanTurn();}
				return;
			}
			if (rbClicked) {
				gem->setSwing(
					mx*2.0f - 1.0f,
					my*2.0f - 1.0f,
					gem->getCurActor()->uid,
					RLBN_RIGT,
					bCtrl
				);
				gem->makeSwing(gem->getCurActor()->uid, RLBN_RIGT);
				if (gem->turnBased) {gem->endHumanTurn();}
				return;
			}
			
		}
		
		
		
		//cout << "NO GUI HIT\n";
		
		
		wsBufferInvalid = true;
		
		if (abDown) {
			getPixData(&mouseDownPD, x, y, true, false);
			getPixData(&mouseDownOPD, x, y, true, true);
		}
		else {
			getPixData(&mouseUpPD, x, y, true, false);
			getPixData(&mouseUpOPD, x, y, true, true);
		}
		
		// if (lbDown) {
		// 	if (gamePhysics != NULL) {
		// 		gamePhysics->pickBody(mouseDownPD.getBTV(),mouseDownOPD.getBTV());
		// 	}
		// }
		
		
		
		
		
		
		if (lbClicked) {
			gamePhysics->lastBodyPick = NULL;
			gamePhysics->lastBodyUID = -1;
		}
		
		

		if (abClicked) {

			if (menuList[E_FM_DDMENU] != NULL) {
				if (noTravel) {
					toggleDDMenu(x,y,false);
				}
				if (
					rbClicked &&
					(!lbDown) &&
					noTravel &&
					(!longClick) &&
					(mouseState != E_MOUSE_STATE_BRUSH)
				) {
					toggleDDMenu(x,y,true);
				}
			}
			
			
			if (abDown) {

			}
			else {
				if (lbClicked) {
					
					if (placingGeom) {
						geomStep++;
						curPrimMod = 0.0f;
						
						cout << "cur step: " << E_GEOM_POINTS_STR[geomStep] << "\n";
						
						if (
							(
								(geomStep == E_GEOM_POINTS_LENGTH) && (!placingTemplate)
							)
							||
							(
								(geomStep == E_GEOM_POINTS_TEMP_LENGTH) && (placingTemplate)
							)
						) {
							
							geomStep--;
							
							if (placingTemplate) {
								
								
								newPos.setFXYZRef(&(geomPoints[0]));
								newPos.addXYZRef(&geomOrigOffset);
								
								//dont add geom twice
								//gameFluid[E_FID_SML]->pushPlaceTemplate(true, &newPos, curPrimTemplate);
								gameFluid[E_FID_BIG]->pushPlaceTemplate(true, &newPos, curPrimTemplate);
								resetGeom();
							}
							
							
							
							placingGeom = false;
							
							
							
						}
						
						
						
					}
					else {
						
						doProc = true;
						
						
						
						if (doProc) {
							if (noTravel) {
								
								
								if (pathfindingTestOn) {
									
									pathFindingStep++;
									
									if (pathFindingStep == 3) {
										pathFindingStep = 0;
										gameLogic->testPath.points[0] = btVector3(0.0f,0.0f,0.0f);
										gameLogic->testPath.points[1] = btVector3(0.0f,0.0f,0.0f);
										gameLogic->testPath.searchedForPath = false;
										gameLogic->testPath.didFindPath = false;
										gameLogic->testPath.nextInd = -1;
										gameLogic->testPath.finalPoints.clear();
									}
								}
								else {
									
								}
								
								
							}
							else {
								gem->endDrag(mouseUpOPD.getFW());
							}
						}
						
						
						
						
						
						

						if ( (activeObject == E_OBJ_CAMERA) && longClick ) {
							mouseMovingStart = (mouseMovingLoc - min(mouseMovingStepsBack, mouseCount) + mouseMovingSize) % mouseMovingSize;
						}


						if (!(shiftDown())) {


							activeObject = E_OBJ_CAMERA;
							

							
							gw->findNearestEnt(
								&selectedEnts,
								E_ET_GEOM,
								2,
								1,
								&mouseUpPD,
								true
							);
							
							selectedEnt = selectedEnts.getSelectedEnt();

							if (
								(selectedEnt == NULL) ||
								(mouseState == E_MOUSE_STATE_PICKING) ||
								(mouseState == E_MOUSE_STATE_BRUSH)
							)	{

							}
							else {

								switch (selectedEnt->buildingType)
								{
								case E_CT_DOOR:
								case E_CT_WINDOW:
									
									
									
									if (selectedEnt->toggled) {
										// open
										switch (selectedEnt->buildingType)
										{
											case E_CT_DOOR:
												playSoundPosAndPitch(
													"open3",
													cameraGetPosNoShake(),
													selectedEnt->getVisMinInPixelsT(),
													0.3f
												);
											break;
											case E_CT_WINDOW:
												playSoundPosAndPitch(
													"open1",
													cameraGetPosNoShake(),
													selectedEnt->getVisMinInPixelsT(),
													0.3f
												);
											break;
										}
									}
									else {
										// close
										
										switch (selectedEnt->buildingType)
										{
											case E_CT_DOOR:
												playSoundPosAndPitch(
													"close2",
													cameraGetPosNoShake(),
													selectedEnt->getVisMinInPixelsT(),
													0.3f
												);
											break;
											case E_CT_WINDOW:
												playSoundPosAndPitch(
													"close1",
													cameraGetPosNoShake(),
													selectedEnt->getVisMinInPixelsT(),
													0.3f
												);
											break;
										}
									}
									

									
									wsBufferInvalid = true;
									break;

								case E_CT_LANTERN:
									selectedEnt->light->toggle();
									playSoundPosAndPitch(
										"castinet0",
										cameraGetPosNoShake(),
										selectedEnt->getVisMinInPixelsT(),
										0.3f
									);
									gw->updateLights();
									cout << "final toggle " << selectedEnt->light->toggled << "\n";
									break;

								}

							}



						}

						
					}
					
					
				}
			}


		}
		else {
			if (abDown) {


				mouseMovingLoc = 0;
				mouseCount = 0;
				
				if (rbDown&&(!lbDown)) {
					activeObject = E_OBJ_CAMERA;
				}
			}
		}
		
		
		if (mouseState == E_MOUSE_STATE_MOVE) {
			
			if (
				gem->orgOn &&
				gem->editPose
				&& (!ddVis)
				
			) {
				findObject = !(gem->updateNearestOrgNode(true, &mouseDownPD));
			}
			else {
				findObject = true;
			}
			
			if (findObject) {
				
				gem->updateDragInfo(mouseDownOPD.getFW(), lbDown, wasDoubleClick[RLBN_LEFT]);
				
			}
		}
		
		
		
		

		
		if (!bShift) {
			if (noTravel) {
				switch (mouseState) {
					case E_MOUSE_STATE_BRUSH:
						
						
						
						if (lbClicked) {
							buttonInt = 0;
						}
						else if (rbClicked) {
							buttonInt = 1;
						}
						else if (mbClicked) {
							buttonInt = 2;
						}
						
						if (abClicked) {
							//gameFluid[E_FID_SML]->pushModifyUnit(true, &mouseUpPD, buttonInt, earthMod, curBrushRad);
							gameFluid[E_FID_BIG]->pushModifyUnit(true, &mouseUpPD, buttonInt, earthMod, curBrushRad);
							forceGetPD = true;
						}
						
						

					break;
				}
			}
		}
		
		
		//cout << "button " << button << "\n";
		//cout << "state " << state << "\n\n";
		
		
		switch (button) {
			case 3: // wheel up
			case 7: // rbDown
			case 11: // shift down
				wheelDelta = 1.0f / 20.0f;
				wheelDeltaInt = 1;
				break;

			case 4: // wheel down
			case 8: // rbDown
			case 12: // shift down
				wheelDelta = -1.0f / 20.0f;
				wheelDeltaInt = -1;
				break;
		}
		
		globWheelDelta += wheelDelta;
		
		
		if ((abs(globWheelDelta) > 0.01f)) {
			frameMouseMove = true;
		}
		
		if ((state==1)) {
			
			
			
			if (placingGeom) {
				
				if ((wheelDeltaInt != 0)) {
					if ((button == 7) || (button == 8)) {
						curPrimTemplate -= wheelDeltaInt;
						
						if (curPrimTemplate <= 1) {
							curPrimTemplate = 1;
						}
						if (curPrimTemplate >= (primTemplateStack.size()/E_PRIMTEMP_LENGTH)) {
							curPrimTemplate = (primTemplateStack.size()/E_PRIMTEMP_LENGTH) - 1;
						}
						
						cout << "curPrimTemplate " << curPrimTemplate << "\n";
					}
					else {
						curPrimMod += wheelDeltaInt;
					}
					
					updateCurGeom(x,y);
				}
				
				
				
			}
			 

		}
		
		

	}
bool Singleton::feetContact (BaseObj * ge)
                                      {
		BodyStruct* curBody;
		
		curBody = ge->getBodyByBoneId(E_BONE_L_LOWERLEG);
		if (curBody != NULL) {
			if (curBody->hasContact) {
				return true;
			}
		}
		curBody = ge->getBodyByBoneId(E_BONE_R_LOWERLEG);
		if (curBody != NULL) {
			if (curBody->hasContact) {
				return true;
			}
		}
		curBody = ge->getBodyByBoneId(E_BONE_L_TALUS);
		if (curBody != NULL) {
			if (curBody->hasContact) {
				return true;
			}
		}
		curBody = ge->getBodyByBoneId(E_BONE_R_TALUS);
		if (curBody != NULL) {
			if (curBody->hasContact) {
				return true;
			}
		}
		
		return false;
	}
void Singleton::flushKeyStack ()
                             {
		while (keyStack.size() > 0) {
			processInput(
				keyStack.front().key,
				keyStack.front().keyDown,
				keyStack.front().x,
				keyStack.front().y
			);
			keyStack.pop_front();
		}
	}
void Singleton::applyKeyAction (bool isReq, int actorId, uint keyFlags, float camRotX, float camRotY)
                                                                                                  {
		
		
		
		int i;
		BaseObj* ca;
		
		btVector3 mouseWP;
		
		bool charMoved;
		float deltaAng;
		
		if (isReq) {
			naUintData[0] = keyFlags;
			naIntData[0] = actorId;
			naFloatData[0] = camRotX;
			naFloatData[1] = camRotY;
			gameNetwork->addNetworkAction(E_NO_KEY_ACTION,naUintData,naIntData,naFloatData);
			return;
		}
		
		if (gem->turnBased) {
			return;
		}
		
		if (actorId < 0) {
			
		}
		else {
			
			ca = &(gem->gameObjects[actorId]);
			
			unzipBits(keyFlags,keyMapResultUnzipped,KEYMAP_LENGTH);
			
			if (ca->isAlive()) {
				
				if (keyMapResultUnzipped[KEYMAP_RIGHT]) {
					
					if (bShift) {
						gem->makeMove( actorId, btVector3( 1.0f,0.0f,0.0f), true, true );
					}
					else {
						gem->makeTurn(actorId, -conVals[E_CONST_TURN_AMOUNT]);
					}
					
					//
				}
				
				if (keyMapResultUnzipped[KEYMAP_LEFT]) {
					if (bShift) {
						gem->makeMove( actorId, btVector3(-1.0f,0.0f,0.0f), true, true );
					}
					else {
						gem->makeTurn(actorId, conVals[E_CONST_TURN_AMOUNT]);
					}
					
					//
				}
				
				if (keyMapResultUnzipped[KEYMAP_FIRE_PRIMARY]) {
					gem->makeShoot(actorId, E_ENTTYPE_BULLET);
				}
				
				if (keyMapResultUnzipped[KEYMAP_GRAB]) {
					gem->makeGrab(actorId,-1);
				}
				
				if (keyMapResultUnzipped[KEYMAP_THROW]) {
					gem->makeThrow(actorId,-1);
				}
				
				if (keyMapResultUnzipped[KEYMAP_UP]) {
					gem->makeJump(actorId, 1, 1.0f);
				}
				
				if (keyMapResultUnzipped[KEYMAP_DOWN]) {
					gem->makeJump(actorId, 0, 1.0f);
				}
				
				if (keyMapResultUnzipped[KEYMAP_FORWARD]) {
					gem->makeMove( actorId, btVector3(0.0f, 1.0f,0.0f), true, true );
				}
				
				if (keyMapResultUnzipped[KEYMAP_BACKWARD]) {
					gem->makeMove( actorId, btVector3(0.0f,-1.0f,0.0f), true, true );
				}
				
				// mouseWP = screenToWorld(
				// 	((float)lastPosX)/origWinW,
				// 	((float)lastPosY)/origWinH,
				// 	camRotX
				// );
				
				//getPixData(&mouseMovePD, lastMouseX, lastMouseY, false, false);
				
				if (bShift) {
					deltaAng = ca->turnTowardsPointDelta(
						// mouseMovePD.getBTV()
						
						ca->getCenterPoint(E_BDG_CENTER) +
						lookAtVec.getBTV()
						
						// ca->getCenterPoint(E_BDG_CENTER) - mouseWP
						
					);
					
					if (!gem->editPose) {
						gem->makeTurn(actorId, deltaAng*16.0f);
					}
				}
				
				
				
				
				
			}
		}
		
		
		
		
	}
void Singleton::gatherKeyActions ()
                                {
		int i;
		
		bool res;
		
		for (i = 0; i < KEYMAP_LENGTH; i++) {
			res = keysPressed[keyMap[i]];
			
			if (res) {
				if (keyMapCoolDown[i] == 0) {
					keyMapCoolDown[i] = keyMapMaxCoolDown[i];
				}
				else {
					res = false;
				}
			}
			
			keyMapCoolDown[i] -= 1;
			if (keyMapCoolDown[i] < 0) {
				keyMapCoolDown[i] = 0;
			}
			
			keyMapResultZipped[i] = res;
		}
		
		applyKeyAction(
			gameNetwork->isConnected,
			gem->getCurActorUID(),
			zipBits(keyMapResultZipped, KEYMAP_LENGTH),
			getCamRot(0),
			getCamRot(1)
		);
	}
void Singleton::handleMovement ()
                              {
		
		
		
		
		int i;
		
		
		btVector3 skullPos;
		
		
		
		float xrotrad = getCamRot(0);
		float yrotrad = getCamRot(1);
		
		angleToVec(&lookAtVec,xrotrad,yrotrad);
		
		lookAtVec2D.copyFrom(&lookAtVec);
		lookAtVec2D.normalizeXY();
		
		
		
		float xmod = 0.0f;
		float ymod = 0.0f;
		float zmod = 0.0f;
		
		
		float tempMoveSpeed;
		
		//unsigned char curKey;
		
		isPressingMove = false;
		
		btVector3 tempBTV;
		
		amountInvalidRotate = (abs(curCamRotation[0]-camRotation[0]) + abs(curCamRotation[1]-camRotation[1]));
		depthInvalidRotate = (amountInvalidRotate > 0.001f);
		
		if (smoothMove||(
			(!gem->firstPerson) &&
			(gem->getCurActor() != NULL)	
		)) {
			curCamRotation[0] += (camRotation[0]-curCamRotation[0])*timeDelta*8.0f;
			curCamRotation[1] += (camRotation[1]-curCamRotation[1])*timeDelta*8.0f;
		}
		else {
			curCamRotation[0] = camRotation[0];
			curCamRotation[1] = camRotation[1];
		}
		
		
		
		if (gem->getCurActor() == NULL) {
			if (keysPressed[keyMap[KEYMAP_UP]]) {
				zmod += 1.0f;
				isPressingMove = true;
			}

			if (keysPressed[keyMap[KEYMAP_DOWN]]) {
				zmod -= 1.0f;
				isPressingMove = true;
			}

			if (keysPressed[keyMap[KEYMAP_FORWARD]]) { // || mbDown

				xmod += lookAtVec[0];//float(cos(xrotrad));
				ymod += lookAtVec[1]; //float(sin(xrotrad));
				zmod += lookAtVec[2];//float(cos(yrotrad));
				
				isPressingMove = true;
			}

			if (keysPressed[keyMap[KEYMAP_BACKWARD]]) {
				
				
				xmod -= lookAtVec[0];
				ymod -= lookAtVec[1];
				zmod -= lookAtVec[2];
				
				// xmod += float(cos(xrotrad+M_PI));
				// ymod += float(sin(xrotrad+M_PI));
				// zmod += float(cos(yrotrad));
				
				isPressingMove = true;
			}

			if (keysPressed[keyMap[KEYMAP_RIGHT]]) {
				
				xmod += lookAtVec2D[1];//float(cos(xrotrad+M_PI*0.5f));
				ymod += -lookAtVec2D[0];//float(sin(xrotrad+M_PI*0.5f));
				
				isPressingMove = true;
			}

			if (keysPressed[keyMap[KEYMAP_LEFT]]) {
				
				xmod += -lookAtVec2D[1];//float(cos(xrotrad-M_PI*0.5f));
				ymod += lookAtVec2D[0];//float(sin(xrotrad-M_PI*0.5f));
				
				isPressingMove = true;
			}

			
			
			
			
			if (isPressingMove) {
				
				curMoveAccel += 0.5f*timeDelta;
				curMoveSpeed += curMoveAccel*timeDelta;
				
				// if (curMoveSpeed > 32.0*timeDelta) {
				// 	curMoveSpeed = 32.0*timeDelta;
				// }
				
				wsBufferInvalid = true;
			}
			else {
				curMoveAccel = 0.0f;
				curMoveSpeed += (0.0f-curMoveSpeed)*timeDelta;
			}
			
			
			
			
			tempMoveSpeed = curMoveSpeed;
			
			if (bShift) {
				tempMoveSpeed *= 1.0f/32.0f;
			}
			
			modXYZ.setFXYZ(
				xmod*tempMoveSpeed,
				ymod*tempMoveSpeed,
				zmod*tempMoveSpeed
			);
			
			moveCamera(&modXYZ);
			
			
			isMoving = (curMoveSpeed >= 1.0);
		}
		
		
		
		if (gem->getCurActor() != NULL) {
			if (gem->getCurActor()->entType == E_ENTTYPE_NPC) {
				skullPos = gem->getCurActor()->getBodyByBoneId(E_BONE_C_SKULL)->body->getCenterOfMassPosition();
			}
			else {
				skullPos = gem->getCurActor()->getCenterPoint(E_BDG_CENTER);
			}
			
			
			if (gem->firstPerson) {
				targetCameraPos.setBTV(
					skullPos
				);
				//targetCameraPos.addXYZ(0.0f,0.0f,2.0f);
			}
			else {
				targetCameraPos.copyFrom(&lookAtVec);
				targetCameraPos.multXYZ( -(gem->subjectDistance)*subjectZoom );
				
				targetCameraPos.addXYZRef(BTV2FIV(
					skullPos
				));
				
			}
			
			
			if (!gem->firstPerson) {
				if (
					keysPressed[keyMap[KEYMAP_FORWARD]] ||
					keysPressed[keyMap[KEYMAP_BACKWARD]]
				) {
					isPressingMove = true;
					if (!rbDown) {
						
						tempBTV = multByOtherRot(
							btVector3(0.0f,1.0f,0.0f),
							gem->getCurActor()->bodies[E_BDG_CENTER].body->getCenterOfMassTransform().getBasis()
						);
						
						camRotation[0] += 
							getShortestAngle(
								camRotation[0],
								atan2(tempBTV.getY(), tempBTV.getX()),
								timeDelta*1.0
							);
					}
				}
			}
			
			
			
			modXYZ.copyFrom(&targetCameraPos);
			modXYZ.addXYZRef(cameraGetPosNoShake(),-1.0f);
			//modXYZ.multXYZ(0.25f);
			
			moveCamera(&modXYZ);
			
		}
		
	}
bool Singleton::anyMenuVisible ()
                              {
		bool doProc = false;
		int i;
		
		
		
		
		if ((mainGUI != NULL)) {
			if (mainGUI->isReady) {
				
				for (i = 0; i < E_FM_LENGTH; i++) {
					if (menuList[i] != NULL) {
						if (menuList[i]->visible){
							doProc = true;
						}
					}
				}
				
				
			}
		}
		
		return doProc;
		
	}
void Singleton::performCamShake (BaseObj * ge, float fp)
                                                    {
		float lastCamShake = cameraShake;
		
		cameraShake = max(
			cameraShake,
			fp
		);
		
		if (cameraShake > lastCamShake) {
			
			
			shakeTimer.stop();
			shakeTimer.start();
		}
		
		
	}
void Singleton::explodeBullet (BaseObj * ge)
                                        {
		
		FIVector4 newPos;
		
		
		
		newPos.setBTV(ge->getCenterPoint(E_BDG_CENTER));
		newPos.addXYZ(0.0f,0.0f,-2.0f);
		
		if (waterBulletOn) {
			playSoundEnt(
				"bubble0",
				ge,
				0.2f
			);
		}
		else {
			playSoundEnt(
				"explosion0",
				ge,
				0.2f,
				4.0
			);
			
			performCamShake(ge,1.0f);
		}
		
		sphereStack.push_back(SphereStruct());
		sphereStack.back().position.setBTV(ge->getCenterPoint(E_BDG_CENTER));
		sphereStack.back().curRad = 1.0f;
		sphereStack.back().maxRad = explodeRad;
		sphereStack.back().radVel = 40.0f;
		sphereStack.back().radAcc = -5.0f;
		
		
		//gameFluid[E_FID_SML]->pushExplodeBullet(true,&newPos,boolToInt(waterBulletOn));
		gameFluid[E_FID_BIG]->pushExplodeBullet(true,&newPos,boolToInt(waterBulletOn),explodeRad);
		
		explodeStack.push_back(ExplodeStruct());
		
		if (ge->hasBodies()) {
			explodeStack.back().pos = ge->bodies[E_BDG_CENTER].body->getCenterOfMassPosition();
			explodeStack.back().radius = 20.0f;
			explodeStack.back().power = 200.0f;
		}
		
		
		gem->removeVisObject(ge->uid, true);
		
	}
void Singleton::getJVNodeByString (JSONValue * rootNode, JSONValue * * resultNode, string stringToSplit)
          {
		//if (TEMP_DEBUG) cout << "getJVNodeByString(" << stringToSplit <<  ")\n";
		
		int i;
		*resultNode = rootNode;
		
		splitStrings.clear();
		splitStrings = split(stringToSplit, '.');
		
		for (i = 0; i < splitStrings.size(); i++) {
			//if (dd) cout << splitStrings[i] << "\n";
			
			if (
				(splitStrings[i][0] >= '0')	&&
				(splitStrings[i][0] <= '9')
			) {
				*resultNode = (*resultNode)->Child(
					stoi(splitStrings[i])
				);
			}
			else {
				if ( (*resultNode)->HasChild(splitStrings[i]) ) {
					*resultNode = (*resultNode)->Child(splitStrings[i]);
				}
				else {
					cout << "NULL RESULT NODE\n";
					*resultNode = NULL;
					return;
				}
			}
			
			
			
		}
		
	}
string Singleton::makePretty (string sourceString, string remString)
                                                                 {
		string newString = sourceString.substr(remString.size());
		
		
		std::string::size_type i;
		
		for (i = 0; i < newString.length(); i++) {
			if (i == 0) {
				
			}
			else {
				if (newString[i-1] == '_') {
					newString[i] = toupper(newString[i]);
				}
				else {
					newString[i] = tolower(newString[i]);
				}
			}
			
		}
		
		for (i = 0; i < newString.length(); i++) {
			if (newString[i] == '_') {
				newString[i] = ' ';
			}
		}
		
		return newString;
		
	}
void Singleton::cleanJVPointer (JSONValue * * jv)
                                            {
		
		if (*jv != NULL) {
			delete *jv;
		}
		
		*jv = NULL;
		
	}
void Singleton::getSpecialData (int datEnum, string datString)
                                                           {
		int i;
		int objectType;
		int childId;
		
		JSONValue* tempVal0;
		JSONValue* tempVal1;
		BaseObj* curCont;
		
		
		cleanJVPointer(&(externalJSON[datString].jv));
				
		externalJSON[datString].jv = new JSONValue(JSONObject());
		
		
		
		StatSheet* curSS;
		
		
		switch (datEnum) {
			case E_SDT_OBJECTDATA:
				externalJSON[datString].jv->object_value["objects"] = new JSONValue(JSONArray());
				tempVal0 = externalJSON[datString].jv->object_value["objects"];
				
				for (itBaseObj iterator = gem->gameObjects.begin(); iterator != gem->gameObjects.end(); iterator++) {
					// iterator->first = key
					// iterator->second = value
					
					curCont = &(gem->gameObjects[iterator->first]);
					
					if (curCont->isOpen) {
						
						tempVal0->array_value.push_back( new JSONValue(JSONObject()) );
						
						tempVal0->array_value.back()->object_value["children"] = new JSONValue(JSONArray());
						tempVal0->array_value.back()->object_value["objectId"] = new JSONValue( ((double)(iterator->first)) );
						tempVal1 = tempVal0->array_value.back()->Child("children");
						
						
						for (i = 0; i < curCont->children.size(); i++) {
							tempVal1->array_value.push_back(new JSONValue(JSONObject()));
							childId = curCont->children[i];
							objectType = gem->gameObjects[childId].objectType;
							tempVal1->array_value.back()->object_value["objectType"] = new JSONValue( ((double)(objectType)) );
							tempVal1->array_value.back()->object_value["objectId"] = new JSONValue( ((double)(childId)) );
						}
					}
				}
			break;
			case E_SDT_STATDATA:
				
				externalJSON[datString].jv->object_value["stats"] = new JSONValue(JSONArray());
				tempVal0 = externalJSON[datString].jv->object_value["stats"];
				
				if (gem->getCurActor() == NULL) {
					cout << "NULL STATS\n";
					return;
				}
				else {
					
					curSS = &(gem->getCurActor()->statSheet);
					
					for (i = 0; i < E_CS_LENGTH; i++) {
						tempVal0->array_value.push_back( new JSONValue(JSONObject()) );
						
						tempVal0->array_value.back()->object_value["label"] = new JSONValue( makePretty(E_CHAR_STAT_STRINGS[i],"E_CS_") );
						tempVal0->array_value.back()->object_value["value"] = new JSONValue( ((double)(curSS->unapplyedStats[i]))/((double)(MAX_STAT_VALUE)) );
						tempVal0->array_value.back()->object_value["divisions"] = new JSONValue( ((double)(MAX_STAT_VALUE)) );
						
						
					}
				}
			break;
			case E_SDT_STATUSDATA:
				
				externalJSON[datString].jv->object_value["status"] = new JSONValue(JSONArray());
				tempVal0 = externalJSON[datString].jv->object_value["status"];
				
				if (gem->getCurActor() == NULL) {
					cout << "NULL STATUS\n";
					return;
				}
				else {
					
					curSS = &(gem->getCurActor()->statSheet);
					
					for (i = 0; i < E_STATUS_LENGTH; i++) {
						tempVal0->array_value.push_back( new JSONValue(JSONObject()) );
						
						tempVal0->array_value.back()->object_value["label"] = new JSONValue( makePretty(E_CHAR_STATUS_STRINGS[i],"E_STATUS_") );
						tempVal0->array_value.back()->object_value["value"] = new JSONValue( ((double)(curSS->curStatus[i]))/((double)(curSS->maxStatus[i])) );
						tempVal0->array_value.back()->object_value["divisions"] = new JSONValue( ((double)(curSS->maxStatus[i])) );
						
						
					}
				}
			break;
			default:
				cout << "ERROR: unexpected type in getSpecialData(): " << datEnum << "\n";
			break;
		}
		
		
		
		
		
	}
void Singleton::updateStatGUI ()
                             {
		UIComponent* tempComp;
		
		
		if (gem->getCurActor() == NULL) {
			return;
		}
		
		StatSheet* curSS = &(gem->getCurActor()->statSheet);
		
		tempComp = getGUIComp("statMenu.availPoints");
		tempComp->setValue(
			((float)curSS->availPoints)/((float)(tempComp->divisions))
		);
		
		
		
	}
void Singleton::updateStatusHUD ()
                               {
		
		
		int i;
		
		if (gem->getCurActor() == NULL) {
			return;
		}
		if (menuList[E_FM_HUDMENU] == NULL) {
			return;
		}
		if (menuList[E_FM_HUDMENU]->visible) {
			
		}
		else {
			return;
		}
		
		StatSheet* curStatSheet = &(gem->getCurActor()->statSheet);
		
		UIComponent* tempComp = getGUIComp("hudMenu.statContainer");
		UIComponent* childComp;
		
		if (tempComp == NULL) {
			return;
		}
		
		float v1;
		float v2;
		
		for (i = 0; i < E_STATUS_LENGTH; i++) {
			childComp = tempComp->getChild(i);
			
			v1 = curStatSheet->curStatus[i];
			v2 = curStatSheet->maxStatus[i];
			
			childComp->setValue(v1/v2);
		}
		
		
	}
void Singleton::showHudMenu (bool visible)
                                       {
		if (menuList[E_FM_HUDMENU] != NULL) {
			menuList[E_FM_HUDMENU]->visible = visible;
			
			externalJSON.erase("E_SDT_STATUSDATA"); // mem leak?
			
			mainGUI->refreshNode(
				mainGUI->findNodeByString("hudMenu.hudContainer")	
			);
						
			if (visible) {
				
				updateStatGUI();
				
			}
			
			
		}
	}
void Singleton::showStatMenu (bool visible)
                                        {
		
		
		cout << "refreshStats\n";
		
		if (menuList[E_FM_STATMENU] != NULL) {
			menuList[E_FM_STATMENU]->visible = visible;
			externalJSON.erase("E_SDT_STATDATA"); // mem leak?
			externalJSON.erase("E_SDT_STATUSDATA"); // mem leak?
			
			mainGUI->refreshNode(
				mainGUI->findNodeByString("statMenu.statContainer")	
			);
						
			if (visible) {
				
				updateStatGUI();
				
			}
			
			
		}
		
	}
void Singleton::refreshContainers (bool onMousePos)
                                                {
		UIComponent* objCont = NULL;
		
		bool oldVis = false;
		
		if (menuList[E_FM_CONTMENU] != NULL) {
			
			cout << "refreshContainers\n";
			
			externalJSON.erase("E_SDT_OBJECTDATA"); // mem leak?
			
			
			
			oldVis = menuList[E_FM_CONTMENU]->visible;
			menuList[E_FM_CONTMENU]->visible = gem->anyContainerOpen();

			objCont = mainGUI->findNodeByString("objectContainer");
			//objCont->jvNodeNoTemplate->Child("dataParams")->number_value = contIndex;
			
			mainGUI->refreshNode(objCont);
			
			if (onMousePos&&(oldVis == false)) {
				
				// menuList[E_FM_CONTMENU]->dragOffset.x = 0.0f;
				// menuList[E_FM_CONTMENU]->dragOffset.y = 0.0f;
				contMenuBar = menuList[E_FM_CONTMENU]->getChild(0)->getChild(0);
				
				contMenuBar->lastDrag.x = (guiX);
				contMenuBar->lastDrag.y = min((float)(guiY), (float)( (guiWinH - menuList[E_FM_CONTMENU]->getChild(0)->resultDimInPixels.y) ));
				contMenuBar->forceDragUpdate = true;
			}
			
		}
	}
JSONValue * Singleton::fetchJSONData (string dataFile, bool doClean, JSONValue * params)
                                                                                          {
		
		
		bool doLoad = false;
		bool loadRes = false;
		int dataFileEnum;
		
		if (externalJSON.find( dataFile ) == externalJSON.end()) {
			doLoad = true;
		}
		else {
			if (externalJSON[dataFile].jv == NULL) {
				doLoad = true;
			}
			else {
				if (doClean) {
					cleanJVPointer( &(externalJSON[dataFile].jv) );
					doLoad = true;
				}
			}
		}
			
		if (doLoad) {
			
			dataFileEnum = stringToEnum(
				E_SPECIAL_DATA_TYPE_STRINGS,
				E_SDT_LENGTH,
				dataFile
			);
			
			switch (dataFileEnum) {
				case E_SDT_SHADERPARAMS:
					cout << "attempted to load shaderParams\n";
				break;
				case -1:
					cout << "load jv data "  + dataFile << "\n";
					loadRes = loadJSON(
						"..\\data\\" + dataFile,
						&((externalJSON[dataFile]).jv)
					);
					
					if (loadRes == false) {
						return NULL;	
					}
				break;
				default:
					getSpecialData(dataFileEnum, dataFile);
				break;
			}
			
			
			
			
		}
		
		
		
		return (externalJSON[dataFile]).jv;
	}
bool Singleton::processJSONFromString (string * sourceBuffer, JSONValue * * destObj)
          {
		cleanJVPointer(destObj);
		
		*destObj = JSON::Parse(sourceBuffer->c_str());

		if (*destObj == NULL)
		{
			doTraceND("Invalid JSON\n\n");
			doAlert();
			//cout << sourceBuffer << "\n\n";
			return false;
		}
		else
		{
			doTraceND("\nValid JSON\n");
			return true;
		}
		
	}
void Singleton::specialReplace (string & allTextString, string preDelim, string pstDelim)
          {
		
		string paramName;
		
		jsonPostStack.clear();
		
		std::size_t found;
		std::size_t found2;
		std::size_t found3;
		
		int baseIndex = 0;
		bool doCont = true;
		
		int preLen = preDelim.size();
		int pstLen = pstDelim.size();
		
		while (doCont) {
			found = allTextString.find(preDelim, baseIndex);
			if (found != std::string::npos) {
				
				
				baseIndex = found+preLen;
				//allTextString[found] = ' ';
				
				found3 = allTextString.find(' ', baseIndex);
				found2 = allTextString.find(pstDelim, baseIndex);
				
				if (found2 != std::string::npos) {
					
					if ( 
						((found2-found) > 32) || // max var length of 32
						(found3 < found2) // found a space between the delimitters
					) { 
						
					}
					else {
						baseIndex = found2+pstLen;
						//allTextString[found2] = ' ';
						
						paramName = allTextString.substr(found + preLen, (found2-found) - pstLen);
						
						jsonPostStack.push_back(paramName);
						
						cout << "PARAM NAME " << paramName << "\n";
						
					}
					
					doCont = true;
				}
				else {
					doCont = false;
				}
				
				
			}
			else {
				doCont = false;
			}
		}
		
	}
void Singleton::jsonPostProc ()
                            {
		
		std::size_t found = jsonPostString.find("@@", 0);
		if (found == std::string::npos) {
			return;	
		}
		
		string preStr = "\"@@";
		string pstStr = "@@\"";
		
		cout << "jsonPostProc\n";
		
		specialReplace(jsonPostString,preStr,pstStr);
		
		int i;
		int enumVal;
		bool doProc;
		
		string newString = "";
		
		for (i = 0; i < jsonPostStack.size(); i++) {
			enumVal = stringToEnum(E_JSON_PARAM_STRINGS,E_JP_LENGTH,jsonPostStack[i]);
			
			doProc = true;
			
			switch(enumVal) {
				case E_JP_STATMENUAVAILDIV:
					newString = i__s(E_CS_LENGTH*MAX_STAT_VALUE);
				break;
				default:
					doProc = false;
					cout << "invalid JSON Post Process Enum " << jsonPostStack[i] << "\n";
				break;
			}
			
			if (doProc) {
				replaceStr(jsonPostString, preStr+jsonPostStack[i]+pstStr, newString);
			}
			
			
			
			
		}
		
		jsonPostStack.clear();
		
	}
bool Singleton::processJSON (charArr * sourceBuffer, charArr * saveBuffer, JSONValue * * destObj)
          {
		
		cleanJVPointer(destObj);

		//doTraceND("destObj is now NULL");
		

		//doTraceND("processJSON()");

		char *buf = sourceBuffer->data;
		int len = sourceBuffer->size;
		//JSONValue *jsonVal = NULL;

		if (saveBuffer != &nullBuffer)
		{
			if (saveBuffer->data != NULL)
			{
				delete[] saveBuffer->data;
				saveBuffer->data = NULL;
			}
			saveBuffer->data = new char[len];
			strncpy(saveBuffer->data, buf, len);
			saveBuffer->size = len;
		}

		//doTraceND("Begin JSON::Parse()");

		if (buf == NULL)
		{
			//doTraceND("buf is NULL");
			return false;
		}
		else
		{
			//doTraceND("buf is not NULL");
			
			jsonPostString = string(buf);
			jsonPostProc();
			
			
			*destObj = JSON::Parse(jsonPostString.c_str());
		}


		//doTraceND("End JSON::Parse()");


		if (*destObj == NULL)
		{
			doTraceND("Invalid JSON\n\n");
			doAlert();
			return false;
		}
		else
		{
			doTraceND("\nValid JSON\n");
			
			
			
			return true;
		}


	}
void Singleton::doAlert ()
                       {
		playSound("xylo0", 1.0f);
	}
bool Singleton::loadJSON (string path, JSONValue * * destObj)
          {
		
		bool res = false;
		
		charArr dest;
		dest.data = NULL;
		dest.size = 0;
		
		if ( loadFile(path, &dest) )
		{
			if (processJSON(&dest, &nullBuffer, destObj)) {
				res = true;
			}
			else {
				res = false;
			}
		}
		else {
			res = false;
		}
		
		
		if (dest.data != NULL)
		{
			delete[] dest.data;
			dest.data = NULL;
		}
		
		return res;
		
	}
void Singleton::setGUIText (string key, string stringValue, float floatValue, bool applyVal, bool applyString)
          {
		UICStruct* curComp;
		if (compMap.find( key ) == compMap.end()) {
			// invalid key
		}
		else {
			curComp = &(compMap[key]);
			
			if (curComp->nodeId < 0) {
				// component was deleted
			}
			else {
				if (applyString) {
					compStack[curComp->nodeId].data->setText(stringValue);
				}
				if (applyVal) {
					compStack[curComp->nodeId].data->setValue(floatValue);
				}
				
			}
		}
	}
float Singleton::getGUIValue (string key)
                                      {
		UICStruct* curComp;
		if (compMap.find( key ) == compMap.end()) {
			// invalid key
		}
		else {
			curComp = &(compMap[key]);
			
			if (curComp->nodeId < 0) {
				// component was deleted
			}
			else {
				return compStack[curComp->nodeId].data->getValue();
			}
		}
		
		return 0.0;
	}
UIComponent * Singleton::getGUIComp (string key)
                                            {
		UICStruct* curComp;
		if (compMap.find( key ) == compMap.end()) {
			// invalid key
		}
		else {
			curComp = &(compMap[key]);
			
			if (curComp->nodeId < 0) {
				// component was deleted
			}
			else {
				return compStack[curComp->nodeId].data;
			}
		}
		
		return NULL;
	}
void Singleton::setGUIValue (string key, float floatValue, bool dispatchEvent, bool preventRefresh)
          {
		UICStruct* curComp;
		
		if (compMap.find( key ) == compMap.end()) {
			// invalid key
		}
		else {
			curComp = &(compMap[key]);
			
			if (curComp->nodeId < 0) {
				// component was deleted
			}
			else {
				compStack[curComp->nodeId].data->setValue(floatValue,dispatchEvent,preventRefresh);
			}
		}
	}
void Singleton::loadValuesGUI (bool applyValues)
                                                     {
		
		cout << "Loading GUI Values\n";
		
		int i;
		
		charArr dest;
		dest.data = NULL;
		dest.size = 0;
		
		UICStruct* curComp;
		
		string loadBuf;
		//vector<string> splitStrings;
		
		
		if ( loadFile(guiSaveLoc, &dest) )
		{
			loadBuf = string(dest.data);
			
			splitStrings.clear();
			splitStrings = split(loadBuf, '^');
			
			for (i = 0; i < splitStrings.size(); i += 2) {
				
				setGUIValue(
					splitStrings[i],
					hexToFloat( &(splitStrings[i+1]) ),
					true,
					true
				);
				
				if (applyValues) {
					
				}
				else {
					
				}
				
			}
			
		}
		else {
			cout << "Unable to load GUI Values\n";
			
		}
		
		if (dest.data != NULL)
		{
			delete[] dest.data;
			dest.data = NULL;
		}
		
		cout << "End Loading GUI Values\n";
	}
void Singleton::saveExternalJSON ()
                                {
		
		cout << "Saving External JSON Values\n";
		
		
		
		
		for(itJSStruct iterator = externalJSON.begin(); iterator != externalJSON.end(); iterator++) {
			
			if (iterator->second.jv != NULL) {
				saveFileString(
					"..\\data\\" + iterator->first,
					&(iterator->second.jv->Stringify())
				);
			}
			
			// iterator->first = key
			// iterator->second = value
		}
		
		
		
		cout << "End Saving External JSON Values\n";
	}
void Singleton::saveGUIValues ()
                             {
		
		cout << "Saving GUI Values\n";
		
		stringBuf = "";
		
		for(itUICStruct iterator = compMap.begin(); iterator != compMap.end(); iterator++) {
				
				if (iterator->second.nodeId < 0) {
					
				}
				else {
					if (iterator->first[0] ==  '$') { // values with $ are saved
						stringBuf.append(
							iterator->first + "^" + floatToHex(compStack[iterator->second.nodeId].data->getValue()) + "^"
						);
					}
					
					
				}
				
		    // iterator->first = key
		    // iterator->second = value
		}
		
		saveFileString(guiSaveLoc,&stringBuf);
		
		cout << "End Saving GUI Values\n";
	}
void Singleton::updateGUI ()
                         {
		
		float chunkMem;
		float fbMem;
		
		
		
		int mvPerPage = 1;
		
		float voxelsGen = PAGE_COUNT*mvPerPage;
		
		string maxGPUMString = " / " + fi__s(MAX_GPU_MEM);
		
		// if (frameCount%120 == 0) {
			
		// 	chunkMem = 0;
		// 	fbMem = TOT_GPU_MEM_USAGE - chunkMem;
			
			
		// 	setGUIText("debug.fbMem", "Frame Buffer Mem Used: " + fi__s(fbMem) + maxGPUMString, fbMem/MAX_GPU_MEM, true );
		// 	setGUIText("debug.chunkMem", "Chunk Mem Used: " + fi__s(chunkMem) + maxGPUMString, chunkMem/MAX_GPU_MEM, true );
		// 	setGUIText("debug.totMem", "Total Mem Used: " + fi__s(TOT_GPU_MEM_USAGE) + maxGPUMString, TOT_GPU_MEM_USAGE/MAX_GPU_MEM, true );
		// 	setGUIText("debug.chunksGen", "Voxels Generated (In Millions!): " + fi__s(voxelsGen) );
			 
		// }
		
	}
void Singleton::beginFieldInput (string defString, int cb)
                                                       {
		currentFieldString = defString;
		
		fieldCallback = cb;
		
		inputOn = true;
		menuList[E_FM_FIELDMENU]->visible = true;
		
		if (fieldText != NULL) {
			if (currentFieldString.compare("") == 0) {
				fieldText->setText(" ");
			}
			else {
				fieldText->setText(currentFieldString);
			}
			
		}
	}
void Singleton::processFieldInput (unsigned char key)
                                                  {
		
		bool doRef = false;
		
		switch (key) {
			case 13: // enter
				endFieldInput(true);
			break;
			case 27: // esc
				endFieldInput(false);
			break;
			case 8: // backspace
				currentFieldString = currentFieldString.substr(0, currentFieldString.size()-1);
				doRef = true;
			break;
			default:
				currentFieldString += key;
				doRef = true;
			break;
		}
		
		if (doRef) {
			if (fieldText != NULL) {
				fieldText->setText(currentFieldString);
			}
		}
	}
void Singleton::endFieldInput (bool success)
                                         {
		
		inputOn = false;
		menuList[E_FM_FIELDMENU]->visible = false;
		
		if (success) {
			switch (fieldCallback) {
				case E_FC_SAVEORG:
					gem->saveOrgFromMenu(currentFieldString);
				break;
				case E_FC_LOADORG:
					gem->loadOrgFromMenu(currentFieldString);					
				break;
				
			}
		}
		
	}
void Singleton::saveOrg ()
                       {
		beginFieldInput("",E_FC_SAVEORG);
	}
void Singleton::loadOrg ()
                       {
		beginFieldInput("",E_FC_LOADORG);
	}
float Singleton::getConst (string conName)
                                       {
		if (constRootJS == NULL) {
			
		}
		else {
			if (constRootJS->HasChild(conName)) {
				return constRootJS->Child(conName)->number_value;
			}
			else {
				doAlert();
				cout << "Missing: " << conName << "\n";
			}
		}
		return 0.0f;
	}
int Singleton::iGetConst (int ev)
                              {
		return conVals[ev];
	}
void Singleton::loadConstants ()
                             {
		int i;
		if (loadJSON("..\\data\\constants.js", &constRootJS)) {
			
			for (i = 0; i < E_CONST_LENGTH; i++) {
				conVals[i] = getConst(E_CONST_STRINGS[i]);
			}
			
		}
		
		mapAmps.setFXYZW(
			conVals[E_CONST_MAPAMP0],
			conVals[E_CONST_MAPAMP1],
			conVals[E_CONST_MAPAMP2],
			conVals[E_CONST_MAPAMP3]
		);
		mapFreqs.setFXYZW(
			conVals[E_CONST_MAPFREQ0],
			conVals[E_CONST_MAPFREQ1],
			conVals[E_CONST_MAPFREQ2],
			conVals[E_CONST_MAPFREQ3]
		);
		
		STEP_TIME_IN_SEC = conVals[E_CONST_STEP_TIME_IN_MICRO_SEC]/1000000.0;
		
		
	}
void Singleton::loadGUI ()
                       {
		int i;
		
		externalJSON.clear();
		doShaderRefresh(bakeParamsOn);
		
		for(itUICStruct iterator = compMap.begin(); iterator != compMap.end(); iterator++) {
				iterator->second.nodeId = -1;
		    // iterator->first = key
		    // iterator->second = value
		}
		
		
		
		
		if (
			loadJSON("..\\data\\lastJSONBufferGUI.js", &guiRootJS)
		) {
			mainGUI->guiFromJSON(
				guiRootJS
			);
		
			// for(itUICStruct iterator = compMap.begin(); iterator != compMap.end(); iterator++) {
			// 	if (iterator->second.nodeId != -1) {
			// 		//iterator->second.uic = (compStack[iterator->second.nodeId].data);
			// 	}
			// }
		
		}
		
		for (i = 0; i < E_FM_LENGTH; i++) {
			menuList[i] = getGUIComp("guiHandles." + E_FLOATING_MENU_STRINGS[i]);
			if (menuList[i] != NULL) {
				menuList[i]->visible = false;
			}
		}
		
		
		mapComp = getGUIComp("map.mapHolder");
		fieldText = getGUIComp("fieldMenu.field");
		
		
		updateMatFlag = true;
		
		
	}
string Singleton::loadFileString (string fnString)
                                               {
		// charArr tempFile;
		// tempFile.data = NULL;
		// tempFile.size = 0;
		// string tempFileString;
		
		
		// if ( loadFile(fnString,&tempFile) ) {
		// 	tempFileString = string(tempFile.data);
			
		// 	if (tempFile.data != NULL)
		// 	{
		// 		delete[] tempFile.data;
		// 		tempFile.data = NULL;
		// 		tempFile.size = 0;
		// 	}
			
		// 	cout << "::::::::::: \n\n\n\n";
			
		// 	cout << tempFileString << "\n";
			
		// 	cout << "::::::::::: \n\n\n\n";
			
		// 	return tempFileString;
			
		// }
		// else {
		// 	return "";
		// }
		
		
		std::ifstream t(fnString);
		std::stringstream buffer;
		buffer << t.rdbuf();
		
		return buffer.str();
		
	}
std::ifstream::pos_type Singleton::filesize (char const * filename)
        {
	    std::ifstream in(filename, std::ifstream::ate | std::ifstream::binary);
	    return in.tellg(); 
	}
bool Singleton::loadFile (string fnString, charArr * dest)
        {
		
		const char* fileName = fnString.c_str();
		
		doTraceND("Loading: ", fileName);

		if (dest == NULL)
		{
			doTraceND("Null Data");
			return false;
		}

		std::ifstream infile (fileName, std::ifstream::in);


		if ( ! infile.is_open() )
		{
			doTraceND("Could Not Open File For Loading");
			return false;
		}

		// // get size of file
		// infile.seekg (0, infile.end);
		// long size = (long)infile.tellg();
		// infile.seekg (0, infile.beg);

		long mySize = filesize(fnString.c_str());

		dest->size = mySize;

		if (dest->data != NULL)
		{
			delete[] dest->data;
			dest->data = NULL;
		}

		dest->data = new char[mySize+8];

		// read content of infile
		infile.read (dest->data, mySize);

		if ( infile.bad() )
		{
			doTraceND("Could Not Load From File");
			infile.close();
			return false;
		}

		infile.close();
		
		dest->data[mySize] = '\0';

		doTraceND("Load Successful");

		return true;
	}
bool Singleton::saveFileString (string fileName, string * source)
        {

		if (source == NULL)
		{
			doTraceND("Null Data");
			return false;
		}

		std::ofstream outfile (fileName.c_str(), std::ofstream::out);

		if ( ! outfile.is_open() )
		{
			doTraceND("Could Not Open File For Saving");
			return false;
		}

		outfile.write(source->c_str(), source->size());

		if ( outfile.bad() )
		{
			doTraceND("Could Not Save To File");
			outfile.close();
			return false;
		}

		outfile.close();

		doTraceND("Save Successful");

		return true;
	}
bool Singleton::saveFile (char * fileName, charArr * source)
        {

		if (source->data == NULL)
		{
			doTraceND("Null Data");
			return false;
		}

		std::ofstream outfile (fileName, std::ofstream::out);

		if ( ! outfile.is_open() )
		{
			doTraceND("Could Not Open File For Saving");
			return false;
		}

		outfile.write (source->data, source->size);

		if ( outfile.bad() )
		{
			doTraceND("Could Not Save To File");
			outfile.close();
			return false;
		}

		outfile.close();

		doTraceND("Save Successful");

		return true;
	}
float Singleton::getUnderWater ()
                              {
		if (
			(gw->getCellAtCoords(
				cameraGetPosNoShake()->getFX(),
				cameraGetPosNoShake()->getFY(),
				cameraGetPosNoShake()->getFZ() - 1.0f
			) == E_CD_WATER) ||
			(cameraGetPosNoShake()->getFZ() < (getSeaHeightScaled()-32.0f))	
		) {
			return 1.0;
		}
		else {
			return 0.0;
		}
		
	}
void Singleton::updateAmbientSounds ()
                                   {
		
		int i;
		int j;
		
		int maxRad = 2;
		
		float avgHeight = 0.0f;
		float tot = 0.0f;
		
		for (i = -maxRad; i <= maxRad; i++) {
			for (j = -maxRad; j <= maxRad; j++) {
				avgHeight += getHeightAtPixelPos(
					cameraGetPosNoShake()->getFX() + i*256.0f,
					cameraGetPosNoShake()->getFY() + j*256.0f
				);
				tot += 1.0f;
			}
		}
		
		float terHeight = avgHeight/tot;
		
		float seaHeight = getSeaHeightScaled();
		
		float heightDif = clampf((terHeight-seaHeight)/(1024.0f), 0.0f, 1.0f);
		
		float isUnderWater = getUnderWater();
		
		// if (cameraGetPosNoShake()->getFZ() < seaHeight) {
		// 	isUnderWater = 1.0f;	
		// }
		
		
		
		music[EML_BIRDSONG0]->setVolume(masterVolume*ambientVolume*timeOfDay*heightDif*(1.0-isUnderWater));
		music[EML_CRICKETS0]->setVolume(masterVolume*ambientVolume*(1.0f-timeOfDay)*heightDif*(1.0-isUnderWater));
		music[EML_OCEANWAVES0]->setVolume(masterVolume*ambientVolume*(1.0f-heightDif)*(1.0-isUnderWater));
		music[EML_UNDERWATER0]->setVolume(masterVolume*ambientVolume*(isUnderWater));
		
		
	}
void Singleton::frameUpdate ()
                           {
		
		float temp;
		float temp2;
		
		//int currentTickMod = 0;
		
		if (firstRun) {
			
		}
		else {
			//curMoveTime = moveTimer.getElapsedTimeInMicroSec();
			
			// if (lastMoveTime == 0.0) {
			// 	//timeDelta = 0.0f;
			// }
			// else {
				
			// 	if (ignoreFrameLimit) {
			// 		timeDelta = 
			// 			timeDelta = bulletTimer.getTimeMicroseconds()/1000000.0;//*0.999 + ((curMoveTime-lastMoveTime)/1000000.0)*0.001;//TIME_DELTA;
			// 			bulletTimer.reset();
			// 			//1.0/45.0;
			// 	}
			// 	else {
			// 		timeDelta = 1.0/120.0;
			// 	}
				
				
				
				
			// 	// if (smoothMove) {
			// 	// 	timeDelta = 1.0f/90.0f;
			// 	// }
			// 	// else {
			// 	// 	timeDelta = 1.0f/90.0f;
			// 	// }
				
			// 	//60.0f;//(curMoveTime-lastMoveTime)/1000000.0;
			// }
			
			//lastMoveTime = curMoveTime;
			
			
			
			
			// #######
			
			
			////////////////////////////////
			
			
			// WAS DOING: PASS KEY STATE (BITFLAG) TO NETWORK FOR EACH TICK AND MOUSE STATE
			
			
			////////////////////////////////
			
			
			
			// #######
			
			
			
			
		}
		
		
		
		if (updateMatFlag&&(!matVolLock)) {
			updateMatFlag = false;
			updateMatVol();
		}
		
		
		if (ignoreFrameLimit) {
			subjectZoom += (targetSubjectZoom - subjectZoom) / 32.0f;
			cameraZoom += (targetZoom - cameraZoom) / 4.0f;
		}
		
		
		
		if (!placingGeom) {
			if (abs(globWheelDelta) > 0.001f) {
				if (gem->getCurActor() != NULL) {
					subjectDelta -= globWheelDelta;
					targetSubjectZoom = pow(2.0, subjectDelta);
					if (!ignoreFrameLimit) {
						subjectZoom = targetSubjectZoom;
					}
				}
			}
		}

		globWheelDelta *= 0.5f;
		
		
		
		if (cameraZoom < 1.0f) {
			cameraZoom = 1.0f;
		}
		
		float hs = cellsPerHolder;
		
		float scrollAmount = 0.0f;
		
		updateAmbientSounds();
		if ((mainGUI != NULL)) {
			if (mainGUI->isReady) {
				//mainGUI->testOver(guiX, guiY);
			}
		}
		syncObjects();
		updateGUI();
		
		
		if (
			(gw->mapLockOn) ||
			(mapInvalid)
		) {
			
		}
		else {
			
			
			
			if (mainGUI != NULL) {
				if (mainGUI->isReady) {
					currentTick++;
					
					
					
					if (gem->getCurActor() != NULL) {
						if ((currentTick%10) == 0) {
							
							// if (rbDown) {
							// 	makeShoot(gem->getCurActor()->uid, E_ENTTYPE_TRACE);
							// }
							
							
						}
					}
					
					if (currentTick > 2) {
						
						
						updateCamVals();
						
						
						
						
						// if (currentTick < 2) {
						// 	gw->update();
						// }
						
						if (currentTick < 4) {
							cameraGetPosNoShake()->setFXYZ(2048.0,2048.0,0.0);
							camLerpPos.copyFrom(cameraGetPosNoShake());
						}
						
						if (currentTick == 4) {
							setCameraToElevation();
							
							gamePhysics = new GamePhysics();
							gamePhysics->init(this);
							
							GLint maxTBO;
							glGetIntegerv(GL_MAX_TEXTURE_BUFFER_SIZE, &maxTBO);
							cout << "GL_MAX_TEXTURE_BUFFER_SIZE " << maxTBO << "\n";
							
							
						}
						
						if (
							(gem->getCurActor() != NULL) &&
							gem->getCurActor()->hasBodies()	
						) {
							
							if (gem->getCurActor()->bodies[E_BDG_CENTER].inWater) {
								temp = clampfZO(
									gem->getCurActor()->getVel(0)->length()
								)*0.25f;
								temp2 = 0.0f;
							}
							else {
								
								if (gem->getCurActor()->allFalling()) {
									temp2 = 0.0f;
								}
								else {
									temp2 = clampfZO(
										gem->getCurActor()->getVel(0)->length()
									);
								}
								
								temp = 0.0f;
							}
							
							
							
							updateSoundPosAndPitch(
								"swimming0",
								cameraGetPosNoShake(),
								BTV2FIV(gem->getCurActor()->getCenterPoint(E_BDG_CENTER)),
								temp*0.2,
								0.01
							);
							updateSoundPosAndPitch(
								"walkinggravel0",
								cameraGetPosNoShake(),
								BTV2FIV(gem->getCurActor()->getCenterPoint(E_BDG_CENTER)),
								temp2*0.2,
								0.1
							);
						}
						
						
						// if (
						// 	gameFluid[E_FID_SML]->fluidReading ||
						// 	gameFluid[E_FID_BIG]->fluidReading
						// ) {
						// 	if (gameFluid[E_FID_BIG]->fluidReading) {
						// 		if (gameFluid[E_FID_SML]->cycleTerminated) {
						// 			gameFluid[E_FID_BIG]->updateAll();
						// 		}
						// 		else {
						// 			// wait for small fluid to finish its cycle
						// 			gameFluid[E_FID_SML]->updateAll();
						// 		}
						// 	}
						// 	else {
						// 		if (gameFluid[E_FID_BIG]->cycleTerminated) {
						// 			gameFluid[E_FID_SML]->updateAll();
						// 		}
						// 		else {
						// 			// wait for big fluid to finish its cycle
						// 			gameFluid[E_FID_BIG]->updateAll();
						// 		}
						// 	}
						// }
						// else {
							
							
						// 	gameFluid[E_FID_SML]->updateAll();
						// 	gameFluid[E_FID_BIG]->updateAll();
							
						// 	if (
						// 		gameFluid[E_FID_SML]->fluidReading ||
						// 		gameFluid[E_FID_BIG]->fluidReading
						// 	) {
								
						// 	}
						// 	else {
								
						// 		if (gameFluid[E_FID_SML]->cycleTerminated) {
						// 			gameFluid[E_FID_SML]->cycleTerminated = false;
									
						// 			//tempVec1.copyFrom(&(gameFluid[E_FID_SML]->volMinReadyInPixels));
						// 			//tempVec1.addXYZRef(&(gameFluid[E_FID_SML]->volMinReadyInPixels),-1.0f);
									
						// 			// gameFluid[E_FID_BIG]->copyPrimTexture(
						// 			// 	tempVec1[0],
						// 			// 	tempVec1[1],
						// 			// 	tempVec1[2],
						// 			// 	gameFluid[E_FID_SML]->volSizePrim,
						// 			// 	&(gameFluid[E_FID_SML]->volDataPrim[0])
						// 			// );
									
						// 			gameFluid[E_FID_SML]->startFT();
						// 		}
								
								
						// 		if (gameFluid[E_FID_BIG]->cycleTerminated) {
						// 			gameFluid[E_FID_BIG]->cycleTerminated = false;
						// 			gameFluid[E_FID_BIG]->startFT();
						// 		}
						// 	}
						// }
						
						if ((!draggingMap)&&(!fpsTest)&&updateHolders) {
							gameFluid[E_FID_BIG]->updateAll();
							
							if (gameFluid[E_FID_BIG]->fluidReading) {
								if (gameFluid[E_FID_BIG]->proceedingToRead) {
									gameFluid[E_FID_BIG]->tryToEndRead();
								}
								else {
									gameFluid[E_FID_BIG]->proceedWithRead();
								}
							}
							
							
							if (gameFluid[E_FID_BIG]->readyForTermination) {
								
								
								if (
								 gameFluid[E_FID_BIG]->anyThreadsRunning()
								) {
									
								}
								else {
									gameFluid[E_FID_BIG]->readyForTermination = false;
									gameFluid[E_FID_BIG]->cycleTerminated = true;
								}
								
								
							}
							
							if (gameFluid[E_FID_BIG]->cycleTerminated) {
								
								gameLogic->loadNearestHolders();
								
								gameFluid[E_FID_BIG]->cycleTerminated = false;
								gameFluid[E_FID_BIG]->startFT();
							}
						}
						
						
					}
					
					
					
					if ((currentTick > 4)&&allInit) {
						
						
						//gw->drawPrim();
						
						if (renderingOct) {
							gw->renderOct(gameOct);
						}
						else {
							gw->update();
						}
						
						
						if (GEN_POLYS_WORLD) {
							gw->generateBlockHolder();
						}
						
						if (gem->turnBased) {
							if (
								((tbTicks%iGetConst(E_CONST_TURNBASED_TICKS)) == 0)
								// || (gem->getCurActor() != NULL)
							) {
								gem->cycleTurn();
							}
							tbTicks++;
						}
						
					}
					
					
					
				}
			}
			
		}
		
		
		
		
		
		
		
		
		
		
		TRACE_ON = false;
		
		
		frameCount++;
	}
FIVector4 * Singleton::cameraGetPos ()
                                  {
		return &resultCameraPos;
	}
FIVector4 * Singleton::cameraGetPosNoShake ()
                                         {
		return cameraPos;
	}
float Singleton::getTargetTimeOfDay ()
                                   {
		return 1.0f-(lightVecOrig.getFZ() + 1.0f)*0.5f;
	}
void Singleton::updateBullets ()
                             {
		int i;
		SphereStruct* ss;
		
		for (i = 0; i < sphereStack.size(); i++) {
			ss = &(sphereStack[i]);
			
			ss->radVel += ss->radAcc*timeDelta;
			ss->curRad += ss->radVel*timeDelta;
			
			if (ss->curRad >= ss->maxRad) {
				ss->curRad = ss->maxRad;
				ss->radVel = 0.0f;
			}
		}
		
		for (i = 0; i < sphereStack.size(); i++) {
			ss = &(sphereStack[i]);
			if (ss->curRad <= 0.0) {
				sphereStack.erase(sphereStack.begin() + i);
			}
		}
	}
void Singleton::display (bool doFrameRender)
        {
		
		bool noTravel = false;
		
		float maxPhysTime = 
			conVals[E_CONST_STEP_TIME_IN_MICRO_SEC]*
			conVals[E_CONST_PHYS_STEPS_PER_FRAME];
		
		
		frameSkipCount++;
		
		
		curTime = myTimer.getElapsedTimeInMilliSec();
		smoothTime = (sin(curTime/200.0)+1.0f)*0.5f;
		
		if (timeMod) {
			pauseTime = curTime;
		}
		

		//float elTime = curTime - lastTime;
		
		// #ifdef USE_POCO
		// 	if (myWS == NULL)
		// 	{

		// 	}
		// 	else
		// 	{

		// 		if (myWS->dataReady)
		// 		{

		// 			if (myWS->isJSON)
		// 			{
		// 				// if ( processJSON( &(myWS->recBuffer), &lastJSONBuffer, &rootObjJS ) )
		// 				// {
		// 				// 	saveAllData();

		// 				// }
		// 			}
		// 			else
		// 			{
		// 				//processB64(  &(myWS->recBuffer), &lastImageBuffer );

		// 			}

		// 			myWS->dataReady = false;
		// 			myWS->isWorking = false;
		// 		}
		// 	}
		// #endif

		
		int i;
		
		for (i = 0; i < MAX_KEYS; i++) {
			if (keysPressed[i]) {
				break;
			}
		}
		
		if (i != MAX_KEYS) {
			frameMouseMove = true;
		}
		
		if (firstRun) {
			bulletTimer.reset();
		}
		
		unsigned long int curTimePassed = bulletTimer.getTimeMicroseconds();
		timeDelta = 1.0/60.0;
		bulletTimer.reset();
		
		//totTimePassedGraphics += curTimePassed;
		// totTimePassedPhysics += curTimePassed*conVals[E_CONST_SPEEDUP_FACTOR];
		
		// if (totTimePassedPhysics > maxPhysTime) {
		// 	totTimePassedPhysics = maxPhysTime;
		// }
		
		
		if (currentTick > 4) {
			if (gamePhysics != NULL) {
				
				
				if (threadNetRecv.isReady()) {
					stopNT2();
					
					gameNetwork->applyNetworkActions();
					
					if (gameNetwork->isConnected) {
						startNT2();
					}
					
				}
				
				
				if (threadNetSend.isReady()) {
					stopNT();
					
					gameNetwork->flushNetworkActions();
					
					if (gameNetwork->isConnected) {
						startNT();
					}
					
				}
				
				gameLogic->applyBehavior();
				
				if (gem->turnBased) {
					
				}
				else {
								
				}
								
				
				flushKeyStack();
				gatherKeyActions();
				handleMovement();
				
				
				// if (destructCount > 50000) {
				// 	waitingOnDestruction = false;
				// }
				
				// if (waitingOnDestruction) {
				// 	destructCount++;
				// }
				// else {
					
				// }
				
				if (physicsOn) {
					gamePhysics->updateAll();
				}
				
				
			}
		}
		
		updateBullets();
		

		if (
			//true  
			// ( 
			// 	((frameSkipCount%frameSkip) == 0) &&
			// 	(frameMouseMove||ignoreFrameLimit)
			// ) || fpsTest
			//totTimePassedGraphics > 8000
			
			true
		) {
			//cout << "totTimePassedGraphics " << totTimePassedGraphics << "\n";
			//totTimePassedGraphics -= 8000;
			
			frameMouseMove = false;

			if (firstRun)
			{
				
			}
			else
			{
				// if ( (frameCount % 3000) == 0)
				// {
				// 	gw->updateLights();
				// }
			}

			


			//lastTime = curTime;
			timeOfDay += (getTargetTimeOfDay() - timeOfDay) / 8.0;

			if (
				lbDown &&
				gem->isDraggingObject && 
				(gem->draggingFromType != E_DT_NOTHING) &&
				((curTime-mdTime) > 300) &&
				(!gem->editPose)
			) {
				glutSetCursor(GLUT_CURSOR_CROSSHAIR);
			
				mouseMoveVec.setFXYZ(lastMouseX,lastMouseY,0.0);
				noTravel = mouseMoveVec.distance(&mouseStart) < MAX_TRAVEL_DIS;	
				markerFound = !noTravel;
				getPixData(&worldMarker, lastMouseX, lastMouseY, true, false);
			
			}
			else {
				markerFound = (menuList[E_FM_DDMENU]->visible)&&(gem->selObjInd < E_OBJ_LENGTH);
				glutSetCursor(GLUT_CURSOR_RIGHT_ARROW);
			}


			mouseMovingLoc = (mouseMovingLoc + 1) % mouseMovingSize;
			mouseCount++;
			mouseMoving[mouseMovingLoc].setIXY(lastMouseX, lastMouseY);



			

			if (shadersAreLoaded)
			{

				if (traceOn)
				{
					traceOn = false;
					TRACE_ON = true;
				}
				if (updateLock)
				{

				}
				else
				{
					
					
					
					//if (doFrameRender) {
						frameUpdate();
						lastDepthInvalidMove = depthInvalidMove;
						depthInvalidMove = false;
						depthInvalidRotate = false;
					//}
					
				}
			}
			
			


			if (fpsTest) {
				fpsCount++;
				
				if (fpsCount == fpsCountMax) {
					
					fpsTest = false;
					
					cout << "Average Frame Time: " << (fpsTimer.getElapsedTimeInMilliSec()*1000.0/((double)(fpsCountMax))) << "\n";
					cout << "FPS: " << 1.0/(fpsTimer.getElapsedTimeInSec()/((double)(fpsCountMax))) << "\n";
					fpsTimer.stop();
				}
				
			}
			
		}
		

		if (firstRun)
		{
			//toggleFullScreen();
		}

		firstRun = false;
		
		

		//doTrace( "POSSIBLE ERROR: " , i__s(glGetError()) , "\n" );

	}
bool Singleton::gluInvertMatrix (double const (m) [16], float (invOut) [16])
        {
	    float inv[16], det;
	    int i;

	    inv[0] = m[5]  * m[10] * m[15] - 
	             m[5]  * m[11] * m[14] - 
	             m[9]  * m[6]  * m[15] + 
	             m[9]  * m[7]  * m[14] +
	             m[13] * m[6]  * m[11] - 
	             m[13] * m[7]  * m[10];

	    inv[4] = -m[4]  * m[10] * m[15] + 
	              m[4]  * m[11] * m[14] + 
	              m[8]  * m[6]  * m[15] - 
	              m[8]  * m[7]  * m[14] - 
	              m[12] * m[6]  * m[11] + 
	              m[12] * m[7]  * m[10];

	    inv[8] = m[4]  * m[9] * m[15] - 
	             m[4]  * m[11] * m[13] - 
	             m[8]  * m[5] * m[15] + 
	             m[8]  * m[7] * m[13] + 
	             m[12] * m[5] * m[11] - 
	             m[12] * m[7] * m[9];

	    inv[12] = -m[4]  * m[9] * m[14] + 
	               m[4]  * m[10] * m[13] +
	               m[8]  * m[5] * m[14] - 
	               m[8]  * m[6] * m[13] - 
	               m[12] * m[5] * m[10] + 
	               m[12] * m[6] * m[9];

	    inv[1] = -m[1]  * m[10] * m[15] + 
	              m[1]  * m[11] * m[14] + 
	              m[9]  * m[2] * m[15] - 
	              m[9]  * m[3] * m[14] - 
	              m[13] * m[2] * m[11] + 
	              m[13] * m[3] * m[10];

	    inv[5] = m[0]  * m[10] * m[15] - 
	             m[0]  * m[11] * m[14] - 
	             m[8]  * m[2] * m[15] + 
	             m[8]  * m[3] * m[14] + 
	             m[12] * m[2] * m[11] - 
	             m[12] * m[3] * m[10];

	    inv[9] = -m[0]  * m[9] * m[15] + 
	              m[0]  * m[11] * m[13] + 
	              m[8]  * m[1] * m[15] - 
	              m[8]  * m[3] * m[13] - 
	              m[12] * m[1] * m[11] + 
	              m[12] * m[3] * m[9];

	    inv[13] = m[0]  * m[9] * m[14] - 
	              m[0]  * m[10] * m[13] - 
	              m[8]  * m[1] * m[14] + 
	              m[8]  * m[2] * m[13] + 
	              m[12] * m[1] * m[10] - 
	              m[12] * m[2] * m[9];

	    inv[2] = m[1]  * m[6] * m[15] - 
	             m[1]  * m[7] * m[14] - 
	             m[5]  * m[2] * m[15] + 
	             m[5]  * m[3] * m[14] + 
	             m[13] * m[2] * m[7] - 
	             m[13] * m[3] * m[6];

	    inv[6] = -m[0]  * m[6] * m[15] + 
	              m[0]  * m[7] * m[14] + 
	              m[4]  * m[2] * m[15] - 
	              m[4]  * m[3] * m[14] - 
	              m[12] * m[2] * m[7] + 
	              m[12] * m[3] * m[6];

	    inv[10] = m[0]  * m[5] * m[15] - 
	              m[0]  * m[7] * m[13] - 
	              m[4]  * m[1] * m[15] + 
	              m[4]  * m[3] * m[13] + 
	              m[12] * m[1] * m[7] - 
	              m[12] * m[3] * m[5];

	    inv[14] = -m[0]  * m[5] * m[14] + 
	               m[0]  * m[6] * m[13] + 
	               m[4]  * m[1] * m[14] - 
	               m[4]  * m[2] * m[13] - 
	               m[12] * m[1] * m[6] + 
	               m[12] * m[2] * m[5];

	    inv[3] = -m[1] * m[6] * m[11] + 
	              m[1] * m[7] * m[10] + 
	              m[5] * m[2] * m[11] - 
	              m[5] * m[3] * m[10] - 
	              m[9] * m[2] * m[7] + 
	              m[9] * m[3] * m[6];

	    inv[7] = m[0] * m[6] * m[11] - 
	             m[0] * m[7] * m[10] - 
	             m[4] * m[2] * m[11] + 
	             m[4] * m[3] * m[10] + 
	             m[8] * m[2] * m[7] - 
	             m[8] * m[3] * m[6];

	    inv[11] = -m[0] * m[5] * m[11] + 
	               m[0] * m[7] * m[9] + 
	               m[4] * m[1] * m[11] - 
	               m[4] * m[3] * m[9] - 
	               m[8] * m[1] * m[7] + 
	               m[8] * m[3] * m[5];

	    inv[15] = m[0] * m[5] * m[10] - 
	              m[0] * m[6] * m[9] - 
	              m[4] * m[1] * m[10] + 
	              m[4] * m[2] * m[9] + 
	              m[8] * m[1] * m[6] - 
	              m[8] * m[2] * m[5];

	    det = m[0] * inv[0] + m[1] * inv[4] + m[2] * inv[8] + m[3] * inv[12];

	    if (det == 0)
	        return false;

	    det = 1.0 / det;

	    for (i = 0; i < 16; i++)
	        invOut[i] = inv[i] * det;

	    return true;
	}
int Singleton::getMatrixInd (int col, int row)
                                           {
		return col*4 + row;
	}
void Singleton::ComputeFOVProjection (float * result, float fov, float aspect, float nearDist, float farDist, bool leftHanded)
          {
	    //
	    // General form of the Projection Matrix
	    //
	    // uh = Cot( fov/2 ) == 1/Tan(fov/2)
	    // uw / uh = 1/aspect
	    // 
	    //   uw         0       0       0    	0  1  2  3
	    //    0        uh       0       0    	4  5  6  7
	    //    0         0      f/(f-n)  1    	8  9  10 11
	    //    0         0    -fn/(f-n)  0   	12 13 14 15
	    //
	    // Make result to be identity first

		int i;
		int j;
		
		float val;
		
		for (i = 0; i < 4; i++) {
			for (j = 0; j < 4; j++) {
				
				if (i == j) {
					val = 1.0f;
				}
				else {
					val = 0.0f;
				}
				
				result[getMatrixInd(i,j)] = val;
			}
		}

		
	    float frustumDepth = farDist - nearDist;
	    float oneOverDepth = 1 / frustumDepth;

	    result[getMatrixInd(1,1)] = 1 / tan(0.5f * fov);
	    result[getMatrixInd(0,0)] = (leftHanded ? 1 : -1 ) * result[getMatrixInd(1,1)] / aspect;
	    result[getMatrixInd(2,2)] = farDist * oneOverDepth;
	    result[getMatrixInd(3,2)] = (-farDist * nearDist) * oneOverDepth;
	    result[getMatrixInd(2,3)] = 1;
	    result[getMatrixInd(3,3)] = 0;
	}
void Singleton::setMatrices (int w, int h)
        {
		int i;
		float* ptr1;
		float* ptr2;
		
		if (perspectiveOn) {
			glViewport (0, 0, (GLsizei)w, (GLsizei)h); //set the viewport to the current window specifications
			glMatrixMode (GL_PROJECTION); //set the matrix to projection
			glLoadIdentity ();
			
			gluPerspective (
				FOV,
				(GLfloat)w / (GLfloat)h,
				clipDist[0],
				clipDist[1]
			); //set the perspective (angle of sight, width, height, , depth)
			
			
			// ComputeFOVProjection(
			// 	projMatrix.get(),
			// 	FOV,
			// 	w/h,
			// 	clipDist[0],
			// 	clipDist[1],
			// 	false
			// );
			
			glGetFloatv(GL_PROJECTION_MATRIX, projMatrix.get());
			
			glMatrixMode (GL_MODELVIEW); //set the matrix back to model
			
			//*180.0f/M_PI / 180 * M_PI
			
			glLoadIdentity();
			
			gluLookAt(
				cameraGetPos()->getFX(),
				cameraGetPos()->getFY(),
				cameraGetPos()->getFZ(),
				cameraGetPos()->getFX()+lookAtVec[0],
				cameraGetPos()->getFY()+lookAtVec[1],
				cameraGetPos()->getFZ()+lookAtVec[2],
				0.0f,
				0.0f,
				1.0f
			);
			
			// glRotatef(getCamRot(1)*180.0f/M_PI,0.0f,1.0f,0.0f);
			// glRotatef(getCamRot(0)*180.0f/M_PI,0.0f,0.0f,1.0f);
			// glTranslated(
			// 	-cameraGetPos()->getFX(),
			// 	-cameraGetPos()->getFY(),
			// 	-cameraGetPos()->getFZ()
			// );
			
			
			
			glGetFloatv(GL_MODELVIEW_MATRIX, viewMatrix.get());
			
			
			ptr1 = viewMatrix.get();
			ptr2 = projMatrix.get();
			
			
			for (i = 0; i < 16; i++) {
				viewMatrixD[i] = ptr1[i];
				projMatrixD[i] = ptr2[i];
			}
			
			gluInvertMatrix(viewMatrixD, viewMatrixDI);
			
			glGetIntegerv(GL_VIEWPORT, viewport);
			
			
			heightOfNearPlane =
				(
					((float)abs(viewport[3]-viewport[1])) /
			    (2.0f*tan(0.5f*FOV*M_PI/180.0f))
			  ) *
			  (
			  	2.0f / ((float)scaleFactor)	
			  );
			
			// lastW = -1; 
			// lastH = -1;
			
		}
		else {
			if (
				(lastW == w) && 
				(lastH == h) &&
				(lastPersp == perspectiveOn)
			) {
				
			}
			else {
				glViewport(0, 0, w, h);
				
				glMatrixMode(GL_MODELVIEW);
				glLoadIdentity ();
				
				glMatrixMode (GL_PROJECTION);
				glLoadIdentity ();
				
				// glMatrixMode(GL_PROJECTION);
				// glLoadIdentity();
				// glOrtho(-0.5, +0.5, -0.5, +0.5, clipDist[0], clipDist[1]);
				
				lastW = w;
				lastH = h;
			}
		}
		
		lastPersp = perspectiveOn;

	}
void Singleton::reshape (int w, int h)
        {

		setWH(w, h);

		screenWidth = w;
		screenHeight = h;
		
		setMatrices(baseW, baseH);
	}
#undef LZZ_INLINE
 
// f00305_shader.h
//

#include "f00305_shader.e"
#define LZZ_INLINE inline
Shader::Shader (Singleton * _singleton)
                                      {
		singleton = _singleton;
		curUBIndex = 0;
	}
char * Shader::textFileRead (char const * fileName)
                                                        {
		
		char* text = "";
		bool failed = true;
	    
		if (fileName != NULL) {
	        FILE *file = fopen(fileName, "rt");
	        
			if (file != NULL) {
	            fseek(file, 0, SEEK_END);
	            int count = ftell(file);
	            rewind(file);
	            
				if (count > 0) {
					text = new char[(count + 1)];
					//(char*)malloc(sizeof(char) * (count + 1));
					count = fread(text, sizeof(char), count, file);
					text[count] = '\0';
					failed = false;
				}
				fclose(file);
			}
		}

		if (failed) {
			doTraceND("FAILED TO READ FILE: ", fileName);
		}
		else {
			//doTrace("READ FILE: ", fileName);
		}
		
		
		return text;
	}
void Shader::validateShader (GLuint shader, char const * file)
                                                                        {
		//pushTrace("validateShader(", file, ")");
		
		const unsigned int BUFFER_SIZE = 512;
		char buffer[BUFFER_SIZE];
		memset(buffer, 0, BUFFER_SIZE);
		GLsizei length = 0;
	    
		glGetShaderInfoLog(shader, BUFFER_SIZE, &length, buffer);
		if (length > 0) {
			doTraceND("Shader " , i__s(shader) , " (" , (file?file:"") , ") compile error: " , buffer);
			LAST_COMPILE_ERROR = true;
		}
		//popTrace();


	}
int Shader::validateProgram (GLuint program)
                                                   {
		//pushTrace("validateProgram()");
		
		const unsigned int BUFFER_SIZE = 512;
		char buffer[BUFFER_SIZE];
		memset(buffer, 0, BUFFER_SIZE);
		GLsizei length = 0;
	    
		memset(buffer, 0, BUFFER_SIZE);
		glGetProgramInfoLog(program, BUFFER_SIZE, &length, buffer);
		if (length > 0) {
			doTraceND( "Program " , i__s(program) , " link error: " , buffer);
			LAST_COMPILE_ERROR = true;
			//popTrace();
			return 0;
		}
	    
		glValidateProgram(program);
		GLint status;
		glGetProgramiv(program, GL_VALIDATE_STATUS, &status);
		if (status == GL_FALSE) {
			doTraceND( "Error validating shader " , i__s(program));
			LAST_COMPILE_ERROR = true;
			//popTrace();
			return 0;
		}
		
		//popTrace();
		return 1;
		
	}
int Shader::countOc (string * src, string testStr)
                                                 {
		int totCount = 0;
		int bInd = 0;
		bool dc = true;
		int fnd = 0;
		
		while (dc) {
			fnd = src->find(testStr, bInd);
			if (fnd != std::string::npos) {
				bInd = fnd+1;
				dc = true;
				totCount++;
			}
			else {
				dc = false;
			}
		}
		
		return totCount;
	}
void Shader::init (string shaderName, bool doBake, map <string, string> * includeMap)
                                                                                   {
		
		string shaderFN;
		vector<string> shaderNameSplit;
		
		string defineString = "\n";
		
		if (
			shaderName.find('_', 0) != std::string::npos
		) {
			shaderNameSplit = split(shaderName,'_');
			shaderFN = shaderNameSplit[0];
			
			//cout << shaderName << "\n";
		}
		else {
			shaderFN = shaderName;
		}
		
		
		string tempFileString = "";
		string tempFileLoc = "";
		
		
		string shaderRoot = "../src/glsl/";
		string _shaderFile = shaderRoot + shaderFN + ".c";
		
		const char* shaderFile = _shaderFile.c_str();
		
		uniVec.clear();
		paramVec.clear();
		paramMapTemp.clear();
		
		shader_vp = glCreateShader(GL_VERTEX_SHADER);
		shader_fp = glCreateShader(GL_FRAGMENT_SHADER);
	    
	  std::size_t foundTF;
	    
		std::size_t found;
		std::size_t found2;
		std::size_t found3;

		int baseIndex;
		int uniCount = 0;
		int dolCount = 0;
		
		string allTextStringInc;
		
		vector<string> allTextStringSplit;
		vector<string> allTextStringSplitInc;

		bool doCont;
		
		string paramName;

		int i;
		
		for (i = 1; i < shaderNameSplit.size(); i++) {
			if (i == 1) {
				defineString.append("#version ");
			}
			else {
				defineString.append("#define ");
			}
			defineString.append(shaderNameSplit[i]);
			defineString.append("\n");
		}
		
		defineString.append("\n");
		

		const char* allText = textFileRead(shaderFile);


		if (allText == NULL) {
			doTraceND( "Error: Either vertex shader or fragment shader file not found." );
			LAST_COMPILE_ERROR = true;
		}
		else {
			
				string allTextString(allText);
				
				
				

				//
				
				dolCount = countOc(&allTextString,"$");

				if (dolCount == 2) {
					
					uniCount = countOc(&allTextString,"ublock");


					if (allTextString.find('^', 0) != std::string::npos) {
						allTextStringInc = "";
						allTextStringSplitInc = split(allTextString, '^');
						
						for (i = 0; i < allTextStringSplitInc.size(); i++) {
							if (allTextStringSplitInc[i].compare("INCLUDE:MATERIALS") == 0) {
								allTextStringInc.append((*includeMap)["materials"]);
							}
							else if (allTextStringSplitInc[i].compare("INCLUDE:PRIMTEMPLATES") == 0) {
								allTextStringInc.append((*includeMap)["primTemplates"]);
							}
							else {
							
								foundTF = allTextStringSplitInc[i].find("INCLUDE:");
								
								if (foundTF != std::string::npos) {
									tempFileLoc = allTextStringSplitInc[i].substr(foundTF+8,std::string::npos);
									
									//cout << "tempFileLoc " << tempFileLoc << "\n";
									
									tempFileString = singleton->loadFileString(shaderRoot+tempFileLoc+".c");
									
									if (tempFileString.size() > 2) {
										
										allTextStringInc.append(tempFileString);
										
									}
									else {
										cout << "Error loading " << shaderRoot+tempFileLoc+".c\n";
									}
									
									
								}
								else {
									allTextStringInc.append(allTextStringSplitInc[i]);
								}
							
									// if (
									// 	allTextStringSplitInc[i].find("INCLUDE:") != std::string::npos	
									// ) {
										
										//singleton->loadFile(shaderRoot+,&tempFile)) {
										
									// }
									// else {
									// 	allTextStringInc.append(allTextStringSplitInc[i]);
							}
						}
						
						allTextString = allTextStringInc;
					}



					baseIndex = 0;
					doCont = true;
					while (doCont) {
						found = allTextString.find('@', baseIndex);
						if (found != std::string::npos) {
							
							
							baseIndex = found+1;
							allTextString[found] = ' ';
							
							found3 = allTextString.find(' ', baseIndex);
							found2 = allTextString.find('@', baseIndex);
							
							if (found2 != std::string::npos) {
								
								if ( 
									((found2-found) > 32) || // max var length of 32
									(found3 < found2) // found a space between the delimitters
								) { 
									//baseIndex = found+1; // already set
								}
								else {
									baseIndex = found2+1;
									allTextString[found2] = ' ';
									
									paramName = allTextString.substr(found + 1, (found2-found)-1);
									
									if (paramMapTemp.find( paramName ) == paramMapTemp.end()) {
										paramMapTemp[paramName] = 0.0f;
										paramVec.push_back(paramName);
										
										if (paramMap.find( paramName ) == paramMap.end()) {
											paramMap[paramName] = 0.0f;
										}
										
										//cout << "paramName --" << paramName << "--\n";
										
									}
								}
								
								
								
								doCont = true;
							}
							else {
								doCont = false;
							}
							
							
						}
						else {
							doCont = false;
						}
					}
					
					
					
					
					
					
					//###
					
					
					// if (allTextString.find('^', 0) != std::string::npos) {
					// 	allTextStringInc = "";
					// 	allTextStringSplitInc = split(allTextString, '^');
						
					// 	for (i = 0; i < allTextStringSplitInc.size(); i++) {
					// 		if (allTextStringSplitInc[i].compare("INCLUDE:MATERIALS") == 0) {
					// 			allTextStringInc.append((*includeMap)["materials"]);
					// 		}
					// 		else if (allTextStringSplitInc[i].compare("INCLUDE:PRIMTEMPLATES") == 0) {
					// 			allTextStringInc.append((*includeMap)["primTemplates"]);
					// 		}
					// 		else {
					// 			allTextStringInc.append(allTextStringSplitInc[i]);
					// 		}
					// 	}
						
					// 	allTextStringSplit = split(allTextStringInc, '$');
					// }
					// else {
					// 	allTextStringSplit = split(allTextString, '$');
					// }
					
					allTextStringSplit = split(allTextString, '$');
					
					
					//###
					
					
					
					
					
					
					
					
					
					allTextStringSplit[0].append("\n");
					
					allTextStringSplit[0] = defineString + allTextStringSplit[0];
					
					//allTextStringSplit[0].append(defineString);
					
					if (doBake) {
						for (i = 0; i < paramVec.size(); i++) {
							allTextStringSplit[0].append("const float ");
							allTextStringSplit[0].append(paramVec[i]);
							allTextStringSplit[0].append("=");
							allTextStringSplit[0].append(f__s(paramMap[paramVec[i]]));
							allTextStringSplit[0].append(";\n");
						}
					}
					else {
						for (i = 0; i < paramVec.size(); i++) {
							allTextStringSplit[0].append("uniform float ");
							allTextStringSplit[0].append(paramVec[i]);
							allTextStringSplit[0].append(";\n");
						}
					}
					
					

					string vertStr = allTextStringSplit[0] + allTextStringSplit[1];
					string fragStr = allTextStringSplit[0] + allTextStringSplit[2];

					if (DO_SHADER_DUMP) {
						localString = fragStr;
						if (_shaderFile.compare("../src/glsl/PrimShader.c") == 0) {
							globString = fragStr;
						}
					}
					

					const GLchar* vertCS = new char[vertStr.length() + 1];
					const GLchar* fragCS = new char[fragStr.length() + 1];

					std::strcpy((GLchar*)vertCS,vertStr.c_str());
					std::strcpy((GLchar*)fragCS,fragStr.c_str());


			    glShaderSource(shader_vp, 1, &(vertCS), 0);
					glShaderSource(shader_fp, 1, &(fragCS), 0);
				    
					glCompileShader(shader_vp);
					validateShader(shader_vp, shaderFile);
					glCompileShader(shader_fp);
					validateShader(shader_fp, shaderFile);



					shader_id = glCreateProgram();
					glAttachShader(shader_id, shader_fp);
					glAttachShader(shader_id, shader_vp);
					glLinkProgram(shader_id);
					validateProgram(shader_id);

					delete [] vertCS;
					delete [] fragCS;


					for (i = 0; i < uniCount; i++) {
						uniVec.push_back(UniformBuffer());
						uniVec.back().init(shader_id, i);
					}


				}
				else {
					LAST_COMPILE_ERROR = true;
					doTraceND( "Error: " , shaderFile , "does not contain proper amount of splits ($)\n" );
				}
				
				
				delete[] allText;
			  
		}
		
		
		//popTrace();
		
	}
Shader::~ Shader ()
                  {

		uniVec.clear();

		//pushTrace("~Shader()");
		glDetachShader(shader_id, shader_fp);
		glDetachShader(shader_id, shader_vp);
		glDeleteShader(shader_fp);
		glDeleteShader(shader_vp);
		glDeleteProgram(shader_id);
		//popTrace();
	}
unsigned int Shader::id ()
                          {
		//pushTrace("id()");
		return shader_id;
		//popTrace();
	}
void Shader::bind ()
                    {
		//pushTrace("bind()");
		glUseProgram(shader_id);
		//popTrace();
	}
void Shader::updateUniformBlock (int ubIndex, int ubDataSize)
                                                             {
		uniVec[ubIndex].updateUniformBlock(ubDataSize);
	}
void Shader::invalidateUniformBlock (int ubIndex)
                                                 {
		uniVec[ubIndex].invalidateUniformBlock();
	}
void Shader::beginUniformBlock (int ubIndex)
                                            {
		curUBIndex = ubIndex;
		uniVec[ubIndex].beginUniformBlock();
	}
bool Shader::wasUpdatedUniformBlock (int ubIndex)
                                                 {

		if (uniVec.size() > ubIndex) {
			return uniVec[ubIndex].wasUpdatedUniformBlock();
		}
		else {
			return true;
		}

		
	}
void Shader::unbind ()
                      {
		//pushTrace("unbind()");
		glUseProgram(0);
		//popTrace();
	}
void Shader::setTexture (GLchar const * name, int texUnit, int texId)
                                                                    {
		GLint baseImageLoc = glGetUniformLocation(shader_id, name);

		glUniform1i(baseImageLoc, texUnit); //Texture unit 0 is for base images.
		
		//When rendering an objectwith this program.
		glActiveTexture(GL_TEXTURE0 + texUnit);
		glBindTexture(GL_TEXTURE_2D, texId);
	}
void Shader::setVec (GLchar const * name, GLfloat const * vecData, int vecSize)
                                                                             {
		
		GLint loc = glGetUniformLocation(shader_id, name);
		
		switch (vecSize) {
			case 0:
				doTraceND( "Error: vecSize of 0 in setVec" );
			break;
			case 1:
				glUniform1fv(loc, 1, vecData);
			break;
			case 2:
				glUniform2fv(loc, 1, vecData);
			break;
			case 3:
				glUniform3fv(loc, 1, vecData);
			break;
			case 4:
				glUniform4fv(loc, 1, vecData);
			break;
		}
	}
void Shader::setVecString (string name, GLfloat const * vecData, int vecSize)
                                                                            {
		
		GLint loc = glGetUniformLocation(shader_id, name.c_str());
		
		switch (vecSize) {
			case 0:
				doTraceND( "Error: vecSize of 0 in setVec" );
			break;
			case 1:
				glUniform1fv(loc, 1, vecData);
			break;
			case 2:
				glUniform2fv(loc, 1, vecData);
			break;
			case 3:
				glUniform3fv(loc, 1, vecData);
			break;
			case 4:
				glUniform4fv(loc, 1, vecData);
			break;
		}
	}
void Shader::setShaderMatrix4x4 (string paramName, float * x, int count)
                                                                       {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		
		glUniformMatrix4fv(
			loc,//GLint location,
			count,//GLsizei count,
			false,//GLboolean transpose,
			x//const GLfloat *value
		);
	}
void Shader::setShaderMatrix3x3 (string paramName, float * x, int count)
                                                                       {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		
		glUniformMatrix3fv(
			loc,//GLint location,
			count,//GLsizei count,
			false,//GLboolean transpose,
			x//const GLfloat *value
		);
	}
void Shader::setShaderArrayfVec4 (string paramName, float * x, int count)
                                                                        {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform4fv(loc, count, x);
	}
void Shader::setShaderArrayfVec3 (string paramName, float * x, int count)
                                                                        {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform3fv(loc, count, x);
	}
void Shader::setShaderArray (string paramName, float * x, int count)
                                                                   {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform1fv(loc, count, x);
	}
GLint Shader::getShaderLoc (string paramName)
                                             {
		return glGetUniformLocation(shader_id, paramName.c_str());
	}
void Shader::setShaderFloat (string paramName, float x)
                                                       {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform1f(loc,x);
	}
void Shader::setShaderVec2 (string paramName, float x, float y)
                                                               {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform2f(loc,x,y);
	}
void Shader::setShaderVec3 (string paramName, float x, float y, float z)
                                                                        {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform3f(loc,x,y,z);
	}
void Shader::setShaderVec4 (string paramName, float x, float y, float z, float w)
                                                                                 {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform4f(loc,x,y,z,w);
	}
void Shader::setShaderInt (string paramName, int x)
                                                   {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform1i(loc,x);
	}
void Shader::setShaderfVec2 (string paramName, FIVector4 * f)
                                                            {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform2f(loc,f->getFX(),f->getFY());
	}
void Shader::setShaderfVec3 (string paramName, FIVector4 * f)
                                                            {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform3f(loc,f->getFX(),f->getFY(),f->getFZ());
	}
void Shader::setShaderfVec4 (string paramName, FIVector4 * f)
                                                            {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform4f(loc,f->getFX(),f->getFY(),f->getFZ(),f->getFW());
	}
void Shader::setShaderbtVec3 (string paramName, btVector3 f)
                                                            {
		GLint loc = glGetUniformLocation(shader_id, paramName.c_str());
		glUniform3f(loc,f.getX(),f.getY(),f.getZ());
	}
void Shader::setShaderFloatUB (string paramName, float x)
                                                         {
		int cp = uniVec[curUBIndex].uniPosition;

		uniVec[curUBIndex].uniData[cp] = x;
		uniVec[curUBIndex].uniPosition += 1;
	}
void Shader::setShaderfVec4UB (string paramName, FIVector4 * f)
                                                              {

		int cp = uniVec[curUBIndex].uniPosition;

		uniVec[curUBIndex].uniData[cp+0] = f->getFX();
		uniVec[curUBIndex].uniData[cp+1] = f->getFY();
		uniVec[curUBIndex].uniData[cp+2] = f->getFZ();
		uniVec[curUBIndex].uniData[cp+3] = f->getFW();
		uniVec[curUBIndex].uniPosition += 4;
	}
#undef LZZ_INLINE
 
// f00307_dynbuffer.h
//

#include "f00307_dynbuffer.e"
#define LZZ_INLINE inline
DynBuffer::DynBuffer ()
                    {
				drawMode = 0;
				imageData = 0;
				
				SCREEN_WIDTH    = 400;
				SCREEN_HEIGHT   = 300;
				CAMERA_DISTANCE = 3.0f;
				TEXT_WIDTH      = 8;
				TEXT_HEIGHT     = 13;
				IMAGE_WIDTH     = 1024;
				IMAGE_HEIGHT    = 1024;
				CHANNEL_COUNT   = 4;
				DATA_SIZE       = IMAGE_WIDTH * IMAGE_HEIGHT * CHANNEL_COUNT;
				
				font = GLUT_BITMAP_8_BY_13;
				
		
		    initSharedMem();

		    //TODO: 
		    //initGL();

		    // get OpenGL info
		    glInfo glInfo;
		    glInfo.getInfo();
		    //glInfo.printSelf();

		    // init 2 texture objects
		    glGenTextures(1, &textureId);
		    glBindTexture(GL_TEXTURE_2D, textureId);
		    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
		    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
		    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
		    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
		    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, IMAGE_WIDTH, IMAGE_HEIGHT, 0, GL_BGRA, GL_UNSIGNED_BYTE, (GLvoid*)imageData);
		    glBindTexture(GL_TEXTURE_2D, 0);

		#ifdef _WIN32
		    // check PBO is supported by your video card
		    if(glInfo.isExtensionSupported("GL_ARB_pixel_buffer_object"))
		    {
		        // get pointers to GL functions
		        glGenBuffersARB = (PFNGLGENBUFFERSARBPROC)wglGetProcAddress("glGenBuffersARB");
		        glBindBufferARB = (PFNGLBINDBUFFERARBPROC)wglGetProcAddress("glBindBufferARB");
		        glBufferDataARB = (PFNGLBUFFERDATAARBPROC)wglGetProcAddress("glBufferDataARB");
		        glBufferSubDataARB = (PFNGLBUFFERSUBDATAARBPROC)wglGetProcAddress("glBufferSubDataARB");
		        glDeleteBuffersARB = (PFNGLDELETEBUFFERSARBPROC)wglGetProcAddress("glDeleteBuffersARB");
		        glGetBufferParameterivARB = (PFNGLGETBUFFERPARAMETERIVARBPROC)wglGetProcAddress("glGetBufferParameterivARB");
		        glMapBufferARB = (PFNGLMAPBUFFERARBPROC)wglGetProcAddress("glMapBufferARB");
		        glUnmapBufferARB = (PFNGLUNMAPBUFFERARBPROC)wglGetProcAddress("glUnmapBufferARB");

		        // check once again PBO extension
		        if(glGenBuffersARB && glBindBufferARB && glBufferDataARB && glBufferSubDataARB &&
		           glMapBufferARB && glUnmapBufferARB && glDeleteBuffersARB && glGetBufferParameterivARB)
		        {
		            pboSupported = true;
		            pboMode = 1;    // using 1 PBO
		            std::cout << "Video card supports GL_ARB_pixel_buffer_object." << std::endl;
		        }
		        else
		        {
		            pboSupported = false;
		            pboMode = 0;    // without PBO
		            std::cout << "Video card does NOT support GL_ARB_pixel_buffer_object." << std::endl;
		        }
		    }

		    // check EXT_swap_control is supported
		    if(glInfo.isExtensionSupported("WGL_EXT_swap_control"))
		    {
		        // get pointers to WGL functions
		        wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)wglGetProcAddress("wglSwapIntervalEXT");
		        wglGetSwapIntervalEXT = (PFNWGLGETSWAPINTERVALEXTPROC)wglGetProcAddress("wglGetSwapIntervalEXT");
		        if(wglSwapIntervalEXT && wglGetSwapIntervalEXT)
		        {
		            // enable v-sync
		            wglSwapIntervalEXT(1);
		            std::cout << "Video card supports WGL_EXT_swap_control." << std::endl;
		        }
		    }


		#else // for linux, do not need to get function pointers, it is up-to-date
		    if(glInfo.isExtensionSupported("GL_ARB_pixel_buffer_object"))
		    {
		        pboSupported = true;
		        pboMode = 1;
		        std::cout << "Video card supports GL_ARB_pixel_buffer_object." << std::endl;
		    }
		    else
		    {
		        pboSupported = false;
		        pboMode = 0;
		        std::cout << "Video card does NOT support GL_ARB_pixel_buffer_object." << std::endl;
		    }
		#endif

		    if(pboSupported)
		    {
		        // create 2 pixel buffer objects, you need to delete them when program exits.
		        // glBufferDataARB with NULL pointer reserves only memory space.
		        glGenBuffersARB(2, pboIds);
		        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, pboIds[0]);
		        glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, DATA_SIZE, 0, GL_STREAM_DRAW_ARB);
		        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, pboIds[1]);
		        glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, DATA_SIZE, 0, GL_STREAM_DRAW_ARB);
		        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
		    }

		    // start timer, the elapsed time will be used for updateVertices()
		    //timer.start();

		    // the last GLUT call (LOOP)
		    // window will be shown and display callback is triggered by events
		    // NOTE: this call never return main().
		    //glutMainLoop(); /* Start GLUT event-processing loop */

		
	}
DynBuffer::~ DynBuffer ()
                     {
		clearSharedMem();
	}
bool DynBuffer::initSharedMem ()
        {
	    screenWidth = SCREEN_WIDTH;
	    screenHeight = SCREEN_HEIGHT;

	    mouseLeftDown = mouseRightDown = false;
	    mouseX = mouseY = 0;

	    cameraAngleX = cameraAngleY = 0;
	    cameraDistance = CAMERA_DISTANCE;

	    drawMode = 0; // 0:fill, 1: wireframe, 2:points

	    // allocate texture buffer
	    imageData = new GLubyte[DATA_SIZE];
	    memset(imageData, 0, DATA_SIZE);

	    return true;
	}
void DynBuffer::clearSharedMem ()
        {
	    // deallocate texture buffer
	    delete [] imageData;
	    imageData = 0;

	    // clean up texture
	    glDeleteTextures(1, &textureId);

	    // clean up PBOs
	    if(pboSupported)
	    {
	        glDeleteBuffersARB(2, pboIds);
	    }
	}
void DynBuffer::initLights ()
        {
	    // set up light colors (ambient, diffuse, specular)
	    GLfloat lightKa[] = {.2f, .2f, .2f, 1.0f};  // ambient light
	    GLfloat lightKd[] = {.7f, .7f, .7f, 1.0f};  // diffuse light
	    GLfloat lightKs[] = {1, 1, 1, 1};           // specular light
	    glLightfv(GL_LIGHT0, GL_AMBIENT, lightKa);
	    glLightfv(GL_LIGHT0, GL_DIFFUSE, lightKd);
	    glLightfv(GL_LIGHT0, GL_SPECULAR, lightKs);

	    // position the light
	    float lightPos[4] = {0, 0, 20, 1}; // positional light
	    glLightfv(GL_LIGHT0, GL_POSITION, lightPos);

	    glEnable(GL_LIGHT0);                        // MUST enable each light source after configuration
	}
void DynBuffer::setCamera (float posX, float posY, float posZ, float targetX, float targetY, float targetZ)
        {
	    glMatrixMode(GL_MODELVIEW);
	    glLoadIdentity();
	    gluLookAt(posX, posY, posZ, targetX, targetY, targetZ, 0, 1, 0); // eye(x,y,z), focal(x,y,z), up(x,y,z)
	}
void DynBuffer::updatePixels (GLubyte * dst, int size)
        {
	    static int color = 0;

	    if(!dst)
	        return;

	    int* ptr = (int*)dst;

	    // copy 4 bytes at once
	    for(int i = 0; i < IMAGE_HEIGHT; ++i)
	    {
	        for(int j = 0; j < IMAGE_WIDTH; ++j)
	        {
	            *ptr = color;
	            ++ptr;
	        }
	        color += 257;   // add an arbitary number (no meaning)
	    }
	    ++color;            // scroll down
	}
void DynBuffer::showTransferRate ()
        {
	    //static Timer timer;
	    //static int count = 0;
	    //static std::stringstream ss;

	    // // update fps every second
	    // ++count;
	    // double elapsedTime = timer.getElapsedTime();
	    // if(elapsedTime > 1.0)
	    // {
	    //     ss.str("");
	    //     ss << std::fixed << std::setprecision(1);
	    //     ss << "Transfer Rate: " << (count / elapsedTime) * DATA_SIZE / (1024 * 1024) << " MB" << std::ends; // update fps string
	    //     ss << std::resetiosflags(std::ios_base::fixed | std::ios_base::floatfield);
	    //     count = 0;                      // reset counter
	    //     timer.start();                  // restart timer
	    // }

	    // backup current model-view matrix
	    glPushMatrix();                     // save current modelview matrix
	    glLoadIdentity();                   // reset modelview matrix

	    // set to 2D orthogonal projection
	    glMatrixMode(GL_PROJECTION);        // switch to projection matrix
	    glPushMatrix();                     // save current projection matrix
	    glLoadIdentity();                   // reset projection matrix
	    //gluOrtho2D(0, IMAGE_WIDTH, 0, IMAGE_HEIGHT); // set to orthogonal projection
	    gluOrtho2D(0, screenWidth, 0, screenHeight); // set to orthogonal projection

	    //float color[4] = {1, 1, 0, 1};
	    //drawString(ss.str().c_str(), 200, 286, color, font);

	    // restore projection matrix
	    glPopMatrix();                      // restore to previous projection matrix

	    // restore modelview matrix
	    glMatrixMode(GL_MODELVIEW);         // switch to modelview matrix
	    glPopMatrix();                      // restore to previous modelview matrix
	}
void DynBuffer::toOrtho ()
        {
	    // set viewport to be the entire window
	    glViewport(0, 0, (GLsizei)screenWidth, (GLsizei)screenHeight);

	    // set orthographic viewing frustum
	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(0, screenWidth, 0, screenHeight, -1, 1);

	    // switch to modelview matrix in order to set scene
	    glMatrixMode(GL_MODELVIEW);
	    glLoadIdentity();
	}
void DynBuffer::toPerspective ()
        {
	    // set viewport to be the entire window
	    glViewport(0, 0, (GLsizei)screenWidth, (GLsizei)screenHeight);

	    // set perspective viewing frustum
	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    gluPerspective(60.0f, (float)(screenWidth)/screenHeight, 1.0f, 1000.0f); // FOV, AspectRatio, NearClip, FarClip

	    // switch to modelview matrix in order to set scene
	    glMatrixMode(GL_MODELVIEW);
	    glLoadIdentity();
	}
void DynBuffer::displayCB ()
        {
	    static int index = 0;
	    int nextIndex = 0;                  // pbo index used for next frame

	    if(pboMode > 0)
	    {
	        // "index" is used to copy pixels from a PBO to a texture object
	        // "nextIndex" is used to update pixels in a PBO
	        if(pboMode == 1)
	        {
	            // In single PBO mode, the index and nextIndex are set to 0
	            index = nextIndex = 0;
	        }
	        else if(pboMode == 2)
	        {
	            // In dual PBO mode, increment current index first then get the next index
	            index = (index + 1) % 2;
	            nextIndex = (index + 1) % 2;
	        }

	        // start to copy from PBO to texture object ///////
	        //t1.start();

	        // bind the texture and PBO
	        glBindTexture(GL_TEXTURE_2D, textureId);
	        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, pboIds[index]);

	        // copy pixels from PBO to texture object
	        // Use offset instead of ponter.
	        glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, IMAGE_WIDTH, IMAGE_HEIGHT, GL_BGRA, GL_UNSIGNED_BYTE, 0);

	        // measure the time copying data from PBO to texture object
	        //t1.stop();
	        //copyTime = t1.getElapsedTimeInMilliSec();
	        ///////////////////////////////////////////////////


	        // start to modify pixel values ///////////////////
	        //t1.start();

	        // bind PBO to update pixel values
	        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, pboIds[nextIndex]);

	        // map the buffer object into client's memory
	        // Note that glMapBufferARB() causes sync issue.
	        // If GPU is working with this buffer, glMapBufferARB() will wait(stall)
	        // for GPU to finish its job. To avoid waiting (stall), you can call
	        // first glBufferDataARB() with NULL pointer before glMapBufferARB().
	        // If you do that, the previous data in PBO will be discarded and
	        // glMapBufferARB() returns a new allocated pointer immediately
	        // even if GPU is still working with the previous data.
	        glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, DATA_SIZE, 0, GL_STREAM_DRAW_ARB);
	        GLubyte* ptr = (GLubyte*)glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, GL_WRITE_ONLY_ARB);
	        if(ptr)
	        {
	            // update data directly on the mapped buffer
	            updatePixels(ptr, DATA_SIZE);
	            glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB); // release pointer to mapping buffer
	        }

	        // measure the time modifying the mapped buffer
	        //t1.stop();
	        //updateTime = t1.getElapsedTimeInMilliSec();
	        ///////////////////////////////////////////////////

	        // it is good idea to release PBOs with ID 0 after use.
	        // Once bound with 0, all pixel operations behave normal ways.
	        glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
	    }
	    else
	    {
	        ///////////////////////////////////////////////////
	        // start to copy pixels from system memory to textrure object
	        //t1.start();

	        glBindTexture(GL_TEXTURE_2D, textureId);
	        glTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, IMAGE_WIDTH, IMAGE_HEIGHT, GL_BGRA, GL_UNSIGNED_BYTE, (GLvoid*)imageData);

	        //t1.stop();
	        //copyTime = t1.getElapsedTimeInMilliSec();
	        ///////////////////////////////////////////////////


	        // start to modify pixels /////////////////////////
	        //t1.start();
	        updatePixels(imageData, DATA_SIZE);
	        //t1.stop();
	        //updateTime = t1.getElapsedTimeInMilliSec();
	        ///////////////////////////////////////////////////
	    }


	    // clear buffer
	    //glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

	    // save the initial ModelView matrix before modifying ModelView matrix
	    // glPushMatrix();

	    // // tramsform camera
	    // glTranslatef(0, 0, -cameraDistance);
	    // glRotatef(cameraAngleX, 1, 0, 0);   // pitch
	    // glRotatef(cameraAngleY, 0, 1, 0);   // heading

	    // // draw a point with texture
	    // glBindTexture(GL_TEXTURE_2D, textureId);
	    // glColor4f(1, 1, 1, 1);
	    // glBegin(GL_QUADS);
	    // glNormal3f(0, 0, 1);
	    // glTexCoord2f(0.0f, 0.0f);   glVertex3f(-1.0f, -1.0f, 0.0f);
	    // glTexCoord2f(1.0f, 0.0f);   glVertex3f( 1.0f, -1.0f, 0.0f);
	    // glTexCoord2f(1.0f, 1.0f);   glVertex3f( 1.0f,  1.0f, 0.0f);
	    // glTexCoord2f(0.0f, 1.0f);   glVertex3f(-1.0f,  1.0f, 0.0f);
	    // glEnd();

	    // // unbind texture
	    // glBindTexture(GL_TEXTURE_2D, 0);

	    // // draw info messages
	    // showInfo();
	    // //showTransferRate();
	    // printTransferRate();

	    // glPopMatrix();

	    //glutSwapBuffers();
	}
void DynBuffer::reshapeCB (int width, int height)
        {
	    screenWidth = width;
	    screenHeight = height;
	    toPerspective();
	}
void DynBuffer::idleCB ()
        {
	    glutPostRedisplay();
	}
void DynBuffer::keyboardCB (unsigned char key, int x, int y)
        {
	    switch(key)
	    {
	    case 27: // ESCAPE
	        exit(0);
	        break;

	    case ' ':
	        if(pboSupported)
	            pboMode = ++pboMode % 3;
	        std::cout << "PBO mode: " << pboMode << std::endl;
	         break;

	    case 'd': // switch rendering modes (fill -> wire -> point)
	    case 'D':
	        drawMode = ++drawMode % 3;
	        if(drawMode == 0)        // fill mode
	        {
	            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
	            glEnable(GL_DEPTH_TEST);
	            glEnable(GL_CULL_FACE);
	        }
	        else if(drawMode == 1)  // wireframe mode
	        {
	            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
	            glDisable(GL_DEPTH_TEST);
	            glDisable(GL_CULL_FACE);
	        }
	        else                    // point mode
	        {
	            glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
	            glDisable(GL_DEPTH_TEST);
	            glDisable(GL_CULL_FACE);
	        }
	        break;

	    default:
	        ;
	    }
	}
void DynBuffer::mouseCB (int button, int state, int x, int y)
        {
	    mouseX = x;
	    mouseY = y;

	    if(button == GLUT_LEFT_BUTTON)
	    {
	        if(state == GLUT_DOWN)
	        {
	            mouseLeftDown = true;
	        }
	        else if(state == GLUT_UP)
	            mouseLeftDown = false;
	    }

	    else if(button == GLUT_RIGHT_BUTTON)
	    {
	        if(state == GLUT_DOWN)
	        {
	            mouseRightDown = true;
	        }
	        else if(state == GLUT_UP)
	            mouseRightDown = false;
	    }
	}
void DynBuffer::mouseMotionCB (int x, int y)
        {
	    if(mouseLeftDown)
	    {
	        cameraAngleY += (x - mouseX);
	        cameraAngleX += (y - mouseY);
	        mouseX = x;
	        mouseY = y;
	    }
	    if(mouseRightDown)
	    {
	        cameraDistance -= (y - mouseY) * 0.2f;
	        if(cameraDistance < 2.0f)
	            cameraDistance = 2.0f;

	        mouseY = y;
	    }
	}
#undef LZZ_INLINE
 
// f00320_fontwrapper.h
//

#include "f00320_fontwrapper.e"
#define LZZ_INLINE inline
FontWrapper::FontWrapper ()
                      {
		
	}
void FontWrapper::init (Singleton * _singleton, string fontName, bool _isIcons, float _fontScale, float _additionalOffset)
          {
		
		int counter;
		int i;
		int j;
		int ind;
		
		additionalOffset = _additionalOffset;
		fontScale = _fontScale;
		isIcons = _isIcons;
		
		JSONValue *cn;
		JSONValue *cc;
		
		singleton = _singleton;
		lastJSONBuffer.data = NULL;
		lastJSONBuffer.size = 0;
		
		cout << "\n\n\nFONT LOAD\n\n\n";
		
		fontImage = loadBMP("..\\data\\fonts\\"+fontName+".bmp");
		if (isIcons) {
			fontImage->getTextureId(GL_NEAREST);
		}
		else {
			fontImage->getTextureId(GL_LINEAR);
		}
		
		
		maxWidth = 0.0f;
		counter = 0;
		
		if (isIcons) {
			maxWidth = 16.0f;
			ascender = 0.0f;
			descender = -15.0f+additionalOffset;
			fontHeight = 16.0f;
			
			
			for (j = 0; j < fontImage->height/16; j++) {
				for (i = 0; i < fontImage->width/16; i++) {
					charVals[counter].consumedW = 16.0f;
					charVals[counter].consumedH = 16.0f;
					charVals[counter].offsetX = 0.0f;
					charVals[counter].offsetY = 0.0f;
					charVals[counter].sampX = i*16;
					charVals[counter].sampY = j*16;
					charVals[counter].sampW = 16.0f;
					charVals[counter].sampH = 16.0f;
					
					counter++;
				}
			}
			
		}
		else {
			if ( singleton->loadFile("..\\data\\fonts\\"+fontName+".js", &lastJSONBuffer) )
			{
				if (singleton->processJSON(&lastJSONBuffer, &(singleton->nullBuffer), &jsRoot)) {
					
					ascender = jsRoot->Child("metrics")->Child("ascender")->number_value;
					descender = jsRoot->Child("metrics")->Child("descender")->number_value;
					fontHeight = jsRoot->Child("metrics")->Child("height")->number_value;
					
					cn = jsRoot->Child("chars");
					
					
					for (i = 32; i <= 126; i++) {
						ind = i-32;
						cc = cn->Child(ind);
						
						charVals[i].consumedH = fontHeight;
						charVals[i].consumedW = cc->Child("width")->number_value;
						
						charVals[i].offsetX = cc->Child("ox")->number_value;
						charVals[i].offsetY = cc->Child("oy")->number_value;
						
						charVals[i].sampX = cc->Child("x")->number_value;
						charVals[i].sampY = cc->Child("y")->number_value;
						charVals[i].sampW = cc->Child("w")->number_value;
						charVals[i].sampH = cc->Child("h")->number_value;
						
						if (charVals[i].consumedW > maxWidth) {
							maxWidth = charVals[i].consumedW;
						}
					}
					
					
					
				}
			}
		}
		
		
		
		
	}
#undef LZZ_INLINE
 
// f00323_gameoctree.h
//

#include "f00323_gameoctree.e"
#define LZZ_INLINE inline
GameOctree::GameOctree ()
                     {
		
	}
void GameOctree::init (Singleton * _singleton, int _dimInVoxels, bool _hasTBO, int _maxSize, int _nodeSize)
          {
		singleton = _singleton;
		dimInVoxels = _dimInVoxels;
		hasTBO = _hasTBO;
		maxSize = _maxSize;
		nodeSize = _nodeSize;
		
		if (maxSize == -1) {
			maxSize = (128/4)*1024*1024;
		}
		if (nodeSize == -1) {
			nodeSize = 8;
		}
		
		maxDepth = intLogB2(dimInVoxels);
		
		data = new uint[maxSize];
		
		renderLevel = 0;
		nullPtr = 0;
		rootPtr = nodeSize;
		nextOpen = rootPtr+nodeSize;
		
		int i;
		
		for (i = 0; i < maxSize; i++) {
			data[i] = nullPtr;
		}
		
		if (hasTBO) {
			octTBO.init(false,NULL,data,maxSize*4);
		}
		
	}
void GameOctree::updateTBO ()
                         {
		octTBO.update(NULL, data, -1);
	}
void GameOctree::captureBuffer ()
                             {
		
		cout << "captureBuffer\n";

		FBOWrapper *fbow = singleton->getFBOWrapper("solidTargFBO", 0);
		fbow->getPixels();
		
		int i;
		
		int x;
		int y;
		int z;
		
		btVector3 myPoint;
		btVector3 camPoint = singleton->cameraGetPosNoShake()->getBTV();
		
		float maxDis = singleton->clipDist[1]-50.0f;
		
		for (i = 0; i < fbow->numBytes; i += 4) {
			x = fbow->pixelsFloat[i+0];
			y = fbow->pixelsFloat[i+1];
			z = fbow->pixelsFloat[i+2];
			
			myPoint = btVector3(x,y,z);
			
			if (camPoint.distance(myPoint) < maxDis) {
				addNode(x,y,z,1);
			}
			
		}

		cout << "newSize " << nextOpen << "\n";
		
	}
void GameOctree::modRenderLevel (int modVal)
                                        {
		renderLevel += modVal;
		if (renderLevel > maxDepth) {
			renderLevel = maxDepth;
		}
		if (renderLevel < 0) {
			renderLevel = 0;
		}
		
		cout << "renderLevel " << renderLevel << "\n";
	}
void GameOctree::addNode (int x, int y, int z, uint col)
                                                    {
		int curPtr = rootPtr;
		int curLevel = 0;
		bool doProc = true;
		
		int curX = x;
		int curY = y;
		int curZ = z;
		
		int subX;
		int subY;
		int subZ;
		
		int curDiv = dimInVoxels/2;
		
		int offset;
		
		if (nextOpen >= (maxSize-nodeSize)) {
			cout << "octree full\n";
			return;
		}
		
		do {
			subX = curX/curDiv;
			subY = curY/curDiv;
			subZ = curZ/curDiv;
			
			curX -= subX*curDiv;
			curY -= subY*curDiv;
			curZ -= subZ*curDiv;
			
			offset = subX + subY*2 + subZ*4;
			
			if (data[curPtr+offset] == nullPtr) {
				data[curPtr+offset] = nextOpen;
				nextOpen += nodeSize;
			}
			
			curPtr = data[curPtr+offset];
			
			curDiv = curDiv/2;
			
		} while (curDiv > 1);
		
		data[curPtr+0] = col;
		
		
	}
void GameOctree::remNode (uint index)
                                 {
		
	}
void GameOctree::startRender ()
                           {
		renderBB(0,0,0,rootPtr,0,dimInVoxels);
	}
void GameOctree::renderBB (int baseX, int baseY, int baseZ, int startIndex, int curLevel, int curDiv)
          {
		
		int i;
		int xm;
		int ym;
		int zm;
		
		if (curLevel > renderLevel) {
			return;
		}
		
		int curDiv2 = curDiv/2;
		
		if (curLevel == renderLevel) {
			singleton->drawBoxMinMax(
				btVector3(baseX,baseY,baseZ),
				btVector3(baseX+curDiv,baseY+curDiv,baseZ+curDiv)
			);
		}
		
		
		
		for (i = 0; i < 8; i++) {
			zm = i/4;
			ym = (i-zm*4)/2;
			xm = (i-(zm*4 + ym*2));
			
			if (data[startIndex+i] == nullPtr) {
				
			}
			else {
				renderBB(
					baseX+xm*curDiv2,
					baseY+ym*curDiv2,
					baseZ+zm*curDiv2,
					data[startIndex+i],
					curLevel+1,
					curDiv2
				);
			}
		}
		
		
	}
#undef LZZ_INLINE
 
// f00325_uicomponent.h
//

#include "f00325_uicomponent.e"
#define LZZ_INLINE inline
UIComponent::UIComponent ()
                      {
		singleton = NULL;
		valuePtr = NULL;
	}
void UIComponent::init (Singleton * _singleton, int _parentId, int _nodeId, int _index, JSONValue * _jvNodeNoTemplate, bool _isFloating, string * stringVals, double * floatVals)
          {
		
		enabled = true;
		
		_children.clear();
		_floatingChildren.clear();
		
		dataLoaded = false;
		
		//valVec = NULL;
		
		privValueY = 0.0f;
		selected = false;
		forceDragUpdate = false;
		
		
		//valVecPtr = NULL;
		valuePtr = NULL;
		foundParent = false;
		foundValuePtr = false;
		

		singleton = _singleton;
		parentId = _parentId;
		nodeId = _nodeId;
		
		flags = floatVals[E_GFT_FLAGS];
		
		
		
		if ((flags&E_GF_X) == 0) {
			valVecMask.setFX(0.0f);
		}
		else {
			valVecMask.setFX(1.0f);
		}
		if ((flags&E_GF_Y) == 0) {
			valVecMask.setFY(0.0f);
		}
		else {
			valVecMask.setFY(1.0f);
		}
		if ((flags&E_GF_Z) == 0) {
			valVecMask.setFZ(0.0f);
		}
		else {
			valVecMask.setFZ(1.0f);
		}
		if ((flags&E_GF_W) == 0) {
			valVecMask.setFW(0.0f);
		}
		else {
			valVecMask.setFW(1.0f);
		}
		
		matCode = floatVals[E_GFT_MATCODE];
		
		valVec.setFXYZW(
			floatVals[E_GFT_VALUE0],
			floatVals[E_GFT_VALUE1],
			floatVals[E_GFT_VALUE2],
			floatVals[E_GFT_VALUE3]
		);
		
		
		
		layerId = -1;
		
		jvNodeNoTemplate = _jvNodeNoTemplate;
		
		layer = floatVals[E_GFT_LAYER];
		hoverType = floatVals[E_GFT_HOVERTYPE];
		isFloating = _isFloating;
		
		ss = stringVals[E_GST_SS];
		label = stringVals[E_GST_LABEL];
		text = label;
		dataRef = stringVals[E_GST_DATAREF];
		dataFile = stringVals[E_GST_DATAFILE];
		dataKey = stringVals[E_GST_DATAKEY];
		valRef = stringVals[E_GST_VALREF];
		
		
		uid = stringVals[E_GST_UID];
		index = _index;
		
		if (uid.size() > 0) {
			
			if (uid[0] == '#') {
				
			}
			else {
				singleton->compMap[uid].nodeId = nodeId;
			}
			
			
		}
		
		
		
		maxDimInPixels.x = floatVals[E_GFT_MAXDIMX];
		maxDimInPixels.y = floatVals[E_GFT_MAXDIMY];
		
		minDimInPixels.x = floatVals[E_GFT_MINDIMX];
		minDimInPixels.y = floatVals[E_GFT_MINDIMY];
		
		
		guiClass = floatVals[E_GFT_TYPE];
		//guiId = _guiId;
		
		
		dragging = false;
		overSelf = false;
		overChild = false;
		isDirty = true;
		visible = false;//(hoverType == E_HT_NORMAL);
		
		hasBackground = floatVals[E_GFT_HASBACKGROUND];
		fillRatioDim.x = floatVals[E_GFT_FILLRATIOX];
		fillRatioDim.y = floatVals[E_GFT_FILLRATIOY];

		singleLine = floatVals[E_GFT_SINGLELINE];
		
		
		curFont = singleton->fontWrappers[EFW_TEXT];
		curFontIcons = singleton->fontWrappers[EFW_ICONS];
		
		wasHit = false;
		
		divisions = floatVals[E_GFT_DIVISIONS];
		privValueX = floatVals[E_GFT_VALUE];
		updateTextNumber();

		mouseDown = false;
		mouseOver = false;

		resSS.init(&(singleton->styleSheetMap[ss]));
		
		
		paddingInPixels = resSS.baseSS->compStates[E_COMP_UP].props[E_SS_PADDING];
		borderInPixels = resSS.baseSS->compStates[E_COMP_UP].props[E_SS_BORDER];
		marginInPixels = resSS.baseSS->compStates[E_COMP_UP].props[E_SS_MARGIN];
		
		
		/////////////////
		
		totOffset.x = 0.0f;
		totOffset.y = 0.0f;
		
		
		targScrollOffset.x = 0.0f;
		targScrollOffset.y = 0.0f;
		
		scrollOffset.x = 0.0f;
		scrollOffset.y = 0.0f;
		
		scrollMaskY.x = 0.0;
		scrollMaskY.y = 0.0;
		
		dragStart.x = 0.0f;
		dragStart.y = 0.0f;
		
		lastDrag.x = 0.0f;
		lastDrag.y = 0.0f;
		
		dragOffset.x = 0.0f;
		dragOffset.y = 0.0f;
		
		floatOffset.x = 0.0f;
		floatOffset.y = 0.0f;
		
		originPos.x = 0.0f;
		originPos.y = 0.0f;
		spaceForCharsInPixels = 200.0f;
		
		/////////////////


		hitBounds.xMin = 0.0f;
		hitBounds.xMax = 0.0f;
		hitBounds.yMin = 0.0f;
		hitBounds.yMax = 0.0f;


		align.x = floatVals[E_GFT_ALIGNX];
		align.y = floatVals[E_GFT_ALIGNY];
		fillDir = floatVals[E_GFT_FILLDIR];
		
		spacing.x = 0.0f;
		spacing.y = 0.0f;

		
		if (isFloating) {
			resultDimInPixels.x = singleton->guiWinW;
			resultDimInPixels.y = singleton->guiWinH;
			originPos.x = 0.0;
			originPos.y = 0.0;
		}
		
		//
		
		
		
	}
void UIComponent::clearChildren ()
                             {
		_children.clear();
		_floatingChildren.clear();
	}
UIComponent * UIComponent::getChild (int ind)
                                       {
		
		int curInd = _children[ind];
		
		//if (singleton->compStack[curInd].isValid) {
			return (singleton->compStack[curInd].data);
		// }
		// else {
		// 	return NULL;
		// }
	}
UIComponent * UIComponent::getFloatingChild (int ind)
                                               {
		
		int curInd = _floatingChildren[ind];
		
		//if (singleton->compStack[curInd].isValid) {
			return (singleton->compStack[curInd].data);
		// }
		// else {
		// 	return NULL;
		// }
	}
int UIComponent::getChildCount ()
                            {
		return _children.size();
	}
int UIComponent::getFloatingChildCount ()
                                    {
		return _floatingChildren.size();
	}
float UIComponent::getDimYClamped (float val)
                                        {
		if (!enabled) {
			return 0.0f;
		}
		
		if (maxDimInPixels.y == 0) {
			return max(val,minDimInPixels.y);
		}
		else {
			return max(min(maxDimInPixels.y, val),minDimInPixels.y);
		}
	}
float UIComponent::getResultDimYClamped ()
                                     {
		if (!enabled) {
			return 0.0f;
		}
		
		if (maxDimInPixels.y == 0) {
			return max(resultDimInPixels.y,minDimInPixels.y);
		}
		else {
			return max(min(maxDimInPixels.y, resultDimInPixels.y),minDimInPixels.y);
		}
	}
string UIComponent::findKeyString (int valEnum)
                                          {
		string resString = "";
		UIComponent* curParent = getParent();
		
		
		while (
			(curParent != NULL)
		) {
			
			switch (valEnum) {
				case E_GST_DATAREF:
					if (curParent->dataRef.compare("") != 0) {
						return curParent->dataRef;
					}
				break;
				case E_GST_DATAFILE:
					if (curParent->dataFile.compare("") != 0) {
						return curParent->dataFile;
					}
				break;
			}
			
			curParent = curParent->getParent();
		}
		
		return "";
	}
void UIComponent::updateLinkedValues (bool isRead)
                                                     {
		int k;
		
		JSONValue* jvFileBase = NULL;
		JSONValue* jvNodeBase = NULL;
		
		
		
		
		if (dataKey.compare("") == 0) {
			
		}
		else {
			
			if (dataFile.compare("") == 0) {
				dataFile = findKeyString(E_GST_DATAFILE);
			}
			
			if (dataRef.compare("") == 0) {
				dataRef = findKeyString(E_GST_DATAREF);
			}
			
			if (
				(dataFile.compare("") == 0) ||
				(dataRef.compare("") == 0)
			) {
				cout << "missing dataFile or dataRef";
			}
			else {
				
				
				jvFileBase = singleton->fetchJSONData(dataFile, false);
				singleton->getJVNodeByString(jvFileBase,&jvNodeBase,dataRef + "." + dataKey);
				
				// if (isRead) {
				// 	cout << "DF " << dataFile << "\n";
				// }
				
				
				if (jvNodeBase != NULL) {
					
					if (isRead) {
						
						//cout << "yay\n";
						
						if (jvNodeBase->IsNumber()) {
							setValue(jvNodeBase->number_value);
						}
						if (jvNodeBase->IsArray()) {
							for (k = 0; k < jvNodeBase->array_value.size(); k++) {
								valVec.setIndex(k,jvNodeBase->array_value[k]->number_value);
							}
						}
					}
					else {
						if (jvNodeBase->IsNumber()) {
							jvNodeBase->number_value = getValue();
						}
						if (jvNodeBase->IsArray()) {
							for (k = 0; k < jvNodeBase->array_value.size(); k++) {
								jvNodeBase->array_value[k]->number_value = valVec[k];
							}
						}
					}
					
					
					
				}
				
			}
			
			
			
		}
	}
void UIComponent::setValueIndex (int ind, float val)
                                               {
		valVec.setIndex(ind,val);
		updateLinkedValues();	
	}
float UIComponent::getValueIndex (int ind)
                                     {
		
		if (!dataLoaded) {
			dataLoaded = true;
			updateLinkedValues(true);
		}
		
		return valVec[ind];
	}
float UIComponent::getValueIndexPtr (int ind)
                                        {
		
		UIComponent* curValuePtr = getValuePtr();
		if (curValuePtr != NULL) {
			return curValuePtr->getValueIndex(ind);
		}
		else {
			return getValueIndex(ind);
		}
		
		
	}
void UIComponent::updateTextNumber ()
                                {
		if (
			//(guiClass == E_GT_SLIDER) &&
			(divisions > 1.0f)
		) {
			setText(
					label + ": " +
					i__s(privValueX*divisions) +
					//getPaddedInt(privValueX*divisions, divisions) +
					" / " +
					i__s(divisions)
			);
		}
	}
void UIComponent::setValue (float _value, bool doEventDispatch, bool preventRefresh)
                                                                                               {
		UIComponent* curValuePtr = getValuePtr();
		
		if (curValuePtr != NULL) {
			
			if ((flags&E_GF_X) != 0) {
				curValuePtr->setValueIndex(0,_value);
			}
			else if ((flags&E_GF_Y) != 0) {
				curValuePtr->setValueIndex(1,_value);
			}
			else if ((flags&E_GF_Z) != 0) {
				curValuePtr->setValueIndex(2,_value);
			}
			else if ((flags&E_GF_W) != 0) {
				curValuePtr->setValueIndex(3,_value);
			}
			
			
		}
		else {
			privValueX = _value;
			
			updateTextNumber();
			
			
			updateLinkedValues();
			
			if (doEventDispatch) {
				singleton->dispatchEvent(GLUT_LEFT_BUTTON, GLUT_UP, 0, 0, this, true, preventRefresh);
			}
		}
		
		
	}
float UIComponent::getValue ()
                         {
		
		if (!dataLoaded) {
			dataLoaded = true;
			updateLinkedValues(true);
		}
		
		UIComponent* highestCont = NULL;
		UIComponent* highestContPar = NULL;
		
		if (matCode == E_MC_MATERIAL) {
			highestCont = getHighestCont(this, 0);
			if (highestCont != NULL) {
				highestContPar = highestCont->getParent();
				if (highestContPar != NULL) {
					return (((float)(highestContPar->index)) + 0.5f)/255.0f;
				}
				
			}
			else {
				return 1.0;
			}
			
		}
		
		
		UIComponent* curValuePtr = getValuePtr();
		if (curValuePtr != NULL) {
			if ((flags&E_GF_X) != 0) {
				return curValuePtr->getValueIndex(0);
			}
			else if ((flags&E_GF_Y) != 0) {
				return curValuePtr->getValueIndex(1);
			}
			else if ((flags&E_GF_Z) != 0) {
				return curValuePtr->getValueIndex(2);
			}
			else if ((flags&E_GF_W) != 0) {
				return curValuePtr->getValueIndex(3);
			}
		}
		else {
			return privValueX;
		}
		
		return 0.0f;
		
	}
void UIComponent::setValueY (float _value, bool doEventDispatch, bool preventRefresh)
                                                                                                {
		UIComponent* curValuePtr = getValuePtr();
		
		int count = 0;
		
		if (curValuePtr != NULL) {
			if ((flags&E_GF_X) != 0) {
				if (count == 1) {
					curValuePtr->setValueIndex(0,_value);
				}
				count++;
			}
			if ((flags&E_GF_Y) != 0) {
				if (count == 1) {
					curValuePtr->setValueIndex(1,_value);
				}
				count++;
			}
			if ((flags&E_GF_Z) != 0) {
				if (count == 1) {
					curValuePtr->setValueIndex(2,_value);
				}
				count++;
			}
			if ((flags&E_GF_W) != 0) {
				if (count == 1) {
					curValuePtr->setValueIndex(3,_value);
				}
				count++;
			}
		}
		else {
			privValueY = _value;
		}
	}
float UIComponent::getValueY ()
                          {
		int count = 0;
		UIComponent* curValuePtr = getValuePtr();
		
		if (!dataLoaded) {
			dataLoaded = true;
			updateLinkedValues(true);
		}
		
		if (curValuePtr != NULL) {
			if ((flags&E_GF_X) != 0) {
				if (count == 1) {
					return curValuePtr->getValueIndex(0);
				}
				count++;
			}
			if ((flags&E_GF_Y) != 0) {
				if (count == 1) {
					return curValuePtr->getValueIndex(1);
				}
				count++;
			}
			if ((flags&E_GF_Z) != 0) {
				if (count == 1) {
					return curValuePtr->getValueIndex(2);
				}
				count++;
			}
			if ((flags&E_GF_W) != 0) {
				if (count == 1) {
					return curValuePtr->getValueIndex(3);
				}
				count++;
			}
			
			return 0.0f;
			
		}
		else {
			return privValueY;
		}
		
	}
UIComponent * UIComponent::getParent ()
                                 {
		if (nodeId <= 0) {
			return NULL;
		}
		else {
			return (singleton->compStack[parentId].data);
		}
	}
UIComponent * UIComponent::findParentByUID (string parUID)
                                                    {
		string resString = "";
		UIComponent* curParent = getParent();
		
		
		while (curParent != NULL) {
			
			
			if(curParent->uid.compare(parUID) == 0) {
				return curParent;
			}
			
			curParent = curParent->getParent();
		}
		
		return NULL;
	}
UIComponent * UIComponent::getValuePtr ()
                                   {
		if (foundValuePtr) {
			
		}
		else {
			
			if (valRef.compare("") != 0) {
				valuePtr = findParentByUID(valRef);
			}
			else {
				valuePtr = NULL;
			}
			
			foundValuePtr = true;
		}
		
		return valuePtr;
	}
UIComponent * UIComponent::findNodeByString (string _uid)
                                                   {
		int i;
		
		if (_uid.compare(uid) == 0) {
			return this;
		}
		
		for (i = 0; i < getChildCount(); i++) {
			if (getChild(i)->findNodeByString(_uid) != NULL) {
				return getChild(i)->findNodeByString(_uid);
			}
		}
		
		for (i = 0; i < getFloatingChildCount(); i++) {
			if (getFloatingChild(i)->findNodeByString(_uid) != NULL) {
				return getFloatingChild(i)->findNodeByString(_uid);
			}
		}
		
		return NULL;
	}
float UIComponent::getMinWidth ()
                            {
		int i;
		
		updateVecs();
		
		if (singleLine) {
			spaceForCharsInPixels = 99999.0f;
			renderText(true);
			
		}
		else {
			textDimInPixels.x = 0;
			textDimInPixels.y = 0;
		}
		
		
		
		float curMW = (marginInPixels+borderInPixels+paddingInPixels)*2.0f + 
			textDimInPixels.x;
		
		
		float totMW = 0.0f;
		float tempMW = 0.0f;
		
		for (i = 0; i < getChildCount(); i++) {
			
			tempMW = getChild(i)->getMinWidth();
			
			if (fillDir == E_FILL_HORIZONTAL) {
				totMW += tempMW;
			}
			else {
				totMW = max(totMW,tempMW);
			}
		}
		
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->getMinWidth();
		}
		
		
		curMW += totMW;
		
		rmDimInPixels.x = max(curMW,minDimInPixels.x);
		
		return rmDimInPixels.x;
		
	}
float UIComponent::getMinHeight ()
                             {
		int i;
		
		if (!singleLine) {
			spaceForCharsInPixels = resultDimInPixels.x;
			renderText(true);
		}
		else {
			// already determined
		}
		
		
		
		float curMH = (marginInPixels+borderInPixels+paddingInPixels)*2.0f + 
			textDimInPixels.y;
		
		float totMH = 0.0f;
		float tempMH = 0.0f;
		
		
		for (i = 0; i < getChildCount(); i++) {
			
			tempMH = getChild(i)->getMinHeight();
			
			if (fillDir == E_FILL_HORIZONTAL) {
				
				totMH = max(totMH,tempMH);
			}
			else {
				totMH += tempMH;
			}
		}
		
		
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->getMinHeight();
		}
		
		curMH += totMH;
		
		rmDimInPixels.y = max(curMH,minDimInPixels.y);
		
		return getDimYClamped(curMH);
		
	}
int UIComponent::addChild (int _lastIndex, int _parentId, string * stringVals, double * floatVals, bool _isFloating, JSONValue * _jvNodeNoTemplate)
          {
		
		int _nodeId;
		int childCount = 0;
		
		_nodeId = singleton->placeInStack();
		
		
		
		if (_isFloating) {
			
			if (_lastIndex < 0) {
				_floatingChildren.push_back(_nodeId);
				childCount = getFloatingChildCount()-1;
			}
			else {
				_floatingChildren[_lastIndex] = _nodeId;
				childCount = _lastIndex;
			}
			
			
		}
		else {
			
			if (_lastIndex < 0) {
				_children.push_back(_nodeId);
				childCount = getChildCount()-1;
			}
			else {
				_children[_lastIndex] = _nodeId;
				childCount = _lastIndex;
			}
			
		}
		
		singleton->compStack[_nodeId].data->init(
			singleton,
			_parentId,
			_nodeId,
			childCount,
			
			_jvNodeNoTemplate,
			_isFloating,
			
			stringVals,
			floatVals
		);
		
		return _nodeId;
		
	}
void UIComponent::setOrigPos ()
                          {
		
		int i;
		
		fVector2 curPos = originPos;
		
		
		
		
		fVector2 availSpaceDim = resultDimInPixels;
		fVector2 totVals;
		
		totVals.x = 0.0f;
		totVals.y = 0.0f;
		
		for (i = 0; i < getChildCount(); i++) {
			
			if (fillDir == E_FILL_HORIZONTAL) {
				totVals.x += getChild(i)->resultDimInPixels.x;
				totVals.y = max(totVals.y,getChild(i)->resultDimInPixels.y);
			}
			else {
				totVals.y += getChild(i)->resultDimInPixels.y;
				totVals.x = max(totVals.x,getChild(i)->resultDimInPixels.x);
			}
			
			
		}
		
		availSpaceDim.x -= totVals.x;
		availSpaceDim.y -= totVals.y;
		
		switch (align.x) {
			case E_ALIGNH_LEFT:
				curPos.x += marginInPixels + borderInPixels + paddingInPixels;
			break;
			case E_ALIGNH_CENTER:
				curPos.x += availSpaceDim.x/2.0f;
			break;
			case E_ALIGNH_RIGHT:
				curPos.x += availSpaceDim.x;
				curPos.x -= marginInPixels + borderInPixels + paddingInPixels;
			break;
		}
		
		switch (align.y) {
			case E_ALIGNV_TOP:
				curPos.y += marginInPixels + borderInPixels + paddingInPixels;
			break;
			case E_ALIGNV_MIDDLE:
				curPos.y += availSpaceDim.y/2.0f;
			break;
			case E_ALIGNV_BOTTOM:
				curPos.y += availSpaceDim.y;
				curPos.y -= marginInPixels + borderInPixels + paddingInPixels;
			break;
		}
		
		if (fillDir == E_FILL_HORIZONTAL) {
			for (i = 0; i < getChildCount(); i++) {
				getChild(i)->originPos.x = curPos.x;
				getChild(i)->originPos.y = curPos.y;
				curPos.x += getChild(i)->resultDimInPixels.x;
			}
		}
		else {
			for (i = 0; i < getChildCount(); i++) {
				getChild(i)->originPos.x = curPos.x;
				getChild(i)->originPos.y = curPos.y;
				curPos.y += getChild(i)->resultDimInPixels.y;
			}
		}
		
		
		for (i = 0; i < getChildCount(); i++) {
			getChild(i)->setOrigPos();
		}
		
		
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->setOrigPos();
		}
		
	}
void UIComponent::applyHeight ()
                           {
		fVector2 totalRatios;
		totalRatios.x = 0.0f;
		totalRatios.y = 0.0f;
		float availSpace = resultDimInPixels.y - (marginInPixels+borderInPixels+paddingInPixels)*2.0f;
		int i;
		
		

		for (i = 0; i < getChildCount(); i++) {
			totalRatios.y += getChild(i)->fillRatioDim.y;
			if (fillDir == E_FILL_HORIZONTAL) {
				
			}
			else {
				availSpace -= getChild(i)->rmDimInPixels.y;
			}
		}
		
		availSpace = max(availSpace,0.0f);
		
		
		if (totalRatios.y == 0.0f) {
			totalRatios.y = 1.0f;
		}
		
		
		for (i = 0; i < getChildCount(); i++) {
			
			if (getChild(i)->enabled == false) {
				getChild(i)->resultDimInPixels.y = 0.0;
			}
			else {
				if (fillDir == E_FILL_HORIZONTAL) {
					
					if (getChild(i)->fillRatioDim.y == 0.0f) {
						getChild(i)->resultDimInPixels.y = getChild(i)->rmDimInPixels.y;
					}
					else {
						
						
						getChild(i)->resultDimInPixels.y = availSpace;
					}
				}
				else {
					getChild(i)->resultDimInPixels.y = ceil(
						getChild(i)->rmDimInPixels.y + 
						(availSpace*getChild(i)->fillRatioDim.y)/totalRatios.y
					);
					
					
				}
			}
			
			
		}
		
		for (i = 0; i < getChildCount(); i++) {
			getChild(i)->applyHeight();	
		}
		
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->applyHeight();
		}
		
	}
void UIComponent::applyWidth ()
                          {
		
		fVector2 totalRatios;
		totalRatios.x = 0.0f;
		totalRatios.y = 0.0f;
		float availSpace = resultDimInPixels.x - (marginInPixels+borderInPixels+paddingInPixels)*2.0f;
		int i;
		

		for (i = 0; i < getChildCount(); i++) {
			totalRatios.x += getChild(i)->fillRatioDim.x;
			if (fillDir == E_FILL_HORIZONTAL) {
				availSpace -= getChild(i)->rmDimInPixels.x;
			}
			else {
				
			}
		}		
		availSpace = max(availSpace,0.0f);
		
		if (totalRatios.x == 0.0f) {
			totalRatios.x = 1.0f;
		}
		
		
		for (i = 0; i < getChildCount(); i++) {
			
			
			if (getChild(i)->enabled == false) {
				getChild(i)->resultDimInPixels.x = 0.0;
			}
			else {
				if (fillDir == E_FILL_HORIZONTAL) {
					
					
					
					getChild(i)->resultDimInPixels.x = ceil(
						max(
							getChild(i)->rmDimInPixels.x +
							(availSpace*getChild(i)->fillRatioDim.x)/totalRatios.x,
							getChild(i)->minDimInPixels.x
						)
					);
					
						
				}
				else {
					
					if (getChild(i)->fillRatioDim.x == 0.0f) {
						getChild(i)->resultDimInPixels.x =
							max(
								getChild(i)->rmDimInPixels.x,
								getChild(i)->minDimInPixels.x
							);
						
					}
					else {
						getChild(i)->resultDimInPixels.x =
							max(
								availSpace,
								getChild(i)->minDimInPixels.x
							);
						
					}
				}
			}
			
			
					
		}
		
		
		for (i = 0; i < getChildCount(); i++) {
			getChild(i)->applyWidth();	
		}
		
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->applyWidth();
		}
		
	}
void UIComponent::gatherDirty (vector <UIComponent*> * dirtyVec)
                                                          {
		
		int i;
		
		if (isDirty) {
			dirtyVec->push_back(this);
		}
		else {
			for (i = 0; i < getChildCount(); i++) {
				getChild(i)->gatherDirty(dirtyVec);
			}
			for (i = 0; i < getFloatingChildCount(); i++) {
				getFloatingChild(i)->gatherDirty(dirtyVec);
			}
		}
		
	}
void UIComponent::clearDirty ()
                          {
		
		int i;
		
		isDirty = false;
		
		for (i = 0; i < getChildCount(); i++) {
			getChild(i)->clearDirty();
		}
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->clearDirty();
		}
	}
void UIComponent::alignToComp (UIComponent * myComp)
                                              {
		UIComponent* myComp2 = myComp->getParent();
		
		
		if (
			(myComp->fillDir == 0) &&
			(myComp2 != NULL)
		) {
			floatOffset.x = myComp2->floatOffset.x + myComp2->dragOffset.x + myComp2->originPos.x + myComp2->resultDimInPixels.x;
			floatOffset.y = myComp2->floatOffset.y + myComp2->dragOffset.y + myComp2->originPos.y;
		}
		else {
			floatOffset.x = myComp->floatOffset.x + myComp->dragOffset.x + myComp->originPos.x + myComp->resultDimInPixels.x;
			floatOffset.y = myComp->floatOffset.y + myComp->dragOffset.y + myComp->originPos.y;
		}
		
		
		
		
	}
void UIComponent::layout ()
                      {
		
		int i;
		
		
		// if (isDirty) {
		// 	isDirty = false;
		// }
		// else {
		// 	return;
		// }
		
		
		
		getMinWidth();
		applyWidth();
		getMinHeight();
		applyHeight();
		setOrigPos();
		
		
		
	}
void UIComponent::updateOffset ()
                            {
		totOffset.x = floatOffset.x + dragOffset.x + scrollOffset.x;
		totOffset.y = floatOffset.y + dragOffset.y + scrollOffset.y;
		return;
	}
void UIComponent::updateValue (float x, float y)
                                           {
		
		int i;
		
		float hoverBuffer = 4.0f;
		float tempValue;
		float tempValueY;
		
		UIComponent* curParent = getParent();
		
		
		UIComponent* highestCont;
		
		if (dragging||forceDragUpdate) {
			highestCont = getHighestCont(this, 0);
			
			if (forceDragUpdate) {
				highestCont->dragOffset.x = lastDrag.x;
				highestCont->dragOffset.y = lastDrag.y;
			}
			else {
				highestCont->dragOffset.x = lastDrag.x + (x - dragStart.x); //
				highestCont->dragOffset.y = lastDrag.y + (y - dragStart.y); //
			}
			
			
			forceDragUpdate = false;
		}
		
		if (curParent == NULL) {
			
		}
		else {
			if (
				(curParent->getFloatingChildCount() > 0)
			) {
				
			}
			else {
				//if (curParent->hoverType != E_HT_ROOT) {
					dragOffset = curParent->dragOffset;
				//}			
			}
		}
		
		
		
		
		
		
		
		if ((maxDimInPixels.y == 0)&&(curParent != NULL)) {
			
			if (curParent->getFloatingChildCount() == 0) {
				scrollOffset.y = curParent->scrollOffset.y;
			}
			
			
		}
		else {
			scrollOffset.y += (targScrollOffset.y-scrollOffset.y)/16.0f;
		}
		
		
		
		
		
		
		
		
		
		switch (hoverType) {
			case E_HT_NORMAL:
				if (curParent != NULL) {
					floatOffset = curParent->floatOffset;					
				}
			break;
			case E_HT_ROOT:
				
			break;
			case E_HT_TOOLTIP:
			case E_HT_TOOLTIP_VALUE:
				floatOffset.x = x + hoverBuffer - dragOffset.x; 
				floatOffset.y = curParent->totOffset.y + curParent->originPos.y + curParent->resultDimInPixels.y + hoverBuffer;
				visible = curParent->overSelf && curParent->enabled;
				
				if ((hoverType == E_HT_TOOLTIP_VALUE)&&visible&&enabled) {
					
					getChild(0)->setText(f__s(curParent->getValue()));
				}
				
			break;
			case E_HT_ONSELECTED:
				if (curParent != NULL) {
					alignToComp(curParent);
					
					//visible = (curParent->selected)&&(curParent->visible);
				}
				
			break;
		}
		
		
		
		
		for (i = 0; i < getChildCount(); i++) {
			
			switch(getChild(i)->hoverType) {
				case E_HT_NORMAL:
					getChild(i)->visible = visible&&enabled;
				break;
				
				case E_HT_ROOT:
					
				break;
				
				case E_HT_TOOLTIP:
				case E_HT_TOOLTIP_VALUE:
				
				break;
				
				case E_HT_ONSELECTED:
					getChild(i)->visible = visible&&selected&&enabled;
				break;
			}
			
		}
		for (i = 0; i < getFloatingChildCount(); i++) {
			
			switch(getFloatingChild(i)->hoverType) {
				case E_HT_NORMAL:
					getFloatingChild(i)->visible = visible&&enabled;
				break;
				
				case E_HT_ROOT:
					
				break;
				
				case E_HT_TOOLTIP:
				case E_HT_TOOLTIP_VALUE:
				
				break;
				
				case E_HT_ONSELECTED:
					getFloatingChild(i)->visible = visible&&selected&&enabled;
				break;
			}
		}
		
		
		updateOffset();
		
		
		if (curParent != NULL) {
			if (curParent->getFloatingChildCount() == 0) {
				if (maxDimInPixels.y == 0) {
					scrollMaskY = curParent->scrollMaskY;
				}
				else {
					scrollMaskY.x = originPos.y + marginInPixels;
					scrollMaskY.y = originPos.y +  getResultDimYClamped() - marginInPixels;
					
					scrollMaskY.x += totOffset.y-scrollOffset.y;
					scrollMaskY.y += totOffset.y-scrollOffset.y;
					
					scrollMaskY.x /= singleton->guiWinH;
					scrollMaskY.y /= singleton->guiWinH;
					scrollMaskY.x = ((1.0f-scrollMaskY.x) - 0.5f)*2.0f;
					scrollMaskY.y = ((1.0f-scrollMaskY.y) - 0.5f)*2.0f;			
				}
			}
		}
		
		
		
		
		
		
		
		float hbxMin = hitBounds.xMin + totOffset.x;
		float hbxMax = hitBounds.xMax + totOffset.x;
		
		float hbyMin = hitBounds.yMin + totOffset.y;
		float hbyMax = hitBounds.yMax + totOffset.y;
		
		if (wasHit&&(guiClass == E_GT_SLIDER)) {
			
			if (divisions == 1.0f) {
				// toggle button, do nothing
			}
			else {
				tempValue = clampfZO((x-hbxMin)/(hbxMax-hbxMin));
				tempValueY = clampfZO(1.0f - (y-hbyMin)/(hbyMax-hbyMin));
				
				if (divisions == 0.0f) {
					setValue(
						tempValue
					);
					setValueY(
						tempValueY	
					);
				}
				else {
					
					setValue(
						floor(tempValue*divisions)/divisions
					);
					setValueY(
						floor(tempValueY*divisions)/divisions
					);
				}
				
			}
		}
	}
void UIComponent::runReport ()
                         {
		
		int i;
		
		//cout << overSelf << " " << text << "\n";
				
		for (i = 0; i < getChildCount(); i++) {
			getChild(i)->runReport();
		}
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->runReport();
		}
	}
void UIComponent::clearOver ()
                         {
		int i;
		overSelf = false;
		
		for (i = 0; i < getChildCount(); i++) {
			getChild(i)->clearOver();
		}
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->clearOver();
		}
		
	}
bool UIComponent::findMaxLayer (float x, float y, float xTransformed, float yTransformed)
                                                                                    {
		
		
		int i;

		overSelf = (
			(x < (hitBounds.xMax+totOffset.x)) &&
			(x > (hitBounds.xMin+totOffset.x)) &&
			(y < (hitBounds.yMax+totOffset.y)) &&
			(y > (hitBounds.yMin+totOffset.y))
		) && visible && enabled;// && hasBackground;
		
		
		if (
			(maxDimInPixels.y == 0) ||
			((abs(scrollMaskY.x) + abs(scrollMaskY.y)) <= 1.0f)
		) {
			
		}
		else {
			if (
					(yTransformed > scrollMaskY.x) || 
				  (yTransformed < scrollMaskY.y)
			) {
				overSelf = false;
				overChild = false;
				return false;
			}
		}
		
		
		
		
		
		
		
		overChild = false;
		
		for (i = 0; i < getChildCount(); i++) {
			overChild = overChild||getChild(i)->findMaxLayer(x,y,xTransformed,yTransformed);
		}
		for (i = 0; i < getFloatingChildCount(); i++) {
			overChild = overChild||getFloatingChild(i)->findMaxLayer(x,y,xTransformed,yTransformed);
		}
		
		if (
			overSelf &&
			visible &&
			enabled &&
			hasBackground &&
			(!overChild) &&
			(layer >= singleton->maxLayerOver)
		) {
			singleton->maxLayerOver = layer;
		}
		
		return overSelf;
	}
void UIComponent::testOver (float x, float y)
                                        {
		
		int i;
		
		bool lastOver = mouseOver;
		
		for (i = 0; i < getChildCount(); i++) {
			getChild(i)->testOver(x,y);
		}
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->testOver(x,y);
		}
		
		mouseOver = 
			overSelf &&
			visible &&
			enabled &&
			(hasBackground) && //||(guiClass == E_GT_DRAGPAD)
			(!overChild) &&
			(layer >= singleton->maxLayerOver);
		
		
		
		if ((mouseOver != lastOver)&&(!(singleton->dragging))) {
			if (mouseOver) {
				singleton->dispatchEvent(
					GLUT_NO_BUTTON,
					GLUT_OVER,
					x,
					y,
					this
				);
				
				
			}
			else {
				singleton->dispatchEvent(
					GLUT_NO_BUTTON,
					GLUT_OUT,
					x,
					y,
					this
				);
			}
		}
		else {
			if (
				wasHit && 
				(
					(guiClass == E_GT_SLIDER) ||
					(guiClass == E_GT_DRAGPAD)	
				)
				
			) {
				
				if (divisions == 1.0f) {
					// toggle button, do nothing
				}
				else {
					singleton->dispatchEvent(
						GLUT_NO_BUTTON,
						GLUT_CHANGING,
						x,
						y,
						this
					);
				}
			}
		}
		
		
		
		
		updateValue(x, y);

	}
bool UIComponent::testHit (int button, int state, float x, float y)
                                                              {
		
		bool hitDeepest = false;		
		float wheelDelta = 0.0f;
		
		
		UIComponent* curParent = getParent();
		UIComponent* curParent2 = NULL;
		
		UIComponent* selParent = NULL;
		
		if (curParent != NULL) {
			curParent2 = curParent->getParent();
		}
		
		
		int i;
		int j;
		bool hitChild = false;
		float lastValue = getValue();
		bool tempValue;
		
		
		
		
		if (button == GLUT_LEFT_BUTTON) {
			if (state == GLUT_DOWN) { // MOUSE DOWN
				if (mouseOver) {
					
					if (enabled && visible) {
						
						
					
						
						if (
							(guiClass != E_GT_HOLDER)
						) {
							wasHit = true;
						}
						
						dragging = (guiClass == E_GT_MENUBAR);
						if (dragging) {
							singleton->dragging = true;
						}
						
						if (dragging||(guiClass == E_GT_DRAGPAD)) {
							dragStart.x = x;
							dragStart.y = y;
						}
						
						
						
					}
					
					
				}

				mouseDown = true;
			}
			else { // MOUSE UP
				
				
				if (dragging) {
					lastDrag.x += (x - dragStart.x);
					lastDrag.y += (y - dragStart.y);
					dragStart.x = 0.0f;
					dragStart.y = 0.0f;
					
					
				}
				dragging = false;
				singleton->dragging = false;
				
				if (mouseOver&&wasHit) {
					
					switch (guiClass) {
						case E_GT_HOLDER:
							
						break;
						case E_GT_SLIDER:
							if (divisions == 1.0f) {
								setValue(1.0f-getValue());
							}
						break;
						case E_GT_BUTTON:
							
						break;
						case E_GT_CHECK:
							selected = !selected;
						break;
						
						case E_GT_RADIO:
							tempValue = !selected;
							
							if (singleton->bCtrl) {
								
							}
							else {
								
								if (singleton->bShift) {
									
								}
								else {
									
								}
								
								if (curParent2 == NULL) {
									for (i = 0; i < curParent->getChildCount(); i++) {
										if (curParent->getChild(i)->guiClass == E_GT_RADIO) {
											curParent->getChild(i)->selected = false;
											//curParent->getChild(i)->setValue(0.0f);
										}
									}
								}
								else {
									
									for (j = 0; j < curParent2->getChildCount(); j++) {
										selParent = curParent2->getChild(j);
										
										for (i = 0; i < selParent->getChildCount(); i++) {
											if (selParent->getChild(i)->guiClass == E_GT_RADIO) {
												//selParent->getChild(i)->setValue(0.0f);
												selParent->getChild(i)->selected = false;
											}
										}
									}
									
									
									
									
								}
								
								
							}
							selected = tempValue;
							//setValue(tempValue);
							
						break;
					}
					
				}


				mouseDown = false;
			}
		}
		else {
				if ( (button == 3) || (button == 4) ) {
					
					
					if (enabled && visible && overSelf) {
						if (maxDimInPixels.y != 0) {
							
							if (button == 3) {
								wheelDelta = 1.0f;
								// wheel up
							}
							else {
								wheelDelta = -1.0f;
								// wheel down
							}
							
							if (resultDimInPixels.y > maxDimInPixels.y) {
								targScrollOffset.y += wheelDelta*20.0f;
								targScrollOffset.y = clampf(targScrollOffset.y, -(resultDimInPixels.y-maxDimInPixels.y), 0.0f);
								
							}
							
							
							return true;
						}	
					}
				}
		}

		updateValue(x, y);
		
		for (i = 0; i < getChildCount(); i++) {
			hitChild = hitChild||getChild(i)->testHit(button, state, x, y);
		}
		
		for (i = 0; i < getFloatingChildCount(); i++) {
			hitChild = hitChild||getFloatingChild(i)->testHit(button, state, x, y);
		}
		
		hitDeepest = (!hitChild)&&(mouseOver);
		
		if ( hitDeepest ) {
			// deepest node
			
			singleton->dispatchEvent(button, state, x, y, this);
		}
		
		bool finalRes = (hitDeepest||hitChild); //(wasHit)
		if ((state == GLUT_UP)) { //&&(wheelDelta==0.0f)
			wasHit = false;
		}
		

		return finalRes;
	}
UIComponent * UIComponent::getHighestCont (UIComponent * curNode, int genCount)
                                                                        {
		UIComponent* curParent = curNode->getParent();
		
		if (curParent == NULL) {
			return curNode;
		}
		else {
			if (curParent->getFloatingChildCount() > 0) {
				return curNode;
			}
			else {
				return getHighestCont(curParent, genCount+1);
			}
		}
		
		
		
	}
void UIComponent::setText (string _text)
                                   {
		
		UIComponent* highestCont;
		
		if (_text.compare(text) == 0) {
			// text unchanged, do nothing
		}
		else {
			text = _text;
			
			highestCont = getHighestCont(this, 0);
			highestCont->isDirty = true;
			singleton->guiDirty = true;
			
		}
		
		
	}
void UIComponent::updateVecs ()
                          {
		
		
		
		lineVec.clear();
		wordVec.clear();

		lineVec = split(text, '\n');

		int i;
		int j;

		for (i = 0; i < lineVec.size(); i++) {
			wordVec.push_back(std::vector<string>());
			wordVec[i] = split(lineVec[i], ' ');
		}
		
	}
void UIComponent::renderAll ()
                         {
		int i;
		
		renderText(false);
		
		for (i = 0; i < getChildCount(); i++) {
			getChild(i)->renderAll();
		}
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->renderAll();
		}
	}
void UIComponent::updateSS ()
                        {
		int i;
		
		resSS.update(mouseOver, mouseDown);
		
		for (i = 0; i < getChildCount(); i++) {
			getChild(i)->updateSS();
		}
		for (i = 0; i < getFloatingChildCount(); i++) {
			getFloatingChild(i)->updateSS();
		}
		
	}
float UIComponent::getLineOffset (int lineCount)
                                           {
		
		switch (align.x) {
			case E_ALIGNH_LEFT:
				return 0.0f;
			break;
			case E_ALIGNH_CENTER:
				return (resultDimInPixels.x - (linePitchVec[lineCount]+(marginInPixels+borderInPixels+paddingInPixels)*2.0f) )/2.0f;
			break;
			case E_ALIGNH_RIGHT:
				return (
					resultDimInPixels.x -
					(
						(linePitchVec[lineCount]) +
						(marginInPixels+borderInPixels+paddingInPixels)
					)
				);
			break;
			default:
				return 0.0f;
			break;
		}
		
		
	}
float UIComponent::lengthOfWord (int i, int j, bool isIcon)
                                                      {
		int numChars = wordVec[i][j].size();
		int k;
		float tot = 0.0f;
		
		if (isIcon) {
			return curFontIcons->maxWidth;
		}
		
		for (k = 0; k < numChars; k++) {
			tot += curFont->charVals[ wordVec[i][j][k] ].consumedW*curFont->fontScale;
		}
		
		return tot;
		
	}
int UIComponent::maxCharsForWord (int i, int j)
                                          {
		int numChars = wordVec[i][j].size();
		
		float tot = 0.0f;
		
		int k = 0;
		while (
			(tot < spaceForCharsInPixels) &&
			(k < wordVec[i][j].size())
		) {
			tot += curFont->charVals[ wordVec[i][j][k] ].consumedW;
			k++;
		}
		
		return k;
	}
void UIComponent::renderText (bool getDimensions)
                                            {
		
		
		
		int curSize = 0;
		int i;
		int j;
		int k;
		int curChar;
		int lineCount = 0;
		
		bool isRendering = !getDimensions;
		bool isIcon = false;

		fVector2 caretPos;
		fVector2 offsetPos;
		
		float vspace = resultDimInPixels.y - textDimInPixels.y;
		
		Singleton::UIQuad* curQuad;
		
		caretPos.x = 0.0f;
		caretPos.y = 0.0f;
		
		if (getDimensions) {
			linePitchVec.clear();
		}
		else {
			offsetPos.x = originPos.x + marginInPixels + borderInPixels + paddingInPixels;
			
			switch (align.y) {
				case E_ALIGNV_TOP:
					offsetPos.y = originPos.y + marginInPixels + borderInPixels + paddingInPixels;
				break;
				case E_ALIGNV_MIDDLE:
					offsetPos.y = originPos.y + vspace/2.0f;
					
				break;
				case E_ALIGNV_BOTTOM:
					offsetPos.y = originPos.y + vspace - (marginInPixels + borderInPixels + paddingInPixels);
				break;
			}
		}
		
		
		float maxCaretPos = 0;

		//float charCount = 0;

		float maxSize;

		if (isRendering) {
			hitBounds.xMin = originPos.x + marginInPixels;
			hitBounds.xMax = originPos.x + resultDimInPixels.x - marginInPixels;
			hitBounds.yMin = originPos.y + marginInPixels;
			hitBounds.yMax = originPos.y + resultDimInPixels.y - marginInPixels;
			
			
			if (layerId == -1) {
				layerId = singleton->placeInLayer(nodeId, layer);
				//singleton->guiLayers[layer].push_back(&uiCont);
			}
			
			
			if (uiCont.charVec.size() > 0) {
				uiCont.charVec.clear();
			}
			
			
			
			//uiCont.uiComp = this;
			uiCont.bg.hitBounds = hitBounds;
			uiCont.bg.cs = NULL;
			uiCont.bg.fontId = -1;
			
			if (hasBackground) {
				uiCont.bg.fontId = 0;
			}
			
		}

		//lines
		for (i = 0; i < wordVec.size(); i++) {
			
			caretPos.x = 0.0f;
			if (isRendering) {
				caretPos.x += getLineOffset(lineCount);
			}
			lineCount++;

			//words in line
			for (j = 0; j < wordVec[i].size(); j++) {
				curSize = wordVec[i][j].size();
				
				if (curSize > 0) {
					isIcon = (wordVec[i][j][curSize-1] == '&') && (curSize >= 2);
					
					//if word won't fit, increment line
					if ( (caretPos.x + lengthOfWord(i,j,isIcon)) + curFont->maxWidth >= spaceForCharsInPixels ) {
						//charCount = 0;
						
						if (getDimensions) {
							linePitchVec.push_back(caretPos.x);
						}
						maxCaretPos = max(caretPos.x, maxCaretPos);
						caretPos.x = 0.0f;
						if (isRendering) {
							caretPos.x += getLineOffset(lineCount);
						}
						
						lineCount++;
						caretPos.y += (curFont->fontHeight*curFont->fontScale + spacing.y);
					}
					
					
					
					
					if (isIcon) {
						// is an icon
						
						curChar = atoi(wordVec[i][j].c_str());
						
						if (isRendering) {
							uiCont.charVec.push_back(Singleton::UIQuad());
							curQuad = &(uiCont.charVec.back());
							curQuad->cs = &(curFontIcons->charVals[ curChar ]);
							curQuad->fontId = EFW_ICONS;
							curQuad->hitBounds.xMin = caretPos.x+offsetPos.x;
							curQuad->hitBounds.yMin = caretPos.y+offsetPos.y;
						}
						
						
						
						caretPos.x += curFontIcons->maxWidth*curFontIcons->fontScale;
						
						
						
						// renderCharAt(
						// 	&(curFontIcons->charVals[ curChar ]),
						// 	curFontIcons,
						// 	caretPos.x+offsetPos.x,
						// 	caretPos.y+offsetPos.y
						// );
						
					}
					else {
						// is characters
						
						//if word won't fit on line, limit chars
						maxSize = maxCharsForWord(i,j);
						
						for (k = 0; k < maxSize; k++) {
							curChar = wordVec[i][j][k];
							if (isRendering) {
								
								uiCont.charVec.push_back(Singleton::UIQuad());
								curQuad = &(uiCont.charVec.back());
								curQuad->fontId = EFW_TEXT;
								curQuad->cs = &(curFont->charVals[ curChar ]);
								curQuad->hitBounds.xMin = caretPos.x+offsetPos.x;
								curQuad->hitBounds.yMin = caretPos.y+offsetPos.y;
								
								// renderCharAt(
								// 	&(curFont->charVals[ curChar ]),
								// 	curFont,
								// 	caretPos.x+offsetPos.x,
								// 	caretPos.y+offsetPos.y
								// );
							}
							caretPos.x += (curFont->charVals[ curChar ].consumedW*curFont->fontScale + spacing.x);
							//charCount++;
						}
					
					}
					
					//chars in word
					
					
					
					// render a space
					
					curChar = ' ';
					if (
						//(i == wordVec.size()-1) && 
						(j == wordVec[i].size()-1)
					) {
						//end of line, no space
					}
					else {
						if (caretPos.x + curFont->maxWidth*curFont->fontScale < spaceForCharsInPixels) {
							
							if (isRendering) {
								
								uiCont.charVec.push_back(Singleton::UIQuad());
								curQuad = &(uiCont.charVec.back());
								curQuad->fontId = EFW_TEXT;
								curQuad->cs = &(curFont->charVals[ curChar ]);
								curQuad->hitBounds.xMin = caretPos.x+offsetPos.x;
								curQuad->hitBounds.yMin = caretPos.y+offsetPos.y;
								
								// renderCharAt(
								// 	&(curFont->charVals[ curChar ]),
								// 	curFont,
								// 	caretPos.x+offsetPos.x,
								// 	caretPos.y+offsetPos.y
								// );
							}
							
							caretPos.x += (curFont->charVals[ curChar ].consumedW*curFont->fontScale + spacing.x);
							// /charCount++;
							
						} 
					}
					
				}
				
				

			}
			//charCount = 0;
			
			if (getDimensions) {
				linePitchVec.push_back(caretPos.x);
			}
			
			maxCaretPos = max(caretPos.x, maxCaretPos);
			caretPos.y += (curFont->fontHeight*curFont->fontScale + spacing.y);

		}

		if (getDimensions) {
			textDimInPixels.x = maxCaretPos - spacing.x;
			textDimInPixels.y = caretPos.y - spacing.y;
		}
		

	}
#undef LZZ_INLINE
 
// f00330_gamegui.h
//

#include "f00330_gamegui.e"
#define LZZ_INLINE inline
GameGUI::GameGUI ()
                  {
		
	}
void GameGUI::init (Singleton * _singleton)
                                         {

		singleton = _singleton;
		isReady = false;
		isLoaded = false;
	}
JSONValue * GameGUI::findNearestKey (JSONValue * jv, string key)
                                                             {
		int i;
		int numChildren = 0;
		int numFloatingChildren = 0;
		JSONValue* jvChildren = NULL;
		JSONValue* jvFloatingChildren = NULL;
		
		JSONValue* tempJV;
		
		if (jv->HasChild(key)) {
			return jv;
		}
		
		if (jv->HasChild("children")) {
			jvChildren = jv->Child("children");
			numChildren = jvChildren->CountChildren();
		}
		for (i = 0; i < numChildren; i++) {
			tempJV = findNearestKey(jvChildren->Child(i),key);
			
			if (tempJV != NULL) {
				return tempJV;
			}
		}
		
		
		if (jv->HasChild("floatingChildren")) {
			jvFloatingChildren = jv->Child("floatingChildren");
			numFloatingChildren = jvFloatingChildren->CountChildren();
		}
		for (i = 0; i < numFloatingChildren; i++) {
			tempJV = findNearestKey(jvFloatingChildren->Child(i),key);
			
			if (tempJV != NULL) {
				return tempJV;
			}
		}
		
		return NULL;
		
	}
void GameGUI::addChildFromJSON (int lastIndex, JSONValue * jv, int curParentId, bool isFloating)
          {
		int i;
		int j;
		int k;
		//int q;
		joi_type iterator;
		//int numEntries;
		int curIcon = 0;
		int objectId = 0;
		
		JSONValue* curTempl = NULL;
		JSONValue* tempJV = NULL;
		
		
		
	
		if (
			jv->HasChild("template")
		) {
			if (
				jvTemplates->HasChild(jv->Child("template")->string_value)
			) {
				
				curTempl = jvTemplates->Child(jv->Child("template")->string_value);
			}
			else {
				cout << "invalid template \n";
			}
		}
		
		
		for (i = 0; i < E_GST_LENGTH; i++) {
			guiStringValues[i] = "";
		}
		for (i = 0; i < E_GFT_LENGTH; i++) {
			guiFloatValues[i] = 0.0f;
		}
		
		guiFloatValues[E_GFT_HASBACKGROUND] = 1.0;
		guiFloatValues[E_GFT_SINGLELINE] = 1.0;
		guiStringValues[E_GST_SS] = "defaultSS";
		
		
		for (j = 0; j < 2; j++) {
			if (curTempl != NULL) {
				for (i = 0; i < E_GST_LENGTH; i++) {
					if (
						curTempl->HasChild(guiStringTypes[i])
					) {
						guiStringValues[i] = curTempl->Child(guiStringTypes[i])->string_value;
					}
				}
				for (i = 0; i < E_GFT_LENGTH; i++) {
					if (
						curTempl->HasChild(guiFloatTypes[i])
					) {
						guiFloatValues[i] = curTempl->Child(guiFloatTypes[i])->number_value;
					}
				}
			}
			curTempl = jv;
		}
		
		UIComponent* parentPtr = singleton->compStack[curParentId].data;
		
		guiFloatValues[E_GFT_LAYER] = max(
			guiFloatValues[E_GFT_LAYER],
			(double)(parentPtr->layer)
		);
		
		int newParent = parentPtr->addChild(
			lastIndex,
			parentPtr->nodeId,
			guiStringValues,
			guiFloatValues,
			isFloating,
			jv
		);
		
		
		
		
		int numChildren = 0;
		int numFloatingChildren = 0;
		int numDataChildren = 0;
		int numFilters = 0;
		int childType = 0;
		JSONValue* jvChildren = NULL;
		JSONValue* jvFloatingChildren = NULL;
		JSONValue* jvChildTemplate = NULL;
		JSONValue* jvFilter = NULL;
		JSONValue* curFilter = NULL;
		
		JSONValue* jvData = NULL;
		JSONValue* jvDataRoot = NULL;
		JSONValue* curData = NULL;
		
		//tempStrings[E_GDS_CHILD_TYPE] = "";
		
		
		
		
		
		
		
		
		////////////////
		
		
		
		bool doProc = false;
		//bool isInternal = false;
		int totCount = 0;
		int curCT = 0;
		
		
		if (jv->HasChild("childType")) {
			childType = stringToEnum(
				E_GUI_CHILD_TYPE_STRINGS,
				E_GCT_LENGTH,
				jv->Child("childType")->string_value
			);
			//tempStrings[E_GDS_CHILD_TYPE] = jv->Child("childType")->string_value;
			
			
			// if (jv->HasChild("isInternal")) {
			// 	if (jv->Child("isInternal")->number_value != 0 ) {
			// 		// use an internally generated JSON node
			// 		isInternal = true;
			// 	}
			// 	else {
			// 		// todo: load JSON file
			// 	}
			// }
			
			if (jv->HasChild("whereAllEqual")) {
				jvFilter = jv->Child("whereAllEqual");
				numFilters = jvFilter->CountChildren();
			}
			else {
				jvFilter = NULL;
				numFilters = 0;
			}
			
			
			if (jv->HasChild("dataSource")) {
				tempStrings[E_GDS_DATA_SOURCE] = jv->Child("dataSource")->string_value;
				
				// if (isInternal) {
				// 	if (jv->HasChild("dataFile")) {
				// 		tempStrings[E_GDS_DATA_FILE] = jv->Child("dataFile")->string_value;
				// 		jvDataRoot = (singleton->internalJSON[tempStrings[E_GDS_DATA_FILE]]).jv;
				// 	}
					
					
				// }
				// else {
					
					if (jv->HasChild("dataFile")) {
						tempStrings[E_GDS_DATA_FILE] = jv->Child("dataFile")->string_value;
						
						if ( jv->HasChild("dataParams") ) {
							jvDataRoot = singleton->fetchJSONData(tempStrings[E_GDS_DATA_FILE], false, jv->Child("dataParams"));
						}
						else {
							jvDataRoot = singleton->fetchJSONData(tempStrings[E_GDS_DATA_FILE], false, NULL);
						}
					}
					else {
						jvDataRoot = jvRoot;
					}
				//}
				
				if (jvDataRoot != NULL) {
					
					
					singleton->getJVNodeByString(jvDataRoot, &jvData, tempStrings[E_GDS_DATA_SOURCE]);
					
					numDataChildren = jvData->CountChildren();
					if (jv->HasChild("childTemplate")) {
						jvChildTemplate = jv->Child("childTemplate");
					}
				}
			}
			
			
			if ((jvData != NULL)&&(jvChildTemplate != NULL)) {
				
				curCT = childType;
				
				// if (compChildStr("E_GCT_INV_ITEM")) {
				// 	curCT = E_GCT_INV_ITEM;
				// }
				// else if (compChildStr("E_GCT_SHADER_PARAM")) {
				// 	curCT = E_GCT_SHADER_PARAM;
				// }
				// else if (compChildStr("E_GCT_GENERIC")) {
				// 	curCT = E_GCT_GENERIC;
				// }
				
				//////////////////////////////////////////////////////////////////////
				//////////////////////////////////////////////////////////////////////
				
				
				
				
				for (i = 0; i < numDataChildren; i++) {
					
					curData = jvData->Child(i);
					if (curData == NULL) {
						cout << "NULL DATA\n";
						tempStrings[E_GDS_LAST_KEY] = "";
					}
					else {
						tempStrings[E_GDS_LAST_KEY] = jvData->lastKey;
					}
					
					
					doProc = true;
					if (jvFilter != NULL) {
						
						
						for (j = 0; j < numFilters; j++) {
							curFilter = jvFilter->Child(j);
							
							if ( curData->Child(curFilter->Child(0)->string_value)->IsNumber() ) {
								if (
									curData->Child(curFilter->Child(0)->string_value)->number_value !=
									curFilter->Child(1)->number_value
								) {
									doProc = false;
								}
							}
							else {
								// todo: string support
							}
						}
						
						
					}
					
					if (doProc) {
						switch (curCT) {
							case E_GCT_INV_ITEM:
								tempStrings[E_GDS_CHILD_NAME] = curData->Child("name")->string_value;
								
								curIcon = singleton->gem->entIdToIcon[
									(int)(jvRoot->
									Child("itemDefs")->
									Child(tempStrings[E_GDS_CHILD_NAME])->
									Child("iconNum")->
									number_value)
								];
									
									
								
								jvChildTemplate->
									Child("floatingChildren")->
									Child(0)->
									Child("children")->
									Child(0)->
									Child("label")->
									string_value = 
										jvRoot->
										Child("itemDefs")->
										Child(tempStrings[E_GDS_CHILD_NAME])->
										Child("class")->
										string_value;
								
								tempStrings[E_GDS_MATERIAL] = curData->Child("mat")->string_value;
								if (tempStrings[E_GDS_MATERIAL].compare("none") == 0) {
									tempStrings[E_GDS_MATERIAL] = "";
								}
								
								jvChildTemplate->Child("label")->string_value = 
									i__s(curIcon) +
									"& " +
									tempStrings[E_GDS_MATERIAL] +
									" " +
									tempStrings[E_GDS_CHILD_NAME];
							break;
							case E_GCT_SHADER_PARAM:
									
								jvChildTemplate->Child("label")->string_value = 
									curData->Child("shaderName")->string_value +
									"." +
									curData->Child("paramName")->string_value;
								
								jvChildTemplate->Child("uid")->string_value = curData->Child("uid")->string_value;
									
								jvChildTemplate->Child("callbackData")->Child("shaderName")->string_value = 
									curData->Child("shaderName")->string_value;
								jvChildTemplate->Child("callbackData")->Child("paramName")->string_value = 
									curData->Child("paramName")->string_value;
									
							break;
							
							case E_GCT_GENERIC:
							
								singleton->splitStrings.clear();
								singleton->splitStrings = split(tempStrings[E_GDS_LAST_KEY], '_');
								
								if (jvChildTemplate->HasChild("label")) {
									
									switch(singleton->splitStrings.size()) {
										case 0:
										case 1:
											jvChildTemplate->Child("label")->string_value = tempStrings[E_GDS_LAST_KEY];
										break;
										case 2:
										case 3:
											jvChildTemplate->Child("label")->string_value = singleton->splitStrings[1];
										break;
									}
								}
								
								tempJV = findNearestKey(jvChildTemplate,"dataSource");
								if (tempJV != NULL) { // is a branch node
									tempJV->Child("dataSource")->string_value =
										tempStrings[E_GDS_DATA_SOURCE] + "." + tempStrings[E_GDS_LAST_KEY];										
								}
								else { // is a leaf node
									
									if (jvChildTemplate->HasChild("dataRef")) {
										jvChildTemplate->Child("dataRef")->string_value =
											tempStrings[E_GDS_DATA_SOURCE] + "." + tempStrings[E_GDS_LAST_KEY];
									}
									if (jvChildTemplate->HasChild("dataFile")) {
										jvChildTemplate->Child("dataFile")->string_value =
											tempStrings[E_GDS_DATA_FILE];
									}
								}
								
								
								
							break;
							
							case E_GCT_CONTAINER:
							
								// curIcon = singleton->gem->entIdToIcon[
								// 	(int)(curData->Child("objectType")->number_value)
								// ];
								objectId = curData->Child("objectId")->number_value;
								jvChildTemplate->Child("objectId")->number_value = objectId;
								jvChildTemplate->Child("label")->string_value = singleton->gem->getStringForObjectId(objectId);
							break;
							
							case E_GCT_CONTAINER_PARENT:
								
								
								tempJV = findNearestKey(jvChildTemplate,"objectId");
								if (tempJV != NULL) {
									tempJV->Child("objectId")->number_value = curData->Child("objectId")->number_value;
								}
								
								tempJV = findNearestKey(jvChildTemplate,"dataSource");
								if (tempJV != NULL) {
									tempJV->Child("dataSource")->string_value = "objects." + i__s(totCount) + ".children";								
								}
							break;
							
							case E_GCT_AUTOMATIC:
								//numEntries = curData->CountChildren();
								// for (q = 0; q < numEntries; q++) {
								// 	jvChildTemplate->Child("label")->string_value = singleton->gem->getStringForObjectId(objectId);
								// }
								
								for (
									iterator = curData->object_value.begin();
									iterator != curData->object_value.end();
									iterator++
								) {
									// iterator->first = key
									// iterator->second = value
									
									// if (jvChildTemplate->HasChild(iterator->first)) {
									// 	// todo: report error if key does not exist?
									// }
									
									if (iterator->second->IsNumber()) {
										jvChildTemplate->Child(iterator->first)->number_value = iterator->second->number_value;
									}
									else {
										// todo: support additional JSON types
										jvChildTemplate->Child(iterator->first)->string_value = iterator->second->string_value;
									}
									
									
								}
								
								
								
							break;
							default:
								cout << "Error: unexpected GTC type\n";
							break;
						}
						
						
						
						
						
						// copy template to new child
						jv->Child("children")->array_value.push_back(
							JSON::Parse(jvChildTemplate->Stringify().c_str())
						);
						
						
						
						totCount++;
						
						
					}
					
					
				
				}
			}
			
		}
		
		
		
		
		////////////////
		
		
		
		
		
		
		
		
		
		
		if (jv->HasChild("children")) {
			jvChildren = jv->Child("children");
			numChildren = jvChildren->CountChildren();
		}
		for (i = 0; i < numChildren; i++) {
			addChildFromJSON(-1,jvChildren->Child(i),newParent, false);
		}
		
		
		if (jv->HasChild("floatingChildren")) {
			jvFloatingChildren = jv->Child("floatingChildren");
			numFloatingChildren = jvFloatingChildren->CountChildren();
		}
		for (i = 0; i < numFloatingChildren; i++) {
			addChildFromJSON(-1,jvFloatingChildren->Child(i),newParent,true);
		}
		
	}
void GameGUI::deleteJSONNodes (JSONValue * jv)
                                            {
		JSONValue* jvChildren = NULL;
		JSONValue* jvFloatingChildren = NULL;
		
		int numChildren = 0;
		int numFloatingChildren = 0;
		
		int i;
		
		
		
		
		
		
		if (jv->HasChild("floatingChildren")) {
			jvFloatingChildren = jv->Child("floatingChildren");
			numFloatingChildren = jvFloatingChildren->CountChildren();
		}
		for (i = 0; i < numFloatingChildren; i++) {
			deleteJSONNodes(jvFloatingChildren->Child(i));
		}
		
		if (jv->HasChild("children")) {
			jvChildren = jv->Child("children");
			numChildren = jvChildren->CountChildren();
		}
		for (i = 0; i < numChildren; i++) {
			deleteJSONNodes(jvChildren->Child(i));
		}
		
		if (jv->HasChild("dataSource")) {
				jvChildren->array_value.clear();
		}
		
		
	}
void GameGUI::clearRenderOrder ()
                                {
		int i;
		for (i = 0; i < singleton->compStack.size(); i++) {
			singleton->compStack[i].data->layerId = -1;
		}
		
		for (i = 0; i < MAX_UI_LAYERS; i++) {
			singleton->guiLayers[i].clear();
		}
		
	}
void GameGUI::deleteNodes (UIComponent * curNode)
                                               {
		int i;
		int curNodeId;
		
		for (i = 0; i < curNode->getChildCount(); i++) {
			deleteNodes(curNode->getChild(i));
		}
		
		for (i = 0; i < curNode->getFloatingChildCount(); i++) {
			deleteNodes(curNode->getFloatingChild(i));
		}
		
		curNodeId = curNode->nodeId;
		
		
		singleton->compMap[curNode->uid].nodeId = -1;
		
		// if (curNode->layerId != -1) {
		// 	singleton->guiLayers[curNode->layer][curNode->layerId] = -1;
		// 	singleton->emptyLayers[curNode->layer].push_back(curNode->layerId);
		// }
		
		//delete (singleton->compStack[curNodeId].data);
		//singleton->compStack[curNodeId].data = NULL;
		singleton->compStack[curNodeId].isValid = false;
		singleton->emptyStack.push_back(curNodeId);
		
		curNode->clearChildren();
		
	}
void GameGUI::refreshNode (UIComponent * oldNode)
                                               {
		
		if (oldNode == NULL) {
			cout << "refreshNode is NULL\n";
		}
		
		isReady = false;
		isLoaded = false;
		
		//TEMP_DEBUG = true;
		
		
		// TODO: there is a problem with this - templated data must be cleared
		JSONValue* oldJV = oldNode->jvNodeNoTemplate;
		
		int curParentId = oldNode->parentId;
		int lastIndex = oldNode->index;
		//oldNode->getParent()->getParent()->isDirty = true;
		singleton->compStack[0].data->isDirty = true;
		
		
		deleteNodes(oldNode);
		
		
		deleteJSONNodes(oldJV);
		
		
		addChildFromJSON(
			lastIndex,
			oldJV,
			curParentId,
			false
		);
		
		clearRenderOrder();
		
		
		TEMP_DEBUG = false;
		
		
		testOver(singleton->guiX,singleton->guiY);
		doRefresh();
		testOver(singleton->guiX,singleton->guiY);
		doRefresh();
		singleton->compStack[0].data->updateSS();
		
		
		isReady = true;
		isLoaded = true;
		
		
	}
void GameGUI::guiFromJSON (JSONValue * jv)
                                        {
		
		int i;
		
		isLoaded = false;
		isReady = false;
		
		guiRenderCount = 0;
		
		
		for (i = 0 ; i < singleton->compStack.size(); i++) {
				if (singleton->compStack[i].data == NULL) {
					
				}
				else {
					delete (singleton->compStack[i].data);
					singleton->compStack[i].data = NULL;
					singleton->compStack[i].isValid = false;
				}
				
		}
		
		singleton->compStack.clear();
		singleton->emptyStack.clear();
		for (i = 0; i < MAX_UI_LAYERS; i++) {
			singleton->guiLayers[i].clear();
			//singleton->emptyLayers[i].clear();
		}
		
		
		singleton->compStack.push_back(Singleton::CompStruct());
		singleton->compStack[0].data = new UIComponent;
		
		for (i = 0; i < E_GST_LENGTH; i++) {
			stringVals[i] = "";
		}
		for (i = 0; i < E_GFT_LENGTH; i++) {
			floatVals[i] = 0.0f;
		}
		
		stringVals[E_GST_LABEL] = "";
		stringVals[E_GST_UID] = "";
		stringVals[E_GST_SS] = "defaultSS";
		
		floatVals[E_GFT_TYPE] = E_GT_HOLDER;
		floatVals[E_GFT_DIVISIONS] = 0.0f;
		floatVals[E_GFT_HASBACKGROUND] = 0.0f;
		floatVals[E_GFT_SINGLELINE] = 1.0f;
		floatVals[E_GFT_FILLRATIOX] = 0.0f;
		floatVals[E_GFT_FILLRATIOY] = 0.0f;
		floatVals[E_GFT_FILLDIR] = E_FILL_HORIZONTAL;
		floatVals[E_GFT_ALIGNX] = E_ALIGNH_LEFT;
		floatVals[E_GFT_ALIGNY] = E_ALIGNV_TOP;
		floatVals[E_GFT_VALUE] = 0.0f;
		floatVals[E_GFT_LAYER] = 0.0f;
		floatVals[E_GFT_HOVERTYPE] = E_HT_NORMAL;
		floatVals[E_GFT_MAXDIMX] = 0.0f;
		floatVals[E_GFT_MAXDIMY] = 0.0f;
		floatVals[E_GFT_MINDIMX] = 0.0f;
		floatVals[E_GFT_MINDIMY] = 0.0f;
		floatVals[E_GFT_FLAGS] = 0.0f;
		
		singleton->compStack[0].data->init(
			singleton,
			-1,
			0,
			0,
			
			NULL,
			false,
			
			stringVals,
			floatVals
		);
		
		// singleton->nullComp->init(
		// 	singleton,
		// 	-1,
		// 	0,
		// 	0,
			
		// 	NULL,
		// 	false,
			
		// 	stringVals,
		// 	floatVals
		// );
		
		
		
		singleton->compStack[0].data->resultDimInPixels.x = singleton->guiWinW;
		singleton->compStack[0].data->resultDimInPixels.y = singleton->guiWinH;
		
		
		
		
		
		
		
		///////
		
		
		
		jvRoot = jv;
		jvTemplates = jv->Child("templates");
		jvSounds = jv->Child("sounds");
		
		
		addChildFromJSON(
			-1,
			jv->Child("baseGUI"),  //jv->Child("curMenu")->string_value
			0,
			false
		);
		
		singleton->compStack[0].data->isDirty = true;
		isReady = true;
		isLoaded = true;
	}
void GameGUI::doRefresh ()
                         {
		
		int i;
		
		singleton->guiDirty = false;
		dirtyVec.clear();
		singleton->compStack[0].data->gatherDirty(&dirtyVec);
		singleton->compStack[0].data->clearDirty();
		
		for (i = 0; i < dirtyVec.size(); i++) {
			dirtyVec[i]->layout();
		}
		
		singleton->compStack[0].data->renderAll();
		
		
	}
void GameGUI::testOver (int x, int y)
                                    {
		singleton->maxLayerOver = -1;
		
		int i;
		
		mouseTrans.x = x;
		mouseTrans.y = y;
		mouseTrans.x /= singleton->guiWinW;
		mouseTrans.y /= singleton->guiWinH;
		mouseTrans.x = ((1.0f-mouseTrans.x) - 0.5f)*2.0f;
		mouseTrans.y = ((1.0f-mouseTrans.y) - 0.5f)*2.0f;		
		
		for (i = 0; i < singleton->compStack.size(); i++) {
			singleton->compStack[i].data->overSelf = false;
		}
		//singleton->compStack[0].data->clearOver();
		singleton->compStack[0].data->findMaxLayer(x, y, mouseTrans.x, mouseTrans.y);
		singleton->compStack[0].data->testOver(x, y);
	}
bool GameGUI::testHit (int button, int state, int x, int y)
                                                          {
		return singleton->compStack[0].data->testHit(button, state, x, y);
	}
UIComponent * GameGUI::findNodeByString (string _uid)
                                                   {
		return singleton->compStack[0].data->findNodeByString(_uid);
	}
void GameGUI::renderCharAt (UIComponent * uiComp, CharStruct * cs, FontWrapper * activeFont, float px, float py, float shadowOffset)
          {
		
		StyleSheetResult* resSS = &(uiComp->resSS);
		
		float sampX = cs->sampX;
		float sampY = cs->sampY;
		float sampW = cs->sampW;
		float sampH = cs->sampH;
		float offsetX = (cs->offsetX)*activeFont->fontScale;
		float offsetY = ((activeFont->fontHeight - cs->offsetY) + activeFont->descender)*activeFont->fontScale;
		float sourceW = activeFont->fontImage->width;
		float sourceH = activeFont->fontImage->height;
		
		fBoundingBox destPos;
		fBoundingBox srcPos;
		
		

		destPos.xMin = (px+offsetX)+uiComp->totOffset.x;
		destPos.yMin = (py+offsetY)+uiComp->totOffset.y+shadowOffset;
		destPos.xMax = (px+offsetX+sampW*activeFont->fontScale)+uiComp->totOffset.x;
		destPos.yMax = (py+offsetY+sampH*activeFont->fontScale)+uiComp->totOffset.y+shadowOffset;
		
		srcPos.xMin = (sampX)/sourceW;
		srcPos.yMin = (sourceH-(sampY+sampH))/sourceH;
		srcPos.xMax = (sampX+sampW)/sourceW;
		srcPos.yMax = ( sourceH-sampY )/sourceH;
		
		

		float x0 = destPos.xMin/singleton->guiWinW;
		float x1 = destPos.xMax/singleton->guiWinW;
		float y0 = destPos.yMin/singleton->guiWinH;
		float y1 = destPos.yMax/singleton->guiWinH;

		x0 = (x0-0.5f)*2.0f;
		x1 = (x1-0.5f)*2.0f;
		y0 = ((1.0f-y0) - 0.5f)*2.0f;
		y1 = ((1.0f-y1) - 0.5f)*2.0f;

		float iconVal = 0.0;
		if (activeFont->isIcons) {
			iconVal = 1.0f;
		}
		
		
		
		
		//dimensions
		glMultiTexCoord4f(1, sampW, sampH, 0.0f, 0.0f);

		glMultiTexCoord4f(4, 1.0f, 1.0f, 1.0f, 1.0f);
		glMultiTexCoord4f(5, iconVal, shadowOffset, uiComp->scrollMaskY.x, uiComp->scrollMaskY.y);
		//border color
		glMultiTexCoord4f(6, 1.0f, 1.0f, 1.0f, 1.0f);
		//misc
		glMultiTexCoord4f(7, 0.0f, 0.0f, 0.0f, 0.0f);
		

		glMultiTexCoord4f(2, resSS->props[E_SS_BGCOLTEXT1_R], resSS->props[E_SS_BGCOLTEXT1_G], resSS->props[E_SS_BGCOLTEXT1_B], resSS->props[E_SS_BGCOLTEXT1_A]);
		glMultiTexCoord4f(3, resSS->props[E_SS_FGCOLTEXT1_R], resSS->props[E_SS_FGCOLTEXT1_G], resSS->props[E_SS_FGCOLTEXT1_B], resSS->props[E_SS_FGCOLTEXT1_A]);
		
		
		glMultiTexCoord4f(0, srcPos.xMin, srcPos.yMin, 0.0f, 1.0f);
		glVertex3f (  x0, y1, -1.0f );
		glMultiTexCoord4f(0, srcPos.xMax, srcPos.yMin, 1.0f, 1.0f);
		glVertex3f (  x1, y1, -1.0f );

		glMultiTexCoord4f(2, resSS->props[E_SS_BGCOLTEXT0_R], resSS->props[E_SS_BGCOLTEXT0_G], resSS->props[E_SS_BGCOLTEXT0_B], resSS->props[E_SS_BGCOLTEXT0_A]);
		glMultiTexCoord4f(3, resSS->props[E_SS_FGCOLTEXT0_R], resSS->props[E_SS_FGCOLTEXT0_G], resSS->props[E_SS_FGCOLTEXT0_B], resSS->props[E_SS_FGCOLTEXT0_A]);		

		glMultiTexCoord4f(0, srcPos.xMax, srcPos.yMax, 1.0f, 0.0f);
		glVertex3f (  x1, y0, -1.0f );
		glMultiTexCoord4f(0, srcPos.xMin, srcPos.yMax, 0.0f, 0.0f);
		glVertex3f (  x0, y0, -1.0f );

	}
void GameGUI::renderQuad (UIComponent * uiComp, fBoundingBox fbb, float shadowOffset)
          {

		StyleSheetResult* resSS = &(uiComp->resSS);
		
		float fMatCode = uiComp->matCode;
		bool isHSL = uiComp->matCode == E_MC_HSV;
		
		
		float selMod = 0.0f;
		float selMod2 = 1.0f;
		
		
		
		float x0 = (fbb.xMin+uiComp->totOffset.x)/singleton->guiWinW;
		float x1 = (fbb.xMax+uiComp->totOffset.x)/singleton->guiWinW;
		float y0 = (fbb.yMin+uiComp->totOffset.y+shadowOffset)/singleton->guiWinH;
		float y1 = (fbb.yMax+uiComp->totOffset.y+shadowOffset)/singleton->guiWinH;

		x0 = (x0-0.5f)*2.0f;
		x1 = (x1-0.5f)*2.0f;
		y0 = ((1.0f-y0) - 0.5f)*2.0f;
		y1 = ((1.0f-y1) - 0.5f)*2.0f;

		
		//dimensions
		glMultiTexCoord4f(1, fbb.xMax-fbb.xMin, fbb.yMax-fbb.yMin, resSS->props[E_SS_BORDER], resSS->props[E_SS_CORNERRAD]);

		glMultiTexCoord4f(5, 0.0f, shadowOffset, uiComp->scrollMaskY.x, uiComp->scrollMaskY.y);
		
		
		// todo: fix this to use style sheet
		if (uiComp->selected) {
			selMod = 0.5f;
			selMod2 = 0.5f;
		}
		
		//border color
		glMultiTexCoord4f(
			6,
			resSS->props[E_SS_BDCOL_R]*selMod2 + selMod,
			resSS->props[E_SS_BDCOL_G]*selMod2 + selMod,
			resSS->props[E_SS_BDCOL_B]*selMod2,
			resSS->props[E_SS_BDCOL_A]*selMod2 + selMod
		);
		
		
		
		//misc
		glMultiTexCoord4f(7, uiComp->getValue(), uiComp->getValueY(), resSS->props[E_SS_ROUNDNESS],  fMatCode);

		if ( isHSL ) { // bg with hsv
			
			glMultiTexCoord4f(
				2,
				mixf(uiComp->getValueIndexPtr(0),-1.0f,uiComp->valVecMask[0]),
				mixf(uiComp->getValueIndexPtr(1),-1.0f,uiComp->valVecMask[1]),
				mixf(uiComp->getValueIndexPtr(2),-1.0f,uiComp->valVecMask[2]),
				1.0f
			);
			
			
		}

		if ( !isHSL ) {
			//bg
			glMultiTexCoord4f(2, resSS->props[E_SS_BGCOL1_R], resSS->props[E_SS_BGCOL1_G], resSS->props[E_SS_BGCOL1_B], resSS->props[E_SS_BGCOL1_A]);
		}
		//fg
		glMultiTexCoord4f(3, resSS->props[E_SS_FGCOL1_R], resSS->props[E_SS_FGCOL1_G], resSS->props[E_SS_FGCOL1_B], resSS->props[E_SS_FGCOL1_A]);
		//tg
		glMultiTexCoord4f(4, resSS->props[E_SS_TGCOL1_R], resSS->props[E_SS_TGCOL1_G], resSS->props[E_SS_TGCOL1_B], resSS->props[E_SS_TGCOL1_A]);
		
		
		
		
		glMultiTexCoord4f(0, 0.0f, 0.0f, 0.0f, 1.0f);
		glVertex3f (  x0, y1, -1.0f );
		glMultiTexCoord4f(0, 0.0f, 0.0f, 1.0f, 1.0f);
		glVertex3f (  x1, y1, -1.0f );

		if ( !isHSL ) {
			//bg
			glMultiTexCoord4f(2, resSS->props[E_SS_BGCOL0_R], resSS->props[E_SS_BGCOL0_G], resSS->props[E_SS_BGCOL0_B], resSS->props[E_SS_BGCOL0_A]);
		}
		//fg
		glMultiTexCoord4f(3, resSS->props[E_SS_FGCOL0_R], resSS->props[E_SS_FGCOL0_G], resSS->props[E_SS_FGCOL0_B], resSS->props[E_SS_FGCOL0_A]);
		//tg
		glMultiTexCoord4f(4, resSS->props[E_SS_TGCOL0_R], resSS->props[E_SS_TGCOL0_G], resSS->props[E_SS_TGCOL0_B], resSS->props[E_SS_TGCOL0_A]);

		glMultiTexCoord4f(0, 0.0f, 0.0f, 1.0f, 0.0f);
		glVertex3f (  x1, y0, -1.0f );
		glMultiTexCoord4f(0, 0.0f, 0.0f, 0.0f, 0.0f);
		glVertex3f (  x0, y0, -1.0f );


	}
void GameGUI::renderQuadDirect (UIComponent * uiComp)
          {
		
		if (uiComp == NULL) {
			return;
		}
		if (uiComp->visible && uiComp->enabled) {
			
		}
		else {
			return;
		}
		
		
		
		float x0 = (uiComp->hitBounds.xMin + uiComp->totOffset.x)/singleton->guiWinW;
		float x1 = (uiComp->hitBounds.xMax + uiComp->totOffset.x)/singleton->guiWinW;
		float y0 = (uiComp->hitBounds.yMin + uiComp->totOffset.y)/singleton->guiWinH;
		float y1 = (uiComp->hitBounds.yMax + uiComp->totOffset.y)/singleton->guiWinH;

		x0 = (x0-0.5f)*2.0f;
		x1 = (x1-0.5f)*2.0f;
		y0 = ((1.0f-y0) - 0.5f)*2.0f;
		y1 = ((1.0f-y1) - 0.5f)*2.0f;

		// glBegin(GL_QUADS);

		// glTexCoord2f(0.0f, 1.0f);
		// glVertex3f (  x0, y1, -1.0f );
		// glTexCoord2f(1.0f, 1.0f);
		// glVertex3f (  x1, y1, -1.0f );
		// glTexCoord2f(1.0f, 0.0f);
		// glVertex3f (  x1, y0, -1.0f );
		// glTexCoord2f(0.0f, 0.0f);
		// glVertex3f (  x0, y0, -1.0f );

		// glEnd();
		
		singleton->setShaderVec4("blitCoords", x0,y0,x1,y1 );
		singleton->fsQuad.draw();

	}
void GameGUI::runReport ()
                         {
		singleton->compStack[0].data->runReport();
	}
void GameGUI::renderGUI ()
                         {
		
		
		int i;
		
		int j;
		int k;
		int m;
		int n;
		
		int maxLoop = 0;
		float shadowOffset = 0.0;
		Singleton::UICont* curCont = NULL;
		UIComponent* curComp = NULL;
		
		
		
		testOver(singleton->guiX,singleton->guiY);
		doRefresh();
		singleton->compStack[0].data->updateSS();
		
		guiRenderCount++;
		
		if (guiRenderCount < 5) {
			return;
		}
		
		for (i = 0; i < 2; i++) {
			
			
			if (i == 0) {
				maxLoop = 1;
			}
			else {
				maxLoop = 2;
			}
			
			singleton->setShaderFloat("passNum", i);
			singleton->setShaderVec2("resolution", singleton->currentFBOResolutionX, singleton->currentFBOResolutionY);
			
			glBegin (GL_QUADS);
			
				for (j = 0; j < MAX_UI_LAYERS; j++) {
					for (k = 0; k < singleton->guiLayers[j].size(); k++) {
						
						
						
						if (singleton->guiLayers[j][k] >= 0) {
							
							curComp = singleton->compStack[ singleton->guiLayers[j][k] ].data;
							curCont = &(curComp->uiCont);
							
							if (curComp->visible  && curComp->enabled && (curComp->layerId >= 0)) {
								
								for (m = 0; m < maxLoop; m++) {
									
									shadowOffset = ((1-m)*i)*2.0f;
									
									
									// only shadow text
									if (shadowOffset == 0.0f) {
										
										
										if (curCont->bg.fontId > -1) {
											renderQuad(
												curComp,
												curCont->bg.hitBounds,
												shadowOffset
											);
										}
										
										
									}
									
									if (i == 0) {
										// don't render text in first pass
									}
									else {
									
										if (false) { //curCont->locked) {
											// busy updating characters
										}
										else {
											for (n = 0; n < curCont->charVec.size(); n++) {
												renderCharAt(
													curComp,
													curCont->charVec[n].cs,
													singleton->fontWrappers[curCont->charVec[n].fontId],
													curCont->charVec[n].hitBounds.xMin,
													curCont->charVec[n].hitBounds.yMin,
													shadowOffset
												);
											}
										}
									}
								}
							}
							
							
							
							
						}
						
						
						
					}
				}
			
			glEnd ();
		}
		
		
		
		
	}
#undef LZZ_INLINE
 
// f00332_gamenetwork.h
//

#include "f00332_gamenetwork.e"
#define LZZ_INLINE inline
int const GameNetwork::FRAME_SIZE_IN_BYTES;
int const GameNetwork::TOT_BUFFER_SIZE;
GameNetwork::GameNetwork ()
                      {
		
	}
void GameNetwork::init (Singleton * _singleton)
                                         {
		singleton = _singleton;
		ConnectSocket = INVALID_SOCKET;
		isConnected = false;
		
		recvPosInBytes = 0;
		sendPosInBytes = 0;
		
		recvConsumedInBytes = 0;
		sendConsumedInBytes = 0;
		
	}
void GameNetwork::getIntFloatLen (int opCode, int * uintLen, int * intLen, int * floatLen)
                                                                                  {
		
		*uintLen = 0;
		*intLen = 0;
		*floatLen = 0;
		
		
		switch (opCode) {
			case E_NO_TERMINAL:
				
			break;
			case E_NO_KEY_ACTION:
				*uintLen = 1;
				*intLen = 1;
				*floatLen = 2;
			break;
			case E_NO_ADD_ENT:
				*intLen = 1;
				*floatLen = 3;
			break;
			case E_NO_REM_ENT:
				*intLen = 1;
			break;
			case E_NO_DRAG_ENT:
				*intLen = 4;
				*floatLen = 3;
			break;
			default:
				cout << "Unsupported net operation\n";
			break;
			
		}
	}
void GameNetwork::addNetworkAction (int opCode, uint * naUintData, int * naIntData, float * naFloatData)
          {
		char* curDataPtr;
		
		int i;
		int pos;
		
		int uintLen = 0;
		int intLen = 0;
		int floatLen = 0;
		getIntFloatLen(opCode, &uintLen, &intLen, &floatLen);
		
		if (!isConnected) {
			return;
		}
		
		netSendStack.push_back(NetworkAction());
		curDataPtr = &(netSendStack.back().data[0]);
		
		curDataPtr[0] = opCode;
		
		pos = 4;
		
		for (i = 0; i < uintLen; i++) {
			uintPtr[i] = toUintPtr(&(curDataPtr[pos])); pos += 4;
			*(uintPtr[i]) = naUintData[i];
		}
		for (i = 0; i < intLen; i++) {
			intPtr[i] = toIntPtr(&(curDataPtr[pos])); pos += 4;
			*(intPtr[i]) = naIntData[i];
		}
		for (i = 0; i < floatLen; i++) {
			floatPtr[i] = toFloatPtr(&(curDataPtr[pos])); pos += 4;
			*(floatPtr[i]) = naFloatData[i];
		}
		
		
	}
void GameNetwork::addNetworkActionForSend (NetworkAction * na)
          {
		char* curDataPtr;
		int i;
		
		curDataPtr = &(sendbuf[sendPosInBytes]);
		
		for (i = 0; i < NA_SIZE_IN_BYTES; i++) {
			curDataPtr[i] = na->data[i];
		}
		
		sendPosInBytes += NA_SIZE_IN_BYTES;
		
	}
void GameNetwork::applyNetworkActions ()
                                   {
		
		
		int i;
		int pos;
		int opCode;
		char* curDataPtr;
		
		while ( (recvPosInBytes - recvConsumedInBytes) >= NA_SIZE_IN_BYTES) {
			
			
			curDataPtr = &(recvbuf[recvConsumedInBytes]);
			
			pos = 4;
			
			opCode = curDataPtr[0];
			
			int intLen = 0;
			int floatLen = 0;
			int uintLen = 0;
			getIntFloatLen(opCode, &uintLen, &intLen, &floatLen);
			
			for (i = 0; i < uintLen; i++) {
				uintPtr[i] = toUintPtr(&(curDataPtr[pos])); pos += 4;
			}
			for (i = 0; i < intLen; i++) {
				intPtr[i] = toIntPtr(&(curDataPtr[pos])); pos += 4;
			}
			for (i = 0; i < floatLen; i++) {
				floatPtr[i] = toFloatPtr(&(curDataPtr[pos])); pos += 4;
				
				if (i < 4) {
					tempVecs[0].setIndex(i,*(floatPtr[i]));
				}
				else {
					tempVecs[1].setIndex(i-4,*(floatPtr[i]));
				}
			}
			
			switch(opCode) {
				case E_NO_TERMINAL:
					
				break;
				case E_NO_KEY_ACTION:
					singleton->applyKeyAction(
						false,
						*(intPtr[0]),
						*(uintPtr[0]),
						*(floatPtr[0]),
						*(floatPtr[1])
					);
				break;
				case E_NO_ADD_ENT:
					singleton->gem->placeNewEnt(false, *(intPtr[0]), &(tempVecs[0]));
				break;
				case E_NO_REM_ENT:
					singleton->gem->removeEntity(false,*(intPtr[0]));
				break;
				case E_NO_DRAG_ENT:
					singleton->gem->performDrag(
						false,
						*(intPtr[0]),
						*(intPtr[1]),
						*(intPtr[2]),
						*(intPtr[3]),
						&(tempVecs[0])
					);
				break;
				
			}
			
			
			recvConsumedInBytes += NA_SIZE_IN_BYTES;
			
		}
		
	}
int GameNetwork::socketConnect (bool doConnect)
                                          {
		int iResult;
		
		struct addrinfo *result = NULL,
		                *ptr = NULL,
		                hints;
		
		if (doConnect) {
			// Initialize Winsock
			iResult = WSAStartup(MAKEWORD(2,2), &wsaData);
			if (iResult != 0) {
			    printf("WSAStartup failed with error: %d\n", iResult);
			    return 1;
			}

			ZeroMemory( &hints, sizeof(hints) );
			hints.ai_family = AF_UNSPEC;
			hints.ai_socktype = SOCK_STREAM;
			hints.ai_protocol = IPPROTO_TCP;

			// Resolve the server address and port
			iResult = getaddrinfo("192.168.1.107", DEFAULT_PORT, &hints, &result); //argv[1] //localhost
			if ( iResult != 0 ) {
			    printf("getaddrinfo failed with error: %d\n", iResult);
			    WSACleanup();
			    return 1;
			}

			// Attempt to connect to an address until one succeeds
			for(ptr=result; ptr != NULL ;ptr=ptr->ai_next) {

			    // Create a SOCKET for connecting to server
			    ConnectSocket = socket(ptr->ai_family, ptr->ai_socktype, 
			        ptr->ai_protocol);
			    if (ConnectSocket == INVALID_SOCKET) {
			        printf("socket failed with error: %ld\n", WSAGetLastError());
			        WSACleanup();
			        return 1;
			    }

			    // Connect to server.
			    iResult = connect( ConnectSocket, ptr->ai_addr, (int)ptr->ai_addrlen);
			    if (iResult == SOCKET_ERROR) {
			        closesocket(ConnectSocket);
			        ConnectSocket = INVALID_SOCKET;
			        continue;
			    }
			    break;
			}

			freeaddrinfo(result);

			if (ConnectSocket == INVALID_SOCKET) {
			    printf("Unable to connect to server!\n");
			    WSACleanup();
			    return 1;
			}
			
			isConnected = true;
			
		}
		else {
			// shutdown the connection since no more data will be sent
			iResult = shutdown(ConnectSocket, SD_SEND);
			if (iResult == SOCKET_ERROR) {
			    printf("shutdown failed with error: %d\n", WSAGetLastError());
			    closesocket(ConnectSocket);
			    WSACleanup();
			    return 1;
			}

			
			

			// cleanup
			closesocket(ConnectSocket);
			WSACleanup();
			
			isConnected = false;
		}
		
		
		

		return 0;
		
	}
void GameNetwork::socketRecv ()
                          {
		
		int iResult;
		
		iResult = recv(
			ConnectSocket, 
			&(recvbuf[recvPosInBytes]), 
			FRAME_SIZE_IN_BYTES, 
			0
		);
		if ( iResult > 0 ) {
			recvPosInBytes += iResult;
			//printf("Bytes received: %d\n", iResult);
		}
		else if ( iResult == 0 ) {
			printf("Connection closed\n");
		}
		else {
			printf("recv failed with error: %d\n", WSAGetLastError());
		}
	}
void GameNetwork::socketSend ()
                          {//char* bufToSend, int totSize) {
		//sendbuf, sendPosInBytes - sendConsumedInBytes
	
		int iResult;
		
		//cout << "Sending...\n";
		
		// Send an initial buffer
		iResult = send(
			ConnectSocket,
			&(sendbuf[sendConsumedInBytes]),
			sendPosInBytes - sendConsumedInBytes,
			0
		);
		
		if (iResult >= 0) {
			sendConsumedInBytes += 
				sendPosInBytes - sendConsumedInBytes;
				//iResult;
		}
		
		if (iResult == SOCKET_ERROR) {
		    printf("send failed with error: %d\n", WSAGetLastError());
		    closesocket(ConnectSocket);
		    WSACleanup();
		}

		//printf("Bytes Sent: %ld\n", iResult);
		
		
	}
void GameNetwork::checkBufferLengthSend ()
                                     {
		
		int roundedPos;
		int basePos;
		int i;
		
		if (sendConsumedInBytes > (TOT_BUFFER_SIZE/2)) {
			roundedPos = (sendConsumedInBytes/NA_SIZE_IN_BYTES)*NA_SIZE_IN_BYTES-NA_SIZE_IN_BYTES;
			
			basePos = sendConsumedInBytes-roundedPos;
			
			for (i = 0; i <= (sendPosInBytes - sendConsumedInBytes); i++) {
				sendbuf[basePos + i] = sendbuf[sendConsumedInBytes+i];
			}
			
			sendConsumedInBytes -= roundedPos;
			sendPosInBytes -= roundedPos;
		}
		
	}
void GameNetwork::checkBufferLengthRecv ()
                                     {
		
		int roundedPos;
		int basePos;
		int i;
		
		
		if (recvConsumedInBytes > (TOT_BUFFER_SIZE/2)) {
			roundedPos = (recvConsumedInBytes/NA_SIZE_IN_BYTES)*NA_SIZE_IN_BYTES-NA_SIZE_IN_BYTES;
			
			basePos = recvConsumedInBytes-roundedPos;
			
			for (i = 0; i <= (recvPosInBytes - recvConsumedInBytes); i++) {
				recvbuf[basePos + i] = recvbuf[recvConsumedInBytes+i];
			}
			
			recvConsumedInBytes -= roundedPos;
			recvPosInBytes -= roundedPos;
		}
		
	}
void GameNetwork::flushNetworkActions ()
                                   {
		
		int i;
		
		// if nothing to send, add in an empty action
		if (
			((sendPosInBytes - sendConsumedInBytes) == 0) &&
			(netSendStack.size() == 0)
		) {
			addNetworkAction(E_NO_TERMINAL, NULL, NULL, NULL);	
		}
		
		//cout << "netSendStack.size() " << netSendStack.size() << "\n";
		
		for (i = 0; i < netSendStack.size(); i++) {
			addNetworkActionForSend(&(netSendStack[i]));
		}
		
		netSendStack.clear();
	}
void GameNetwork::updateSend ()
                          {
		checkBufferLengthSend();
		socketSend();
	}
void GameNetwork::updateRecv ()
                          {
		checkBufferLengthRecv();
		socketRecv();
	}
#undef LZZ_INLINE
 
// f00335_gameai.h
//

#include "f00335_gameai.e"
#define LZZ_INLINE inline
GameAI::GameAI ()
                 {
		kbCompiled = NULL;
		qbCompiled = NULL;
		jvKB = NULL;
	}
void GameAI::init (Singleton * _singleton)
                                         {
		singleton = _singleton;
	}
string GameAI::getResolvedString (VNode * tempNode)
                                                  {
		// if (tokenIndexToVar[tempNode->tokenIndex] == NULL) {
		// 	return intToVToken[tempNode->tokenIndex].stringValue;
		// }
		// else {
		// 	return intToVToken[tokenIndexToVar[tempNode->tokenIndex]->tokenIndex].stringValue;
		// }
		
		return intToVToken[tempNode->tokenIndex].stringValue;
		
	}
bool GameAI::setEqualTo (VNode * destNodeFinal, VNode * srceNodeFinal, int curGen)
                                                                                {
		
		bool notAssigned = false;
		
		cout << SPACE_BUFFER[curGen] << "setEqualTo(): " << getResolvedString(destNodeFinal) << " = " << 
			getResolvedString(srceNodeFinal) << "\n";

		// VNode* destNodeFinal = NULL;
		// VNode* srceNodeFinal = NULL;
		
		// if (tokenIndexToVar[destNode->tokenIndex] == NULL) {
		// 	destNodeFinal = destNode;
		// }
		// else {
		// 	destNodeFinal = tokenIndexToVar[destNode->tokenIndex];
		// }
		
		// if (tokenIndexToVar[srceNode->tokenIndex] == NULL) {
		// 	srceNodeFinal = srceNode;
		// }
		// else {
		// 	srceNodeFinal = tokenIndexToVar[srceNode->tokenIndex];
		// }
		
		if (tokenIndexToVar[destNodeFinal->tokenIndex] == NULL) {
			notAssigned = true;
		}
		// else {
		// 	if (intToVToken[tokenIndexToVar[destNodeFinal->tokenIndex]->tokenIndex].type == E_VCT_VARIABLE) {
		// 		notAssigned = true;
		// 	}
		// }
		
		if (notAssigned) {
			// check if dest node is already set
			
			assignStack.push_back(AssignStruct());
			assignStack.back().lastAssign = tokenIndexToVar[destNodeFinal->tokenIndex];
			assignStack.back().newAssign = srceNodeFinal;
			assignStack.back().tokenIndex = destNodeFinal->tokenIndex;
			assignStack.back().genIndex = curGen;
			
			tokenIndexToVar[destNodeFinal->tokenIndex] = srceNodeFinal;
			
		}
		else {
			
			// cout << SPACE_BUFFER[curGen] << "token indices: " << tokenIndexToVar[destNodeFinal->tokenIndex]->tokenIndex <<
			// ", " << srceNodeFinal->tokenIndex << "\n";
			
			if (tokenIndexToVar[destNodeFinal->tokenIndex]->tokenIndex == srceNodeFinal->tokenIndex) {
				// if set value matches, do nothing
				cout << SPACE_BUFFER[curGen] << "Attempted to set variable to same value\n";
				return true;
			}
			else {
				// attempted to set to different value
				cout << SPACE_BUFFER[curGen] << "Variable is already assigned\n";
				return false;
			}
			
			
		}

		return true;
	}
void GameAI::rollBack (int curGen)
                                  {
		// roll back any assignments
		bool foundGen = true;
		do {
			if (assignStack.size() <= 0) {
				foundGen = false;
			}
			else {
				if (assignStack.back().genIndex > curGen) {
					
					
					// assignStack.back().lastAssign = tokenIndexToVar[destNodeFinal->tokenIndex];
					// assignStack.back().newAssign = srceNodeFinal;
					// assignStack.back().tokenIndex = destNodeFinal->tokenIndex;
					// assignStack.back().genIndex = curGen;
					// tokenIndexToVar[destNodeFinal->tokenIndex] = srceNodeFinal;
					
					cout << "Roll back; " << intToVToken[
						assignStack.back().tokenIndex
					].stringValue << " = ";
					
					if (assignStack.back().lastAssign == NULL) {
						cout << "NULL\n";
					}
					else {
						cout << intToVToken[
							assignStack.back().lastAssign->tokenIndex
						].stringValue << "\n";
					}
					
					
					
					tokenIndexToVar[assignStack.back().tokenIndex] = assignStack.back().lastAssign;
					
					assignStack.pop_back();
				}
				else {
					foundGen = false;
				}
			}
		} while (foundGen);
		
	}
bool GameAI::attemptUnify (VNode * nodeToUnify, VNode * testNode, int curGen)
                                                                           {
		
		int nodeToUnifyType = intToVToken[nodeToUnify->tokenIndex].type;
		int testNodeType = intToVToken[testNode->tokenIndex].type;
		int i;
		
		bool isPredicate1 = nodeToUnifyType == E_VCT_PREDICATE;
		bool isPredicate2 = testNodeType == E_VCT_PREDICATE;
		
		cout << SPACE_BUFFER[curGen] << "attemptUnify(" << getResolvedString(nodeToUnify);
		if (isPredicate1) {
			cout << "[ ";
			for (i = 0; i < nodeToUnify->children.size(); i++) {
				cout << getResolvedString(nodeToUnify->children[i]) << " ";
			}
			cout << "]";
		}
		
		cout << ", " << getResolvedString(testNode);
		
		if (isPredicate2) {
			cout << "[ ";
			for (i = 0; i < testNode->children.size(); i++) {
				cout << getResolvedString(testNode->children[i]) << " ";
			}
			cout << "]";
		}
		
		cout << ")\n";
		
		bool res;
		
		switch (nodeToUnifyType) {
			case E_VCT_FLOAT:
				if (testNodeType == E_VCT_FLOAT) {
					return intToVToken[testNode->tokenIndex].floatValue == intToVToken[nodeToUnify->tokenIndex].floatValue;
				}
				else {
					if (testNodeType == E_VCT_VARIABLE) {
						// set variable to float
						return setEqualTo(testNode, nodeToUnify, curGen);
					}
					else {
						return false;
					}
				}
			break;
			case E_VCT_NOUN:
				switch (testNodeType) {
					case E_VCT_FLOAT:
						return false;
					break;
					case E_VCT_NOUN:
						return testNode->tokenIndex == nodeToUnify->tokenIndex;
					break;
					case E_VCT_OPERATOR:
						return false;
					break;
					case E_VCT_VARIABLE:
						// set variable to noun
						return setEqualTo(testNode, nodeToUnify, curGen);
					break;
					case E_VCT_PREDICATE:
						return false;
					break;
				}
			break;
			case E_VCT_OPERATOR:
				return false;
			break;
			case E_VCT_VARIABLE:
				switch (testNodeType) {
					case E_VCT_FLOAT:
						// set variable to the float value
						setEqualTo(nodeToUnify, testNode, curGen);
					break;
					case E_VCT_NOUN:
						// set the variable to the noun value
						return setEqualTo(nodeToUnify, testNode, curGen);
					break;
					case E_VCT_OPERATOR:
						return false;
					break;
					case E_VCT_VARIABLE:
						// set variables to share values
						return setEqualTo(nodeToUnify, testNode, curGen);
					break;
					case E_VCT_PREDICATE:
						// set the variable to the predicate
						// todo: fix?
						return false;
					break;
				}
			break;
			case E_VCT_PREDICATE:
				switch (testNodeType) {
					case E_VCT_FLOAT:
						return false;
					break;
					case E_VCT_NOUN:
						return false;
					break;
					case E_VCT_OPERATOR:
						return false;
					break;
					case E_VCT_VARIABLE:
						// set variable to the predicate
						// todo: fix this?
						return false;
					break;
					case E_VCT_PREDICATE:
						// unify predicates
						
						if (testNode->tokenIndex == nodeToUnify->tokenIndex) {
							if (testNode->children.size() == nodeToUnify->children.size()) {
								
								for (i = 0; i < nodeToUnify->children.size(); i++) {
									res = attemptUnify(nodeToUnify->children[i], testNode->children[i], curGen);
									
									if (res) {
										
									}
									else {
										return false;
									}
								}
							}
							else {
								return false;
							}
						}
						else {
							return false;
						}
						
					break;
				}
			break;
			
		}
		
		return true;
	}
VNode * GameAI::drillDown (VNode * curVar)
                                        {
		VNode* tempVar = curVar;
		
		if (tempVar == NULL) {
			return NULL;
		}
		else {
			while ( tokenIndexToVar[tempVar->tokenIndex] != NULL ) {
				tempVar = tokenIndexToVar[tempVar->tokenIndex];
			}
			return tempVar;
		}
		
	}
bool GameAI::testEqual (VNode * testNode)
                                        {
		
		VNode* term1;
		VNode* term2;
		bool res = false;
		
		if (testNode->children.size() != 2) {
			cout << "Invalid number of arguments for testEqual()\n";
			return false;
		}
		else {
			term1 = drillDown(testNode->children[0]);
			term2 = drillDown(testNode->children[1]);
			
			if (term1 == NULL) {
				return (term2 == NULL);
			}
			
			res = (term1->tokenIndex == term2->tokenIndex);
			
			cout << "testEqual(): " << res << "\n";
			
			return res;
		}
	}
bool GameAI::isBetween (VNode * testNode)
                                        {
		
		cout << "isBetween()\n";
		
		VNode* term0;
		VNode* term1;
		VNode* term2;
		
		float fv0;
		float fv1;
		float fv2;
		
		if (testNode->children.size() != 3) {
			cout << "Invalid number of arguments for isBetween()\n";
			return false;
		}
		else {
			term0 = drillDown(testNode->children[0]);
			term1 = drillDown(testNode->children[1]);
			term2 = drillDown(testNode->children[2]);
			
			if (
				(term0 == NULL) ||
				(term1 == NULL) ||
				(term2 == NULL)	
			) {
				cout << "null term\n";
				return false;
			}
			else {
				
				if (
					(intToVToken[term0->tokenIndex].type == E_VCT_FLOAT) &&
					(intToVToken[term1->tokenIndex].type == E_VCT_FLOAT) &&
					(intToVToken[term2->tokenIndex].type == E_VCT_FLOAT)
				) {
					
					fv0 = intToVToken[term0->tokenIndex].floatValue;
					fv1 = intToVToken[term1->tokenIndex].floatValue;
					fv2 = intToVToken[term2->tokenIndex].floatValue;
					
					cout << "success, compare: " << fv0 << " " << fv1 << " " << fv2 << "\n";
					
					return ((fv0 >= fv1)&&(fv0<=fv2));
					
				}
				else {
					cout << "non float term\n";
					
					return false;
				}
				
			}
			
			
			
		}
	}
bool GameAI::searchToUnify (VNode * nodeToUnifyBase, int curGen, int curOffset)
                                                                                  {
		
		
		int i;
		int j;
		int k;
		
		bool tempRes = false;
		bool tempRes2 = false;
		bool foundUni;
		bool isHead;
		bool wasSuccessful = false;
		bool foundGen;
		
		VNode* curKBRule = NULL;
		VNode* curKBRuleHead = NULL;
		VNode* curKBRuleTail = NULL;
		VNode* nodeToUnify = nodeToUnifyBase;
		
		// if (goalList.size() == 0) {
		// 	wasSuccessful = true;
		// 	goto DO_RETURN;
		// }
		
		//nodeToUnify = goalList.back();
		//removeGoal();
		//goalList.pop_back();
		
		cout << SPACE_BUFFER[curGen]  << "searchToUnify(" <<
		 intToVToken[nodeToUnify->tokenIndex].stringValue << ") curOffset = " << curOffset << "\n";
		
		for (j = 0; j < qbCompiled->children[0]->children.size(); j++) {
			printChain(qbCompiled->children[0]->children[j]);
			cout << "\n";
		}
		cout << "\n";
		
		
		
		if (intToVToken[nodeToUnify->tokenIndex].type == E_VCT_OPERATOR) {
			switch (nodeToUnify->tokenIndex) {
				case E_VC_ALL:
				case E_VC_NONE:
					nodeToUnify = nodeToUnify->children[curOffset];
				break;
				case E_VC_ANY:
					wasSuccessful = false;
					for (i = 0; i < nodeToUnify->children.size(); i++) {
						wasSuccessful = wasSuccessful || searchToUnify(nodeToUnify->children[i], curGen + 1);
					}
					goto DO_RETURN;
				break;
			}
		}
		
		if (intToVToken[nodeToUnify->tokenIndex].type == E_VCT_OPERATOR) {
			switch (nodeToUnify->tokenIndex) {
				case E_VC_EQUAL:
					wasSuccessful = testEqual(nodeToUnify);
					goto DO_RETURN;
				break;
				case E_VC_NOTEQUAL:
					wasSuccessful = !( testEqual(nodeToUnify) );
					goto DO_RETURN;
				break;
				case E_VC_ISBETWEEN:
					wasSuccessful = isBetween(nodeToUnify);
					goto DO_RETURN;
				break;				
			}
		}
		
		
		
		for (i = 0; i < tokenToRules[nodeToUnify->tokenIndex].data.size(); i++) {
			
			curKBRule = kbCompiled->children[
				tokenToRules[nodeToUnify->tokenIndex].data[i]	
			];
			
			
			isHead = false;
			
			// if dealing with an if then statement, set rule to head
			if (curKBRule->tokenIndex == E_VC_IFTHEN) {
				
				if (curKBRule->children.size() != 2) {
					cout << "Error: If/Then statement requires exactly two arguments.\n";
					wasSuccessful = false;
								goto DO_RETURN;
				}
				else {
					isHead = true;
					curKBRuleHead = curKBRule->children[1]; // then
					curKBRuleTail = curKBRule->children[0]; // if
				}
			}
			else {
				curKBRuleHead = curKBRule;
			}
			
			foundUni = false;
			if (curKBRuleHead->tokenIndex == E_VC_LIST) {
				for (j = 0; j < curKBRule->children[1]->children.size(); j++) {
					curKBRuleHead = curKBRule->children[1]->children[j];
					
					tempRes = attemptUnify(nodeToUnify, curKBRuleHead, curGen + 1);
					
					if (tempRes) {
						cout << SPACE_BUFFER[curGen] << "Unify success\n";
						foundUni = true;
						break;
					}
					else {
						cout << SPACE_BUFFER[curGen] << "Unify failure\n";
						rollBack(curGen);
					}
				}
			}
			else {
				
				tempRes = attemptUnify(nodeToUnify, curKBRuleHead, curGen + 1);
				// if (nodeToUnifyBase->tokenIndex == E_VC_NONE) {
				// 	tempRes = !tempRes;
				// }
				
				
				if (tempRes) {
					
					if (intToVToken[nodeToUnifyBase->tokenIndex].type == E_VCT_OPERATOR) {
						switch (nodeToUnifyBase->tokenIndex) {
							case E_VC_ALL:
							case E_VC_NONE:
							
								if (curOffset < (nodeToUnifyBase->children.size()-1) ) {
									// we still have more items to prove
									
									tempRes2 = searchToUnify(nodeToUnifyBase, curGen + 1, curOffset + 1);
									// if (nodeToUnifyBase->tokenIndex == E_VC_NONE) {
									// 	tempRes2 = !tempRes2;
									// }
									
									if (tempRes2) {
										cout << SPACE_BUFFER[curGen] << "Unify success\n";
										foundUni = true;
									}
									else {
										cout << SPACE_BUFFER[curGen] << "Unify failure\n";
										rollBack(curGen);
									}
									
								}
								else {
									// done proving items
									cout << SPACE_BUFFER[curGen] << "Total unify success\n";
									foundUni = true;
								}
							
								
							break;
							case E_VC_ANY:
								// should not hit this
								cout << SPACE_BUFFER[curGen] << "Error: should not reach this segment\n";
							break;
						}
					}
					else {
						cout << SPACE_BUFFER[curGen] << "Unify success\n";
						foundUni = true;
					}
					
				}
				else {
					cout << SPACE_BUFFER[curGen] << "Unify failure\n";
					rollBack(curGen);
				}
			}
			
			
			if (foundUni) {
				// rule or head of rule successfully unified
				
				
				if (isHead) {
					// attempt to prove all tail conditions true
					
					tempRes = searchToUnify(curKBRuleTail, curGen + 1);
					if (tempRes) {
						wasSuccessful = true;
									goto DO_RETURN;
					}
					else {
						rollBack(curGen);
					}
				}
				else {
					wasSuccessful = true;
								goto DO_RETURN;
				}
			}
			else {
				rollBack(curGen);
			}
			
			
			
			
			
			
		}
		
DO_RETURN:

		if (nodeToUnifyBase->tokenIndex == E_VC_NONE) {
			if (curOffset == 0) {
				wasSuccessful = !wasSuccessful;
			}
		}

		cout << SPACE_BUFFER[curGen] << "wasSuccessful: " << wasSuccessful << "\n";
		return wasSuccessful;
		
	}
void GameAI::printChain (VNode * curVar)
                                       {
		
		if (curVar == NULL) {
			cout << "NULL";
		}
		else {
			cout << intToVToken[curVar->tokenIndex].stringValue;
			
			if ( tokenIndexToVar[curVar->tokenIndex] == NULL ) {
				return;
			}
			else {
				cout << " -> ";
				printChain(tokenIndexToVar[curVar->tokenIndex]);
			}
		}
		
	}
void GameAI::runQueries ()
                          {
		int i;
		int j;
		
		bool res = false;
		
		
		cout << "\n\n";
		
		for (i = 0; i < qbCompiled->children.size(); i++) {
			
			
			//goalList.clear();
			assignStack.clear();
			
			
			res = searchToUnify(qbCompiled->children[i], 0);
			
			for (j = 0; j < qbCompiled->children[i]->children.size(); j++) {
				printChain(qbCompiled->children[i]->children[j]);
				cout << "\n";
			}
			
			cout << "final result: " << res << "\n";
			
			
		}
		
		cout << "\n\n";
	}
bool GameAI::compileVocab (JSONValue * uncompiledNode, VNode * curVNode)
                                                                      {
		int i;
		int curInd;
		int tokIndex;
		bool result = true;
		JSONValue* curJVNode = NULL;
		JSONValue* lastJVNode = NULL;
		
		
		string tempNumberStr;
		
		if (uncompiledNode->IsArray()) {
			for (i = 0; i < uncompiledNode->array_value.size(); i++) {
				curJVNode = uncompiledNode->array_value[i];
				
				//compiledNode.array_value.push_back( new JSONValue(JSONArray()) );
				
				if (curJVNode->IsArray()) {
					if (lastJVNode == NULL) {
						cout << "Array must be preceded by string value\n";
						return false;
					}
					else {
						if (lastJVNode->IsString()) {
							
							tokIndex = stringToVTokenIndex[lastJVNode->string_value];
							
							if (
								(intToVToken[tokIndex].type == E_VCT_OPERATOR) ||
								(intToVToken[tokIndex].type == E_VCT_PREDICATE)
							) {
								curVNode->children.push_back(new VNode(tokIndex));
								result = result && compileVocab(curJVNode, curVNode->children.back());
							}
							else {
								cout << "Array must be preceded by operator or predicate\n";
								return false;
							}
							
							
						}
						else {
							cout << "Array must be preceded by string value\n";
							return false;
						}
					}
				}
				else if (curJVNode->IsString()) {
					
					
					tokIndex = stringToVTokenIndex[curJVNode->string_value];
					
					if (
						(intToVToken[tokIndex].type == E_VCT_OPERATOR) ||
						(intToVToken[tokIndex].type == E_VCT_PREDICATE)
					) {
						// wait to consume array
					}
					else {
						curVNode->children.push_back(new VNode(tokIndex));
					}
					
					
				}
				else if (curJVNode->IsNumber()) {
					
					tempNumberStr = f__s(curJVNode->number_value);
					if (stringToVTokenIndex.find( tempNumberStr ) == stringToVTokenIndex.end()) {
						intToVToken.push_back(VToken());
						curInd = intToVToken.size()-1;
						intToVToken[curInd].index = curInd;
						intToVToken[curInd].stringValue = tempNumberStr;
						intToVToken[curInd].floatValue = curJVNode->number_value;
						intToVToken[curInd].type = E_VCT_FLOAT;
						intToVToken[curInd].maxParam = 0;
						stringToVTokenIndex[tempNumberStr] = curInd;
					}
					
					tokIndex = stringToVTokenIndex[tempNumberStr];
					curVNode->children.push_back(new VNode(tokIndex));
					
				}
				
				
				lastJVNode = uncompiledNode->array_value[i];
				
			}
		}
		
		return result;
	}
bool GameAI::checkVocab (JSONValue * jv)
                                       {
		
		int i;
		
		bool result = true;
		
		if (jv->IsArray()) {
			for (i = 0; i < jv->array_value.size(); i++) {
				result = result && checkVocab(jv->array_value[i]);
			}
		}
		else {
			if (jv->IsString()) {
				if (stringToVTokenIndex.find( jv->string_value ) == stringToVTokenIndex.end()) {
						result = false;
						cout << "Undeclared token " << jv->string_value << "\n";
				}
			}
		}
		
		return result;
	}
void GameAI::buildRule (VNode * curNode, int ruleNumber, bool isIfThen)
                                                                      {
		int i;
		VToken* vt =  &(intToVToken[curNode->tokenIndex]);
		
		std::vector<int>::iterator it;
		
		if (curNode->tokenIndex == E_VC_IFTHEN) {
			buildRule(curNode->children[1], ruleNumber, true);
		}
		else {
			
			if (
				(vt->type == E_VCT_NOUN) ||
				(vt->type == E_VCT_PREDICATE)
			) {
				
				if (isIfThen) { // push if-then rules to the back
					tokenToRules[curNode->tokenIndex].data.push_back(ruleNumber);
				}
				else { // all other rules go to the front
					it = tokenToRules[curNode->tokenIndex].data.begin();
					it = tokenToRules[curNode->tokenIndex].data.insert ( it , ruleNumber );
				}
				
				
			}
			
			for (i = 0; i < curNode->children.size(); i++) {
				buildRule(curNode->children[i], ruleNumber, isIfThen);
			}
		}
	}
void GameAI::buildRuleSet (VNode * curNode)
                                          {
		
		int i;
		
		for (i = 0; i < curNode->children.size(); i++) {
			buildRule(curNode->children[i], i, false);
		}
		
	}
void GameAI::numberRule (VNode * curNode, int ruleNumber)
                                                        {
		int i;
		int curInd;
		
		
		curNode->ruleNumber = ruleNumber;
		
		if (intToVToken[curNode->tokenIndex].type == E_VCT_VARIABLE) {
			// check if variable already registered
			
			tempVarStr = intToVToken[curNode->tokenIndex].stringValue;
			tempVarStr.append("__");
			tempVarStr.append(i__s(ruleNumber));
			
			if (stringToVTokenIndex.find( tempVarStr ) == stringToVTokenIndex.end()) {
				// variable not yet created, make it
				
				intToVToken.push_back(VToken());
				curInd = intToVToken.size()-1;
				intToVToken[curInd].index = curInd;
				intToVToken[curInd].stringValue = tempVarStr;
				intToVToken[curInd].floatValue = 0.0f;
				intToVToken[curInd].type = E_VCT_VARIABLE;
				intToVToken[curInd].maxParam = 0;
				stringToVTokenIndex[tempVarStr] = curInd;
				
				
			}
			
			curNode->tokenIndex = stringToVTokenIndex[tempVarStr];
			
		}
		
		for (i = 0; i < curNode->children.size(); i++) {
			numberRule(curNode->children[i], ruleNumber);
		}		
	}
int GameAI::numberRuleSet (VNode * curNode, int offset)
                                                      {
		
		int i;
		
		for (i = 0; i < curNode->children.size(); i++) {
			numberRule(curNode->children[i], i + offset);
		}
		
		return i;
	}
void GameAI::printRule (VNode * curNode, int offset)
                                                   {
		int i;
		int curInd;
		
		
		curNode->tokenIndex;
		
		
		
		if (curNode->children.size() > 0) {
			cout << SPACE_BUFFER[offset] << intToVToken[curNode->tokenIndex].stringValue << "[\n";
		}
		else {
			cout << SPACE_BUFFER[offset] << intToVToken[curNode->tokenIndex].stringValue << "\n";
		}
		
		for (i = 0; i < curNode->children.size(); i++) {
			printRule(curNode->children[i], offset + 1);
		}	
		
		if (curNode->children.size() > 0) {
			cout << SPACE_BUFFER[offset] << "]\n";
		}	
	}
void GameAI::printRuleSet (VNode * curNode)
                                          {
		
		int i;
		
		for (i = 0; i < curNode->children.size(); i++) {
			printRule(curNode->children[i],0);
			
			cout << "\n\n";
			
		}
		
	}
bool GameAI::parseKB ()
                       {
		int i;
		int j;
		int tokIndex;
		int curType;
		int arraySize;
		int tempInt0;
		int curInd;
		int tempInt = 0;
		string tempStr0;
		JSONValue* curJV;
		
		bool res0;
		bool res1;
		
		
		
		
		
		for (i = 0; i < jvKB->Child("vocabulary")->array_value.size(); i++) {
			
			curJV = jvKB->Child("vocabulary")->array_value[i];
			
			if ( curJV->IsArray() ) {
				
				arraySize = curJV->array_value.size();
				
				if (arraySize == 2) {
					
					tempStr0 = curJV->array_value[0]->string_value;
					tempInt0 = curJV->array_value[1]->number_value;
					
					switch(tempStr0[0]) {
						case 'f':
							curType = E_VCT_FLOAT;
						break;
						case 'o':
							curType = E_VCT_OPERATOR;
						break;
						case 'v':
							curType = E_VCT_VARIABLE;
						break;
						case 'n':
							curType = E_VCT_NOUN;
						break;
						case 'p':
							curType = E_VCT_PREDICATE;
						break;
						default:
							cout << "Unsupported type in token " << tempStr0 << "\n";
							return false;
						break;
					}
					
					intToVToken.push_back(VToken());
					curInd = intToVToken.size()-1;
					intToVToken[curInd].index = curInd;
					intToVToken[curInd].stringValue = tempStr0;
					intToVToken[curInd].floatValue = 0.0f;
					intToVToken[curInd].type = curType;
					intToVToken[curInd].maxParam = tempInt0;
					stringToVTokenIndex[tempStr0] = curInd;
					
				}
				else {
					cout << "Invalid Array Size of " << arraySize << " in vocabulary.\n";
					return false;
				}
				
				
				
			}
			else {
				cout << "Vocabulary entry " << i << " is not an array.\n";
				return false;
			}
		}
		
		res0 = checkVocab(jvKB->Child("kb"));
		res1 = checkVocab(jvKB->Child("qb"));
		
		if (res0&&res1) {
			
		}
		else {
			cout << "checkVocab() failed\n";
			return false;
		}
		
		
		if (kbCompiled != NULL) {
			delete kbCompiled;
		}
		if (qbCompiled != NULL) {
			delete qbCompiled;
		}
		
		
		
		tokIndex = stringToVTokenIndex["oList"];
		
		kbCompiled = new VNode(tokIndex);
		qbCompiled = new VNode(tokIndex);
		
		cout << "Begin vocab compile\n";
		
		res0 = compileVocab(jvKB->Child("kb"),kbCompiled);
		res1 = compileVocab(jvKB->Child("qb"),qbCompiled);
		
		if (res0&&res1) {
			
		}
		else {
			cout << "compileVocab() failed\n";
			return false;
		}
		
		
		for (i = 0; i < intToVToken.size();i++) {
			tokenToRules.push_back(intVec());
		}
		buildRuleSet(kbCompiled);
		tempInt = numberRuleSet(kbCompiled, 0);
		numberRuleSet(qbCompiled,tempInt);
		
		
		
		for (i = 0; i < intToVToken.size();i++) {
			tokenIndexToVar.push_back(NULL);
		}
		
		
		
		traceRules();
		
		
		return true;
	}
void GameAI::traceRules ()
                          {
		int i;
		int j;
		
		cout << "TokenToRules:\n";
		for (i = 0; i < tokenToRules.size(); i++) {
			
			cout << intToVToken[i].stringValue << ": ";
			
			for (j = 0; j < tokenToRules[i].data.size(); j++) {
				cout << tokenToRules[i].data[j] << " ";
			}
			
			cout << "\n";
		}
		
		cout << "\nAll Vocab:\n";
		for (i = 0; i < intToVToken.size(); i++) {
			cout << intToVToken[i].stringValue << "\n";
		}
		
		
		cout << "kb\n";
		printRuleSet(kbCompiled);
		cout << "qb\n";
		printRuleSet(qbCompiled);
		cout << "\n\n";
		
	}
void GameAI::getKB ()
                     {
		
		bool res;
		
		cout << "getKB()\n";
		tokenToRules.clear();
		stringToVTokenIndex.clear();
		tokenIndexToVar.clear();
		intToVToken.clear();
		
		jvKB = singleton->fetchJSONData("kb.js", true);
		
		if (jvKB == NULL) {
			return;
		}
		
		res = parseKB();
		
		if (res) {
			cout << "Successfully compiled KB\n";
			
			runQueries();
			
		}
		else {
			cout << "Failed to compile KB\n";
		}
		
	}
#undef LZZ_INLINE
 
// f00337_gamefluid.h
//

#include "f00337_gamefluid.e"
#define LZZ_INLINE inline
int GameFluid::getFluidId (int groupNum, int ind)
                                              {
		return fluidIds[fsVec[groupNum].fidBegInd + ind];
	}
int GameFluid::getFIDSize (int groupNum)
                                     {
		return fsVec[groupNum].fidEndInd - fsVec[groupNum].fidBegInd;
	}
void GameFluid::fidPushBack (int groupNum, int val)
                                                {
		fluidIds[fsVec[groupNum].fidEndInd] = val;
		fsVec[groupNum].fidEndInd++;
	}
int * GameFluid::fidGetBeg (int groupNum)
                                     {
		return fluidIds + fsVec[groupNum].fidBegInd;
	}
int * GameFluid::fidGetEnd (int groupNum)
                                     {
		return fluidIds + fsVec[groupNum].fidEndInd;
	}
int GameFluid::getIdealCellId (int groupNum, int ind)
                                                  {
		return idealCellIds[fsVec[groupNum].iciBegInd + ind];
	}
int GameFluid::getICISize (int groupNum)
                                     {
		return fsVec[groupNum].iciEndInd - fsVec[groupNum].iciBegInd;
	}
void GameFluid::iciPushBack (int groupNum, int val)
                                                {
		idealCellIds[fsVec[groupNum].iciEndInd] = val;
		fsVec[groupNum].iciEndInd++;
	}
GameFluid::GameFluid ()
                    {
		
		fluidChanged = false;
		posShifted = false;
		hasRead = false;
		
		UNIT_MIN = FLUID_UNIT_MIN;
		UNIT_MAX = FLUID_UNIT_MAX;
		
		UNIT_INSIDE = FLUID_UNIT_MIN + 8;
		
		invalidated = true;
		
		F_UNIT_MIN = UNIT_MIN;
		F_UNIT_MAX = UNIT_MAX;
		
		watchMinX = -1;
		watchMaxX = -1;
		watchMinY = -1;
		watchMaxY = -1;
		watchMinZ = -1;
		watchMaxZ = -1;
		
	}
void GameFluid::init (Singleton * _singleton, int _mainId)
                                                      {
		int i;
		
		singleton = _singleton;
		mainId = _mainId;
		
		// qqqqqq
		// WAS DOING: LEVEL OUT TOP OF WATER BY SEARCHING FOR WATER RIGHT BELOW TOP
		// AND FILLING WITH ZERO VALUE WATER IF THERE IS
		
		//volSizes[E_FID_SML] = 64;
		volSizes[E_FID_BIG] = DEF_VOL_SIZE;
		mipSizes[E_FID_BIG] = 1;
		
		// volSizes[E_FID_MIP] = 256;
		// mipSizes[E_FID_MIP] = 4;
		
		waterTick = 0;
		waterTickMax = 32;
		waterTickMaxDiv = 64;
		waterTickReady = false;
		
		
		
		volSizePrim = volSizes[mainId]/mipSizes[mainId];
		cellsPerBlock = singleton->cellsPerBlock;
		cellsPerHolder = singleton->cellsPerHolder;
		
		readyForTermination = false;
		cycleTerminated = false;
		proceedingToRead = false;
		fluidReading = false;
		modifiedUnit = false;
		modifiedGeom = false;
		readyForTBOUpdate = false;
		firstVPUpdate = true;
		
		internalPrimFormat = GL_RGBA;
		precPrimFormat = GL_UNSIGNED_BYTE;
		
		curGeomCount = 0;
		waterLerp = 0.0f;
		primDiv = 4;
		volSizePrimMacro = volSizePrim/primDiv;
		primsPerMacro = 8;
		floatsPerPrimEntry = 8;
		floatsInPrimMacro = volSizePrimMacro*volSizePrimMacro*volSizePrimMacro*primsPerMacro*floatsPerPrimEntry;
		
		
		
		
		
		
		threadLoader.init();
		threadTex.init();
		threadFluid.init();
		
		
		camPosVP.setFXYZ(0.0f,0.0f,0.0f);
		lastCamPosVP.setFXYZ(0.0f,0.0f,0.0f);//(-100.0f,-100.0f,-100.0f);
		
		
		bufAmount = 1;
		
		if (mipSizes[mainId] > 1) {
			bufAmount = 0;
		}
		
		volSizePrimBuf = volSizePrim+bufAmount*2;
		
		forceFullRefresh = 2;
		
		shrinkCount = 0;
		
		//curTick = 0;
		//maxTicks = 1;//volSizePrim/8;
		
		vspMin = bufAmount;
		vspMax = volSizePrimBuf-bufAmount;
		
		fluidData = new int[volSizePrimBuf*volSizePrimBuf*volSizePrimBuf*4];
		extraData = new int[volSizePrimBuf*volSizePrimBuf*volSizePrimBuf*4];
		
		fluidIds = new int[volSizePrimBuf*volSizePrimBuf*volSizePrimBuf];
		idealCellIds = new int[volSizePrimBuf*volSizePrimBuf*volSizePrimBuf];
		
		
		totSize = volSizePrimBuf*volSizePrimBuf*volSizePrimBuf;
		
		
		
		for (i = 0; i < E_PL_LENGTH; i++) {
			volDataPrim[i] = new uint[volSizePrim*volSizePrim*volSizePrim];
		}
		
		//maxDirtyRegion();
		
		tboData = new float[floatsInPrimMacro];
		
		
		
		
		setupPrimTexture();
		
	}
void GameFluid::flushActionStack ()
                                {
		PushModStruct* curPM;
		
		
		
		while (pmStack.size() > 0) {
			
			//cout << "flushActionStack()\n";
			
			curPM = &(pmStack.back());
			
			switch(curPM->actionType) {
				case E_PM_EXPLODE_BULLET:
					pushExplodeBullet(
						false,
						&(curPM->data[0]),
						curPM->data[1].getIX(),
						curPM->data[2].getFX()
					);
				break;
				case E_PM_MODIFY_UNIT:
					pushModifyUnit(
						false,
						&(curPM->data[0]),
						curPM->data[1].getIX(),
						curPM->data[1].getIY(),
						curPM->data[1].getIZ()
					);
				break;
				case E_PM_PLACE_TEMPLATE:
					pushPlaceTemplate(false,&(curPM->data[0]), curPM->data[1].getIX());
				break;
			}
			
			pmStack.pop_back();
		}
	}
void GameFluid::pushExplodeBullet (bool isReq, FIVector4 * newPos, int waterBulletOn, float newRad)
                                                                                               {
		
		
		if (isReq) {
			pmStack.push_back(PushModStruct());
			pmStack.back().actionType = E_PM_EXPLODE_BULLET;
			pmStack.back().data[0].copyFrom(newPos);
			pmStack.back().data[1].setIX(waterBulletOn);
			pmStack.back().data[2].setFX(newRad);
			return;
		}
		
		if (waterBulletOn > 0) {
			modifyUnit(newPos, E_BRUSH_ADD, E_PTT_WAT, newRad);
		}
		else {
			modifyUnit(newPos, E_BRUSH_SUB, E_PTT_TER, newRad);
		}
		
		singleton->waitingOnDestruction = true;
		singleton->destructCount = 0;
		
		modifiedUnit = true;
		
		
	}
void GameFluid::pushModifyUnit (bool isReq, FIVector4 * mp, int buttonNum, int earthMod, int curBrushRad)
                                                                                                     {
		
		cout << "pushModifyUnit " << isReq << "\n";
		
		if (isReq) {
			pmStack.push_back(PushModStruct());
			pmStack.back().actionType = E_PM_MODIFY_UNIT;
			pmStack.back().data[0].copyFrom(mp);
			pmStack.back().data[1].setIXYZ(buttonNum,earthMod,curBrushRad);
			return;
		}
		
		//bool lbClicked, bool rbClicked, bool mbClicked
		
		switch (buttonNum) {
			case 0: //lb
				modifyUnit(mp, E_BRUSH_ADD, earthMod, curBrushRad);
			break;	
			case 1: //rb
				modifyUnit(mp, E_BRUSH_SUB, earthMod, curBrushRad);
			break;	
			case 2: //mb
				modifyUnit(mp, E_BRUSH_REF, earthMod, curBrushRad);
			break;	
		}
		
		modifiedUnit = true;
		
		
		
		
	}
void GameFluid::pushPlaceTemplate (bool isReq, FIVector4 * newPos, int pt)
                                                                      {
		
		if (isReq) {
			pmStack.push_back(PushModStruct());
			pmStack.back().actionType = E_PM_PLACE_TEMPLATE;
			pmStack.back().data[0].copyFrom(newPos);
			pmStack.back().data[1].setIX(pt);
			return;
		}
		
		addGeom(newPos,pt);
		
		modifiedGeom = true;
		
		
	}
bool GameFluid::addPrimObj (FIVector4 * pos, int tempId, int uid)
                                                             {
		int baseInd = tempId*E_PRIMTEMP_LENGTH;
		int i;
		int j;
		int k;
		int m;
		int ind;
		float fPrimDiv = 1.0f/primDiv;
		//float cornerDis = singleton->primTemplateStack[baseInd+E_PRIMTEMP_CORNERDIS].getFX();
		
		tempBoundsMin.copyFrom(&(singleton->primTemplateStack[baseInd+E_PRIMTEMP_VISMIN]));
		tempBoundsMax.copyFrom(&(singleton->primTemplateStack[baseInd+E_PRIMTEMP_VISMAX]));
		
		tempBoundsMin.addXYZRef(pos);
		tempBoundsMax.addXYZRef(pos);
		
		tempBoundsMin.addXYZRef(&volMinReadyInPixels,-1.0f);
		tempBoundsMax.addXYZRef(&volMinReadyInPixels,-1.0f);
		
		//tempBoundsMin.addXYZ(-volSizePrim/2);
		//tempBoundsMax.addXYZ(-volSizePrim/2);
		
		
		
		//tempBoundsMin.addXYZ(-cornerDis);
		//tempBoundsMax.addXYZ(cornerDis);
		
		tempBoundsMin.multXYZ(fPrimDiv);
		tempBoundsMax.multXYZ(fPrimDiv);
		
		//tempBoundsMin.intDivXYZ(primDiv);
		//tempBoundsMax.intDivXYZ(primDiv);
		
		
		
		// tempBoundsMin.addXYZ(0.0f, 0.0f, 2.0f);
		// tempBoundsMax.addXYZ(0.0f, 0.0f, 2.0f);
		
		
		
		int iMin = max(tempBoundsMin[0],0.0f);
		int jMin = max(tempBoundsMin[1],0.0f);
		int kMin = max(tempBoundsMin[2],0.0f);
		
		int iMax = min(tempBoundsMax[0],volSizePrimMacro-1.0f);
		int jMax = min(tempBoundsMax[1],volSizePrimMacro-1.0f);
		int kMax = min(tempBoundsMax[2],volSizePrimMacro-1.0f);
		
		bool wasAdded = false;
		
		for (i = iMin; i <= iMax; i++) {
			for (j = jMin; j <= jMax; j++) {
				for (k = kMin; k <= kMax; k++) {
					for (m = 0; m < primsPerMacro; m++) {
						
						ind = (
							(
								i +
								j*volSizePrimMacro +
								k*volSizePrimMacro*volSizePrimMacro
							)*primsPerMacro + m
						)*floatsPerPrimEntry;
						
						if (tboData[ind+3] == 0.0f) {
							
							wasAdded = true;
							
							tboData[ind+0] = pos->getFX();
							tboData[ind+1] = pos->getFY();
							tboData[ind+2] = pos->getFZ();
							tboData[ind+3] = tempId;
							
							tboData[ind+4] = 0;//diagCount;//;
							tboData[ind+5] = uid + 1; // uid of 0 results in blank object
							tboData[ind+6] = 0.0f;
							tboData[ind+7] = 0.0f;
							
							break;
						}
					}
				}
			}
		}
		
		return wasAdded;
	}
void GameFluid::addGeom (FIVector4 * newPos, int templateId)
                                                        { //FIVector4* pos, FIVector4* offset
		
		FIVector4 camBlockPos;
		GameBlock* curBlock;
		
		
		
		camBlockPos.copyFrom(newPos);
		camBlockPos.intDivXYZ(cellsPerBlock);
		
		curBlock = singleton->gw->getBlockAtCoords(
			camBlockPos.getIX(),
			camBlockPos.getIY(),
			camBlockPos.getIZ(),
			true
		);
		
		curBlock->gameEnts[E_ET_GEOM].data.push_back(GameEnt());
		
		GameEnt* gameEnt = &(curBlock->gameEnts[E_ET_GEOM].data.back());
		
		gameEnt->templateId = templateId;
		gameEnt->templatePos.copyFrom(newPos);
	}
void GameFluid::fetchGeom ()
                         {
		
		
		int i;
		int j;
		int k;
		
		int m;
		
		GameBlock* curBlock;
		GameEnt* gameEnt;
		FIVector4 start;
		FIVector4 end;
		FIVector4 avg;

		
		
		int geomCount = 0;
		int tempId;
		
		FIVector4 camBlockPos;
		
		camBlockPos.averageXYZ(&volMinReadyInPixels,&volMaxReadyInPixels);
		camBlockPos.intDivXYZ(cellsPerBlock);
		
		for (i = -1; i <= 1; i++) {
			for (j = -1; j <= 1; j++) {
				for (k = -1; k <= 1; k++) {
					
					
					curBlock = singleton->gw->getBlockAtCoords(
						camBlockPos.getIX()+i,
						camBlockPos.getIY()+j,
						camBlockPos.getIZ()+k,
						true
					);

					for (m = 0; m < curBlock->gameEnts[E_ET_GEOM].data.size(); m++) {

						gameEnt = &(curBlock->gameEnts[E_ET_GEOM].data[m]);

						tempId = gameEnt->templateId;
						

						
						

						//if (FIVector4::intersect(&start,&end,&volMinReadyInPixels,&volMaxReadyInPixels)) {
							
							//avg.averageXYZ(&start,&end);
							
							if( addPrimObj(&(gameEnt->templatePos), tempId, geomCount) ) {
								geomCount++;
							}
							
							
						//}
					}
						
				}
			}
		}
		
		curGeomCount = geomCount;
		
		//cout << geomCount << " <-- geomCount\n";


		
	}
void GameFluid::setupPrimTexture ()
                                {
		int i;

		

		for (i = 0; i < E_PL_LENGTH; i++) {
			
			
			glGenTextures(1, &(volIdPrim[i]));
			
			//cout << "vp " << volIdPrim[i] << "\n";
			
			glBindTexture(GL_TEXTURE_3D, volIdPrim[i]);
			glTexImage3D(
				GL_TEXTURE_3D,
				0,
				internalPrimFormat, //GL_RGBA, // GL_RGBA32F
				volSizePrim,
				volSizePrim,
				volSizePrim,
				0,
				GL_RGBA,
				precPrimFormat, // GL_UNSIGNED_BYTE, // GL_FLOAT
				0
			);
			glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
			glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
			//glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_BORDER_COLOR, 0);
			glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE); //GL_CLAMP_TO_BORDER
			glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
			glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
			glBindTexture(GL_TEXTURE_3D, 0);
			
			
		}
		
		
	}
bool GameFluid::tryToEndRead ()
                            {
		
		
		if (threadLoader.isReady()) {
			
			
			stopTL();
			endFluidRead();
			//cycleTerminated = false;
			
			
			//if (mainId == E_FID_SML) {
			//	startFT();
			//}
			
			return true;
		}
		else {
			return false;
		}
	}
bool GameFluid::anyThreadsRunning ()
                                 {
		return threadLoader.threadRunning||threadTex.threadRunning||threadFluid.threadRunning;
	}
bool GameFluid::updateAll ()
                         {
		
		
		if (cycleTerminated) {
			
			return true;
		}
		
		waterTick++;		
		if (waterTick == waterTickMax) {
			waterTickReady = true;	
		}
		
		if (waterTick > waterTickMaxDiv) {
			waterTick = waterTickMaxDiv;
		}
		
		waterLerp = ((float)waterTick)/((float)waterTickMaxDiv);
		
		
		
		
		//cout << "still going " << mainId << "\n";
		
		
		if (fluidReading) {
			
		}
		else {
			/////////
			
			if (threadTex.threadRunning) {
				
			}
			else {
				
				
				
				
				
				if (waterTickReady) {
					
					
					
					if (threadFluid.isReady()) {
						
						waterTickReady = false;
						
						stopFT();
						
						// cout << "\n\nimmobileHeight " << immobileHeight << "\n";
						// cout << "maxWaterHeight " << maxWaterHeight << "\n\n";
						
						flushActionStack();
						
						if (modifiedUnit) {
							applyMods();
						}
						
						if (modifiedGeom) {	
							fillAllGeom();
							updateTBOData(false,false);
						}
						
						if (modifiedUnit||modifiedGeom) {
							singleton->refreshPaths = true;
						}
						
						//DirtyRegion
						if (modifiedUnit||modifiedGeom||fluidChanged) {
							
							if (fluidChanged) {
								//cout << "fluidChanged (max/imobile)" << maxWaterHeight << " " << immobileHeight << "\n";
							}
							
							
							if (hasRead&&(!firstVPUpdate)) {
								writeMIP.copyFrom(&volMinInPixels); //volMinInPixels
								
								//if (mainId == E_FID_SML) {
									singleton->gameLogic->threadPoolPath->stopAll();
									singleton->gameLogic->threadPoolList->stopAll();
									writeFluidData();
								//}
								
							}
							
						}
							
						modifiedUnit = false;
						modifiedGeom = false;
						
						forceFullRefresh = 1; // todo: should not require this?
						
						startTT();
					}
				}
			}
			
			
			if (threadFluid.threadRunning) {
				
			}
			else {
				
				
				if (threadTex.isReady()) {
					stopTT();
					
					
					volMinReadyInPixels.copyFrom(&volMinInPixels);
					volMaxReadyInPixels.copyFrom(&volMaxInPixels);
					
					if (readyForTBOUpdate) {
						readyForTBOUpdate = false;
						fetchGeom();
						tboWrapper.update(tboData,NULL,-1);
					}
					
					waterTick = 0;
					waterLerp = ((float)waterTick)/((float)waterTickMaxDiv);
					
					//if (mainId == E_FID_BIG) {
						copyPrimTexture(
							0,
							0,
							0,
							volSizePrim,
							&(volDataPrim[0])
						);
					//}
					
					
					
					curDirtyMax.copyFrom(&(dirtyMax));
					curDirtyMin.copyFrom(&(dirtyMin));
					curWaterMin.copyFrom(&tempMin2);
					curWaterMax.copyFrom(&tempMax2);
					//curWaterMin.addXYZRef(&volMinReadyInPixels);
					//curWaterMax.addXYZRef(&volMinReadyInPixels);
					//shrinkDirtyRegion();
					resetDirtyRegion();
					
					
					shiftRegion();
					
					if (fluidReading) {
						
					}
					else {
						terminateCycle();
					}
				}
				
				
				
			}
			
			////////////////
		}
		return false;
	}
void GameFluid::copyPrimTexture (int ox, int oy, int oz, int dim, uint * * myData)
                                                                             {
		
		
		int i;
		
		for (i = 0; i < E_PL_LENGTH; i++) {
			
			
			glBindTexture(GL_TEXTURE_3D, volIdPrim[i]);
			glTexSubImage3D(
				GL_TEXTURE_3D,
				0,

				ox,
				oy,
				oz,

				dim,
				dim,
				dim,

				GL_RGBA,
				precPrimFormat, //GL_UNSIGNED_BYTE,

				myData[i]
			);
			glBindTexture(GL_TEXTURE_3D, 0);
		}
		
		//singleton->depthInvalidMove = true;
		
	}
void GameFluid::fillAllGeom ()
                           {
		
		clearAllGeom();
		
		int i;
		int j;
		int k;
		
		int m;
		
		GameBlock* curBlock;
		GameEnt* gameEnt;
		FIVector4 start;
		FIVector4 end;
		FIVector4 avg;

		
		
		int geomCount = 0;
		int tempId;
		
		FIVector4 camBlockPos;
		
		camBlockPos.averageXYZ(&volMinReadyInPixels,&volMaxReadyInPixels);
		camBlockPos.intDivXYZ(cellsPerBlock);
		
		int baseInd;
		
		
		for (i = -1; i <= 1; i++) {
			for (j = -1; j <= 1; j++) {
				for (k = -1; k <= 1; k++) {
					
					curBlock = singleton->gw->getBlockAtCoords(
						camBlockPos.getIX()+i,
						camBlockPos.getIY()+j,
						camBlockPos.getIZ()+k,
						true
					);

					for (m = 0; m < curBlock->gameEnts[E_ET_GEOM].data.size(); m++) {

						gameEnt = &(curBlock->gameEnts[E_ET_GEOM].data[m]);

						tempId = gameEnt->templateId;
						baseInd = tempId*E_PRIMTEMP_LENGTH;

						start.copyFrom(&(singleton->primTemplateStack[baseInd+E_PRIMTEMP_VISMIN]));
						end.copyFrom(&(singleton->primTemplateStack[baseInd+E_PRIMTEMP_VISMAX]));
						start.addXYZRef(&(gameEnt->templatePos));
						end.addXYZRef(&(gameEnt->templatePos));
						
						

						if (FIVector4::intersect(&start,&end,&volMinReadyInPixels,&volMaxReadyInPixels)) {
							
							//cout << "fillCurrentGeom" << tempId;
							
							fillCurrentGeom(tempId, &(gameEnt->templatePos));
							
							// baseInd = curPrimTemplate*E_PRIMTEMP_LENGTH;
							
							// for (j = 0; j < E_PRIMTEMP_LENGTH; j++) {
							// 	setFXYZWGeom(j, &(singleton->primTemplateStack[baseInd+j]) );
							// }
							
						}
					}
				}
				
				
			}
		}
		
		
		clearInsideValues();
		
	}
void GameFluid::updateTBOData (bool firstTime, bool reloadTemplates)
                                                                 {
		int i;
		int ind;
		
		// if (mainId == E_FID_SML) {
		// 	// no need to update geometry visuals for small buffer
		// 	return;
		// }
		
		
		if (firstTime||reloadTemplates) {
			if (singleton->getPrimTemplateString()) {
				
			}
			else {
				return;
			}
		}
		
		int totCount = 0;
		
		
		// clear tbo data
		
		for (i = 0; i < floatsInPrimMacro/floatsPerPrimEntry; i++) {
			
			ind = i*floatsPerPrimEntry;
			
			tboData[ind + 0] = 0.0f;
			tboData[ind + 1] = 0.0f;
			tboData[ind + 2] = 0.0f;
			tboData[ind + 3] = 0.0f;
			
			tboData[ind + 4] = 0.0f;
			tboData[ind + 5] = 0.0f;
			tboData[ind + 6] = 0.0f;
			tboData[ind + 7] = 0.0f;
			
		}
		
		
		
		if (firstTime) {
			tboWrapper.init(true,tboData,NULL,floatsInPrimMacro*4);
		}
		else {
			readyForTBOUpdate = true;
		}
		
	}
void GameFluid::terminateCycle ()
                              {
		readyForTermination = true;
	}
void GameFluid::beginFluidRead (FIVector4 * _campPosVPDump)
                                                       {
		
		//fdWritePos = 0;
		//fdReadPos = 0;
		
		//cout << "pos change " << mainId << "\n";
		fluidReading = true;
		campPosVPDump.copyFrom(_campPosVPDump);
		terminateCycle();
	}
void GameFluid::proceedWithRead ()
                               {
		
		
		proceedingToRead = true;
		//
		camPosVPInPixels.copyFrom( &campPosVPDump );
		camPosVPInPixels.multXYZ( cellsPerHolder );
		volMinInPixels.copyFrom( &camPosVPInPixels );
		volMaxInPixels.copyFrom( &camPosVPInPixels );
		volMaxInPixels.addXYZ(volSizePrim);				
		//
		
		
		
		readMIP.copyFrom(&volMinInPixels);
		
		singleton->gameLogic->threadPoolPath->stopAll();
		singleton->gameLogic->threadPoolList->stopAll();
		prereadFluidData();
		
		
		startTL();
		
	}
void GameFluid::endFluidRead ()
                            {
		
		
		
		//cout << "pos change end " << mainId << "\n";
		fluidReading = false;
		proceedingToRead = false;
		
		
		updateTBOData(false,false);
		lastCamPosVP.setFXYZRef(&campPosVPDump);
		
		if (firstVPUpdate) {
			firstVPUpdate = false;
			volMinReadyInPixels.copyFrom(&volMinInPixels);
			volMaxReadyInPixels.copyFrom(&volMaxInPixels);
		}
		
		hasRead = true;
		posShifted = true;
		
		
	}
void GameFluid::shiftRegion ()
                           {
		
		
		bool notThirdPerson = (singleton->gem->getCurActor() == NULL);
		
		if (notThirdPerson) {
			newCamPos.copyFrom(singleton->cameraGetPosNoShake());
		}
		else {
			newCamPos.setBTV(singleton->gem->getCurActor()->getCenterPoint(0));
		}
		
		if (notThirdPerson&&(volSizePrim < 512)) { // && (mainId==E_FID_SML)
			newCamPos.addXYZRef(&singleton->lookAtVec,volSizePrim*0.4f);
		}
		
		camPosVP.copyFrom(&newCamPos);
		camPosVP.addXYZ(-volSizePrim*0.5f + cellsPerHolder*0.5f);
		
		
		
		camPosVP.intDivXYZ(cellsPerHolder);
		
		
		
		
		
		if (
			camPosVP.iNotEqual(&lastCamPosVP) && 
			(lastCamPos.distance(&newCamPos) > cellsPerHolder/16.0f)
		) {
			lastCamPos.copyFrom(&newCamPos);
			forceFullRefresh = 1;
			
			
			
			beginFluidRead(&camPosVP);
			
		}
		
	}
void GameFluid::funcFT ()
                      {
		threadFluid.setRunningLocked(true);
		//if (mainId==E_FID_SML) {
			fluidChanged = updateFluidData();
		//}
		
		threadFluid.setRunningLocked(false);
	}
void GameFluid::startFT ()
                       {
		if (threadFluid.threadRunning) {
			
		}
		else {
			threadFluid.threadRunning = true;
			
			if (SINGLE_THREADED) {
				funcFT();
			}
			else {
				threadFluid.threadMain = std::thread(&GameFluid::funcFT, this);
			}
			
			
		}
		
	}
bool GameFluid::stopFT ()
                      {
		bool didStop = false;
		
		if (threadFluid.threadRunning) {
			
			if (SINGLE_THREADED) {
				
			}
			else {
				threadFluid.threadMain.join();
			}
			
			threadFluid.threadRunning = false;
			didStop = true;
		}
		return didStop;
	}
void GameFluid::funcTL ()
                      {
		threadLoader.setRunningLocked(true);
		readFluidData();
		threadLoader.setRunningLocked(false);
	}
void GameFluid::startTL ()
                       {
		if (threadLoader.threadRunning) {
			
		}
		else {
			
			threadLoader.threadRunning = true;
			
			if (SINGLE_THREADED) {
				funcTL();
			}
			else {
				threadLoader.threadMain = std::thread(&GameFluid::funcTL, this);
			}
			
		}
		
	}
bool GameFluid::stopTL ()
                      {
		bool didStop = false;
		if (threadLoader.threadRunning) {
			
			if (SINGLE_THREADED) {
				
			}
			else {
				threadLoader.threadMain.join();
			}
			
			threadLoader.threadRunning = false;
			didStop = true;
		}
		return didStop;
	}
void GameFluid::funcTT ()
                      {
		threadTex.setRunningLocked(true);
		getPrimData(0);
		threadTex.setRunningLocked(false);
	}
void GameFluid::startTT ()
                       {
		if (threadTex.threadRunning) {
			
		}
		else {
			
			threadTex.threadRunning = true;
			
			if (SINGLE_THREADED) {
				funcTT();
			}
			else {
				threadTex.threadMain = std::thread(&GameFluid::funcTT, this);
			}
			
		}
		
	}
bool GameFluid::stopTT ()
                      {
		bool didStop = false;
		if (threadTex.threadRunning) {
			
			if (SINGLE_THREADED) {
				
			}
			else {
				threadTex.threadMain.join();
			}
			
			threadTex.threadRunning = false;
			didStop = true;
		}
		return didStop;
	}
void GameFluid::getPrimData (int n)
                                {
		
		// gggg
		
		//cout << "start\n";
		
		int i;
		int j;
		int k;
		int c;
		
		uint v0;
		uint v1;
		uint v2;
		uint v3;
		
		uint maxVal = 255;
		
		int indAbove;
		int indBelow;
		
		int indSrc;
		int indDest;
		
		int iMin = clamp(dirtyMin.getIX(), vspMin, vspMax);
		int iMax = clamp(dirtyMax.getIX(), vspMin, vspMax);
		int jMin = clamp(dirtyMin.getIY(), vspMin, vspMax);
		int jMax = clamp(dirtyMax.getIY(), vspMin, vspMax);
		int kMin = clamp(dirtyMin.getIZ(), vspMin, vspMax);
		int kMax = clamp(dirtyMax.getIZ(), vspMin, vspMax);
		
		if (forceFullRefresh > 0) {
		 	forceFullRefresh--;
			
			iMin = vspMin;
			iMax = vspMax;
			jMin = vspMin;
			jMax = vspMax;
			kMin = vspMin;
			kMax = vspMax;
		}
		
		
		float NEW_UNIT_MAX = UNIT_MAX + 1;
		
		uint* vdpPtr = (volDataPrim[n]);
		
		switch (n) {
			case E_PL_TERRAIN:
				
				// for (i = 0; i < totSize; i++) {
				// 	indSrc = i*4;
					
				// 	fluidData[indSrc+E_PTT_LST] += (fluidData[indSrc+E_PTT_LST] - fluidData[indSrc+E_PTT_WAT])/16;
					
				// 	if (fluidData[indSrc+E_PTT_LST] > fluidData[indSrc+E_PTT_WAT]) {
				// 		fluidData[indSrc+E_PTT_LST]--;
				// 	}
				// 	if (fluidData[indSrc+E_PTT_LST] < fluidData[indSrc+E_PTT_WAT]) {
				// 		fluidData[indSrc+E_PTT_LST]++;
				// 	}
				// }
				
				for (i = iMin; i < iMax; i++) {
					for (j = jMin; j < jMax; j++) {
						for (k = kMin; k < kMax; k++) {
							indSrc = (i + j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf)*4;
							//indAbove = indSrc+volSizePrimBuf*volSizePrimBuf*4;
							//indBelow = indSrc-volSizePrimBuf*volSizePrimBuf*4;
							indDest = ((i-bufAmount) + (j-bufAmount)*volSizePrim + (k-bufAmount)*volSizePrim*volSizePrim);
							
							v0 = ((fluidData[indSrc+0]+1)*255)/NEW_UNIT_MAX;
							v1 = ((fluidData[indSrc+1]+1)*255)/NEW_UNIT_MAX;
							v2 = ((fluidData[indSrc+2]+1)*255)/NEW_UNIT_MAX;
							v3 = ((fluidData[indSrc+3]+1)*255)/NEW_UNIT_MAX;
							
							
							// if (
							// 	(fluidData[indAbove+1] == -1) &&
							// 	(fluidData[indBelow+1] > -1)
							// ) {
							// 	v1 = 0;
							// }
							// if (
							// 	(fluidData[indAbove+2] == -1) &&
							// 	(fluidData[indBelow+2] > -1)
							// ) {
							// 	v2 = 0;
							// }
							
							
							if (v1 != 0) {
								v1 = (v1+510)/3;
							}
							if (v2 != 0) {
								v2 = (v2+510)/3;
							}
							
							v1 = min(v1,maxVal);
							v2 = min(v2,maxVal);
							
							vdpPtr[indDest] = 
								 (v0) |
								((v1) << 8) |
								((v2) << 16) |
								((v3) << 24);
								
							
							
						}
					}
				}
				
				
			break;
			
			// case E_PL_PRIMIDS:
				
			// break;
			
		}
		//cout << "end\n\n";
	}
void GameFluid::writeFluidData ()
                              {
		int i;
		int j;
		int k;
		
		int ind;
		
		//cout << "writeFluidData " << mainId << "\n";
		
		
		tempMin.copyFrom(&dirtyMin);
		tempMax.copyFrom(&dirtyMax);
		
		int iMin = clamp(tempMin.getIX()-1, vspMin, vspMax);
		int iMax = clamp(tempMax.getIX()+1, vspMin, vspMax);
		int jMin = clamp(tempMin.getIY()-1, vspMin, vspMax);
		int jMax = clamp(tempMax.getIY()+1, vspMin, vspMax);
		int kMin = clamp(tempMin.getIZ()-1, vspMin, vspMax);
		int kMax = clamp(tempMax.getIZ()+1, vspMin, vspMax);
		
		
		
		int ox = writeMIP.getIX();
		int oy = writeMIP.getIY();
		int oz = writeMIP.getIZ();
		
		//bool doFW = (mainId == E_FID_SML);
		
		if (hasRead) {
			
			for (k = kMin; k < kMax; k++) {
				
				for (j = jMin; j < jMax; j++) {
					
					for (i = iMin; i < iMax; i++) {
						
						
						ind = (i + j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf)*4;
						
						singleton->gw->setArrAtCoords(
							i-bufAmount+ox,
							j-bufAmount+oy,
							k-bufAmount+oz,
							//ind,
							&(fluidData[ind]),
							&(extraData[ind])
							//,doFW
						);
					}
				}
			}
			
			
		}
		
		singleton->refreshPaths = false;
		singleton->gameLogic->testPath.searchedForPath = false;
	}
void GameFluid::prereadFluidData ()
                                {
		
		GamePageHolder* curHolder;
		
		int i;
		int j;
		int k;
		int q;
		
		int ox = readMIP.getIX()/cellsPerHolder;
		int oy = readMIP.getIY()/cellsPerHolder;
		int oz = readMIP.getIZ()/cellsPerHolder;
		
		int maxVal = (volSizePrimBuf/cellsPerHolder) + 2;
		
		
		
		for (k = -2; k < maxVal; k++) {
			
			for (j = -2; j < maxVal; j++) {
				
				for (i = -2; i < maxVal; i++) {
					
					
					curHolder = singleton->gw->getHolderAtCoords(
						i+ox,
						j+oy,
						k+oz,
						true
					);
					
					if (curHolder->wasGenerated) {
						
					}
					else {
						
						curHolder->genCellData();
						
					}
				}
			}
		}
		
		
		
		
		
	}
void GameFluid::readFluidData ()
                             {
		
		int i;
		int j;
		int k;
		int q;
		
		
		int ind;
		int ind2;
		
		
		
		for (i = 0; i < totSize; i++) {
			ind = i*4;
			
			for (q = 0; q < 4; q++) {
				fluidData[ind+q] = UNIT_MIN;
				extraData[ind+q] = UNIT_MIN;
			}
			fluidData[ind+E_PTT_TER] = UNIT_MAX;
			
		}
		
		
		
		
		for (k = vspMin; k < vspMax; k++) {
			
			for (j = vspMin; j < vspMax; j++) {
				
				for (i = vspMin; i < vspMax; i++) {
					
					
					ind = (i + j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf)*4;
					
					singleton->gw->getArrAtCoords(
						(i-bufAmount)+readMIP.getIX(),
						(j-bufAmount)+readMIP.getIY(),
						(k-bufAmount)+readMIP.getIZ(),
						&(fluidData[ind]),
						&(extraData[ind])
					);
					
					
				}
				
				
			}
		}
		
		
	}
void GameFluid::applyMods ()
                         {
		while (modStack.size() > 0) {
			applyUnitModification(
				&(modStack.back().basePos),
				modStack.back().brushAction,
				modStack.back().modType,
				modStack.back().radius
			);
			modStack.pop_back();
		}
	}
bool GameFluid::passesCheck (int n)
                                {
		
		// true; // 
		return (getICISize(n) != 0); //fsVec[n].idealCellIds.size()
	}
bool GameFluid::updateFluidData ()
                               {
		
		// rrrr
		
		//maxDirtyRegion(); // todo: utilize dirty regions instad?
		
		int indAbove;
		int indBelow;
		int indSrc;
		
		int i;
		int j;
		int k;
		int c;
		int dir;
		int n;
		int p;
		int q;
		
		int tempv;
		
		int testInd;
		int testInd2;
		int testInd3;
		int testI;
		int testJ;
		int testK;
		
		int numCells;
		
		int ind;
		int ind2;
		
		int totWat;
		
		float fVSP = volSizePrimBuf;
		
		bool doProc;
		
		float fi;
		float fj;
		float fk;
		
		int ox;
		int oy;
		int oz;
		
		int curId;
		int tempi;
		
		int* bldVal;
		int* terVal;
		int* watVal;
		int* watVal2;
		int* watVal3;
		int* terVal2;
		int* bldVal2;
		int* ideVal;
		int* edgVal;
		
		int curCollectedWater;
		
		int fluidBodyCount;
		
		
		// k is largest at the top
		
		bool bTouchesAir;
		
		// float fSimp[4];
		// int iSimp[4];
		
		float disFromTop;
		float disFromBot;
		float spanZ;
		float minZ;
		float maxZ;
		
		float maxDif = 1.0f/4.0f;// /8.0f;
		
		float zv;
		
		bool isAir;
		bool isEmptyWater;
		bool didPrint = false;
		
		bool isInBounds;
		
		int minV0 = 0;//min( ((curTick)*totSize)/maxTicks, totSize-1 );
		int minV1 = totSize;//min( ((curTick+1)*totSize)/maxTicks, totSize-1 );
		
		
		
		if (hasRead) {
			
		}
		else {
			return false;
		}
		
		
		//if (curTick == 0) {
			// clear water ids and edges
			for (i = 0; i < totSize; i++) {
				ind = i;
				extraData[ind*4+E_PTT_IDE] = 0;
				extraData[ind*4+E_PTT_STB] = 0;
				fluidData[ind*4+E_PTT_LST] = fluidData[ind*4+E_PTT_WAT];
			}
			
			// for (i = 0; i < fsVec.size(); i++) {
			// 	fsVec[i].fluidIds.clear();
			// 	fsVec[i].idealCellIds.clear();
			// }
			fsVec.clear();
			
			// for (i = 0; i < fsPlaneVec.size(); i++) {
			// 	fsPlaneVec[i].fluidIds.clear();
			// }
			// fsPlaneVec.clear();
			
			
			
		//}
		
		
		
		
		// find the immobile height
		bool notFound = true;
		ind = 0;
		immobileHeight = 0;
		while (notFound && (ind < totSize)) {
			watVal = &(fluidData[ind*4+E_PTT_WAT]);
			bldVal = &(extraData[ind*4+E_PTT_BLD]);
			terVal = &(fluidData[ind*4+E_PTT_TER]);
			
			if (
				(*watVal > UNIT_MIN) ||
				(*bldVal > UNIT_MIN) ||
				(*terVal > UNIT_MIN)
			) {
				ind++;
			}
			else {
				notFound = false;
			}
		}
		immobileHeight = max((ind/(volSizePrimBuf*volSizePrimBuf)),0);
		immobileInd = immobileHeight*(volSizePrimBuf*volSizePrimBuf);
		
		
		// find the max water height
		notFound = true;
		ind = totSize-1;
		maxWaterHeight = 0;
		while (notFound && (ind >= 0)) {
			watVal = &(fluidData[ind*4+E_PTT_WAT]);
			
			if (*watVal != UNIT_MIN) {
				notFound = false;
			}
			else {
				ind--;
			}
		}
		maxWaterHeight = (ind/(volSizePrimBuf*volSizePrimBuf));
		maxWaterInd = ind;//maxWaterHeight*(volSizePrimBuf*volSizePrimBuf);
		
		
		if ((maxWaterHeight - immobileHeight) <= 1) {
			
			tempMin2.setFXYZ(0,0,0);
			tempMax2.setFXYZ(volSizePrimBuf,volSizePrimBuf,maxWaterHeight+1);
			
			
			return false;
		}
		
		
		minV0 = immobileInd;
		minV1 = maxWaterInd;
		
		
		
		
		// add zero water above all existing water
		
		// p = max(
		// 	immobileInd - volSizePrimBuf*volSizePrimBuf,
		// 	0
		// );
		
		// for (i = p; i <= minV1; i++) {
		// 	ind = i;
		// 	indAbove = i + volSizePrimBuf*volSizePrimBuf;
			
		// 	if (indAbove < totSize) {
		// 		watVal = &(fluidData[ind*4+E_PTT_WAT]);
				
		// 		watVal2 = &(fluidData[indAbove*4+E_PTT_WAT]);
		// 		terVal = &(fluidData[indAbove*4+E_PTT_TER]);
		// 		bldVal = &(extraData[indAbove*4+E_PTT_BLD]);
				
		// 		if (
		// 			(*watVal > 0) &&
		// 			(*watVal2 == UNIT_MIN) &&
		// 			(*terVal == UNIT_MIN) &&
		// 			(*bldVal == UNIT_MIN)
		// 		) {
		// 			*watVal2 = 0;
		// 		}
		// 	}
		// }
		
		
		
		
		
		// find stable regions
		fluidBodyCount = 1;
		for (i = minV0; i <= minV1; i++) {
			ind = i;
			
			
			watVal = &(fluidData[ind*4+E_PTT_WAT]);
			ideVal = &(extraData[ind*4+E_PTT_STB]);
			
			if (
				(*watVal >= 0) &&
				(*ideVal == 0)
			) {
				
				if (findStableRegions(ind,fluidBodyCount)) {
					fluidBodyCount++;
				}
			}
		}
		
		
		
		
		// flood fill water ids
		fluidBodyCount = 1;
		for (i = minV0; i <= minV1; i++) {
			ind = i;
			
			watVal = &(fluidData[ind*4+E_PTT_WAT]);
			ideVal = &(extraData[ind*4+E_PTT_IDE]);
			
			if (
				(*watVal >= 0) &&
				(*ideVal == 0)
			) {
				
				if (floodFillId(ind,fluidBodyCount)) {
					
					//if (fsVec.back().minZ > vspMin) {
					//	sort(fsVec.back().fluidIds.begin(), fsVec.back().fluidIds.end());
					//}
					
					
					// int intArray[SIZE] = {5, 3, 32, -1, 1, 104, 53};
					// sort(intArray, intArray + SIZE);
					
					j = fsVec.size()-1;
					
					sort(fidGetBeg(j),fidGetEnd(j));
					
					fluidBodyCount++;
				}
				
			}
			
		}
		
		
		
		
		
		
		// find most ideal areas to distribute water
		for (n = 0; n < fsVec.size(); n++) {
			
			spanZ = fsVec[n].maxZ - fsVec[n].minZ;
			
			#ifdef DEBUG_BOUNDS
			isInBounds = false;
			#endif
			
			for (p = 0; p < getFIDSize(n); p++) { //fsVec[n].fluidIds.size()
				ind = getFluidId(n,p);//fsVec[n].fluidIds[p];
				
				k = ind/(volSizePrimBuf*volSizePrimBuf);
				j = (ind - k*volSizePrimBuf*volSizePrimBuf)/volSizePrimBuf;
				i = ind - ( j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf );
				
				#ifdef DEBUG_BOUNDS
				isInBounds = isInBounds||inBounds(i,j,k);
				#endif
				
				
				bldVal = &(extraData[ind*4+E_PTT_BLD]);
				terVal = &(fluidData[ind*4+E_PTT_TER]);
				watVal = &(fluidData[ind*4+E_PTT_WAT]);
				
				isAir = 
					(*watVal == UNIT_MIN) &&
					(*bldVal == UNIT_MIN) &&
					(*terVal == UNIT_MIN);
				
				isEmptyWater = (*watVal == 0);
				
				#ifdef DEBUG_BOUNDS
				if (isInBounds) {
					if (isAir) {cout << "isAir\n";}
					cout << "watVal " << *watVal << "\n";
				}
				#endif
				
				
				if (
					isAir
					// && ((k != fsVec[n].maxZ)||(spanZ==1)) // water on top is not ideal for redist
				) {
					// check for water above
					testInd = ind + (volSizePrimBuf*volSizePrimBuf);
					watVal2 = &(fluidData[testInd*4+E_PTT_WAT]);
					
					if (*watVal2 > 0) {
						iciPushBack(n,ind);
						//fsVec[n].idealCellIds.push_back(ind);
					}
					else {
						for (dir = 0; dir < 4; dir++) {
							testI = (i+DIR_VECS_I[dir][0]);
							testJ = (j+DIR_VECS_I[dir][1]);
							testK = (k+DIR_VECS_I[dir][2]);
							testInd2 = 
								testI +
								testJ*volSizePrimBuf +
								testK*volSizePrimBuf*volSizePrimBuf;
							
							watVal3 = &(fluidData[testInd2*4+E_PTT_WAT]);
							
							// has (partially) full water cell to side
							if (*watVal3 >= 0) {
								
								// if unit below that one is earth
								testInd3 = testInd2 - volSizePrimBuf*volSizePrimBuf;
								if (
									(fluidData[testInd3*4+E_PTT_TER] > UNIT_MIN) ||
									(extraData[testInd3*4+E_PTT_BLD] > UNIT_MIN)
									// || (fluidData[testInd3*4+E_PTT_WAT] == UNIT_MIN)
								) {
									iciPushBack(n,ind);
									//fsVec[n].idealCellIds.push_back(ind);
									break;
								}
							}
						}
					}
				}
			}
			
			#ifdef DEBUG_BOUNDS
			if (isInBounds) {
				didPrint = true;
				cout << "cells considered " << getFIDSize(n) << "\n"; //fsVec[n].fluidIds.size()
				cout << "cells pushed " << getICISize(n) << "\n"; //fsVec[n].idealCellIds.size()
			}
			#endif
			
			
		}
		
		
		
		
		
		// if no ideal spots exist, find next most ideal spots
		for (n = 0; n < fsVec.size(); n++) {
			
			spanZ = fsVec[n].maxZ - fsVec[n].minZ;
			
			#ifdef DEBUG_BOUNDS
			isInBounds = false;
			#endif
			
			if (passesCheck(n)) {
				
			}
			else {
				for (p = 0; p < getFIDSize(n); p++) { //fsVec[n].fluidIds.size()
					ind = getFluidId(n,p);//fsVec[n].fluidIds[p];
					
					k = ind/(volSizePrimBuf*volSizePrimBuf);
					j = (ind - k*volSizePrimBuf*volSizePrimBuf)/volSizePrimBuf;
					i = ind - ( j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf );
					
					bldVal = &(extraData[ind*4+E_PTT_BLD]);
					terVal = &(fluidData[ind*4+E_PTT_TER]);
					watVal = &(fluidData[ind*4+E_PTT_WAT]);
					
					isAir = 
						(*watVal == UNIT_MIN) &&
						(*bldVal == UNIT_MIN) &&
						(*terVal == UNIT_MIN);
					
					isEmptyWater = (*watVal == 0);
					
					
					if (
						isAir
						// && ((k != fsVec[n].maxZ)||(spanZ==1)) // water on top is not ideal for redist
					) {
						// check for water above
						testInd = ind + (volSizePrimBuf*volSizePrimBuf);
						watVal2 = &(fluidData[testInd*4+E_PTT_WAT]);
						
						if (*watVal2 > 0) {
							iciPushBack(n,ind);
							//fsVec[n].idealCellIds.push_back(ind);
						}
						else {
							for (dir = 0; dir < 4; dir++) {
								testI = (i+DIR_VECS_I[dir][0]);
								testJ = (j+DIR_VECS_I[dir][1]);
								testK = (k+DIR_VECS_I[dir][2]);
								testInd2 = 
									testI +
									testJ*volSizePrimBuf +
									testK*volSizePrimBuf*volSizePrimBuf;
								
								watVal3 = &(fluidData[testInd2*4+E_PTT_WAT]);
								
								// has (partially) full water cell to side
								if (*watVal3 >= 0) {
									
									// if unit below that one is earth < IGNORED FOR THIS PASS
									// testInd3 = testInd2 - volSizePrimBuf*volSizePrimBuf;
									// if (
									// 	(fluidData[testInd3*4+E_PTT_TER] > UNIT_MIN) ||
									// 	(extraData[testInd3*4+E_PTT_BLD] > UNIT_MIN)
									// 	// || (fluidData[testInd3*4+E_PTT_WAT] == UNIT_MIN)
									// ) {
										iciPushBack(n,ind);
										//fsVec[n].idealCellIds.push_back(ind);
										break;
									//}
								}
							}
						}
					}
				}
			}
			
			
			
		}
		
		
		
		
	
		// remove water from top of fluid body (and only the very top)
		for (n = 0; n < fsVec.size(); n++) {
			
			if (passesCheck(n)) {
				fsVec[n].collectedWater = 0;
				curCollectedWater = 0;
				
				minZ = fsVec[n].minZ;
				maxZ = fsVec[n].maxZ;
				spanZ = maxZ-minZ;
				
				#ifdef DEBUG_BOUNDS
				isInBounds = false;
				#endif
				
				totWat = 0;
				
				for (p = 0; p < getFIDSize(n); p++) { //fsVec[n].fluidIds.size()
					ind = getFluidId(n,p);//fsVec[n].fluidIds[p];
					
					k = ind/(volSizePrimBuf*volSizePrimBuf);
					j = (ind - k*volSizePrimBuf*volSizePrimBuf)/volSizePrimBuf;
					i = ind - ( j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf );
					
					#ifdef DEBUG_BOUNDS
					isInBounds = isInBounds||inBounds(i,j,k);
					#endif
					
					fk = k;
					
					
					
					if (fk >= (maxZ-1.0f)) {
						watVal = &(fluidData[ind*4+E_PTT_WAT]);
						if ((*watVal) > 0) {
							curCollectedWater = (*watVal);
							*watVal -= curCollectedWater;
							fsVec[n].collectedWater += curCollectedWater;
						}
					}
					// else {
						
					// 	disFromBot = (fk-minZ)/(spanZ);
					// 	disFromTop = 1.0f - disFromBot;
						
					// 	disFromBot = mixf(0.25,0.75,disFromBot);
					// 	disFromTop = mixf(0.25,0.75,disFromTop);
						
					// 	if (spanZ <= 3.0f) {
					// 		disFromBot = 1.0f;
					// 	}
						
						
					// 	//terVal = &(fluidData[ind*4+E_PTT_TER]);
					// 	watVal = &(fluidData[ind*4+E_PTT_WAT]);
					// 	//ideVal = &(extraData[ind*4+E_PTT_IDE]);
						
					// 	totWat += max(*watVal,0);
						
					// 	// make sure no water is above or that there is earth above
					// 	testInd = ind + (volSizePrimBuf*volSizePrimBuf);
					// 	watVal2 = &(fluidData[testInd*4+E_PTT_WAT]);
					// 	terVal2 = &(fluidData[testInd*4+E_PTT_TER]);
					// 	bldVal2 = &(extraData[testInd*4+E_PTT_BLD]);
						
					// 	if (
					// 		(*watVal > 0) &&
					// 		(
					// 			(*watVal2 == UNIT_MIN) || // todo: examine this
					// 			(*terVal2 != UNIT_MIN) ||
					// 			(*bldVal2 != UNIT_MIN)
					// 		)
					// 	) {
					// 		curCollectedWater = 
					// 			min(
					// 				((int)(disFromBot*F_UNIT_MAX*maxDif + 1.0f)),
					// 				*watVal
					// 			);
					// 		*watVal -= curCollectedWater;
					// 		fsVec[n].collectedWater += curCollectedWater;
					// 	}
						
					// }
					
					
					
					
					
					
					
					
					
				}
				
				
				
				// cout << "fsVec[n].collectedWater " << fsVec[n].collectedWater << "\n";
				
				// if (fsVec[n].collectedWater == 0) {
				// 	cout << "fsVec[n].fluidIds.size() " << getFIDSize(n) << "\n"; //fsVec[n].fluidIds.size()
				// }
				
				
				
				#ifdef DEBUG_BOUNDS
				if (isInBounds) {
					didPrint = true;
					cout << "totWat " << totWat << "\n";
					cout << "fsVec[n].collectedWater " << fsVec[n].collectedWater << "\n";
				}
				#endif
				
			}
			
			fsVec[n].didCollectWater = (fsVec[n].collectedWater > 0);
			
		}
		
		
		
		
		
		// add water to ideal spots
		for (n = 0; n < fsVec.size(); n++) {
			
			numCells = getICISize(n);//fsVec[n].idealCellIds.size();
			
			if (numCells > 0) {
				
				for (p = 0; p < numCells; p++) {
					ind = getIdealCellId(n,p);//fsVec[n].idealCellIds[p];
					watVal = &(fluidData[ind*4+E_PTT_WAT]);
					
					if (*watVal == UNIT_MIN) {
						*watVal = 0;
					}
				}
				
				
				
				if ( (fsVec[n].collectedWater/numCells) > UNIT_MAX ) {
					curCollectedWater = UNIT_MAX;
				}
				else {
					curCollectedWater = fsVec[n].collectedWater/numCells;
				}
				
				//cout << "curCollectedWater " << curCollectedWater << "\n";
				
				curCollectedWater = curCollectedWater*maxDif;
				
				#ifdef DEBUG_BOUNDS
				isInBounds = false;
				#endif
				
				
				for (p = 0; p < numCells; p++) {
					ind = getIdealCellId(n,p);//fsVec[n].idealCellIds[p];
					
					k = ind/(volSizePrimBuf*volSizePrimBuf);
					j = (ind - k*volSizePrimBuf*volSizePrimBuf)/volSizePrimBuf;
					i = ind - ( j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf );
					
					#ifdef DEBUG_BOUNDS
					isInBounds = isInBounds||inBounds(i,j,k);
					#endif
					
					
					watVal = &(fluidData[ind*4+E_PTT_WAT]);
					
					
					if (curCollectedWater > 0) {
						
						tempi = min(UNIT_MAX - *watVal,curCollectedWater);
						
						*watVal += tempi;
						fsVec[n].collectedWater -= tempi;
					}
					
					
					
					
					
					
					if (fsVec[n].collectedWater <= 0) {
						break;
					}
					
				}
				
				#ifdef DEBUG_BOUNDS
				if (isInBounds) {
					didPrint = true;
					cout << "dist water " << fsVec[n].collectedWater << "\n\n";
				}
				#endif
				
			}
		}
		
		
		
		
		// add water to bottom of fluid body
		for (n = 0; n < fsVec.size(); n++) {
			
			if (passesCheck(n)) {
				curCollectedWater = 0;
				minZ = fsVec[n].minZ;
				
				
				while (fsVec[n].collectedWater > 0) {
					
					
					//for (q = fsVec[n].minZ; q <= fsVec[n].maxZ; q++) {
						for (p = 0; p < getFIDSize(n); p++) { //fsVec[n].fluidIds.size()
							ind = getFluidId(n,p);//fsVec[n].fluidIds[p];
							
							k = ind/(volSizePrimBuf*volSizePrimBuf);
							watVal = &(fluidData[ind*4+E_PTT_WAT]);
							
							//if (k == q) {
								
								if (fsVec[n].collectedWater > UNIT_MAX) {
									tempv = UNIT_MAX;
								}
								else {
									tempv = fsVec[n].collectedWater;
								}
								
								//if (fluidData[ind*4+E_PTT_TER] == UNIT_MIN) {
									
									curCollectedWater = min(
										((int)((UNIT_MAX - max(*watVal,0) )*maxDif + 1.0f )),
										tempv
									);
									
									if (curCollectedWater > 0) {
										if (*watVal == UNIT_MIN) {
											*watVal = 0;
										}
										
										tempi = min(UNIT_MAX - *watVal,curCollectedWater);
										
										*watVal += tempi;
										fsVec[n].collectedWater -= tempi;
									}
									
								//}
							//}
							
							
							// out of water, break both parent loops
							if (fsVec[n].collectedWater <= 0) {
								break;
								//p = fsVec[n].fluidIds.size() + 1;
								//q = fsVec[n].maxZ + 1;
							}
						}
					//}
				}
			}
		}
		
		if (didPrint) {
			watchMinX = -1;
		}
		
		
		// curTick++;
		// if (curTick == maxTicks) {
		// 	curTick = 0;
		// }
		
		
		
		/////////////
		
		
		tempMax.setFXYZ(vspMin);
		tempMin.setFXYZ(vspMax);
		
		tempMax2.setFXYZ(vspMin);
		tempMin2.setFXYZ(vspMax);
		
		for (n = 0; n < fsVec.size(); n++) {
			
			minV.setIXYZ(fsVec[n].minX,fsVec[n].minY,fsVec[n].minZ);
			maxV.setIXYZ(fsVec[n].maxX,fsVec[n].maxY,fsVec[n].maxZ);
			
			if (
				
				passesCheck(n)
				
				// || (
				// 	(fsVec[n].fluidIds.size() > 0) &&
				// 	(fsVec[n].fluidIds.size() < 8)
				// )
				
			) {
				FIVector4::growBoundary(&tempMin,&tempMax,&minV,&maxV);
			}
			
			FIVector4::growBoundary(&tempMin2,&tempMax2,&minV,&maxV);
		}
		
		tempMin.addXYZ(-1.0f);
		tempMax.addXYZ(1.0f);
		
		
		if (maxWaterHeight > 0) {
			minV.setIXYZ(0,0,0);
			maxV.setIXYZ(cellsPerHolder,cellsPerHolder,maxWaterHeight);
			FIVector4::growBoundary(&tempMin2,&tempMax2,&minV,&maxV);
		}
		
		
		
		FIVector4::growBoundary(&dirtyMin,&dirtyMax,&tempMin,&tempMax);
		
		//dirtyMin.setFZ(max(dirtyMin[2],(float)(immobileHeight)));
		
		
		
		
		// sink water into immobile area
		
		// int kMin = clamp(immobileHeight, vspMin, vspMax);
		// int kMax = clamp(immobileHeight+1, vspMin, vspMax);
		
		// k = immobileHeight;
		
		// for (k = kMin; k < kMax; k++) {
		// 	for (j = vspMin; j < vspMax; j++) {
		// 		for (i = vspMin; i < vspMax; i++) {
		// 			indSrc = (i + j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf);
		// 			indAbove = indSrc + volSizePrimBuf*volSizePrimBuf;
					
		// 			watVal = &(fluidData[indSrc*4 + E_PTT_WAT]);
		// 			watVal2 = &(fluidData[indAbove*4 + E_PTT_WAT]);
					
		// 			if ((*watVal) > UNIT_MIN) {
		// 				if ((*watVal2) <= 0) {
		// 					(*watVal2) = UNIT_MIN;
		// 				}
		// 				else {
							
		// 					curCollectedWater = 0;
							
		// 					if ((*watVal2) == 1) {
		// 						curCollectedWater = 1;
		// 					}
		// 					else {
		// 						curCollectedWater = (*watVal2)/2;
		// 					}
							
		// 					if (curCollectedWater >= 1) {
		// 						if (((*watVal) + curCollectedWater) < UNIT_MAX) {
		// 							*watVal2 = UNIT_MIN;
		// 							*watVal += curCollectedWater;
		// 						}
		// 					}
							
		// 				}
		// 			}
		// 		}
		// 	}
		// }
		
		// todo: expand water within immobile area if necessary
		
		
		
		// int iMin = clamp(tempMin.getIX(), vspMin, vspMax);
		// int iMax = clamp(tempMax.getIX(), vspMin, vspMax);
		// int jMin = clamp(tempMin.getIY(), vspMin, vspMax);
		// int jMax = clamp(tempMax.getIY(), vspMin, vspMax);
		// int kMin = clamp(tempMin.getIZ(), vspMin, vspMax);
		// int kMax = clamp(tempMax.getIZ(), vspMin, vspMax);
		
		
		// int iMin2 = vspMax;
		// int iMax2 = vspMin;
		// int jMin2 = vspMax;
		// int jMax2 = vspMin;
		// int kMin2 = vspMax;
		// int kMax2 = vspMin;
		
		
		// for (k = kMin; k <= kMax; k++) {
		// 	for (j = jMin; j <= jMax; j++) {
		// 		for (i = iMin; i <= iMax; i++) {
		// 			indSrc = (i + j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf)*4;
		
		
		// for (p = 0; p < (totSize - volSizePrimBuf); p++) {
		// 	ind = p;
		// 	indAbove = p + volSizePrimBuf*volSizePrimBuf;
			
		// 	k = ind/(volSizePrimBuf*volSizePrimBuf);
		// 	j = (ind - k*volSizePrimBuf*volSizePrimBuf)/volSizePrimBuf;
		// 	i = ind - ( j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf );
		
		// 			if (
					
		// 				fluidData[ind*4 + E_PTT_WAT] != fluidData[ind*4 + E_PTT_LST]
						
		// 			) {
						
		// 				// if (fluidData[indSrc + E_PTT_LST] < fluidData[indSrc + E_PTT_WAT]) {
		// 				// 	fluidData[indSrc + E_PTT_LST]++;
		// 				// }
		// 				// if (fluidData[indSrc + E_PTT_LST] > fluidData[indSrc + E_PTT_WAT]) {
		// 				// 	fluidData[indSrc + E_PTT_LST]--;
		// 				// }
						
		// 				if (i < iMin2) {iMin2 = i;}
		// 				if (j < jMin2) {jMin2 = j;}
		// 				if (k < kMin2) {kMin2 = k;}
		// 				if (i > iMax2) {iMax2 = i;}
		// 				if (j > jMax2) {jMax2 = j;}
		// 				if (k > kMax2) {kMax2 = k;}
						
		// 			}
		// }
		// 		}
		// 	}
		// }
		
		// minV.setIXYZ(iMin2,jMin2,kMin2);
		// maxV.setIXYZ(iMax2,jMax2,kMax2);
		// FIVector4::growBoundary(&dirtyMin,&dirtyMax,&minV,&maxV);
		
		
		return true;
		
	}
bool GameFluid::findStableRegions (int startInd, int newId)
                                                        {
		indexStack.clear();
		indexStack.push_back(startInd);
		
		int dir;
		
		int ind;
		int testInd;
		int testInd2;
		int* bldVal;
		int* bldVal2;
		int* terVal;
		int* terVal2;
		int* watVal;
		int* watVal2;
		int* ideVal;
		
		int i;
		int j;
		int k;
		int n;
		
		
		int foundInd;
		
		int testI;
		int testJ;
		int testK;
		
		bool notFound;
		bool isAir;
		bool terBelow;
		
		int watCount;
		int maxSize;
		
		long long int totWat;
		long long int totWat2;
		long long int divWat;
		
		fluidPlane.planeIds.clear();
		
		int emptyWaterCount = 0;
		int airCount = 0;
		int targWat;
		
		while (indexStack.size() > 0) {
			
			ind = indexStack.back();
			extraData[ind*4+E_PTT_STB] = newId;
			fluidPlane.planeIds.push_back(ind);
			
			if (fluidData[ind*4+E_PTT_WAT] == 0) {
				emptyWaterCount++;
			}
			
			
			k = ind/(volSizePrimBuf*volSizePrimBuf);
			j = (ind - k*volSizePrimBuf*volSizePrimBuf)/volSizePrimBuf;
			i = ind - ( j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf );
						
			
			foundInd = -1;
			
			for (dir = 0; dir < 4; dir++) {
				testI = (i+DIR_VECS_I[dir][0]);
				testJ = (j+DIR_VECS_I[dir][1]);
				testK = (k+DIR_VECS_I[dir][2]);
				testInd = 
					testI +
					testJ*volSizePrimBuf +
					testK*volSizePrimBuf*volSizePrimBuf;
				
				testInd2 = testInd - volSizePrimBuf*volSizePrimBuf;
				
				terVal = &(fluidData[testInd*4+E_PTT_TER]);
				watVal = &(fluidData[testInd*4+E_PTT_WAT]);
				ideVal = &(extraData[testInd*4+E_PTT_STB]);
				bldVal = &(extraData[testInd*4+E_PTT_BLD]);
				
				
				// isAir = 
				// 	(*watVal == UNIT_MIN) &&
				// 	(*terVal == UNIT_MIN) &&
				// 	(*bldVal == UNIT_MIN);
					
				//terVal2 = &(fluidData[testInd2*4+E_PTT_TER]);
				//watVal2 = &(fluidData[testInd2*4+E_PTT_WAT]);
				// terBelow = 
				// 	//(*watVal2 == UNIT_MIN) &&
				// 	(*terVal2 == UNIT_MIN);
				// if (isAir&&terBelow) {
				// 	airCount++;
				// }
				
				if (
					(*ideVal == 0) &&
					(*watVal >= 0)
				) {
					foundInd = testInd;
				}
			}
			
			if (foundInd >= 0) {
				indexStack.push_back(foundInd);
			}
			else {
				indexStack.pop_back();
			}
			
		}
		
		
		maxSize = fluidPlane.planeIds.size();
		
		
		
		if (
			(emptyWaterCount == maxSize)
			// && (airCount == 0)	
		) {
			// all fluid cells in this plane are empty,
			// and there are no adjacent air cells,
			// so get rid of all empty water cells
			
			
			for (i = 0; i < maxSize; i++) {
				ind = fluidPlane.planeIds[i];
				
				fluidData[ind*4+E_PTT_WAT] = UNIT_MIN;
			}
			
			fluidPlane.planeIds.clear();
			
		}
		else {
			
			
			/*
			
			
			// equalize fluid density in this plane
			
			if (maxSize > 0) {
				
				totWat = 0;
				for (i = 0; i < maxSize; i++) {
					ind = fluidPlane.planeIds[i];
					watVal = &(fluidData[ind*4+E_PTT_WAT]);
					totWat += *watVal;
				}
				
				divWat = maxSize;
				if (divWat > 0) {
					
					targWat = (totWat/divWat);
					
					if ( targWat > 0 ) {
						
						totWat2 = 0;
						for (i = 0; i < maxSize; i++) {
							ind = fluidPlane.planeIds[i];
							watVal = &(fluidData[ind*4+E_PTT_WAT]);
							*watVal += (targWat - *watVal)/2;
							totWat2 += *watVal;
						}
						
						i = 0;
						
						while (totWat > totWat2) {
							
							ind = fluidPlane.planeIds[i];
							watVal = &(fluidData[ind*4+E_PTT_WAT]);
							
							*watVal += 1;
							totWat2 += 1;
							
							i++;
							if (i==maxSize) { i = 0; }
							
						}
						
						while (totWat < totWat2) {
							
							ind = fluidPlane.planeIds[i];
							watVal = &(fluidData[ind*4+E_PTT_WAT]);
							
							*watVal -= 1;
							totWat2 -= 1;
							
							i++;
							if (i==maxSize) { i = 0; }
						}
						
					}
				}
				
			}
			
			
			
			
			
			
			*/
			
			
			
		}
		
		//fsPlaneVec.pop_back();
		
		if ( fluidPlane.planeIds.size() == 0 ) {
			
			return false;
		}
		else {
			return true;
		}
		
		
		
	}
bool GameFluid::floodFillId (int startInd, int newId)
                                                  {
		
		indexStack.clear();
		indexStack.push_back(startInd);
		
		int dir;
		
		int ind;
		int testInd;
		int* bldVal;
		int* terVal;
		int* watVal;
		int* watVal2;
		int* ideVal;
		
		int i;
		int j;
		int k;
		int n;
		
		
		int foundInd;
		
		int testI;
		int testJ;
		int testK;
		
		bool notFound;
		bool isAir;
		bool isEmptyWater;
		
		fsVec.push_back(FluidStruct());
		
		
		
		FluidStruct* fsPtr = &(fsVec.back());
		FluidStruct* fsPtrLast;
		
		int groupId = fsVec.size()-1;
		
		
		if (groupId == 0) {
			fsPtr->fidBegInd = 0;
			fsPtr->fidEndInd = 0;
			fsPtr->iciBegInd = 0;
			fsPtr->iciBegInd = 0;
		}
		else {
			fsPtrLast = &(fsVec[groupId-1]);
			
			fsPtr->fidBegInd = fsPtrLast->fidEndInd;
			fsPtr->fidEndInd = fsPtrLast->fidEndInd;
			fsPtr->iciBegInd = fsPtrLast->iciEndInd;
			fsPtr->iciBegInd = fsPtrLast->iciEndInd;
		}
		
		fsPtr->minX = volSizePrimBuf*2;
		fsPtr->minY = volSizePrimBuf*2;
		fsPtr->minZ = volSizePrimBuf*2;
		fsPtr->maxX = -volSizePrimBuf*2;
		fsPtr->maxY = -volSizePrimBuf*2;
		fsPtr->maxZ = -volSizePrimBuf*2;
		
		while (indexStack.size() > 0) {
			
			ind = indexStack.back();
			extraData[ind*4+E_PTT_IDE] = newId;
			
			k = ind/(volSizePrimBuf*volSizePrimBuf);
			j = (ind - k*volSizePrimBuf*volSizePrimBuf)/volSizePrimBuf;
			i = ind - ( j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf );
			
			watVal2 = &(fluidData[ind*4+E_PTT_WAT]);
			
			notFound = true;
			
			if (k > immobileHeight) {
				if (*watVal2 < UNIT_MAX) {
					// if water is partially filled, add to fluidId stack
					fidPushBack(groupId,ind); //fsPtr->fluidIds.push_back(ind);
					notFound = false;
				}
				else {
					// if its full and there is earth above, add it
					testInd = ind + volSizePrimBuf*volSizePrimBuf;
					
					if (
						(fluidData[testInd*4+E_PTT_TER] != UNIT_MIN) ||
						(extraData[testInd*4+E_PTT_BLD] != UNIT_MIN)	
					) {
						fidPushBack(groupId,ind); //fsPtr->fluidIds.push_back(ind);
						notFound = false;
					}
					
				}
			}
			
			
			foundInd = -1;
			
			
			for (dir = 0; dir < 6; dir++) {
				testI = (i+DIR_VECS_I[dir][0]);
				testJ = (j+DIR_VECS_I[dir][1]);
				testK = (k+DIR_VECS_I[dir][2]);
				testInd = 
					testI +
					testJ*volSizePrimBuf +
					testK*volSizePrimBuf*volSizePrimBuf;
				
				
				if (testK > immobileHeight) {
					bldVal = &(extraData[testInd*4+E_PTT_BLD]);
					terVal = &(fluidData[testInd*4+E_PTT_TER]);
					watVal = &(fluidData[testInd*4+E_PTT_WAT]);
					ideVal = &(extraData[testInd*4+E_PTT_IDE]);
					
					isAir = 
						(*watVal == UNIT_MIN) &&
						(*terVal == UNIT_MIN) &&
						(*bldVal == UNIT_MIN);
					
					isEmptyWater = (*watVal == 0);
					
					// check if water touches air or an empty water cell, if so add to fluidId stack
					if (
						(isAir||isEmptyWater)	&&
						notFound
					) {
						fidPushBack(groupId,ind); //fsPtr->fluidIds.push_back(ind);
						notFound = false;
					}
					
					if (*ideVal == 0) {
						if (isAir) {
							// it is an unmarked air value or empty water cell adjacent to a water cell
							// push back immediately without growing main stack
							
							fidPushBack(groupId,testInd); //fsPtr->fluidIds.push_back(testInd);
							*ideVal = newId;
							
						}
						
						if (*watVal >= 0) {
							foundInd = testInd;
						}
						
					}
				}
			}
			
			if (foundInd >= 0) {
				indexStack.push_back(foundInd);
			}
			else {
				indexStack.pop_back();
			}
			
		}
		
		
		for (n = 0; n < getFIDSize(groupId); n++) { //fsPtr->fluidIds.size()
			
			ind = getFluidId(groupId,n); //fsPtr->fluidIds[n];
			
			k = ind/(volSizePrimBuf*volSizePrimBuf);
			j = (ind - k*volSizePrimBuf*volSizePrimBuf)/volSizePrimBuf;
			i = ind - ( j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf );
			
			bldVal = &(extraData[ind*4+E_PTT_BLD]);
			terVal = &(fluidData[ind*4+E_PTT_TER]);
			watVal = &(fluidData[ind*4+E_PTT_WAT]);
			
			// remove ids from any air values so they can be reused
			if (
				(*watVal == UNIT_MIN) &&
				(*terVal == UNIT_MIN) &&
				(*bldVal == UNIT_MIN)
			) {
				extraData[ind*4+E_PTT_IDE] = 0;
			}
			
			//fluidData[ind*4+E_PTT_EDG] = UNIT_MAX;
			
			
			if (i < fsPtr->minX) {fsPtr->minX = i;}
			if (j < fsPtr->minY) {fsPtr->minY = j;}
			if (k < fsPtr->minZ) {fsPtr->minZ = k;}
			if (i > fsPtr->maxX) {fsPtr->maxX = i;}
			if (j > fsPtr->maxY) {fsPtr->maxY = j;}
			if (k > fsPtr->maxZ) {fsPtr->maxZ = k;}
			
		}
		
		if ( getFIDSize(groupId) == 0) { //fsPtr->fluidIds.size() 
			fsVec.pop_back();
			return false;
		}
		else {
			return true;
		}
		
	}
bool GameFluid::inBounds (int i, int j, int k)
                                           {
		return (
			(watchMinX >= 0) &&
			(i >= watchMinX) &&
			(i <= watchMaxX) &&
			(j >= watchMinY) &&
			(j <= watchMaxY) &&
			(k >= watchMinZ) &&
			(k <= watchMaxZ)
		);
	}
void GameFluid::modifyUnit (FIVector4 * fPixelWorldCoordsBase, int brushAction, int modType, int radius)
          {
		modStack.push_back(ModUnitStruct());
		modStack.back().basePos.copyFrom(fPixelWorldCoordsBase);
		modStack.back().brushAction = brushAction;
		modStack.back().modType = modType;
		modStack.back().radius = radius;
	}
void GameFluid::roundBox (FIVector4 * absVecFromCenter, FIVector4 * innerBoxRad, FIVector4 * cornerDisThicknessPower, bool & isInObj, bool & isInside)
          {
		
		//doTraceVecND("absVecFromCenter ", absVecFromCenter);
		//doTraceVecND("innerBoxRad ", innerBoxRad);
		
		
		FIVector4 newP;
		FIVector4 orig1;
		FIVector4 orig2;
		
		orig1.setFXYZ(0.0f,0.0f,0.0f);
		
		//vec3 newP = abs(max( absVecFromCenter-(box_dim.xyz),0.0));
		
		orig2.copyFrom(absVecFromCenter);
		orig2.addXYZRef(innerBoxRad,-1.0f);
		newP.maxXYZ(&orig2,&orig1);
		newP.absXYZ();
		
		float powX = cornerDisThicknessPower->getFZ();
		float powY = cornerDisThicknessPower->getFW();
		
		
		

		//newP.xy = pow(newP.xy, box_power.xx );
		newP.powXYZ(powX,powX,1.0f);		
		//newP.x = pow( newP.x + newP.y, 1.0/box_power.x );
		newP.setFX(newP[0] + newP[1]);
		newP.powXYZ(1.0/powX,1.0f,1.0f);

		//newP.xz = pow(newP.xz, box_power.yy );
		newP.powXYZ(powY,1.0f,powY);
		//newP.x = pow( newP.x + newP.z, 1.0/box_power.y );
		newP.setFX(newP[0] + newP[2]);
		newP.powXYZ(1.0/powY,1.0f,1.0f);
		
		//newP.setFX(newP.length());
		
		float rad = cornerDisThicknessPower->getFX();
		float wallThickness = cornerDisThicknessPower->getFY();
		
		// float dis = 
		// 	max(
		// 		(newP[0]-rad),
		// 		( (rad-wallThickness)-newP[0] )	 //newP[0] - (rad-wallThickness)
		// 	);
		
		// //cout << newP[0] << " - " << cornerDisThicknessPower->getFX() << " = " << dis << "\n";
		
		// return dis < 0.0f;
		
		isInObj = (newP[0]-rad) < 0.0f;
		isInside = (newP[0] - (rad-wallThickness)) < 0.0f;

	}
void GameFluid::clearAllGeom ()
                            {
		int i;
		int ind;
		for (i = 0; i < totSize; i++) {
			ind = i;
			extraData[ind*4+E_PTT_BLD] = UNIT_MIN;
		}
	}
void GameFluid::clearInsideValues ()
                                 {
		int i;
		int ind;
		for (i = 0; i < totSize; i++) {
			ind = i;
			if (extraData[ind*4+E_PTT_BLD] == UNIT_INSIDE) {
				extraData[ind*4+E_PTT_BLD] = UNIT_MIN;
			}
			
		}
	}
void GameFluid::fillCurrentGeom (int templateId, FIVector4 * templatePos)
                                                                     {
		
		
		
		
		int i;
		int j;
		int k;
		
		
		FIVector4* paramArrGeom = &(singleton->primTemplateStack[templateId*E_PRIMTEMP_LENGTH]);
		
		FIVector4 innerBoxRad;
		FIVector4 absVecFromCenter;
		//FIVector4 centerCoord;
		
		FIVector4 baseVec;
		baseVec.averageXYZ(
			&(paramArrGeom[E_PRIMTEMP_BOUNDSMIN]),
			&(paramArrGeom[E_PRIMTEMP_BOUNDSMAX])
		);
		baseVec.addXYZRef(templatePos);
		baseVec.addXYZRef(&(volMinReadyInPixels),-1.0f);
		baseVec.addXYZ(1.0f);
		
		FIVector4 curCoord;
		
		FIVector4 newCoordMin;
		FIVector4 newCoordMax;
		newCoordMin.copyFrom(&baseVec);
		newCoordMax.copyFrom(&baseVec);
		
		// centerCoord.averageXYZ(
		// 	&(paramArrGeom[E_PRIMTEMP_BOUNDSMAX]),
		// 	&(paramArrGeom[E_PRIMTEMP_BOUNDSMIN])
		// );
		innerBoxRad.averageNegXYZ(
			&(paramArrGeom[E_PRIMTEMP_BOUNDSMAX]),
			&(paramArrGeom[E_PRIMTEMP_BOUNDSMIN])
		);
		
		innerBoxRad.addXYZ(paramArrGeom[E_PRIMTEMP_CORNERDIS].getFX(),-1.0f);
		
		newCoordMin.addXYZRef(&(paramArrGeom[E_PRIMTEMP_VISMIN]));
		newCoordMax.addXYZRef(&(paramArrGeom[E_PRIMTEMP_VISMAX]));
		
		//newCoordMin.addXYZ(2.0f,2.0f,2.0f);
		//newCoordMax.addXYZ(2.0f,2.0f,2.0f);
		
		int iMin = clamp(newCoordMin.getIX(), vspMin, vspMax);
		int iMax = clamp(newCoordMax.getIX(), vspMin, vspMax);
		int jMin = clamp(newCoordMin.getIY(), vspMin, vspMax);
		int jMax = clamp(newCoordMax.getIY(), vspMin, vspMax);
		int kMin = clamp(newCoordMin.getIZ(), vspMin, vspMax);
		int kMax = clamp(newCoordMax.getIZ(), vspMin, vspMax);
		
		int* empVal;
		int* bldVal;
		int* terVal;
		int* watVal;
		
		int ind;
		
		bool isInObj;
		bool isInside;
		
		minV.setIXYZ(iMin,jMin,kMin);
		maxV.setIXYZ(iMax,jMax,kMax);
		FIVector4::growBoundary(&dirtyMin,&dirtyMax,&minV,&maxV);
		
		
		
		// cout << "cornerDis " << paramArrGeom[E_PRIMTEMP_CORNERDIS].getFX() << "\n";
		// doTraceVecND("E_PRIMTEMP_BOUNDSMIN ", &(paramArrGeom[E_PRIMTEMP_BOUNDSMIN]));
		// doTraceVecND("E_PRIMTEMP_BOUNDSMAX ", &(paramArrGeom[E_PRIMTEMP_BOUNDSMAX]));
		// doTraceVecND("innerBoxRad ", &innerBoxRad);
		
		for (k = kMin; k < kMax; k++) {
			for (j = jMin; j < jMax; j++) {
				for (i = iMin; i < iMax; i++) {
					
					curCoord.setFXYZ(i,j,k);
					curCoord.addXYZ(0.5f);
					absVecFromCenter.copyFrom(&curCoord);
					absVecFromCenter.addXYZRef(&baseVec,-1.0f);
					absVecFromCenter.absXYZ();
					
					roundBox(
						&absVecFromCenter,
						&innerBoxRad,
						&(paramArrGeom[E_PRIMTEMP_CORNERDIS]),
						isInObj,
						isInside
					);
					
					ind = (i + j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf);
					bldVal = &(extraData[ind*4+E_PTT_BLD]);
					terVal = &(fluidData[ind*4+E_PTT_TER]);
					watVal = &(fluidData[ind*4+E_PTT_WAT]);
					empVal = &(fluidData[ind*4+E_PTT_EMP]);
					
					if (*bldVal == UNIT_INSIDE) {
						
					}
					else {
						
						if (isInObj) {
							if (isInside) {
								*bldVal = UNIT_INSIDE;
							}
							else {
								*bldVal = UNIT_MAX;
								*watVal = UNIT_MIN; // todo: collect water for redist instead of destroying it
							}
							
						}
						else {
							
						}
					}
					
					
					*empVal = UNIT_MIN;
					
					// if (*bldVal == UNIT_MAX) {
					// 	*terVal = UNIT_MAX;
					// }
					// else {
					// 	*terVal = UNIT_MIN;
					// }
					
					
				}
			}
		}
		
		
		
	}
void GameFluid::resetDirtyRegion ()
                                {
		
		dirtyMax.setFXYZ(vspMin);
		dirtyMin.setFXYZ(vspMax);
	}
void GameFluid::shrinkDirtyRegion ()
                                 {
		
		if (shrinkCount == 4) {
			shrinkCount = 0;
			dirtyMax.addXYZ(-1.0f);
			dirtyMin.addXYZ(1.0f);
		}
		
		if (
			(dirtyMax[0] <= dirtyMin[0]) ||
			(dirtyMax[1] <= dirtyMin[1]) ||
			(dirtyMax[2] <= dirtyMin[2])
		) {
			resetDirtyRegion();
		}
		
		shrinkCount++;
	}
void GameFluid::maxDirtyRegion ()
                              {
		dirtyMax.setFXYZ(vspMax);
		dirtyMin.setFXYZ(vspMin);
	}
void GameFluid::applyUnitModification (FIVector4 * fPixelWorldCoordsBase, int brushAction, int modType, int radius)
          {
		
			
		
			FIVector4 baseVec;
			baseVec.copyFrom(fPixelWorldCoordsBase);
			baseVec.addXYZRef(&(volMinReadyInPixels),-1.0f);
			
			
			FIVector4 curCoord;
			
			FIVector4 newCoordMin;
			FIVector4 newCoordMax;
			newCoordMin.copyFrom(&baseVec);
			newCoordMax.copyFrom(&baseVec);
			
			
			newCoordMin.addXYZ(-radius + 1);
			newCoordMax.addXYZ( radius + 1);
			
			int iMin = clamp(newCoordMin.getIX(), vspMin, vspMax);
			int iMax = clamp(newCoordMax.getIX(), vspMin, vspMax);
			int jMin = clamp(newCoordMin.getIY(), vspMin, vspMax);
			int jMax = clamp(newCoordMax.getIY(), vspMin, vspMax);
			int kMin = clamp(newCoordMin.getIZ(), vspMin, vspMax);
			int kMax = clamp(newCoordMax.getIZ(), vspMin, vspMax);
			
			minV.setIXYZ(iMin,jMin,kMin);
			maxV.setIXYZ(iMax,jMax,kMax);
			FIVector4::growBoundary(&dirtyMin,&dirtyMax,&minV,&maxV);
			
			
			int i;
			int j;
			int k;
			
			int* empVal;
			int* bldVal;
			int* terVal;
			int* watVal;
			// int* ideVal;
			// int* stbVal;
			
			int ind;
			int ind2;
			
			int i2;
			int j2;
			int k2;
			
			int i3;
			int j3;
			int k3;
			
			bool touchesBuilding;
			
			for (k = kMin; k < kMax; k++) {
				for (j = jMin; j < jMax; j++) {
					for (i = iMin; i < iMax; i++) {
						
						curCoord.setFXYZ(i,j,k);
						
						if (baseVec.distance(&curCoord) <= radius) {
							
							
							ind = (i + j*volSizePrimBuf + k*volSizePrimBuf*volSizePrimBuf);
							
							bldVal = &(extraData[ind*4+E_PTT_BLD]);
							empVal = &(fluidData[ind*4+E_PTT_EMP]);
							terVal = &(fluidData[ind*4+E_PTT_TER]);
							watVal = &(fluidData[ind*4+E_PTT_WAT]);
							// ideVal = &(extraData[ind*4+E_PTT_IDE]);
							// stbVal = &(extraData[ind*4+E_PTT_STB]);
							
							switch (brushAction) {
								case E_BRUSH_MOVE:
									return;
								break;
								case E_BRUSH_ADD:
								
									if (modType == E_PTT_WAT) {
										//if (mainId == E_FID_SML) {
											if (
												(*terVal == UNIT_MIN) &&
												(*bldVal == UNIT_MIN)	
											) {
												*watVal = UNIT_MAX;
											}
										//}
									}
									else {
										*terVal = UNIT_MAX;
										*watVal = UNIT_MIN;
										*empVal = UNIT_MIN;
									}
									
									
									
								break;
								case E_BRUSH_SUB:
									
									// touchesBuilding = false;
									
									// for (k2 = -1; k2 <= 1; k2++) {
									// 	for (j2 = -1; j2 <= 1; j2++) {
									// 		for (i2 = -1; i2 <= 1; i2++) {
												
									// 			i3 = clamp(i+i2,vspMin,vspMax);
									// 			j3 = clamp(j+j2,vspMin,vspMax);
									// 			k3 = clamp(k+k2,vspMin,vspMax);
												
												
									// 			ind2 = 
									// 				i3 +
									// 				j3*volSizePrimBuf +
									// 				k3*volSizePrimBuf*volSizePrimBuf;
												
									// 			touchesBuilding = touchesBuilding || (extraData[ind2*4+E_PTT_BLD] != UNIT_MIN);
												
									// 		}
									// 	}
									// }
									
									// if (
									// 	touchesBuilding ||
									// 	(*terVal != UNIT_MIN) ||
									// 	(*watVal != UNIT_MIN)
									// ) {
									// 	*empVal = UNIT_MAX;
									// 	*bldVal = UNIT_MIN;
									// 	*terVal = UNIT_MIN;
									// 	*watVal = UNIT_MIN;
									// }
									
									if (
										(*bldVal == UNIT_MAX) ||
										(*terVal == UNIT_MAX)
									) {
										
										if (
											((i%2)==0) &&
											((j%2)==0) &&
											((k%2)==0)	
											
										) {
											
											if (GEN_DEBRIS) {
												singleton->debrisStack.push_back(DebrisStruct());
												singleton->debrisStack.back().pos = btVector3(
													i + volMinReadyInPixels[0] - bufAmount,
													j + volMinReadyInPixels[1] - bufAmount,
													k + volMinReadyInPixels[2] - bufAmount
												);
											}
																					
										}
										
										
										
									}
									
									*empVal = UNIT_MAX;
									*bldVal = UNIT_MIN;
									*terVal = UNIT_MIN;
									*watVal = UNIT_MIN;
								
									
									
								break;
								case E_BRUSH_REF:
									watchMinX = iMin;
									watchMaxX = iMax;
									
									watchMinY = jMin;
									watchMaxY = jMax;
									
									watchMinZ = kMin;
									watchMaxZ = kMax;
									
								break;
								
							}
							
							
						}
						
						
					}
				}
			}
			
	}
#undef LZZ_INLINE
 
// f00338_gameorgnode.h
//

#include "f00338_gameorgnode.e"
#define LZZ_INLINE inline
GameOrgNode::GameOrgNode (GameOrgNode * _parent, int _nodeName, float _material, float _rotThe, float _rotPhi, float _rotRho, float _tanLengthInCells0, float _bitLengthInCells0, float _norLengthInCells0, float _tanLengthInCells1, float _bitLengthInCells1, float _norLengthInCells1, float _tanX, float _tanY, float _tanZ, float _bitX, float _bitY, float _bitZ, float _norX, float _norY, float _norZ)
          {
		orgVecs[E_OV_POWVALS].setFXYZW(2.0f,2.0f,2.0f,0.5f);
		orgVecs[E_OV_TBNOFFSET].setFXYZW(0.0f,0.0f,0.0f,0.0f);
		
		orgVecs[E_OV_MATPARAMS].setFX(_material);//8.0;
		
		parent = _parent;
		nodeName = _nodeName;
		
		orgVecs[E_OV_THETAPHIRHO].setFXYZ(_rotThe,_rotPhi,_rotRho);
		orgVecs[E_OV_TPRORIG].setFXYZ(_rotThe,_rotPhi,_rotRho);
		
		// rotThe = _rotThe;
		// rotPhi = _rotPhi;
		// rotRho = _rotRho;

		

		//boneLengthHalf = _boneLength*0.5f;// *multiplier;

		orgVecs[E_OV_TBNRAD0].setFXYZ(
			_tanLengthInCells0, // *multiplier,
			_bitLengthInCells0, // *multiplier,
			_norLengthInCells0 // *multiplier
		);
		orgVecs[E_OV_TBNRAD1].setFXYZ(
			_tanLengthInCells1, // *multiplier,
			_bitLengthInCells1, // *multiplier,
			_norLengthInCells1 // *multiplier
		);
		
		
		(orgVecs[E_OV_TANGENT]).setFXYZ(_tanX,_tanY,_tanZ);
		(orgVecs[E_OV_BITANGENT]).setFXYZ(_bitX,_bitY,_bitZ);
		(orgVecs[E_OV_NORMAL]).setFXYZ(_norX,_norY,_norZ);
		(orgVecs[E_OV_TANGENT]).normalize();
		(orgVecs[E_OV_BITANGENT]).normalize();
		(orgVecs[E_OV_NORMAL]).normalize();
		
	}
GameOrgNode * GameOrgNode::addChild (int _nodeName, float _material, float _rotThe, float _rotPhi, float _rotRho, float _tanLengthInCells0, float _bitLengthInCells0, float _norLengthInCells0, float _tanLengthInCells1, float _bitLengthInCells1, float _norLengthInCells1, float _tanX, float _tanY, float _tanZ, float _bitX, float _bitY, float _bitZ, float _norX, float _norY, float _norZ)
          {
		
		//if (_nodeName >= E_BONE_C_END) {
		//	cout << "nodeName: " << _nodeName << "\n";
		//}
		
		children.push_back(
			new GameOrgNode(
				this,
				
				_nodeName,
				//_boneLength,
				
				_material,
				
				_rotThe,
				_rotPhi,
				_rotRho,
				
				_tanLengthInCells0,
				_bitLengthInCells0,
				_norLengthInCells0,
				
				_tanLengthInCells1,
				_bitLengthInCells1,
				_norLengthInCells1,
				
				_tanX, _tanY, _tanZ,
				_bitX, _bitY, _bitZ,
				_norX, _norY, _norZ
			)
		);
		
		return children.back();
	}
GameOrgNode * GameOrgNode::getNode (int _nodeName)
                                            {
		int i;
		
		// cout << "getNode("<< _nodeName << "): " << nodeName << "\n";
		
		
		if (nodeName == _nodeName) {
			return this;
		}
		
		for (i = 0; i < children.size(); i++) {
			
			if (children[i]->getNode(_nodeName) != NULL) {
				return children[i]->getNode(_nodeName);
			}
		}
		
		return NULL;
	}
void GameOrgNode::flipOrient (float newVal)
                                      {
		int i;
		
		if (nodeName == E_BONE_WEAPON_CROSSR) {
			orgVecs[E_OV_THETAPHIRHO].setFZ( newVal*M_PI/2.0f );
		}
		if (nodeName == E_BONE_WEAPON_CROSSL) {
			orgVecs[E_OV_THETAPHIRHO].setFZ( -newVal*M_PI/2.0f );
		}
		
		
		for (i = 0; i < children.size(); i++) {
			children[i]->flipOrient(newVal);
		}
	}
void GameOrgNode::doTransform (Singleton * singleton, GameOrgNode * tempParent)
          {
		
		int i;
		int j;
		int popCount = 0;
		int modCount;
		
		GameOrgNode* resultParent;
		
		if (tempParent == NULL) {
			resultParent = parent;
		}
		else {
			resultParent = tempParent;
		}
		
		// start
		if (resultParent == NULL) {
			orgTrans[0].setFXYZ(0.0f,0.0f,0.0f);
		}
		else {
			orgTrans[0].setFXYZRef(&(resultParent->orgTrans[2]));
		}
		
		
		/*
		E_OV_TANGENT,
		E_OV_BITANGENT,
		E_OV_NORMAL,
		*/
		for (i = 0; i < 3; i++) {
			tbnBaseTrans[i].copyFrom(&(orgVecs[i]));
			//tbnBaseTrans[i].addXYZRef(&(orgTrans[0]));
		}
		
		
		readTBN = tbnBaseTrans;
		writeTBN = tbnRotA;
		
		
		modCount = 0;
		
		
		if (orgVecs[E_OV_THETAPHIRHO].getFZ() != 0.0f) {
			singleton->rotMatStack.push_back(RotationInfo());
			singleton->rotMatStack.back().basePoint.copyFrom(&(orgTrans[0]));
			singleton->rotMatStack.back().axisAngle.copyFrom(&(readTBN[2]));
			singleton->rotMatStack.back().axisAngle.setFW(orgVecs[E_OV_THETAPHIRHO].getFZ());
			axisRotationInstance.buildRotMatrix(&(singleton->rotMatStack.back()));
			
			popCount++;
		}
		if (orgVecs[E_OV_THETAPHIRHO].getFX() != 0.0f) {
			singleton->rotMatStack.push_back(RotationInfo());
			singleton->rotMatStack.back().basePoint.copyFrom(&(orgTrans[0]));
			singleton->rotMatStack.back().axisAngle.copyFrom(&(readTBN[1]));
			singleton->rotMatStack.back().axisAngle.setFW(orgVecs[E_OV_THETAPHIRHO].getFX());
			axisRotationInstance.buildRotMatrix(&(singleton->rotMatStack.back()));
			popCount++;
		}
		if (orgVecs[E_OV_THETAPHIRHO].getFY() != 0.0f) {
			singleton->rotMatStack.push_back(RotationInfo());
			singleton->rotMatStack.back().basePoint.copyFrom(&(orgTrans[0]));
			singleton->rotMatStack.back().axisAngle.copyFrom(&(readTBN[0]));
			singleton->rotMatStack.back().axisAngle.setFW(orgVecs[E_OV_THETAPHIRHO].getFY());
			axisRotationInstance.buildRotMatrix(&(singleton->rotMatStack.back()));
			popCount++;
		}
		
		
		for (i = singleton->rotMatStack.size()-(1); i >= 0; i--) {
			
			axisRotationInstance.applyRotation(
				writeTBN,
				readTBN,
				&(singleton->rotMatStack[i])
			);
			
			if ((modCount%2) == 0) {
				readTBN = tbnRotA;
				writeTBN = tbnRotB;
			}
			else {
				readTBN = tbnRotB;
				writeTBN = tbnRotA;
			}
			
			
			modCount++;
			
		}
		
		
		for (j = 0; j < 3; j++) {
			tbnRotC[j].setFXYZRef(&( readTBN[j] ));
			//tbnRotC[j].addXYZRef(&(orgTrans[0]),-1.0f);
			tbnRotC[j].normalize();
		}
		
		
		// middle
		orgTrans[1].setFXYZRef(&(tbnRotC[0]));
		orgTrans[1].multXYZ(orgVecs[E_OV_TBNRAD0].getFX());
		orgTrans[1].addXYZRef(&(orgTrans[0]));
		
		// end
		orgTrans[2].setFXYZRef(&(tbnRotC[0]));
		orgTrans[2].multXYZ(
			orgVecs[E_OV_TBNRAD0].getFX() +
			orgVecs[E_OV_TBNRAD1].getFX()
		);
		orgTrans[2].addXYZRef(&(orgTrans[0]));
		
		
		
		if (orgVecs[E_OV_TBNOFFSET].anyXYZ()) {
			tbnOffset = orgVecs[E_OV_TBNOFFSET].getBTV();
			tempOffset = 
				tbnOffset.getX()*tbnRotC[0].getBTV() + 
				tbnOffset.getY()*tbnRotC[1].getBTV() + 
				tbnOffset.getZ()*tbnRotC[2].getBTV();
			tempFI.setBTV(tempOffset);
			for (i = 0; i < 3; i++) {
				orgTrans[i].addXYZRef(&tempFI);
			}
		}
		
		
		
		
		
		for (i = 0; i < 3; i++) {
			(tbnTrans[i]).setFXYZRef(&(tbnRotC[i]));
			//(tbnTrans[i]).multXYZ(orgVecs[E_OV_TBNRAD0][i]); //*tbnRadScale0[i]
			(tbnTrans[i]).addXYZRef(&(orgTrans[1]));
		}
		
		
		
		for (i = 0; i < children.size(); i++) {
			children[i]->doTransform(singleton, NULL);
		}
		
		
		for (i = 0; i < popCount; i++) {
			singleton->rotMatStack.pop_back();
			//singleton->transStack.pop_back();
			//singleton->rotStack.pop_back();
		}
		
	}
#undef LZZ_INLINE
 
// f00339_gameorg.h
//

#include "f00339_gameorg.e"
#define LZZ_INLINE inline
float GameOrg::gv (float * vals)
                              {
		float lerp = fGenRand();
		return vals[0]*lerp + vals[1]*(1.0f-lerp);
	}
float const GameOrg::baseMat = 12.0f;
GameOrg::GameOrg ()
                  {
		basePose.group = -1;
		basePose.RLBN = -1;
		basePose.step = -1;
		targetPose.RLBN = RLBN_NEIT;
		targetPose.group = -1;
		rootObj = NULL;
		defVecLength = 0.05f*ORG_SCALE_BASE;
	}
void GameOrg::init (Singleton * _singleton, int _ownerUID, int _entType, int _subType)
          {
		singleton = _singleton;

		stepCount = 0;

		ownerUID = _ownerUID;

		entType = _entType;
		subType = _subType;

		// GameOrgNode(
		// 	GameOrgNode* _parent,
		// 	int _nodeName,
		// 	float _boneLength,
		// 	float _tanLengthInCells,
		// 	float _bitLengthInCells,
		// 	float _norLengthInCells,
			
		// 	float _tanX, float _tanY, float _tanZ,
		// 	float _bitX, float _bitY, float _bitZ,
		// 	float _norX, float _norY, float _norZ
			
			
		// )
		
		int i;
		
		for (i = 0; i < E_BONE_C_END; i++) {
			allNodes[i] = NULL;
		}
		
		switch (entType) {
			case E_ENTTYPE_NPC:
				initHuman();
			break;
			case E_ENTTYPE_WEAPON:
				initWeapon();
			break;
		}
		
		singleton->curOrgId++;
		
		
	}
void GameOrg::jsonToNode (JSONValue * * parentObj, GameOrgNode * curNode, bool notThePose)
                                                                                      {
		
		int i;
		
		
		curNode->nodeName = (*parentObj)->Child("id")->number_value;
		
		JSONValue* tempVal;
		
		bool doProc;
		
		tempVal = (*parentObj)->Child("orgVecs");
		
		int mv1 = tempVal->CountChildren()/4;
		int mv2 = E_OV_LENGTH;
		
		int numChildren = min(mv1, mv2);
		
		for (i = 0; i < numChildren; i++) {	
		
			doProc = false;
			if (notThePose) {
				switch (i) {
					//case E_OV_TANGENT:
					//case E_OV_BITANGENT:
					//case E_OV_NORMAL:
					case E_OV_TBNRAD0:
					case E_OV_TBNRAD1:
					//case E_OV_THETAPHIRHO:
					//case E_OV_TPRORIG:
					case E_OV_MATPARAMS:
						doProc = true;
					break;
				}
			}
			else {
				doProc = true;
			}
			
		
			if (doProc) {
				
				curNode->orgVecs[i].setFXYZW(
					tempVal->array_value[i*4 + 0]->number_value,
					tempVal->array_value[i*4 + 1]->number_value,
					tempVal->array_value[i*4 + 2]->number_value,
					tempVal->array_value[i*4 + 3]->number_value
				);
			}
		
			
			
		}
		
		
		int totSize = 0;
		
		
		if ((*parentObj)->HasChild("children")) {
			totSize = (*parentObj)->Child("children")->array_value.size();
			
			for (i = 0; i < totSize; i++) {
				
				
				if (i >= curNode->children.size()) {
					
					//curNode->children.push_back(new GameOrgNode())
				}
				
				jsonToNode(
					&( (*parentObj)->Child("children")->array_value[i] ),
					curNode->children[i],
					notThePose
				);
				
				
			}
		}
		
		
		
		
	}
void GameOrg::setBinding (int actorId, bool val)
                                               {
		
		if (actorId < 0) {
			return;
		}
		
		int i;
		for (i = 0; i < RLBN_LENGTH; i++) {
			singleton->gem->bindPose(actorId, i, val);
		}
	}
int GameOrg::getPoseUID ()
                         {
		
		BaseObj* ca;
		
		if (singleton->gem->curActorUID < 0) {
			return -1;
		}
		else {
			ca = &(singleton->gem->gameObjects[singleton->gem->curActorUID]);
			if (ca->entType != E_ENTTYPE_NPC) {
				return -1;
			}
		}
		
		return singleton->gem->curActorUID;
	}
void GameOrg::loadOrgFromFile (string fileName, bool notThePose)
                                                               {
		
		
		int actorId = getPoseUID();
		
		setBinding(actorId,false);
		
		singleton->loadJSON(
			"..\\data\\orgdata\\" + fileName + ".js",
			&rootObj
		);
		
		jsonToNode(&rootObj, baseNode, notThePose);
		
		setBinding(actorId,true);
		
	}
void GameOrg::saveOrgToFile (string fileName)
                                            {
		
		cout << "saveOrgToFile " << fileName << "\n";
		
		int actorId = getPoseUID();
		
		
		setBinding(actorId,false);
		
		if (rootObj != NULL)
		{
			delete rootObj;
			rootObj = NULL;
		}
		
		rootObj = new JSONValue(JSONObject());
		
		nodeToJSON(&rootObj, baseNode); //(rootObj->object_value["rootVal"])
		
		
		singleton->saveFileString(
			"..\\data\\orgdata\\" + fileName + ".js",
			&(rootObj->Stringify())
		);
		
		setBinding(actorId,true);
		
	}
BaseObj * GameOrg::getOwner ()
                            {
		
		if (ownerUID < 0) {
			return NULL;
		}
		
		return &(singleton->gem->gameObjects[ownerUID]);
	}
void GameOrg::setTPG (int _targetPoseGroup, int _targetPoseRLBN)
                                                               {
		
		if (
			(targetPose.group == _targetPoseGroup) &&
			(targetPose.RLBN == _targetPoseRLBN)	
		) {
			// same pose, let it finish
		}
		else {
			
			targetPose.group = _targetPoseGroup;
			targetPose.RLBN = _targetPoseRLBN;
			stepCount = 0;
			
			totTime = 0.0;
		}
		
		
	}
void GameOrg::setToPose (GameOrg * otherOrg, float lerpAmount, int boneId)
          {
		int i;
		int j;
		
		int begInd;
		int endInd;
		
		if (otherOrg == NULL) {
			cout << "ARGH\n";
			//return;
		}
		
		
		GameOrgNode* sourceNode;
		GameOrgNode* destNode;
		
		if (boneId == -1) {
			begInd = 0;
			endInd = E_BONE_C_END;
		}
		else {
			begInd = boneId;
			endInd = boneId+1;
		}
		
		
		
		for (i = begInd; i < endInd; i++) {
			sourceNode = otherOrg->allNodes[i];
			destNode = allNodes[i];
			
			if (
				(sourceNode != NULL) &&
				(destNode != NULL)	
			) {
				for (j = 0; j < E_OV_LENGTH; j++) {
					
					if (j == E_OV_MATPARAMS) {
						destNode->orgVecs[j].copyFrom(&(sourceNode->orgVecs[j]));
					}
					else {
						destNode->orgVecs[j].lerpXYZW(&(sourceNode->orgVecs[j]), lerpAmount);
					}
					
					
				}
			}
		}
	}
void GameOrg::updatePose (double curTimeStep)
                                            {
		totTime += curTimeStep;
		
		float timeInterval = 1.0f;
		float lerpSpeed = 0.005f;
		
		int actionToStop;
		
		float* curData;
		
		float curVelXY;
		
		BaseObj* curOwner = getOwner();
		
		if (singleton->gem->editPose) {
			
		}
		else {
			if (targetPose.group > -1) {
				
				curData = &(singleton->gem->gamePoseInfo[targetPose.group].data[0]);
				
				
				lerpSpeed = curData[E_PIK_LERPSPEED]*singleton->conVals[E_CONST_ANIMLERP_MULT];
				timeInterval = curData[E_PIK_TIMEINTERVAL]*singleton->conVals[E_CONST_TIMEINTERVAL_MULT];
				
				if (targetPose.group == E_PG_WALKFORWARD) {
					curVelXY = curOwner->getPlanarVel();
					
					if (curOwner->getActionState(E_ACT_ISWALKING,RLBN_NEIT)) {
						curVelXY = max(curVelXY,singleton->conVals[E_CONST_MIN_WALK_ANIM_VEL]);
					}
					
					if (curOwner->airCount > singleton->conVals[E_CONST_AIRANIM_THRESH]) {
						curVelXY = 0.0f;
					}
					
					lerpSpeed *= (curVelXY*singleton->conVals[E_CONST_WALKANIM_LERP_MOD]);
					
					if (curVelXY > 0.0) {
						timeInterval /= (curVelXY*singleton->conVals[E_CONST_WALKANIM_INTERVAL_MOD]);
					}
					
				}
				
				targetPose.step = stepCount;
				
				if (curData[E_PIK_DOLOOP] == 1.0f) {
					targetPose.step = stepCount%((int)(curData[E_PIK_NUMSTEPS]));
				}
				else {
					if (targetPose.step >= curData[E_PIK_NUMSTEPS]) {
						targetPose.step = curData[E_PIK_NUMSTEPS]-1;
					}
					
					
					
					if (stepCount > (curData[E_PIK_NUMSTEPS] + curData[E_PIK_EXTRASTEPS])) {
						
						actionToStop = singleton->gem->getActionStateFromPose(targetPose.group);
						
						curOwner->setActionState(
							actionToStop,
							targetPose.RLBN,
							false
						);
						if (actionToStop == E_ACT_ISSWINGING) {
							curOwner->setActionState(
								E_ACT_HASNOTHIT,
								targetPose.RLBN,
								false
							);
						}
						
						if (curOwner->isDead()) {
							
						}
						else {
							setTPG(E_PG_IDLE,RLBN_NEIT);
							targetPose.step = 0;
						}
						
						
					}
				}
				
				if (totTime > timeInterval) {
					totTime -= timeInterval;
					stepCount++;					
				}
				
				setToPose(
					
					singleton->gem->getPose(
						targetPose.group,targetPose.RLBN,targetPose.step
					),
					
					lerpSpeed
				);
			}
		}
		
		
		
		
		singleton->gem->transformOrg(this, NULL);
		
	}
void GameOrg::nodeToJSON (JSONValue * * parentObj, GameOrgNode * curNode)
                                                                     {
		
		int i;
		int j;
		
		float mult = 1.0f;
		
		JSONValue* tempVal;
		
		(*parentObj)->object_value["id"] = new JSONValue((double)(curNode->nodeName) );
		(*parentObj)->object_value["name"] = new JSONValue(boneStrings[curNode->nodeName]);
		
		(*parentObj)->object_value["orgVecs"] = new JSONValue(JSONArray());
		
		
		for (i = 0; i < E_OV_LENGTH; i++) {
			
			mult = 1.0f;
			
			switch (i) {
				//case E_OV_TANGENT:
				//case E_OV_BITANGENT:
				//case E_OV_NORMAL:
				case E_OV_TBNRAD0:
				case E_OV_TBNRAD1:
				//case E_OV_THETAPHIRHO:
				//case E_OV_TPRORIG:
				//case E_OV_MATPARAMS:
				case E_OV_TBNOFFSET:
					mult = ORG_SCALE_DELTA;
				break;
			}
			
			
			for (j = 0; j < 4; j++) {
				
				if (j == 3) {
					mult = 1.0f;
				}
				
				(*parentObj)->object_value["orgVecs"]->array_value.push_back(new JSONValue(
					(double)(curNode->orgVecs[i][j]*mult)	
				));
				
			}
			
		}
		
		if (curNode->children.size() > 0) {
			
			(*parentObj)->object_value["children"] = new JSONValue(JSONArray());
			for (i = 0; i < curNode->children.size(); i++) {
				(*parentObj)->object_value["children"]->array_value.push_back(new JSONValue(JSONObject()));
				
				nodeToJSON(
					&((*parentObj)->object_value["children"]->array_value.back()),
					curNode->children[i]
				);
				
				
			}
			
			
		}
		
	}
void GameOrg::updateHandleOffset ()
                                  {
		
		if (entType != E_ENTTYPE_WEAPON) {
			return;
		}
		
		
		allNodes[E_BONE_C_BASE]->orgVecs[E_OV_TBNOFFSET].setFXYZ(
			-(
					allNodes[E_BONE_WEAPON_POMMEL]->orgVecs[E_OV_TBNRAD0].getFX() +
					allNodes[E_BONE_WEAPON_POMMEL]->orgVecs[E_OV_TBNRAD1].getFX() +
					allNodes[E_BONE_WEAPON_HANDLE]->orgVecs[E_OV_TBNRAD0].getFX()
			),
			0.0f,
			0.0f
		);
		
	}
void GameOrg::initWeapon ()
                          {
		
		int i;
		int j;
		int curName;
		
		float dirMod = 1.0f;
		
		
		baseNode = allNodes[E_BONE_C_BASE] = new GameOrgNode(
			NULL,
			E_BONE_C_BASE,
			
			baseMat, 0.0f, 0.0f, M_PI/2.0f, 
			0.01f, defVecLength, defVecLength,
			0.01f, defVecLength, defVecLength,
			
			1.0f, 0.0f, 0.0f,
			0.0f, 1.0f, 0.0f,
			0.0f, 0.0f, 1.0f
		);
		
		GameOrgNode* curNode = baseNode;
		
		GameOrgNode* centerNode;
		
		
		
		
		wepLengths[E_BONE_WEAPON_POMMEL] = 0.125f*ORG_SCALE_BASE;
		wepLengths[E_BONE_WEAPON_HANDLE] = 0.3f*ORG_SCALE_BASE;
		wepLengths[E_BONE_WEAPON_CENTER] = 0.125f*ORG_SCALE_BASE;
		wepLengths[E_BONE_WEAPON_CROSSR] = 0.5f*ORG_SCALE_BASE;
		wepLengths[E_BONE_WEAPON_BLADER] = 0.5f*ORG_SCALE_BASE;
		wepLengths[E_BONE_WEAPON_CROSSL] = 0.5f*ORG_SCALE_BASE;
		wepLengths[E_BONE_WEAPON_BLADEL] = 0.5f*ORG_SCALE_BASE;
		wepLengths[E_BONE_WEAPON_BLADEU] = 1.0f*ORG_SCALE_BASE;
		
		
		
		
		curName = E_BONE_WEAPON_POMMEL;
		curNode = allNodes[curName] = curNode->addChild( curName,
			baseMat, 0.0f, 0.0f, 0.0f,
			wepLengths[curName], defVecLength, defVecLength,
			wepLengths[curName], defVecLength, defVecLength,
			1.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 1.0f
		);
		
		curName = E_BONE_WEAPON_HANDLE;
		curNode = allNodes[curName] = curNode->addChild( curName,
			baseMat, 0.0f, 0.0f, 0.0f,
			wepLengths[curName], defVecLength, defVecLength,
			wepLengths[curName], defVecLength, defVecLength,
			1.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 1.0f
		);
		
		curName = E_BONE_WEAPON_CENTER;
		centerNode = curNode = allNodes[curName] = curNode->addChild( curName,
			baseMat, 0.0f, 0.0f, 0.0f,
			0.125f, defVecLength, defVecLength,
			0.125f, defVecLength, defVecLength,
			1.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 1.0f
		);
		
		curName = E_BONE_WEAPON_CROSSR;
		curNode = allNodes[curName] = centerNode->addChild( curName,
			baseMat, 0.0f, 0.0f, M_PI/2.0f,
			wepLengths[curName], defVecLength, defVecLength,
			wepLengths[curName], defVecLength, defVecLength,
			1.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 1.0f
		);
		
		curName = E_BONE_WEAPON_BLADER;
		curNode = allNodes[curName] = curNode->addChild( curName,
			baseMat, 0.0f, 0.0f, 0.0f,
			wepLengths[curName], defVecLength, defVecLength,
			wepLengths[curName], defVecLength, defVecLength,
			1.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 1.0f
		);
		
		curName = E_BONE_WEAPON_CROSSL;
		curNode = allNodes[curName] = centerNode->addChild( curName,
			baseMat, 0.0f, 0.0f, -M_PI/2.0f,
			wepLengths[curName], defVecLength, defVecLength,
			wepLengths[curName], defVecLength, defVecLength,
			1.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 1.0f
		);
		
		curName = E_BONE_WEAPON_BLADEL;
		curNode = allNodes[curName] = curNode->addChild( curName,
			baseMat, 0.0f, 0.0f, 0.0f,
			wepLengths[curName], defVecLength, defVecLength,
			wepLengths[curName], defVecLength, defVecLength,
			1.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 1.0f
		);
		
		curName = E_BONE_WEAPON_BLADEU;
		curNode = allNodes[curName] = centerNode->addChild( curName,
			baseMat, 0.0f, 0.0f, 0.0f,
			wepLengths[curName], defVecLength, defVecLength,
			wepLengths[curName], defVecLength, defVecLength,
			1.0f, 0.0f, 0.0f,  0.0f, 1.0f, 0.0f,  0.0f, 0.0f, 1.0f
		);
		
		
		
		baseNode->doTransform(singleton, NULL);
		
	}
void GameOrg::initHuman ()
                         {
		
		int i;
		int j;
		int lrMod;
		
		float dirMod = 1.0f;
		
		
		baseNode = allNodes[E_BONE_C_BASE] = new GameOrgNode(
			NULL,
			E_BONE_C_BASE,
			
			baseMat, 0.0f, 0.0f, 0.0f,
			0.01f, defVecLength, defVecLength,
			0.01f, defVecLength, defVecLength,
			
			0.0f, 1.0f, 0.0f,			
			1.0f, 0.0f, 0.0f,
			0.0f,0.0f,1.0f
		);
		
		GameOrgNode* curNode = baseNode;
		

		float numSpineSegs = E_BONE_C_SKULL-E_BONE_C_SPINE0;
		
		for (i = E_BONE_C_SPINE0; i < E_BONE_C_SKULL; i++) {
			curNode = allNodes[i] = curNode->addChild(
				i,
				
				baseMat, 0.0f, 0.0f, 0.0f,
				0.75f*ORG_SCALE_BASE/numSpineSegs, defVecLength, defVecLength,
				0.75f*ORG_SCALE_BASE/numSpineSegs, defVecLength, defVecLength,
				
				0.0f,0.0f,1.0f,
				0.0f,1.0f,0.0f,
				1.0f,0.0f,0.0f
				
			);
		}
		
		curNode = allNodes[E_BONE_C_SKULL] = curNode->addChild(
			E_BONE_C_SKULL,
			
			baseMat, 0.0f, 0.0f, 0.0f,
			0.25f*ORG_SCALE_BASE,  defVecLength, defVecLength,
			0.25f*ORG_SCALE_BASE,  defVecLength, defVecLength,
			
			0.0f,0.0f,1.0f,
			0.0f,1.0f,0.0f,
			1.0f,0.0f,0.0f
		);
		
		
		for (j = 0; j < 2; j++) {
			
			if (j == 0) { // left limbs
				lrMod = 0;
				dirMod = 1.0f;
			}
			else { // right limbs
				lrMod = E_BONE_R_BEG - E_BONE_L_BEG;
				dirMod = -1.0f;
			}
			
			curNode = baseNode->getNode(E_BONE_C_SKULL-2);
			
			
			curNode = allNodes[E_BONE_L_SHOULDER + lrMod] = curNode->addChild(
				E_BONE_L_SHOULDER + lrMod,

				baseMat, 0.0f, 0.0f, 0.0f,
				0.20f*ORG_SCALE_BASE,  defVecLength, defVecLength,
				0.20f*ORG_SCALE_BASE,  defVecLength, defVecLength,
				
				dirMod*1.0f,0.0f,0.0f,
				0.0f,1.0f,0.0f,
				0.0f,0.0f,1.0f
			);
			curNode = allNodes[E_BONE_L_UPPERARM + lrMod] = curNode->addChild(
				E_BONE_L_UPPERARM + lrMod,
				
				baseMat, 0.0f, 0.0f, 0.0f,
				0.25f*ORG_SCALE_BASE, defVecLength, defVecLength,
				0.25f*ORG_SCALE_BASE, defVecLength, defVecLength,
				
				dirMod*1.0f,0.0f,0.0f,
				0.0f,1.0f,0.0f,
				0.0f,0.0f,1.0f
			);
			curNode = allNodes[E_BONE_L_LOWERARM + lrMod] = curNode->addChild(
				E_BONE_L_LOWERARM + lrMod,
				
				baseMat, 0.0f, 0.0f, 0.0f,
				0.25f*ORG_SCALE_BASE, defVecLength, defVecLength,
				0.25f*ORG_SCALE_BASE, defVecLength, defVecLength,
				
				dirMod*1.0f,0.0f,0.0f,
				0.0f,1.0f,0.0f,
				0.0f,0.0f,1.0f
			);
			curNode = allNodes[E_BONE_L_METACARPALS + lrMod] = curNode->addChild(
				E_BONE_L_METACARPALS + lrMod,
				
				baseMat, 0.0f, 0.0f, 0.0f,
				0.1f*ORG_SCALE_BASE, defVecLength, defVecLength,
				0.1f*ORG_SCALE_BASE, defVecLength, defVecLength,
				
				dirMod*1.0f,0.0f,0.0f,
				0.0f,1.0f,0.0f,
				0.0f,0.0f,1.0f
			);
			
			
			curNode = baseNode;
			
			curNode = allNodes[E_BONE_L_HIP + lrMod] = curNode->addChild(
				E_BONE_L_HIP + lrMod,
				
				baseMat, 0.0f, 0.0f, 0.0f,
				0.1f*ORG_SCALE_BASE, defVecLength, defVecLength,
				0.1f*ORG_SCALE_BASE, defVecLength, defVecLength,
				
				dirMod*1.0f,0.0f,0.0f,
				0.0f,1.0f,0.0f,
				0.0f,0.0f,1.0f
			);
			curNode = allNodes[E_BONE_L_UPPERLEG + lrMod] = curNode->addChild(
				E_BONE_L_UPPERLEG + lrMod,
				
				baseMat, 0.0f, 0.0f, 0.0f,
				0.45f*ORG_SCALE_BASE, defVecLength, defVecLength,
				0.45f*ORG_SCALE_BASE, defVecLength, defVecLength,
				
				0.0f,0.0f,-1.0f,
				0.0f,1.0f,0.0f,
				dirMod*1.0f,0.0f,0.0f
			);
			curNode = allNodes[E_BONE_L_LOWERLEG + lrMod] = curNode->addChild(
				E_BONE_L_LOWERLEG + lrMod,
				
				baseMat, 0.0f, 0.0f, 0.0f,
				0.45f*ORG_SCALE_BASE, defVecLength, defVecLength,
				0.45f*ORG_SCALE_BASE, defVecLength, defVecLength,
				
				0.0f,0.0f,-1.0f,
				0.0f,1.0f,0.0f,
				dirMod*1.0f,0.0f,0.0f
			);
			curNode = allNodes[E_BONE_L_TALUS + lrMod] = curNode->addChild(
				E_BONE_L_TALUS + lrMod,
				
				baseMat, 0.0f, 0.0f, 0.0f,
				0.2f*ORG_SCALE_BASE, defVecLength, defVecLength,
				0.2f*ORG_SCALE_BASE, defVecLength, defVecLength,
				
				0.0f,1.0f,0.0f,
				dirMod*1.0f,0.0f,0.0f,
				0.0f,0.0f,1.0f
			);
			
		}
		
		baseNode->doTransform(singleton, NULL);
		
		
	}
#undef LZZ_INLINE
 
// f00340_gameplantnode.h
//

#include "f00340_gameplantnode.e"
#define LZZ_INLINE inline
GamePlantNode::GamePlantNode ()
                        {
		sphereRad = 0.0f;
		parent = NULL;
		children = NULL;
		upVec.setFXYZ(0.0f,0.0f,1.0f);
	}
void GamePlantNode::updateTangent (float angleInRadians)
                                                 {
		tangent.setFXYZRef(&endPoint);
		tangent.addXYZRef(&begPoint,-1.0f);
		tangent.normalize();
		baseShoot.setFXYZRef(&tangent);
		baseShoot.rotate(angleInRadians, E_PLANE_XZ);
		baseShoot.normalize();

		shootLength = begPoint.distance(&endPoint);

	}
void GamePlantNode::init (GamePlantNode * _parent, int _maxChildren, int _numChildren)
          {
		parent = _parent;
		
		maxChildren = _maxChildren;	
		numChildren = _numChildren;

		sphereRad = 0.0f;

		if (maxChildren > 0) {

			if (children == NULL) {
				children = new GamePlantNode[maxChildren];
			}
			else {

			}

			
		}
		
	}
#undef LZZ_INLINE
 
// f00341_gameplant.h
//

#include "f00341_gameplant.e"
#define LZZ_INLINE inline
PlantRules (GamePlant::allPlantRules) [E_PT_LENGTH];
void GamePlant::initAllPlants (Singleton * _singleton)
                                                         {
		int i;
		int j;


		float pi = 3.14159;

		PlantRules* pr;

		pr = &(allPlantRules[E_PT_OAK_TRUNK]);
		pr->numChildren[0] = 3.0f;
		pr->numChildren[1] = 5.0f;
		pr->divergenceAngleV[0] = pi/3.0f;
		pr->divergenceAngleV[1] = pi/5.0f;
		pr->begThickness = 1.5f;
		pr->endThickness = 0.3f;
		pr->sphereGen = 5.0f;
		pr->sphereRad = 5.0f;
		pr->numGenerations = 5.0f;
		pr->angleUniformityU = 0.75f;
		pr->isInit = 0.0;
		pr->curLength[0] = 6.0f;
		pr->curLength[1] = 4.0f;
		pr->curLength[2] = 6.0f;
		pr->curLength[3] = 4.5f;
		pr->curLength[4] = 4.0f;
		pr->curLength[5] = 3.5f;
		pr->curLength[6] = 1.0f;
		pr->curLength[7] = 1.0f;
		pr->curLength[8] = 0.75f;

		pr = &(allPlantRules[E_PT_OAK_ROOTS]);
		pr->numChildren[0] = 2.0f;
		pr->numChildren[1] = 5.0f;
		pr->divergenceAngleV[0] = pi/8.0f;
		pr->divergenceAngleV[1] = pi/8.0f;
		pr->begThickness = 1.5f;
		pr->endThickness = 0.0f;
		pr->sphereGen = -1.0f;
		pr->sphereRad = 0.0f;		
		pr->numGenerations = 2.0f;
		pr->angleUniformityU = 0.75f;
		pr->isInit = 0.0;
		pr->curLength[0] = 6.0f;
		pr->curLength[1] = 8.0f;
		pr->curLength[2] = 8.0f;
		pr->curLength[3] = 8.5f;
		pr->curLength[4] = 8.5f;
		pr->curLength[5] = 8.5f;
		pr->curLength[6] = 1.5f;
		pr->curLength[7] = 1.0f;
		pr->curLength[8] = 0.75f;
		
		
		pr = &(allPlantRules[E_PT_OAK2_TRUNK]);
		pr->numChildren[0] = 3.0f;
		pr->numChildren[1] = 5.0f;
		pr->divergenceAngleV[0] = pi/3.0f;
		pr->divergenceAngleV[1] = pi/4.0f;
		pr->begThickness = 1.0f;
		pr->endThickness = 0.2f;
		pr->sphereGen = 5.0f;
		pr->sphereRad = 6.0f;
		pr->numGenerations = 5.0f;
		pr->angleUniformityU = 0.75f;
		pr->isInit = 0.0;
		pr->curLength[0] = 6.0f;
		pr->curLength[1] = 4.0f;
		pr->curLength[2] = 6.0f;
		pr->curLength[3] = 4.5f;
		pr->curLength[4] = 4.0f;
		pr->curLength[5] = 3.5f;
		pr->curLength[6] = 1.0f;
		pr->curLength[7] = 1.0f;
		pr->curLength[8] = 0.75f;

		pr = &(allPlantRules[E_PT_OAK2_ROOTS]);
		pr->numChildren[0] = 2.0f;
		pr->numChildren[1] = 3.0f;
		pr->divergenceAngleV[0] = pi/8.0f;
		pr->divergenceAngleV[1] = pi/8.0f;
		pr->begThickness = 1.0f;
		pr->endThickness = 0.0f;
		pr->sphereGen = -1.0f;
		pr->sphereRad = 0.0f;
		pr->numGenerations = 2.0f;
		pr->angleUniformityU = 0.75f;
		pr->isInit = 0.0;
		pr->curLength[0] = 6.0f;
		pr->curLength[1] = 8.0f;
		pr->curLength[2] = 8.0f;
		pr->curLength[3] = 8.5f;
		pr->curLength[4] = 8.5f;
		pr->curLength[5] = 2.0f;
		pr->curLength[6] = 1.5f;
		pr->curLength[7] = 1.0f;
		pr->curLength[8] = 0.75f;





		pr = &(allPlantRules[E_PT_BARE_OAK_TRUNK]);
		pr->numChildren[0] = 2.0f;
		pr->numChildren[1] = 5.0f;
		pr->divergenceAngleV[0] = pi/3.0f;
		pr->divergenceAngleV[1] = pi/4.0f;
		pr->begThickness = 1.0f;
		pr->endThickness = 0.2f;
		pr->sphereGen = -1.0f;
		pr->sphereRad = 0.0f;
		pr->numGenerations = 4.0f;
		pr->angleUniformityU = 0.75f;
		pr->isInit = 0.0;
		pr->curLength[0] = 6.0f;
		pr->curLength[1] = 4.0f;
		pr->curLength[2] = 6.0f;
		pr->curLength[3] = 4.5f;
		pr->curLength[4] = 4.5f;
		pr->curLength[5] = 1.5f;
		pr->curLength[6] = 1.0f;
		pr->curLength[7] = 1.0f;
		pr->curLength[8] = 0.75f;

		pr = &(allPlantRules[E_PT_BARE_OAK_ROOTS]);
		pr->numChildren[0] = 2.0f;
		pr->numChildren[1] = 5.0f;
		pr->divergenceAngleV[0] = pi/8.0f;
		pr->divergenceAngleV[1] = pi/8.0f;
		pr->begThickness = 1.0f;
		pr->endThickness = 0.0f;
		pr->sphereGen = -1.0f;
		pr->sphereRad = 0.0f;
		pr->numGenerations = 4.0f;
		pr->angleUniformityU = 0.75f;
		pr->isInit = 0.0;
		pr->curLength[0] = 6.0f;
		pr->curLength[1] = 8.0f;
		pr->curLength[2] = 8.0f;
		pr->curLength[3] = 8.5f;
		pr->curLength[4] = 8.5f;
		pr->curLength[5] = 8.5f;
		pr->curLength[6] = 1.5f;
		pr->curLength[7] = 1.0f;
		pr->curLength[8] = 0.75f;
		

		


		
		for (i = 0; i < E_PT_LENGTH; i++) {
			if (allPlantRules[i].isInit == 0.0f) {



				

			}
		}
	}
float GamePlant::gv (float * vals)
                              {
		float lerp = fGenRand();
		return vals[0]*lerp + vals[1]*(1.0f-lerp);
	}
GamePlant::GamePlant ()
                    {
		trunkNode = NULL;
		rootsNode = NULL;
	}
void GamePlant::init (Singleton * _singleton, PlantRules * _rootRules, PlantRules * _trunkRules, FIVector4 * _origin)
          {
		singleton = _singleton;
		rootRules = _rootRules;
		trunkRules = _trunkRules;
		origin.setFXYZRef(_origin);

		trunkVec.setFXYZ(fGenRand()*0.1f,fGenRand()*0.1f,1.0f);
		trunkVec.normalize();
		rootVec.setFXYZRef(&trunkVec);
		rootVec.multXYZ(-1.0f);

		if (trunkNode == NULL) {
			trunkNode = new GamePlantNode();
		}
		if (rootsNode == NULL) {
			rootsNode = new GamePlantNode();
		}


		initBase(rootRules, rootsNode, &rootVec);
		initBase(trunkRules, trunkNode, &trunkVec);

	}
void GamePlant::initBase (PlantRules * rules, GamePlantNode * curNode, FIVector4 * baseVec)
          {
		int i;
		float curLerp;
		float maxLength = 0.0f;
		//float curMult = 1.0f;
		int maxGen = rules->numGenerations;

		
		curNode->init(NULL,rules->numChildren[1],gv(rules->numChildren));
		//curNode->tangent.setFXYZRef(baseVec);
		curNode->begPoint.setFXYZRef(&origin);
		curNode->endPoint.setFXYZRef(&origin);
		curNode->endPoint.addXYZRef(baseVec,rules->curLength[0]);
		curNode->updateTangent(gv(rules->divergenceAngleV));

		for (i = 1; i <= maxGen; i++) {
			maxLength += rules->curLength[i]; // *curMult;
			//curMult *= rules->nodeLengthMultiplier;
		}

		

		// curLerp = rules->curLength[0]/maxLength;
		// curNode->endThickness = (1.0f-curLerp)*rules->begThickness + curLerp*rules->endThickness;

		// curLerp = 0.0f;
		// curNode->begThickness = curNode->endThickness;//(1.0f-curLerp)*rules->begThickness + curLerp*rules->endThickness;

		// curNode->midThickness = (curNode->begThickness+curNode->endThickness)*0.5f;

		curNode->begThickness = rules->begThickness;
		curNode->endThickness = curNode->begThickness;
		curNode->midThickness = curNode->begThickness;

		


		applyRules(
			rules,
			curNode,
			0,
			maxGen,
			//rules->baseLength*(rules->nodeLengthMultiplier),
			0.0f,
			maxLength
		);
	}
void GamePlant::applyRules (PlantRules * rules, GamePlantNode * curParent, int curGen, int maxGen, float totLength, float maxLength)
          {


		//cout << "curLength: " << curLength << "\n";

		int i;
		float fi;
		float fCurGen = (float)curGen;
		float fNumChildren;
		float curLerp;
		float twoPi = 6.283185307f;
		float curLength = rules->curLength[curGen];

		GamePlantNode* curChild;

		fNumChildren = (float)(curParent->numChildren);

		for (i = 0; i < curParent->numChildren; i++) {

			fi = ((float)i)/fNumChildren;

			curChild = &(curParent->children[i]);


			if (curGen == maxGen) {
				curChild->init(curParent,0,0);
			}
			else {
				curChild->init(curParent,rules->numChildren[1], max( gv(rules->numChildren)-(float)curGen/2, 1.0f) );
			}

			
			curChild->begPoint.setFXYZRef(&(curParent->endPoint));
			curChild->endPoint.setFXYZRef(&(curParent->endPoint));

			axisRotationInstance.doRotation(
				&tempv0,
				&(curParent->baseShoot),
				&(curParent->tangent),
				fi*twoPi + (fGenRand()-0.5f)*twoPi*(1.0f-rules->angleUniformityU)/fNumChildren
			);
			curChild->endPoint.addXYZRef(&tempv0,curLength);
			curChild->updateTangent(gv(rules->divergenceAngleV));

			curLerp = (totLength/maxLength);
			curChild->begThickness = (1.0f-curLerp)*rules->begThickness + curLerp*rules->endThickness;

			curLerp = ((totLength+curLength)/maxLength);
			curChild->endThickness = (1.0f-curLerp)*rules->begThickness + curLerp*rules->endThickness;

			curChild->midThickness = (curChild->begThickness+curChild->endThickness)*0.5f;

			if ( rules->sphereGen == fCurGen ) {
				curChild->sphereRad = rules->sphereRad; //(maxLength-totLength) + 
			}

			if (curGen < maxGen) {
				applyRules(rules, curChild, curGen + 1, maxGen, totLength+curLength, maxLength);
			}

		}
	}
#undef LZZ_INLINE
 
// f00347_gamephysrig.h
//

#include "f00347_gamephysrig.e"
#define LZZ_INLINE inline
void GamePhysRig::updatePivot (int jointId)
                                      {
		
		
		
		RigJointStruct* curJoint = &(rigJoints[jointId]);
		RigJointStruct* parJoint;
		
		curJoint->isFixed = (baseEnt->entType == E_ENTTYPE_WEAPON);
		
		// btPoint2PointConstraint* ballC; //btFixedConstraint
		// btFixedConstraint* fixedC;
		btVector3 pivotA;
		btVector3 pivotB;
		btTransform localA, localB, localC;
		
		if (curJoint->joint == NULL) {
			
		}
		else {
			m_ownerWorld->removeConstraint(curJoint->joint);
			delete curJoint->joint;
			curJoint->joint = NULL;
		}
		
		if (curJoint->parentId < 0) { //
			curJoint->joint = NULL;
			//curJoint->body->setAngularFactor(btVector3(0.0f,0.0f,0.0f));
			//curJoint->body->setLinearFactor(btVector3(0.1f,0.1f,0.1f));
			
		}
		else {
			parJoint = &(rigJoints[curJoint->parentId]);
			pivotA = btVector3(-parJoint->length*0.5f,0.0,0.0);
			pivotB = btVector3( curJoint->length*0.5f,0.0,0.0);
			

			
			localA.setIdentity();
			localB.setIdentity();
			localA.setOrigin(pivotA);
			localB.setOrigin(pivotB);
			localA.getBasis() = parJoint->basis; 
			localB.getBasis() = curJoint->basis; 
			//localA.setRotation(parJoint->quat);
			//localB.setRotation(curJoint->quat);
			
			
			// if (curJoint->isFixed) {
			// 	curJoint->joint = new btFixedConstraint(
			// 		*(parJoint->body),
			// 		*(curJoint->body),
			// 		localA,
			// 		localB
			// 	);
			// }
			// else {
				curJoint->joint = new btPoint2PointConstraint(
					*(parJoint->body),
					*(curJoint->body),
					pivotA,
					pivotB
				);
			//}
			
			
			
			
			m_ownerWorld->addConstraint(curJoint->joint, true);
			
			
		}
	}
int GamePhysRig::addJoint (int nodeName, int parentId, int jointType, float mass, GameOrgNode * curNode)
          {
		
		int i;
		
		
		float rad = 0.0f;
		float len = 0.0f;
		
		btVector3 begPos;
		btVector3 midPos;
		btVector3 endPos;
		
		//int colInd = geId % MAX_COL_BODY;
		int colType = bodyCollidesWith;//[colInd];
		int colBase = COL_BODY;//0<<(colInd);
		
		
		
		switch(jointType) {
			case E_JT_LIMB:
				rad = 0.25f;
				len = curNode->orgTrans[0].getBTV().distance(curNode->orgTrans[2].getBTV());
				begPos = curNode->orgTrans[0].getBTV();
				midPos = curNode->orgTrans[1].getBTV();
				endPos = curNode->orgTrans[2].getBTV();
			break;
			case E_JT_BALL:
				rad = 0.05f;
				begPos = curNode->orgTrans[2].getBTV();
				midPos = curNode->orgTrans[2].getBTV();
				endPos = curNode->orgTrans[2].getBTV();
			break;
			case E_JT_NORM:
				// rad = 0.05f;
				// begPos = curNode->orgTrans[1].getBTV() + curNode->orgVecs[E_OV_NORMAL];
				// midPos = begPos;
				// endPos = begPos;
			break;
		}
		
		
		btVector3 targAlignT = curNode->tbnRotC[0].getBTV();
		btVector3 targAlignB = curNode->tbnRotC[1].getBTV();
		btVector3 targAlignN = curNode->tbnRotC[2].getBTV();
		
		
		
		
		
		btVector3 vUp(0, 0, 1);
		
		// btGeneric6DofSpringConstraint* springC;
		// btHingeConstraint* hingeC;
		// btConeTwistConstraint* coneC;

		btTransform localA, localB, localC;
		
		rigJoints.push_back(RigJointStruct());
		int curId = rigJoints.size()-1;
		
		RigJointStruct* curJoint = &(rigJoints.back());
		RigJointStruct* parJoint;
		//RigJointStruct* grdJoint;
		
		curJoint->boneId = nodeName;
		curJoint->jointType = jointType;
		curJoint->rad = rad;
		curJoint->length = len;
		//begOrig
		//endOrig
		curJoint->targAlignT = targAlignT;
		curJoint->targAlignB = targAlignB;
		curJoint->targAlignN = targAlignN;
		curJoint->jointId = curId;
		curJoint->parentId = parentId;
		
		//float jointSpace  = curJoint->rad*2.0f;
		
		float curLength = curJoint->length;// - curJoint->rad*4.0;
		
		if (parentId < 0) {
			curLength = curJoint->length;
		}
		
		switch(jointType) {
			case E_JT_LIMB:
				curJoint->shape = new btCapsuleShapeX(curJoint->rad, curLength);
			break;
			case E_JT_BALL:
				curJoint->shape = new btSphereShape(curJoint->rad);
			break;
			case E_JT_NORM:
				
			break;
		}
		
		
		
		btTransform transform;
		btTransform offset;
		
		
		
		
		
		offset.setIdentity();
		offset.setOrigin(origOffset);
		
		//btVector3 begPos = getStartPosition(curId);
		//btVector3 endPos = begPos + curJoint->targAlignT*(curJoint->length);
		//btVector3 midPos = (begPos+endPos)*0.5f;
		
		curJoint->begOrig = begPos;
		curJoint->midOrig = midPos;
		curJoint->endOrig = endPos;


		
		transform.setIdentity();
		transform.setOrigin(midPos);
		
		
		
		btVector3 axis;
		btScalar angle;
		btQuaternion quat;
		
		
		btVector3 vectorA = vUp;
		btVector3 vectorB = endPos-begPos;
		
		
		switch(jointType) {
			case E_JT_LIMB:
				vectorB.normalize();
			break;
			case E_JT_BALL:
				
			break;
			case E_JT_NORM:
				
			break;
		}
		
		
		// if ( abs(vectorA.dot(vectorB)) == 1.0f ) {
		// 	// todo: handle (anti)parallel case
		// 	//curJoint->pivotAxis = btVector3(0.0f,0.0f,0.0f);
		// 	curJoint->quat = btQuaternion(btVector3(0.0f,0.0f,1.0f), 0.0f);
		// }
		// else {
		// 	axis = (vectorA.cross(vectorB)).normalized();
		// 	angle = btAcos(vectorA.dot(vectorB)) / (vectorA.length() * vectorB.length());
		// 	curJoint->quat = btQuaternion(axis, angle);
		// 	transform.setRotation(curJoint->quat);
		// 	//curJoint->pivotAxis = axis;
		// }
		
		btMatrix3x3 basis = btMatrix3x3(
			targAlignT.getX(), targAlignT.getY(), targAlignT.getZ(),
			targAlignB.getX(), targAlignB.getY(), targAlignB.getZ(),
			targAlignN.getX(), targAlignN.getY(), targAlignN.getZ()
		);
		curJoint->basis = basis;
		transform.getBasis() = basis;
		
		
		/*
		setEulerZYX params in order: 
		eulerX	Roll about X axis
		eulerY	Pitch about Y axis
		eulerZ	Yaw about Z axis

		*/
		
		
		// xx, xy, xz,
		// yx, yy, yz,
		// zx, zy, zz
		
		// transform.getBasis().setValue(
			
		// );
		
		
		
		
		
		
		curJoint->body = singleton->gamePhysics->example->createRigidBodyMask(
			mass,
			offset*transform,
			curJoint->shape,
			colBase,
			colType
		);
		//curJoint->body->bodyUID = uid;
		//curJoint->body->setDamping(0.05, 0.85);
		curJoint->body->setDeactivationTime(0.8);
		curJoint->body->setSleepingThresholds(0.5f, 0.5f);

		
		
		// curJoint->joint = NULL;
		// return curId;
		
		curJoint->joint = NULL;
		updatePivot(curJoint->jointId);
		
		
		return curId;
		
	}
void GamePhysRig::initFromOrg (GameOrgNode * curNode, int curParent)
          {
		
		
		int i;
		
		float curMass = MASS_PER_LIMB;
		
		
		
		int curChild = addJoint(
			curNode->nodeName,
			curParent,
			E_JT_LIMB,
			curMass,
			curNode
		);
		
		int curChild2 = addJoint(
			curNode->nodeName,
			curChild,
			E_JT_BALL,
			curMass,
			curNode
			
		);
		
		// int curChild3 = addJoint(
		// 	curNode->nodeName,
		// 	curChild,
		// 	E_JT_NORM,
		// 	MASS_PER_LIMB,
		// 	curNode
		// );
		
		
		
		for (i = 0; i < curNode->children.size(); i++) {
			initFromOrg(
				curNode->children[i],
				curChild2
			);
		}
		
	}
void GamePhysRig::reinit ()
                      {
		removeAllBodies();
		initFromOrg(
			baseOrg->baseNode,
			-1
		);
	}
GamePhysRig::GamePhysRig (Singleton * _singleton, int _geId, btDynamicsWorld * ownerWorld, btVector3 const & positionOffset)
          {
		
		int i;
		
		singleton = _singleton;
		m_ownerWorld = ownerWorld;
		geId = _geId;
		//uid = _uid;
		
		origOffset = positionOffset;// - btVector3(0.0f,0.0f,16.0f);
		

		baseOrg = singleton->gem->gameOrgs[
			singleton->gem->gameObjects[geId].orgId	
		];
		
		baseEnt = &(singleton->gem->gameObjects[geId]);

		initFromOrg(
			baseOrg->baseNode,
			-1
		);

	}
void GamePhysRig::removeAllBodies ()
                               {
		int i;

		// Remove all constraints
		for ( i = 0; i < rigJoints.size(); ++i)
		{
			if (rigJoints[i].joint == NULL) {
				
			}
			else {
				m_ownerWorld->removeConstraint(rigJoints[i].joint);
				delete rigJoints[i].joint;
				rigJoints[i].joint = NULL;
			}
		}

		for ( i = 0; i < rigJoints.size(); ++i)
		{
			m_ownerWorld->removeRigidBody(rigJoints[i].body);
			
			delete rigJoints[i].body->getMotionState();
			delete rigJoints[i].body;
			rigJoints[i].body = NULL;
			delete rigJoints[i].shape;
			rigJoints[i].shape = NULL;
		}
		
		rigJoints.clear();
	}
GamePhysRig::~ GamePhysRig ()
        {
		removeAllBodies();
	}
#undef LZZ_INLINE
 
// f00349_gameentmanager.h
//

#include "f00349_gameentmanager.e"
#define LZZ_INLINE inline
GameEntManager::GameEntManager ()
                         {
		
	}
void GameEntManager::init (Singleton * _singleton)
                                         {
		singleton = _singleton;
		
		int i;
		int j;
		int k;
		
		weaponToPlace = E_PG_WPSWORD;
		
		activeActorUID = -1;
		curActorUID = -1;
		
		activeNode = NULL;
		selectedNode = NULL;
		lastSelNode = NULL;
		poseRootJS = NULL;
		
		curPoseType = -1;
		highlightedLimb = -1;
		
		takingTurn = true;
		curActorNeedsRefresh = false;
		destroyTerrain = false;
		editPose = false;
		EDIT_POSE = editPose;
		combatOn = false;
		mirrorOn = true;
		orgOn = false;
		isDraggingObject = false;
		firstPerson = false;
		showHealth = false;
		
		lastSubjectDistance = 0.0f;
		
		lastObjInd = 0;
		actObjInd = 0;
		setSelInd(0);
		
		draggingFromInd = 0;
		draggingToInd = 0;
		draggingFromType = E_DT_NOTHING;
		draggingToType = E_DT_NOTHING;
		gameObjCounter = E_OBJ_LENGTH;
		
		
		for (i = 0; i < E_ENTTYPE_LENGTH; i++) {
			entPoolStack[i].curIndex = 0;
			
			switch (i) {
				case E_ENTTYPE_BULLET:
					k = 10;
				break;
				case E_ENTTYPE_TRACE:
					k = 10;
				break;
				case E_ENTTYPE_DEBRIS:
					k = MAX_DEBRIS;
				break;
				default:
					k = 0;
				break;
				
			}

			entPoolStack[i].maxCount = k;
			
			for (j = 0; j < entPoolStack[i].maxCount; j++) {
				placeNewEnt(false, i, &singleton->origin, true);
			}
		}
		
		initAllObjects();
		loadPoseInfo(false);
		
	}
BaseObj * GameEntManager::getCurActor ()
                               {
		if (curActorUID < 0) {
			return NULL;
		}
		else {
			return &(gameObjects[curActorUID]);
		}
	}
BaseObj * GameEntManager::getActiveActor ()
                                  {
		if (activeActorUID < 0) {
			return NULL;
		}
		else {
			return &(gameObjects[activeActorUID]);
		}
	}
void GameEntManager::refreshActiveId ()
                               {
		if (turnList.size() == 0) {
			activeActorUID = -1;
		}
		else {
			activeActorUID = turnList[turnListInd];
		}
	}
void GameEntManager::endHumanTurn ()
                            {
		takingTurn = false;
		singleton->tbTicks = 1;
	}
void GameEntManager::cycleTurn ()
                         {
		refreshActiveId();
		
		if (curActorUID != activeActorUID) {
			takingTurn = false;
		}
		
		if ((curActorUID == activeActorUID)&&takingTurn) {
			// wait for human to take turn
		}
		else {
			nextTurn();
		}
		
	}
void GameEntManager::nextTurn ()
                        {
		singleton->tbTicks = 1;
		
		refreshActiveId();
		if (activeActorUID > -1) {
			changeStatus(activeActorUID, E_STATUS_STAMINA, 2);
		}
		
		turnListInd++;
		if (turnListInd >= turnList.size()) {
			turnListInd = 0;
		}
		
		refreshActiveId();
		
		if (curActorUID == activeActorUID) {
			// human turn
			takingTurn = true;
		}
		else {
			singleton->gameLogic->applyTBBehavior();
		}
		
	}
void GameEntManager::refreshTurnList ()
                               {
		int i;
		int testInd;
		BaseObj* testObj;
		
		turnListInd = 0;
		turnList.clear();
		
		for (i = 0; i < visObjects.size(); i++) {
			testInd = visObjects[i];
			testObj = &(gameObjects[testInd]);
			
			// todo: sort by initiative
			
			if (testObj->entType == E_ENTTYPE_NPC) {
				turnList.push_back(testInd);
			}
		}
	}
void GameEntManager::setTurnBased (bool newVal)
                                       {
		turnBased = newVal;
		
		int i;
		int testInd;
		BaseObj* testObj;
		
		for (i = 0; i < visObjects.size(); i++) {
			testInd = visObjects[i];
			testObj = &(gameObjects[testInd]);
			
			if (testObj->isHidden) {
				
			}
			else {
				testObj->tbPos = testObj->getUnitBounds(false);	
			}
			
			
		}
		
		refreshTurnList();
		
		cout << "turnBased " << turnBased << "\n";
	}
void GameEntManager::checkActorRefresh ()
                                 {
		if (curActorNeedsRefresh&&editPose) {
			refreshActor(getCurActorUID());
			curActorNeedsRefresh = false;
		}
	}
void GameEntManager::closeAllContainers ()
                                  {
		BaseObj* curCont;
		
		bool oldOpen;
		bool didClose = false;
		
		for (itBaseObj iterator = gameObjects.begin(); iterator != gameObjects.end(); iterator++) {
			// iterator->first = key
			// iterator->second = value
			
			
			
			curCont = &(gameObjects[iterator->first]);
			oldOpen = curCont->isOpen;
			
			curCont->isOpen = false;
			
			
			if (oldOpen != curCont->isOpen) {
				didClose = true;
			}
		}
		
		if (didClose) {
			singleton->playSoundEnt("leather0", NULL, 0.1);
		}
	}
bool GameEntManager::anyContainerOpen ()
                                {
		BaseObj* curCont;
		for (itBaseObj iterator = gameObjects.begin(); iterator != gameObjects.end(); iterator++) {
			// iterator->first = key
			// iterator->second = value
			
			curCont = &(gameObjects[iterator->first]);
			
			if (curCont->isOpen) {
				return true;
			}
		}
		return false;
	}
void GameEntManager::togglePoseEdit ()
                              {
		editPose = !editPose;
		EDIT_POSE = editPose;
		
		cout << "editPose " << editPose << "\n";
		
		if (editPose) {
			loadCurrentPose();
		}
	}
void GameEntManager::loadDefaultPose (int actorId)
                                          {
		BaseObj* ca = &(gameObjects[actorId]);
		
		if (ca->defaultPose.group < 0) {
			return;
		}
		
		string tempPoseString = getPoseString(
			ca->defaultPose.group,
			ca->defaultPose.RLBN,
			ca->defaultPose.step
		);
		
		if ( tempPoseString.compare("") == 0 ) {
			
		}
		else {
			gameOrgs[ca->orgId]->loadOrgFromFile(
				tempPoseString,
				false
			);
			gameOrgs[ca->orgId]->updateHandleOffset();
			transformOrg(gameOrgs[ca->orgId], NULL);
		}
		
		
		
	}
void GameEntManager::applyNonPoseData ()
                                {
		if (curPose[curPoseType].group == E_PG_NONPOSE) {
			saveCurrentPose();
			loadNonPoseData(E_PG_NONPOSE, RLBN_NEIT, 0);
		}
		else {
			cout << "Error, switch to E_PG_NONPOSE\n";
		}
	}
void GameEntManager::setFirstPerson (bool _newVal)
                                          {
		
		bool newVal = _newVal;
		
		if (getCurActor() == NULL) {
			newVal = false;	
		}
		
		if (firstPerson) {
			subjectDistance = lastSubjectDistance;
		}
		
		firstPerson = newVal;
		
		if (firstPerson) {
			lastSubjectDistance = subjectDistance;
		}
		
		cout << "firstPerson " << firstPerson << "\n";
	}
int GameEntManager::getCurActorUID ()
                             {
		if (getCurActor() == NULL) {
			return -1;
		}
		else {
			return getCurActor()->uid;
		}
	}
void GameEntManager::updateOrgMat (UIComponent * comp)
                                             {
		
		GameOrgNode* tmpNode = NULL;
		
		if (selectedNode != NULL) {
			
			selectedNode->orgVecs[E_OV_MATPARAMS].setFX(comp->index);
			tmpNode = getMirroredNode(selectedNode);
			if (tmpNode != NULL) {
				tmpNode->orgVecs[E_OV_MATPARAMS].setFX(comp->index);
			}
			makeDirty();
		}
	}
void GameEntManager::doDrag ()
                      {
		performDrag(
			singleton->gameNetwork->isConnected,
			draggingFromInd,
			draggingFromType,
			draggingToInd,
			draggingToType,
			&(singleton->worldMarker)
		);
	}
void GameEntManager::endDrag (int upInd)
                                {
		if (isDraggingObject) {
			
			if (upInd == 0) {
				draggingToInd = 0;
				draggingToType = E_DT_NOTHING;
				performDrag(
				singleton->gameNetwork->isConnected,
					draggingFromInd,
					draggingFromType,
					draggingToInd,
					draggingToType,
					&(singleton->worldMarker)
				);
			}
			else {
				if (upInd >= E_OBJ_LENGTH) {
					
						if (isContainer[gameObjects[upInd].objectType]) {
							draggingToInd = upInd;
							draggingToType = E_DT_WORLD_OBJECT;
						}
						else {
							draggingToInd = 0;
							draggingToType = E_DT_NOTHING;
						}
						
						performDrag(
							singleton->gameNetwork->isConnected,
							draggingFromInd,
							draggingFromType,
							draggingToInd,
							draggingToType,
							&(singleton->worldMarker)
						);
				}						
			}
			
			
			
		}
	}
bool GameEntManager::handleGUI (UIComponent * comp, bool mouseUpEvent, bool mouseDownEvent, bool noTravel, bool wasDoubleClick)
          {
		
		bool isCon = singleton->gameNetwork->isConnected;
		
		int i;
		
		//cout << "COMPINDEX: " << comp->index << "\n";
		
		
		if (comp->uid.compare("#contItemParent") == 0) {
			if (comp->jvNodeNoTemplate != NULL) {
				if (comp->jvNodeNoTemplate->HasChild("objectId")) {
					if (mouseUpEvent) {
						if (isDraggingObject) {
							if (noTravel) {
								
							}
							else {
								draggingToType = E_DT_INV_OBJECT_PARENT;
								draggingToInd = comp->jvNodeNoTemplate->Child("objectId")->number_value;
								doDrag();
							}
						}
					}
				}
			}
			return true;			
		}
		else if (comp->uid.compare("#contItem") == 0) {
			
			
			
			if (comp->jvNodeNoTemplate != NULL) {
				
				
				if (comp->jvNodeNoTemplate->HasChild("objectId")) {
					
					// !!
					
					if (mouseUpEvent) {
						
						if (wasDoubleClick) {
							i = comp->jvNodeNoTemplate->Child("objectId")->number_value;
							if (isContainer[gameObjects[i].objectType]) {
								cout << "isCont\n";
								toggleCont(i, false);
							}
							else {
								cout << "notCont\n";
								
								gameObjects[i].isEquipped = !(gameObjects[i].isEquipped);
								if (gameObjects[i].isEquipped) {
									singleton->playSoundEvent("showGUI");
								}
								else {
									singleton->playSoundEvent("hideGUI");
								}
								singleton->refreshContainers(false);
							}
							
							
						}
						else if (isDraggingObject) {
							if (noTravel) {
								
							}
							else {
								draggingToType = E_DT_INV_OBJECT;
								draggingToInd = comp->jvNodeNoTemplate->Child("objectId")->number_value;
								doDrag();
							}
							
						}
					}
					else if (mouseDownEvent&&(!editPose)) {
						
						isDraggingObject = true;
						draggingFromType = E_DT_INV_OBJECT;
						draggingFromInd = comp->jvNodeNoTemplate->Child("objectId")->number_value;
					}
				}
			}
			
			return true;
			
		}
		else if (mouseUpEvent) {
			if (comp->uid.compare("#contMenu.close") == 0) {		
				i = comp->getParent()->getChild(1)->jvNodeNoTemplate->Child("objectId")->number_value;
				closeContainer(i);
			}
			else if (comp->uid.compare("statMenu.close") == 0) {		
				singleton->menuList[E_FM_STATMENU]->visible = false;
				//i = comp->getParent()->getChild(1)->jvNodeNoTemplate->Child("objectId")->number_value;
				//closeContainer(i);
			}
			else if (comp->uid.compare("hudMenu.close") == 0) {		
				singleton->menuList[E_FM_HUDMENU]->visible = false;
				//i = comp->getParent()->getChild(1)->jvNodeNoTemplate->Child("objectId")->number_value;
				//closeContainer(i);
			}
			else if (comp->uid.compare("ddMenu.removeEntity") == 0) {
				removeEntity(isCon, selObjInd);
			}
			else if (comp->uid.compare("ddMenu.placeEntity.npc") == 0) {
				placeNewEnt(isCon, E_ENTTYPE_NPC, &singleton->lastCellPos);
			}
			else if (comp->uid.compare("ddMenu.placeEntity.sword") == 0) {
				weaponToPlace = E_PG_WPSWORD;
				placeNewEnt(isCon, E_ENTTYPE_WEAPON, &singleton->lastCellPos);
			}
			else if (comp->uid.compare("ddMenu.placeEntity.axe") == 0) {
				weaponToPlace = E_PG_WPAXE;
				placeNewEnt(isCon, E_ENTTYPE_WEAPON, &singleton->lastCellPos);
			}
			else if (comp->uid.compare("ddMenu.placeEntity.mace") == 0) {
				weaponToPlace = E_PG_WPMACE;
				placeNewEnt(isCon, E_ENTTYPE_WEAPON, &singleton->lastCellPos);
			}
			else if (comp->uid.compare("ddMenu.placeEntity.hammer") == 0) {
				weaponToPlace = E_PG_WPHAMMER;
				placeNewEnt(isCon, E_ENTTYPE_WEAPON, &singleton->lastCellPos);
			}
			else if (comp->uid.compare("ddMenu.placeEntity.staff") == 0) {
				weaponToPlace = E_PG_WPSTAFF;
				placeNewEnt(isCon, E_ENTTYPE_WEAPON, &singleton->lastCellPos);
			}
			else if (comp->uid.compare("ddMenu.placeEntity.spear") == 0) {
				weaponToPlace = E_PG_WPSPEAR;
				placeNewEnt(isCon, E_ENTTYPE_WEAPON, &singleton->lastCellPos);
			}
			
			// else if (comp->uid.compare("ddMenu.placeEntity.object") == 0) {
			// 	placeNewEnt(singleton->gameNetwork->isConnected,E_ENTTYPE_OBJ, (int)E_SUB_DEFAULT, &singleton->lastCellPos);
			// }
			else {
				return false;
			}
		}
		else {
			return false;
		}
		
		
		return true;
	}
BaseObj * GameEntManager::getEquipped (BaseObj * parentObj)
                                                 {
		int i;
		
		int curChild;
		
		for (i = 0; i < parentObj->children.size();i++) {
			curChild = parentObj->children[i];
			if (gameObjects[curChild].isEquipped) {
				return &(gameObjects[curChild]);
			}
		}
		
		return NULL;
	}
void GameEntManager::updateDragInfo (int bestInd, bool lbDown, bool wasDoubleClick)
                                                                           {
		
		if (lbDown) {
			setSelInd(bestInd);
			
			if (selObjInd != 0) {
				if (lastObjInd == selObjInd) {
					
				}
			}
			
			lastObjInd = selObjInd;
			
			
			
			draggingFromInd = 0;
			draggingFromType = E_DT_NOTHING;
			
			
			
			if ((bestInd >= E_OBJ_LENGTH)&&(!editPose)) {
				
				isDraggingObject = true;
				//singleton->markerFound = true;
				draggingFromInd = selObjInd;
				draggingFromType = E_DT_WORLD_OBJECT;
				
				// todo: make sure bestInd exists
				
			}
			else {
				
				// if (bCtrl) {
				// 	if (bestInd <= 0) {
						
				// 	}
				// 	else {
				// 		activeObject = (E_OBJ)(bestInd);
				// 		hitObject = true;
				// 	}
				// }
				
				// if (hitObject) {
					
				// }
				// else {
				// 	//setCurActor(-1);
				// }
				
				
			}
		}
		else {
			if (wasDoubleClick) {
				toggleCont(selObjInd, true);
			}
		}
		
		
	}
int GameEntManager::getRandomContId ()
                              {
		return iGenRand2(360,419);
	}
int GameEntManager::getRandomNPCId ()
                             {
		return (iGenRand2(1432,1671)/4)*4;
	}
int GameEntManager::getRandomMonsterId ()
                                 {
		return (iGenRand2(1240,1431)/2)*2;
	}
int GameEntManager::getRandomObjId ()
                             {
		return iGenRand2(0,907);
		
	}
void GameEntManager::fillWithRandomObjects (int parentUID, int gen)
                                                           {
		
		int i;
		int maxObj = iGenRand2(2,16);
		BaseObj* tmpObj = NULL;
		
		int curId;
		
		
		for (i = 0; i < maxObj; i++) {
			gameObjects[gameObjCounter] = BaseObj();
			tmpObj = &(gameObjects[gameObjCounter]);
			
			curId = getRandomObjId();
			
			
			// if (
			// 	(curId%5 == 0) &&
			// 	(gen <= 1)
			// ) {
				
			// 	curId = getRandomContId();
			// }
			
			tmpObj->init(
				gameObjCounter,
				parentUID,
				curId,
				E_ENTTYPE_OBJ,
				(int)E_SUB_DEFAULT,
				&singleton->lastCellPos
			);
			
			gameObjects[parentUID].children.push_back(gameObjCounter);
			
			gameObjCounter++;
			
			if (isContainer[curId] && (gen < 1)) {
				fillWithRandomObjects(gameObjCounter-1, gen + 1);
			}
			
		}
		
	}
void GameEntManager::removeEntity (bool isReq, int ind)
                                               {
		
		if (isReq) {
			singleton->naIntData[0] = ind;
			singleton->gameNetwork->addNetworkAction(
				E_NO_REM_ENT,
				singleton->naUintData,
				singleton->naIntData,
				singleton->naFloatData
			);
			return;
		}
		
		if (ind >= E_OBJ_LENGTH) {
			if (removeVisObject(ind, false)) {
				setSelInd(0);
			}
		}
	}
bool GameEntManager::isRecycledFunc (int poolId)
                                        {
		if (
			(entPoolStack[poolId].maxCount == 0) ||
			(entPoolStack[poolId].entIds.size() < entPoolStack[poolId].maxCount)	
		) {
			return false;
		}
		else {
			return true;
		}
	}
BaseObjType GameEntManager::placeNewEnt (bool isReq, int et, FIVector4 * cellPos, bool isHidden)
          {
		
		BaseObj* tmpObj = NULL;
		
		int newType = 0;
		int poolId = et;
		int xv = 1;
		int yv = 1;
		int zv = 1;
		
		int curEntId;
		
		int mf = 0;
		
		int curSubType = (int)E_SUB_DEFAULT;
		
		bool isRecycled = false;
		
		if (isReq) {
			singleton->naFloatData[0] = cellPos->getFX();
			singleton->naFloatData[1] = cellPos->getFY();
			singleton->naFloatData[2] = cellPos->getFZ();
			singleton->naIntData[0] = et;
			singleton->gameNetwork->addNetworkAction(E_NO_ADD_ENT,singleton->naUintData,singleton->naIntData,singleton->naFloatData);
			return - 1;
		}
		
		float bounciness = 0.0f;
		float friction = 0.9;
		float windResistance = 0.9;
		
		switch (et) {
			case E_ENTTYPE_OBJ:
				newType = getRandomObjId();
				friction = 0.1;
				windResistance = 1.0f;
				bounciness = 0.3;
			break;
			case E_ENTTYPE_NPC:
				newType = getRandomNPCId();
				mf = 4;
				zv = 2;
			break;
			
			case E_ENTTYPE_BULLET:
			case E_ENTTYPE_TRACE:
				
				if (singleton->waterBulletOn) {
					newType = 1103;
				}
				else {
					newType = 1139;
				}
				
				// if (et == E_ENTTYPE_TRACE) {
					
				// }
				
			break;
			
			case E_ENTTYPE_DEBRIS:
				newType = 0;
			break;
			case E_ENTTYPE_WEAPON:
				newType = 0;
				
			break;
			
			
		}
		
		
		if (
			isRecycledFunc(et)
		) {
			
			
			isRecycled = true;
			curEntId = entPoolStack[poolId].entIds[
				entPoolStack[poolId].curIndex
			];
			
			entPoolStack[poolId].curIndex++;
			if (entPoolStack[poolId].curIndex == entPoolStack[poolId].maxCount) {
				entPoolStack[poolId].curIndex = 0;
			}
			
		}
		else {
			isRecycled = false;
			curEntId = gameObjCounter;
			entPoolStack[poolId].entIds.push_back(gameObjCounter);
			
		}
		
		FIVector4 newPos;
		newPos.copyFrom(cellPos);
		
		if (isRecycled) {
			removeVisObject(curEntId,true);
		}
		else {
			newPos.addXYZ(0.0f,0.0f,4.0f);
		}
		
		
		
		
		gameObjects[curEntId] = BaseObj();
		tmpObj = &(gameObjects[curEntId]);
		tmpObj->init(
			curEntId,
			0,
			newType,
			et,
			curSubType,
			&newPos
		);
		
		tmpObj->tbPos = floorBTV(cellPos->getBTV());
		
		
		
		
		tmpObj->defaultPose.group = -1;
		tmpObj->defaultPose.RLBN = RLBN_NEIT;
		tmpObj->defaultPose.step = 0;
		
		switch (et) {
			case E_ENTTYPE_NPC:
				tmpObj->defaultPose.group = E_PG_NONPOSE;
			break;
			case E_ENTTYPE_WEAPON:
				tmpObj->defaultPose.group = weaponToPlace;
			break;
		}
		
		
		if (
			(et == E_ENTTYPE_BULLET) ||
			(et == E_ENTTYPE_TRACE)
		) {
			
			bounciness = 0.0f;
			friction = 0.0f;
			windResistance = 1.0f;
			
		}
		
		
		tmpObj->isHidden = isHidden;
		tmpObj->bounciness = bounciness;
		tmpObj->friction = friction;
		tmpObj->windResistance = windResistance;
		
		tmpObj->maxFrames = mf;
		
		BaseObjType thisObjId = curEntId;
		
		if (isRecycled) {
			addVisObject(curEntId, true);
		}
		else {
			addVisObject(curEntId, false);
			
			gameObjCounter++;
			
			if (isContainer[newType]) {
				fillWithRandomObjects(gameObjCounter-1, 0);
			}
		}
		
		
		
		return thisObjId;
		
	}
void GameEntManager::performDrag (bool isReq, int _draggingFromInd, int _draggingFromType, int _draggingToInd, int _draggingToType, FIVector4 * _worldMarker)
          {
		
		int i;
		int bestPos;
		bool moveCont = false;
		bool draggedIntoWorldObj = false;
		BaseObj* sourceObj = NULL;
		BaseObj* destObj = NULL;
		
		vector<BaseObjType>* myVec;
		
		if (isReq) {
			singleton->naFloatData[0] = _worldMarker->getFX();
			singleton->naFloatData[1] = _worldMarker->getFY();
			singleton->naFloatData[2] = _worldMarker->getFZ();
			singleton->naIntData[0] = _draggingFromInd;
			singleton->naIntData[1] = _draggingFromType;
			singleton->naIntData[2] = _draggingToInd;
			singleton->naIntData[3] = _draggingToType;
			singleton->gameNetwork->addNetworkAction(E_NO_DRAG_ENT,singleton->naUintData,singleton->naIntData,singleton->naFloatData);
			return;
		}
		
		
		cout << "from " << dragStrings[_draggingFromType] << " to " << dragStrings[_draggingToType] << "\n";
		
		switch (_draggingFromType) {
			case E_DT_NOTHING:
				
			break;
			case E_DT_WORLD_OBJECT:
			
				sourceObj = &(gameObjects[_draggingFromInd]);
			
				switch (_draggingToType) {
					case E_DT_NOTHING:
						
						// singleton->lastCellPos.copyFrom(_worldMarker);
						// singleton->lastCellPos.addXYZ(0,0,5);
						// sourceObj->setCenterPoint(&singleton->lastCellPos);
						
						
					break;
					case E_DT_WORLD_OBJECT:
					case E_DT_INV_OBJECT:
					case E_DT_INV_OBJECT_PARENT:
						destObj = &(gameObjects[_draggingToInd]);
						moveCont = true;
					break;
				}
			break;
			
			case E_DT_INV_OBJECT:
			
				sourceObj = &(gameObjects[_draggingFromInd]);
			
				switch (_draggingToType) {
					case E_DT_NOTHING:
						
						
						singleton->lastCellPos.copyFrom(_worldMarker);
						singleton->lastCellPos.addXYZ(0,0,5);
						sourceObj->startPoint = singleton->lastCellPos.getBTV();
						
						
						gameObjects[sourceObj->parentUID].removeChild(sourceObj->uid);
						addVisObject(sourceObj->uid, false);
						sourceObj->parentUID = 0;
						
						
					break;
					case E_DT_WORLD_OBJECT:
					case E_DT_INV_OBJECT:
					case E_DT_INV_OBJECT_PARENT:
						destObj = &(gameObjects[_draggingToInd]);
						moveCont = true;
					break;
				}
			break;
			case E_DT_INV_OBJECT_PARENT:
				
			break;
		}
		
		
		if (moveCont) {
			
			if (isContainer[destObj->objectType]) {	
				if (_draggingFromInd == _draggingToInd) {
					goto PERFORM_DRAG_END;
				}
			}
			else {
				if (_draggingFromInd == destObj->parentUID) {
					goto PERFORM_DRAG_END;
				}
			}
			
			
			gameObjects[sourceObj->parentUID].removeChild(sourceObj->uid);
			
			if (isContainer[destObj->objectType]) {
				destObj->children.push_back(sourceObj->uid);
				sourceObj->parentUID = destObj->uid;
				draggedIntoWorldObj = true;
			}
			else {
				
				myVec = &(gameObjects[destObj->parentUID].children);
				
				bestPos = 0;
				for (i = 0; i < myVec->size(); i++) {
					if ((*myVec)[i] == destObj->uid) {
						bestPos = i+1;
					}
				}
				myVec->insert(
					myVec->begin()+bestPos,
					sourceObj->uid
				);
				
				sourceObj->parentUID = destObj->parentUID;
			}
			
			if (_draggingFromType == E_DT_WORLD_OBJECT) {
				removeVisObject(sourceObj->uid, false);
			}
			
		}
		
		
		
		if (
			(_draggingFromType == E_DT_INV_OBJECT) ||
			(_draggingToType == E_DT_INV_OBJECT) ||
			(_draggingToType == E_DT_INV_OBJECT_PARENT) ||
			draggedIntoWorldObj
		) {
			singleton->refreshContainers(false);
		}
		
		
		PERFORM_DRAG_END:		
		singleton->markerFound = false;
		isDraggingObject = false;
	}
void GameEntManager::setCurActor (int newUID)
                                     {
		
		curActorUID = newUID;
		
		BaseObj* ca;
		
		if (curActorUID < 0) {
			actObjInd = 0;
			setFirstPerson(false);
		}
		else {
			ca = &(gameObjects[newUID]);
			actObjInd = newUID;
			subjectDistance = singleton->BTV2FIV(
				ca->getCenterPoint(E_BDG_CENTER)
			)->distance(singleton->cameraGetPosNoShake());
			curPoseType = ca->entType;
		}
		
		
	}
void GameEntManager::toggleFirstPerson ()
                                 {
		setFirstPerson(!firstPerson);
	}
void GameEntManager::toggleActorSel ()
                              {
		singleton->targetSubjectZoom = 1.0f;
		singleton->subjectZoom = singleton->targetSubjectZoom;
		
		if (selObjInd >= E_OBJ_LENGTH) {
			if (selObjInd == actObjInd) {
				setCurActor(-1);
			}
			else {
				setCurActor(selObjInd);
				
				if (getCurActor() != NULL) {
					
				}
				
				
				singleton->playSoundEnt(
					"swimming0",
					getCurActor(),
					0.0f,
					0.0f,
					true
				);
				
				singleton->playSoundEnt(
					"walkinggravel0",
					getCurActor(),
					0.0f,
					0.0f,
					true
				);
				
			}
		}
		else {
			setCurActor(-1);
		}
	}
void GameEntManager::setSelInd (int ind)
                                {
		selObjInd = ind;
	}
void GameEntManager::closeContainer (int i)
                                   {
		singleton->playSoundEnt("leather0", NULL, 0.1);
		gameObjects[i].isOpen = false;
		singleton->refreshContainers(false);
	}
void GameEntManager::toggleCont (int contIndex, bool onMousePos)
                                                        {
		
		if (contIndex < E_OBJ_LENGTH) {
			return;
		}
		
		if (
			isContainer[gameObjects[contIndex].objectType]
		) {
			singleton->playSoundEnt("leather0", NULL, 0.1);
			gameObjects[contIndex].isOpen = !(gameObjects[contIndex].isOpen);
			singleton->refreshContainers(onMousePos);
		}
		else {
			singleton->playSoundEnt("bump0");	
		}
		
		
	}
void GameEntManager::addVisObject (BaseObjType _uid, bool isRecycled)
                                                             {
		
		BaseObj* ge = &(gameObjects[_uid]);
		
		if (isRecycled) {
			
		}
		else {
			visObjects.push_back(_uid);
		}
		
		if (ge->isHidden) {
			
		}
		else {
			singleton->gamePhysics->addBoxFromObj(_uid, false);
		}
		
	}
bool GameEntManager::removeVisObject (BaseObjType _uid, bool isRecycled)
                                                                {
		int i;
		
		BaseObj* ge = &(gameObjects[_uid]);
		
		singleton->gamePhysics->remBoxFromObj(_uid);
		
		// if (ge->body != NULL) {
		// 	//singleton->gamePhysics->scene->RemoveBody(ge->body);
		// 	ge->body = NULL;
		// }
		
		if (isRecycled) {
			ge->isHidden = true;
			return true;
		}
		else {
			for (i = 0; i < visObjects.size(); i++) {
				if (visObjects[i] == _uid) {
					visObjects.erase(visObjects.begin() + i);
					return true;
				}
			}
		}
		
		
		return false;
	}
bool GameEntManager::areEnemies (int actorUID1, int actorUID2)
                                                      {
		return true;
	}
bool GameEntManager::areFriends (int actorUID1, int actorUID2)
                                                      {
		return false;
	}
int GameEntManager::getUnitDisXY (btVector3 p1, btVector3 p2)
                                                     {
		
				
		return 
			floor(abs(p1.getX() - p2.getX())) +
			floor(abs(p1.getY() - p2.getY()));
		
	}
btVector3 GameEntManager::getUnitDistance (int actorUID1, int actorUID2)
                                                                {
		
		if (
			(actorUID1 < 0) ||
			(actorUID2 < 0)	
		) {
			return btVector3(-1.0f,-1.0f,-1.0f);
		}
		
		BaseObj* actor1 = &(gameObjects[actorUID1]);
		BaseObj* actor2 = &(gameObjects[actorUID2]);
		
		btVector3 p1 = actor1->tbPos;
		btVector3 p2 = actor2->tbPos;
				
		return btVector3(
			abs(p1.getX() - p2.getX()),
			abs(p1.getY() - p2.getY()),
			abs(p1.getZ() - p2.getZ())
		);
		
	}
int GameEntManager::getClosestActor (int actorId, int objType, float maxDis, uint flags)
          {
		
		int i;
		float bestDis = maxDis;
		float testDis;
		int testInd;
		int bestInd = -1;
		
		if (actorId < 0) {
			return -1;
		}
		
		BaseObj* ca = &(gameObjects[actorId]);
		
		BaseObj* testObj;
		
		bool testForGrabbed = ( (flags&E_CF_NOTGRABBED) > 0 );
		bool testForEnemies = ( (flags&E_CF_AREENEMIES) > 0 );
		bool testForFriends = ( (flags&E_CF_AREFRIENDS) > 0 );
		bool testForAlive = ( (flags&E_CF_ISALIVE) > 0 );
		
		for(i = 0; i < visObjects.size(); i++) {
			
			testInd = visObjects[i];
			testObj = &(gameObjects[testInd]);
			
			// if (
			// 	(testInd == actorId) ||
			// 	(testObj->isGrabbedById >= 0) ||
			// 	(testObj->getVel(0)->length() > 2.0f) ||
			// 	(testObj->isHidden) ||
			// 	(testObj->entType != objType)	
			// )
			
			if (
				(!(testObj->isHidden)) &&
				(testObj->entType == objType)	&&
				(testInd != actorId)
			) {
				
				if (
					
					(
						( testForGrabbed && (testObj->isGrabbedById < 0) ) ||
						(!testForGrabbed)
					) &&
					(
						( testForEnemies && (areEnemies(actorId,testInd)) ) ||
						(!testForEnemies)
					) &&
					(
						( testForFriends && (areFriends(actorId,testInd)) ) ||
						(!testForFriends)
					) &&
					(
						( testForAlive && (testObj->isAlive()) ) ||
						(!testForAlive)
					)
					
				) {
					testDis = testObj->getCenterPoint(0).distance(ca->getCenterPoint(0));
					
					if (testDis < bestDis) {
						bestDis = testDis;
						bestInd = testInd;
					}
				}
				
				
			}
		}
		
		return bestInd;
		
	}
GameOrg * GameEntManager::getCurOrg ()
                             {
		if (getCurActor() == NULL) {
			return NULL;
		}
		if (getCurActor()->orgId < 0) {
			return NULL;
		}
		return gameOrgs[getCurActor()->orgId];
	}
BaseObj * GameEntManager::getActorRef (int uid)
                                      {
		if (uid < 0) {
			return NULL;
		}
		else {
			return &(gameObjects[uid]);
		}
	}
bool GameEntManager::combatMode ()
                          {
		return (getCurActor() != NULL)&&combatOn&&(!editPose);
	}
bool GameEntManager::isSwingingWeapon (int actorId, int handNum)
                                                        {
		if (actorId < 0) {
			return false;
		}
		BaseObj* ca = &(gameObjects[actorId]);
		PoseInfo* curPI = &(gamePoseInfo[ca->swingType[handNum]]);
		return (curPI->data[E_PIK_SUBTYPE] == E_SUB_SWING);
	}
bool GameEntManager::isPunching (int actorId, int handNum)
                                                  {
		if (actorId < 0) {
			return false;
		}
		BaseObj* ca = &(gameObjects[actorId]);
		PoseInfo* curPI = &(gamePoseInfo[ca->swingType[handNum]]);
		return (curPI->data[E_PIK_SUBTYPE] == E_SUB_PUNCH);
	}
bool GameEntManager::isKicking (int actorId, int handNum)
                                                 {
		if (actorId < 0) {
			return false;
		}
		BaseObj* ca = &(gameObjects[actorId]);
		PoseInfo* curPI = &(gamePoseInfo[ca->swingType[handNum]]);
		return (curPI->data[E_PIK_SUBTYPE] == E_SUB_KICK);
	}
void GameEntManager::setSwing (float _mx, float _my, int actorId, int handNum, bool isKick)
          {
		
		float mx = _mx;
		float my = -_my;
		
		
		
		if (actorId < 0 ) {
			return;
		}
		
		//int handMod = 0;
		
		BaseObj* ca = &(gameObjects[actorId]);
		
		bool isHolding = (ca->isGrabbingId[handNum] > -1);
		
		// if (handNum == RLBN_RIGT) {
		// 	mx *= -1.0f;
		// }
		
		// if (handNum == RLBN_LEFT) {
		// 	handMod = 1;
		// }
		
		int curAttack = E_PG_SLSH;
		
		if (abs(my) > abs(mx)) {
			if (my > 0.0f) {
				// top
				
				if (isKick) {
					curAttack = E_PG_BKIK;
				}
				else {
					if (isHolding) {
						curAttack = E_PG_HACK;
					}
					else {
						curAttack = E_PG_UPPR;
					}
				}
				
				
			}
			else {
				// bottom
				
				if (isKick) {
					curAttack = E_PG_FRNT;
				}
				else {
					if (isHolding) {
						curAttack = E_PG_STAB;
					}
					else {
						curAttack = E_PG_JABP;
					}
				}
				
			}
		}
		else {
			if (mx > 0.0f) {
				// right
				
				if (isKick) {
					curAttack = E_PG_ROUN;
				}
				else {
					if (isHolding) {
						curAttack = E_PG_SLSH;
					}
					else {
						curAttack = E_PG_HOOK;
					}
				}
				
			}
			else {
				// left
				
				if (isKick) {
					curAttack = E_PG_REVR;
				}
				else {
					if (isHolding) {
						curAttack = E_PG_BACK;
					}
					else {
						curAttack = E_PG_ELBO;
					}
				}
				
			}
		}
		
		//curAttack += handMod;
		
		ca->swingType[handNum] = curAttack;
		
	}
void GameEntManager::nextSwing (int actorId, int handNum)
                                                 {
		
		if (actorId < 0 ) {
			return;
		}
		
		BaseObj* ca = &(gameObjects[actorId]);
		
		ca->swingType[handNum] += iGenRand2(1,10);
		
		if (ca->swingType[handNum] > (E_PG_FRNT)) {
			ca->swingType[handNum] -= E_PG_FRNT;
			ca->swingType[handNum] += (E_PG_SLSH);
		}
		
		
	}
void GameEntManager::makeShoot (int actorId, int bulletType)
                                                    {
		
		int entNum;
		
		int vx;
		int vy;
		
		
		FIVector4 newCellPos;
		FIVector4 newVel;
		
		if (actorId < 0) {
			return;
		}
		
		
		
		BaseObj* ca = &(gameObjects[actorId]);
		
		if (ca == NULL) {
			
		}
		else {
			
			if (ca->hasBodies()) {
			
				newCellPos.setBTV(ca->getCenterPoint(E_BDG_CENTER));
				
				// vx = cos(ca->ang)*3.0f;
				// vx = vx;
				
				// vy = sin(ca->ang)*3.0f;
				// vy = vy;
				
				
				btVector3 tempBTV = multByOtherRot(
					btVector3(0.0f,3.0f,3.0f),
					ca->bodies[E_BDG_CENTER].body->getCenterOfMassTransform().getBasis()
				);
				newCellPos.addXYZ(tempBTV.getX(), tempBTV.getY(), tempBTV.getZ());
				
				entNum = placeNewEnt(false, bulletType, &newCellPos);
				
				
				
				// gameObjects[entNum].setVel(
				// 	cos(ca->ang)*20.0f,
				// 	sin(ca->ang)*20.0f,
				// 	30.0f
				// );
			
			
				gameObjects[entNum].applyImpulseOtherRot(
					btVector3(0.0,200,200)*gameObjects[entNum].getTotalMass(),
					ca->bodies[E_BDG_CENTER].body->getCenterOfMassTransform().getBasis(),
					true,
					0
				);
			}
			
			
			
			if (bulletType != E_ENTTYPE_TRACE) {
				singleton->playSoundEnt(
					"woosh0",
					ca,
					0.2f
				);
			}
			
			
			
		}
	}
void GameEntManager::bindPose (int actorId, int handNum, bool bindOn)
                                                             {
		
		if (actorId < -1) {
			return;
		}
		
		BaseObj* ca = &(gameObjects[actorId]);
		
		if ((ca->entType != E_ENTTYPE_NPC) || (ca->orgId < 0)) {
			return;
		}
		
		GameOrg* curOrg = gameOrgs[ca->orgId];
		
		BaseObj* grabObj;
		GameOrg* grabObjOrg;
		
		if (ca->isGrabbingId[handNum] > -1) {
			grabObj = &(gameObjects[ca->isGrabbingId[handNum]]);
			grabObjOrg = gameOrgs[grabObj->orgId];
			
			
			
			
			if (bindOn) {
				if (handNum == RLBN_LEFT) {
					curOrg->allNodes[
						getCorrectedName(E_BONE_L_METACARPALS)
					]->children.push_back(
						grabObjOrg->allNodes[E_BONE_C_BASE]
					);
					grabObjOrg->allNodes[E_BONE_C_BASE]->parent = 
						curOrg->allNodes[
							getCorrectedName(E_BONE_L_METACARPALS)
						];
					
					grabObjOrg->allNodes[E_BONE_C_BASE]->flipOrient(-1.0f);
					transformOrg(curOrg, NULL);
				}
				else {
					curOrg->allNodes[
						getCorrectedName(E_BONE_R_METACARPALS)
					]->children.push_back(
						grabObjOrg->allNodes[E_BONE_C_BASE]
					);
					grabObjOrg->allNodes[E_BONE_C_BASE]->parent = 
						curOrg->allNodes[
							getCorrectedName(E_BONE_R_METACARPALS)
						];
					
					grabObjOrg->allNodes[E_BONE_C_BASE]->flipOrient(1.0f);
					transformOrg(curOrg, NULL);
				}
			}
			else {
				if (handNum == RLBN_LEFT) {
					curOrg->allNodes[
						getCorrectedName(E_BONE_L_METACARPALS)
					]->children.pop_back();
				}
				else {
					curOrg->allNodes[
						getCorrectedName(E_BONE_R_METACARPALS)
					]->children.pop_back();
				}
				grabObjOrg->allNodes[E_BONE_C_BASE]->parent = NULL;
				
			}
			
			
			
			
		}
		
	}
void GameEntManager::makeGrab (int actorId, int _handNum)
                                                 {
		
		int res;
		
		if (actorId < 0) {
			return;
		}
		
		int handNum = _handNum;
		
		BaseObj* ca = &(gameObjects[actorId]);
		GameOrg* curOrg = gameOrgs[ca->orgId];
		
		BaseObj* grabObj;
		GameOrg* grabObjOrg;
		
		if (handNum < 0) {
			handNum = 0;
			
			if (ca->isGrabbingId[handNum] > -1) {
				handNum = 1;
			}
			
		}
		
		if (ca->isGrabbingId[handNum] < 0) {
			
			// find obj to pickup
			
			res = getClosestActor(
				actorId,
				E_ENTTYPE_WEAPON,
				5.0f,
				E_CF_NOTGRABBED
			);
			
			if (res < 0) {
				
			}
			else {
				
				curOrg->stepCount = 0;
				curOrg->totTime = 0;
				ca->setActionState(E_ACT_ISPICKINGUP,RLBN_NEIT,true);
				
				grabObj = &(gameObjects[res]);
				grabObjOrg = gameOrgs[grabObj->orgId];
				
				singleton->playSoundEnt(
					"scrape0",
					ca,
					0.2f
				);
				
				ca->isGrabbingId[handNum] = res;
				grabObj->setGrabbedBy(actorId, handNum);
				
				bindPose(actorId,handNum,true);
				
				
			}
			
			
		}
		
		
	}
void GameEntManager::makeDropAll (int actorId)
                                      {
		int i;
		
		
		
		if (actorId < 0) {
			return;
		}
		
		BaseObj* ca = &(gameObjects[actorId]);
		
		for (i = 0; i < 2; i++) {
			if (ca->isGrabbingId[i] > -1) {
				makeThrow(ca->uid,i);
			}
		}
	}
void GameEntManager::makeThrow (int actorId, int _handNum)
                                                  {
		
		int res;
		
		if (actorId < 0) {
			return;
		}
		
		int handNum = _handNum;
		
		BaseObj* ca = &(gameObjects[actorId]);
		GameOrg* curOrg = gameOrgs[ca->orgId];
		
		if (ca->entType != E_ENTTYPE_NPC) {
			return;
		}
		
		BaseObj* grabObj;
		GameOrg* grabObjOrg;
		
		if (handNum < 0) {
			handNum = 0;
			
			if (ca->isGrabbingId[handNum] < 0) {
				handNum = 1;
			}
			
		}
		
		
		if (ca->isGrabbingId[handNum] > -1) {
			// throw current obj
			
			grabObj = &(gameObjects[ca->isGrabbingId[handNum]]);
			grabObjOrg = gameOrgs[grabObj->orgId];
			
			
			if (ca->hasBodies()) {
				grabObj->applyImpulseOtherRot(
					btVector3(
						0.0,
						singleton->conVals[E_CONST_THROW_STRENGTHXY],
						singleton->conVals[E_CONST_THROW_STRENGTHZ]
					)*grabObj->getMarkerMass(),
					ca->bodies[E_BDG_CENTER].body->getCenterOfMassTransform().getBasis(),
					false,
					0
				);
			}
			
			singleton->playSoundEnt(
				"woosh0",
				ca,
				0.2f
			);
			
			bindPose(actorId,handNum,false);
			grabObj->setGrabbedBy(-1, -1);
			ca->isGrabbingId[handNum] = -1;
			
			
		}
		
	}
void GameEntManager::changeStatus (int actorId, int status, int modVal)
                                                               {
		if (actorId < 0 ) {
			return;
		}
		BaseObj* ca = &(gameObjects[actorId]);
		
		ca->modifyStatus(status,modVal);
		
		//if (ca->uid == curActorUID) {
			
			
			singleton->updateStatusHUD();
		//}
		
	}
void GameEntManager::makeSwing (int actorId, int handNum)
                                                 {
		
		int totCost;
		
		if (editPose) {
			return;
		}
		
		if (actorId < 0 ) {
			return;
		}
		
		BaseObj* ca = &(gameObjects[actorId]);
		
		if (ca->entType != E_ENTTYPE_NPC) {
			return;
		}
		
		GameOrg* curOrg;
		
		if (ca->isDead()) {
			return;
		}
		
		int i;
		
		btVector3 swingPos;
		BaseObj* entInSquare;
		
		if (ca->getActionState(E_ACT_ISSWINGING,handNum) || (ca->bindingPower < 0.01f)) {
			
		}
		else {
			
			for (i = 0; i < RLBN_LENGTH; i++) {
				if (i != handNum) {
					ca->setActionState(E_ACT_ISSWINGING,i,false);
					ca->setActionState(E_ACT_HASNOTHIT,i,false);
				}
			}
			
			
			
			//if (ca->weaponActive) {
				
				ca->setActionState(E_ACT_ISSWINGING,handNum,true);
				ca->setActionState(E_ACT_HASNOTHIT,handNum,true);
				curOrg = gameOrgs[ca->orgId];
				curOrg->stepCount = 0;
				curOrg->totTime = 0;
				singleton->playSoundEnt("woosh0", ca, 0.25f);
				singleton->playSoundEnt("gruntm0", ca, 0.25f, 0.1f);
				
				
				
				// if (ca->baseContact()) {
				// 	makeMove( actorId,
				// 		btVector3(
				// 			0.0f,
				// 			singleton->conVals[E_CONST_DASH_AMOUNT],
				// 			singleton->conVals[E_CONST_DASH_UP_AMOUNT]
				// 		),
				// 		true,
				// 		false
				// 	);
				// }
				
				
				if (turnBased) {
					
					if (ca->hasAtLeast(E_STATUS_STAMINA,5)) {
						swingPos = getOffsetTB(ca->tbPos,ca->tbDir,1.0f);
						entInSquare = getEntAtUnitPos(swingPos);
						
						// if (entInSquare != NULL) {
							
						// 	if (entInSquare->isAlive()) {
								
						// 		if (isKicking(ca->uid,handNum)) { //isPunching(ca->uid,handNum)||
						// 			makeHit(true, ca->uid, entInSquare->uid, -1);
						// 		}
						// 		else {
						// 			makeHit(true, ca->uid, entInSquare->uid, ca->isGrabbingId[handNum]);
						// 		}
						// 	}
							
						// }
						
						changeStatus(ca->uid, E_STATUS_STAMINA,-5);
					}
				}
				
				
				if (ca->uid != getCurActorUID()) {
					nextSwing(actorId,RLBN_LEFT);
					nextSwing(actorId,RLBN_RIGT);
				}
				
				
				
			//}
			
			
		}
		
	}
void GameEntManager::makeTurnTowardsTB (int actorId, btVector3 actorTargVec)
                                                                    {
		BaseObj* ca = &(gameObjects[actorId]);
		btVector3 actorFinalVec = actorTargVec - ca->tbPos;
		
		actorFinalVec = floorBTV(actorFinalVec);
		
		if (actorFinalVec.getX() == 1.0f) {
			ca->tbDir = 0;
		}
		if (actorFinalVec.getX() == -1.0f) {
			ca->tbDir = 2;
		}
		if (actorFinalVec.getY() == 1.0f) {
			ca->tbDir = 1;
		}
		if (actorFinalVec.getY() == -1.0f) {
			ca->tbDir = 3;
		}
		
	}
BaseObj * GameEntManager::getEntAtUnitPos (btVector3 pos)
                                                {
		int i;
		
		BaseObj* ca;
		
		for (i = 0; i < turnList.size(); i++) {
			ca = &(gameObjects[turnList[i]]);
			
			if (ca->isHidden) {
				
			}
			else {
				if (getUnitDisXY(ca->tbPos, pos) < 1) {
					return ca;
				}
			}
			
		}
	
		return NULL;
	}
void GameEntManager::makeTurnTB (int actorId, int modVal)
                                                 {
		BaseObj* ca = &(gameObjects[actorId]);
		
		ca->tbDir += modVal;
		
		if (ca->tbDir < 0) {
			ca->tbDir = 3;
		}
		if (ca->tbDir > 3) {
			ca->tbDir = 0;
		}
	}
btVector3 GameEntManager::getOffsetTB (btVector3 orig, int dir, float amount)
                                                                     {
		float ang = TBDIR_ARR[dir];
		
		btVector3 testPos = orig + btVector3(
			roundVal(cos(ang)*amount),
			roundVal(sin(ang)*amount),
			0.0f
		);
		
		return testPos;
	}
bool GameEntManager::makeMoveTB (int actorId, int modVal)
                                                 {
		BaseObj* ca = &(gameObjects[actorId]);
		
		if (actorId != activeActorUID) {
			// only active actor should be moving
			return false;
		}
		
		
		
		btVector3 testPos = getOffsetTB(ca->tbPos, ca->tbDir, modVal);
		
		
		
		while (
			singleton->gw->getCellAtCoords(
				testPos.getX(),
				testPos.getY(),
				testPos.getZ()
			) == E_CD_EMPTY
		) {
			testPos += btVector3(0.0f,0.0f,-1.0f);
		}
		
		while (
			singleton->gw->getCellAtCoords(
				testPos.getX(),
				testPos.getY(),
				testPos.getZ()
			) != E_CD_EMPTY
		) {
			testPos += btVector3(0.0f,0.0f,1.0f);
		}
		
		BaseObj* entInSquare = getEntAtUnitPos(testPos);
		
		bool preventMove = false;
		
		if (entInSquare == NULL) {
			
		}
		else {
			if (entInSquare->isAlive()) {
				preventMove = true;
			}
		}
		
		if (ca->hasAtLeast(E_STATUS_STAMINA,1)) {
			
		}
		else {
			preventMove = true;
		}
		
		
		if (preventMove) {
			if (actorId == curActorUID) {
				singleton->playSoundEnt("bump0");	
			}
			
			return false;
		}
		else {
			changeStatus(ca->uid, E_STATUS_STAMINA,-1);
			ca->tbPos = testPos;
			return true;
		}
		
	}
void GameEntManager::makeTurn (int actorId, float dirFactor)
                                                    {
		
		BaseObj* ca = &(gameObjects[actorId]);
		
		if (ca->bodies.size() < 0) {
			return;
		}
		
		ca->applyAngularImpulse(btVector3(0,0,dirFactor), true, 0);
	}
void GameEntManager::makeMoveVec (int actorId, btVector3 moveVec)
                                                         {
		BaseObj* ca = &(gameObjects[actorId]);
		
		if (ca->bodies.size() < 0) {
			return;
		}
		
		float walkAmount; 
		
		if (ca->baseContact()) {
			walkAmount = singleton->conVals[E_CONST_WALK_AMOUNT];
		}
		else {
			walkAmount = singleton->conVals[E_CONST_WALK_AMOUNT_AIR];
		}
		
		if (ca->hasBodies()) {
			ca->setActionState(E_ACT_ISWALKING,RLBN_NEIT,true);
			ca->applyImpulse(
				moveVec*walkAmount*ca->getMarkerMass(),
				true,
				0
			);
		}
	}
void GameEntManager::makeMove (int actorId, btVector3 moveDir, bool relative, bool delayed)
                                                                                   {
		BaseObj* ca = &(gameObjects[actorId]);
		
		btVector3 newMoveDir = moveDir;
		
		if (ca->bodies.size() < 0) {
			return;
		}
		
		float walkAmount; 
		
		if (ca->baseContact()) {
			walkAmount = singleton->conVals[E_CONST_WALK_AMOUNT];
		}
		else {
			walkAmount = singleton->conVals[E_CONST_WALK_AMOUNT_AIR];
		}
		
		if (ca->hasBodies()) {
			ca->setActionState(E_ACT_ISWALKING,RLBN_NEIT,true);
			
			
			newMoveDir *= walkAmount;
			
			if (ca->baseContact()) {
				newMoveDir +=	btVector3(
					0.0f,
					0.0f,
					singleton->conVals[E_CONST_WALK_UP_AMOUNT]
				);
			}
			
			
			if (relative) {
				ca->applyImpulseOtherRot(
					newMoveDir*ca->getMarkerMass(),
					ca->bodies[E_BDG_CENTER].body->getCenterOfMassTransform().getBasis(),
					delayed,
					0
				);
			}
			else {
				ca->applyImpulse(
					newMoveDir*ca->getMarkerMass(),
					delayed,
					0
				);
			}
		}
	}
void GameEntManager::makeJump (int actorId, int isUp, float jumpFactor)
                                                               {
		
		BaseObj* ge = &(gameObjects[actorId]);
		
		if (ge->bodies.size() < 0) {
			return;
		}
		
		if (ge->jumpCooldown > 0) {
			return;
		}
		
		if (ge->baseContact()) {
			
		}
		else {
			return;
		}
		
		float jumpAmount = singleton->conVals[E_CONST_JUMP_AMOUNT]*ge->getMarkerMass()*jumpFactor;
		
		
		if (isUp == 1) {
			if (ge->bodies[E_BDG_CENTER].inWater) {
				
				
				if (
					singleton->gw->getCellAtCoords(
						ge->getCenterPoint(E_BDG_CENTER).getX(),
						ge->getCenterPoint(E_BDG_CENTER).getY(),
						ge->getCenterPoint(E_BDG_CENTER).getZ() + 1.0f
					) == E_CD_EMPTY
				) {
					
					
					// at water surface
					
					ge->applyImpulse(btVector3(0.0f,0.0f,jumpAmount), false, 0);
					
					
					
				}
				else {
					
					// underwater
					
					
					ge->applyImpulse(btVector3(0.0f,0.0f,jumpAmount), false, 0);
					
					singleton->playSoundEnt(
						"bubble0",
						ge,
						0.3f,
						0.5f
					);
				}
				
				ge->setActionState(E_ACT_ISJUMPING,RLBN_NEIT,true);
				ge->jumpCooldown = singleton->conVals[E_CONST_JUMP_COOLDOWN_MAX];
				
			}
			else {
				if (ge->allFalling()) {
					
				}
				else {
					
					
					ge->applyImpulse(btVector3(0.0f,0.0f,jumpAmount), false, 0);
					ge->zeroZ = true;
					
					singleton->playSoundEnt(
						"jump0",
						ge,
						0.1f,
						0.2f
					);
					
					ge->setActionState(E_ACT_ISJUMPING,RLBN_NEIT,true);
					ge->jumpCooldown = singleton->conVals[E_CONST_JUMP_COOLDOWN_MAX];
					
				}
			}
		}
		else {
			if (ge->bodies[E_BDG_CENTER].inWater) {
				ge->applyImpulse(btVector3(0.0f,0.0f,-jumpAmount), false, 0);
				
				singleton->playSoundEnt(
					"bubble0",
					ge,
					0.3f,
					0.5f
				);
			}
		}
		
		
		
	}
void GameEntManager::makeHit (bool tb, int attackerId, int victimId, int weaponId)
          {
		
		btVector3 impVec;
		
		BaseObj* geAttacker = getActorRef(attackerId);
		BaseObj* geVictim = getActorRef(victimId);
		BaseObj* geWeapon = getActorRef(weaponId);
		
		int lastHealth;
		
		// if (turnBased&&(!tb)) {
		// 	return;
		// }
		// if ((!turnBased)&&tb) {
		// 	return;
		// }
		
		GameOrg* curOrg = NULL;
		
		int i;
		
		if (geAttacker == NULL) {
			return;
		}
		
		if (geAttacker->isDead()) {
			return;
		}
		
		if (geVictim == NULL) {
			
		}
		else {
			if (
				(geVictim->entType == E_ENTTYPE_WEAPON) &&
				(geWeapon != NULL)
			) {
				if (geWeapon->isGrabbedById == geVictim->isGrabbedById) {
					// owners two weapons hit each other
					return;
				}
			}
		}
		
		
		for (i = 0; i < RLBN_LENGTH; i++) {
			
			
			if (geAttacker->getActionState(E_ACT_HASNOTHIT,i)) {

				
				if (geAttacker->orgId > -1) {
					curOrg = gameOrgs[geAttacker->orgId];
					

					
					if ( (curOrg->stepCount > 1) || tb ) {
						

						
						geAttacker->setActionState(E_ACT_HASNOTHIT,i,false);
						
						
						if (geVictim == NULL) {
							// hit static obj
							
							if (geWeapon != NULL) {
								singleton->playSoundEnt("metalhit5",geAttacker,0.2,0.5f);
								
								if (destroyTerrain) {
									tempVec1.setBTV(geWeapon->getCenterPoint(E_BDG_CENTER));
									singleton->gameFluid[E_FID_BIG]->pushExplodeBullet(true,&tempVec1,0,4.0f);
								}
								
								
							}
							
							
						}
						else {
							
							
							if (geVictim->entType == E_ENTTYPE_WEAPON) {
								singleton->playSoundEnt("clang0",geAttacker,0.1,1.0f);
								geAttacker->setActionState(E_ACT_ISSWINGING,i,false);
							}
							
							if (geVictim->entType == E_ENTTYPE_NPC) {
								
								singleton->playSoundEnt("hit0",geVictim,0.3,1.0f);
								if (geVictim->isAlive()) {
									singleton->playSoundEnt("grunthitm0",geVictim,0.15,0.2f);
								}
							}
							
							
							
							
							if (geVictim->entType == E_ENTTYPE_NPC) {
								
								
								geVictim->hitCooldown = singleton->conVals[E_CONST_HIT_COOLDOWN_MAX];
								
								//geVictim->setActionState(E_ACT_ISHIT,RLBN_NEIT,true);
								geVictim->bindingPower = singleton->conVals[E_CONST_BINDING_POW_ON_HIT];
								lastHealth = geVictim->statSheet.curStatus[E_STATUS_HEALTH];
								geVictim->statSheet.curStatus[E_STATUS_HEALTH] -= 1;
								if (geVictim->statSheet.curStatus[E_STATUS_HEALTH] < 0) {
									geVictim->statSheet.curStatus[E_STATUS_HEALTH] = 0;
								}
								
								if (geVictim->isDead() && (lastHealth > 0)) {
									// just died
									
									
									// geVictim->bodies[E_BDG_CENTER].body->setAngularFactor(
									// 	btVector3(1.0f,1.0f,1.0f)
									// );
									// geVictim->bodies[E_BDG_CENTER].body->setAngularVelocity(btVector3(1.0f,1.0f,0.0f)*20.0f);
									
									makeDropAll(geVictim->uid);
									
									singleton->playSoundEnt("dyingm0",geVictim,0.15,0.2f);
									
								}
								
								impVec = geVictim->getCenterPoint(E_BDG_CENTER) - geAttacker->getCenterPoint(E_BDG_CENTER);
								impVec *= btVector3(1.0f,1.0f,0.0f);
								impVec.normalize();
								//impVec += btVector3(0.0f,0.0f,2.0f);
								geVictim->applyImpulse(
									impVec*geVictim->getMarkerMass()*singleton->conVals[E_CONST_HIT_STRENGTH],
									false,
									E_BDG_CENTER
								);
							}
						}
					}
				}
			}
			
			
			
		}
		
	}
GameOrgNode * GameEntManager::getMirroredNode (GameOrgNode * curNode)
                                                           {
		if (getCurOrg() == NULL) {
			return NULL;
		}
		GameOrg* testOrg = getCurOrg();
		
		if (mirrorOn) {
			
			
			if (curNode->nodeName < E_BONE_C_BEG) {
				if (curNode->nodeName <= E_BONE_L_END) {
					return testOrg->baseNode->getNode(
						curNode->nodeName+(E_BONE_R_BEG-E_BONE_L_BEG)
					);
				}
				else {
					return testOrg->baseNode->getNode(
						curNode->nodeName-(E_BONE_R_BEG-E_BONE_L_BEG)
					);
				}
			}
			else {
				
				
				switch(curNode->nodeName) {
					
					case E_BONE_WEAPON_CROSSR:
						return testOrg->allNodes[E_BONE_WEAPON_CROSSL];
					break;
					case E_BONE_WEAPON_CROSSL:
						return testOrg->allNodes[E_BONE_WEAPON_CROSSR];
					break;
					case E_BONE_WEAPON_BLADER:
						return testOrg->allNodes[E_BONE_WEAPON_BLADEL];
					break;
					case E_BONE_WEAPON_BLADEL:
						return testOrg->allNodes[E_BONE_WEAPON_BLADER];
					break;
					
				}
				
			}
		}
		
		
		
		return NULL;
		
	}
void GameEntManager::refreshActor (int actorId)
                                       {
		
		int q;
		
		if (actorId < 0) {
			return;
		}
		BaseObj* ca = &(gameObjects[actorId]);
		GameOrg* curOrg = (gameOrgs[ca->orgId]);
		
		int grabberId = ca->isGrabbedById;
		
		for (q = 0; q < 2; q++) {
			bindPose(grabberId, q, false);
		}
		
		transformOrg(curOrg, NULL);
		
		curOrg->updateHandleOffset();
		
		singleton->gamePhysics->addBoxFromObj(actorId, true);
		
		transformOrg(curOrg, NULL);
		
		for (q = 0; q < 2; q++) {
			bindPose(grabberId, q, true);
		}
		
		ca->setGrabbedBy(grabberId,ca->isGrabbedByHand);
		
		transformOrg(curOrg, NULL);
	}
void GameEntManager::applyNodeChanges (GameOrgNode * _curNode, float dx, float dy)
                                                                         {
		
		GameOrgNode* curNode = _curNode;
		
		int i;
		int j;
		int k;
		
		int q;
		
		float xm = 0.0f;
		float ym = 0.0f;
		float zm = 0.0f;
		
		float dirMod = 1.0f;
		
		int cuid = getCurActorUID();
		if (cuid < 0) {
			return;
		}
		
		
		GameOrg* testOrg = getCurOrg();
		
		if (
			(
				(curNode->nodeName < E_BONE_C_BEG) ||
				(
					(curNode->nodeName >= E_BONE_WEAPON_CROSSR) &&
					(curNode->nodeName <= E_BONE_WEAPON_BLADEL)	
				)
			) &&
			(mirrorOn)
		) {
			j = 2;
		}
		else {
			j = 1;
		}
		
		for (i = 0; i < j; i++) {
			
			
			if (i == 1) {
				curNode = getMirroredNode(curNode);
				
				dirMod = -1.0f;
			}
			
			
			if (singleton->abDown) {
				makeDirty();
			}
			
			xm = dx/100.0f;
			ym = dy/100.0f;
			
			if (singleton->bShift) {
								
				if (singleton->lbDown) {
					curNode->orgVecs[E_OV_TBNRAD0].addXYZ(0.0f,xm,ym);
				}
				if (singleton->rbDown) {
					curNode->orgVecs[E_OV_TBNRAD1].addXYZ(0.0f,xm,ym);
				}
				if (singleton->mbDown) {
					curNode->orgVecs[E_OV_TBNRAD0].addXYZ(ym, 0.0f, 0.0f);
					curNode->orgVecs[E_OV_TBNRAD1].addXYZ(ym, 0.0f, 0.0f);
					
					curActorNeedsRefresh = true;
				}
			}
			else if (singleton->bCtrl) {
				if (singleton->lbDown) {
					curNode->orgVecs[E_OV_POWVALS].addXYZW(xm, ym, 0.0f, 0.0f);
				}
				if (singleton->rbDown) {
					curNode->orgVecs[E_OV_POWVALS].addXYZW(0.0f, 0.0f, xm, ym);
				}
				
				if (singleton->mbDown) {
					curNode->orgVecs[E_OV_TBNOFFSET].addXYZW(0.0f, 0.0f, 0.0f, ym);
				}
				
				// if (singleton->mbDown) {
				// 	curNode->orgVecs[E_OV_POWVALS].addXYZ(ym, 0.0f, 0.0f);
				// 	curNode->orgVecs[E_OV_POWVALS].addXYZ(ym, 0.0f, 0.0f);
				// }
			}
			else {
				if (singleton->lbDown) {
					curNode->orgVecs[E_OV_THETAPHIRHO].addXYZ(dirMod*ym,0.0,0.0); //dirMod*ym
					//curNode->orgVecs[E_OV_TBNOFFSET].addXYZ(dirMod*ym,0.0,0.0);
				}
				if (singleton->rbDown) {
					curNode->orgVecs[E_OV_THETAPHIRHO].addXYZ(0.0,0.0,dirMod*ym);
				}
				if (singleton->mbDown) {
					curNode->orgVecs[E_OV_THETAPHIRHO].addXYZ(0.0,dirMod*ym,0.0);
				}
			}
			
			// if (applyToChildren) {
			// 	for (k = 0; k < curNode->children.size(); k++) {
			// 		applyNodeChanges(curNode->children[k], dx, dy);
			// 	}
			// }
			
			
		}
			
		
	}
void GameEntManager::transformOrg (GameOrg * curOrg, GameOrgNode * tempParent)
          {
		curOrg->baseNode->doTransform(singleton, tempParent);
	}
void GameEntManager::resetActiveNode ()
                               {
		if (editPose) {
			
			
			
			
			GameOrgNode* curNode = NULL;
			
			GameOrg* testOrg = getCurOrg();
			
			if (selectedNode == NULL) {
				
				curNode = lastSelNode;
			}
			else {
				
				curNode = selectedNode;
			}
			
			if (curNode != NULL) {
				
				if (testOrg != NULL) {
					
					switch(curPoseType) {
						case E_ENTTYPE_NPC:
							testOrg->setToPose(getPose(E_PG_TPOSE,RLBN_NEIT,0),1.0,curNode->nodeName);
						break;
						case E_ENTTYPE_WEAPON:
							testOrg->setToPose(getPose(E_PG_WPTPOSE,RLBN_NEIT,0),1.0,curNode->nodeName);
							refreshActor(getCurActorUID());
						break;
					}
					
				}
				
				//curNode->rotThe = 0.0f;
				//curNode->rotPhi = 0.0f;
				//curNode->rotRho = 0.0f;
				
				//curNode->tbnRadScale0.setFXYZ(1.0f,1.0f,1.0f);
				//curNode->tbnRadScale1.setFXYZ(1.0f,1.0f,1.0f);
				//makeDirty();
				
				
				
			}
			
		}
		
	}
bool GameEntManager::updateNearestOrgNode (bool setActive, FIVector4 * mousePosWS)
                                                                         {
		// tempVec3.setFXYZRef(mousePosWS);
		// tempVec3.addXYZRef(&(testOrg->basePosition),-1.0f);
		
		//worldToScreenBase(&tempVec1, mousePosWS);
		
		GameOrgNode* mirNode = NULL;
		
		if (getCurOrg() == NULL) {
			return false;
		}
		GameOrg* testOrg = getCurOrg();
		
		bestNode = NULL;
		
		int boneId;
		
		highlightedLimb2 = -1;
		highlightedLimb = -1;
		
		singleton->gamePhysics->pickBody(&singleton->mouseMoveOPD);
		
		if (
			(singleton->gamePhysics->lastBodyPick == NULL) ||
			(singleton->gamePhysics->lastBodyUID == -1) ||
			(singleton->gamePhysics->lastBodyUID != getCurActorUID())
		) {
			
		}
		else {
			highlightedLimb = singleton->gamePhysics->lastBodyPick->limbUID;
			
			if (highlightedLimb > -1) {
				boneId = getCurActor()->bodies[highlightedLimb].boneId;
				
				
				if (boneId > -1) {
					bestNode = testOrg->allNodes[boneId];
					
					// if (mirrorOn) {
					// 	mirNode = getMirroredNode(bestNode);
						
					// 	if (mirNode == NULL) {
							
					// 	}
					// 	else {
					// 		mirNode->nodeName
					// 	}
						
					// }
					
					setSelNode(bestNode);
					if (setActive) {
						activeNode = bestNode;
					}
					return true;
				}
			}
			
		}
		
		
		bestNode = NULL;
		activeNode = NULL;
		setSelNode(NULL);
		return false;
		
	}
void GameEntManager::saveOrgFromMenu (string currentFieldString)
                                                        {
		if (getCurOrg() == NULL) {
			return;
		}
		GameOrg* testOrg = getCurOrg();
		
		float tempVal;
		
		
		tempVal = testOrg->baseNode->orgVecs[E_OV_THETAPHIRHO].getFZ();
		
		testOrg->baseNode->orgVecs[E_OV_THETAPHIRHO].setFZ(0.0f);
		transformOrg(testOrg, NULL);
		
		testOrg->saveOrgToFile(currentFieldString);
		
		testOrg->baseNode->orgVecs[E_OV_THETAPHIRHO].setFZ(tempVal);
		transformOrg(testOrg, NULL);
	}
void GameEntManager::loadOrgFromMenu (string currentFieldString)
                                                        {
		if (getCurOrg() == NULL) {
			return;
		}
		GameOrg* testOrg = getCurOrg();
		
		float tempVal;
		
		testOrg->loadOrgFromFile(currentFieldString, false);
		//orientRotation();
		if (getCurActor() != NULL) {
			//getCurActor()->curRot = 1;
		}
		transformOrg(testOrg, NULL);
		makeDirty();
	}
void GameEntManager::makeDirty ()
                         {
		
		// if (getCurActor() != NULL) {
		// 	getCurActor()->wakeAll();
		// }
		
		//testOrg->gph->childrenDirty = true;
	}
void GameEntManager::setSelNode (GameOrgNode * newNode)
                                              {
		
		selectedNode = newNode;
		
		// if (selectedNode != NULL) {
		// 	cout << boneStrings[selectedNode->nodeName] << "\n";
		// }
		
		
		
		if (selectedNode != lastSelNode) {
			makeDirty();
		}
		lastSelNode = newNode;
		
	}
bool GameEntManager::hasRLBN (int rlbnRes, int k)
                                         {
		
		bool doProc = false;
		
		
		
		switch (k) {
			case 0:
				doProc = ((rlbnRes&RLBN_FLAG_RIGHT) > 0);
			break;
			case 1:
				doProc = ((rlbnRes&RLBN_FLAG_LEFT) > 0);
			break;
			case 2:
				doProc = ((rlbnRes&RLBN_FLAG_BOTH) > 0);
			break;
			case 3:
				doProc = ((rlbnRes&RLBN_FLAG_NEITHER) > 0);
			break;
		}
		
		return doProc;
		
	}
void GameEntManager::loadPoseInfo (bool justRefresh)
                                            {
		int i;
		int j;
		int k;
		int m;
		
		bool doProc;
		bool allowLoad = true;
		
		int numChildren;
		int numSteps;
		
		JSONValue* jv = NULL;
		JSONValue* curTempl = NULL;
		JSONValue* tempJV = NULL;
		JSONValue* poses = NULL;
		JSONValue* templates = NULL;
		int rlbnRes;
		int poseCount = 0;
		
		string curString;
		
		gamePoses.clear();
		
		
		if (singleton->loadJSON("..\\data\\poseinfo.js", &poseRootJS)) {
			
			templates = poseRootJS->Child("templates");
			poses = poseRootJS->Child("poses");
			//numChildren = poses->CountChildren();
			
			for (i = 0; i < E_PG_LENGTH; i++) {
				
				allowLoad = true;
				
				jv = poses->Child(E_POSE_GROUP_STRINGS[i]);
				
				curTempl = NULL;
				
				if (jv->HasChild("template")) {
					if (
						templates->HasChild(jv->Child("template")->string_value)
					) {
						curTempl = templates->Child(jv->Child("template")->string_value);
					}
					else {
						cout << "invalid template \n";
					}
				}
				
				// gamePoseInfo.push_back(PoseInfo());
				
				
				for (j = 0; j < 2; j++) {
					if (curTempl != NULL) {
						
						
						for (k = 0; k < E_PIK_LENGTH; k++) {
							if (
								curTempl->HasChild(E_PIK_STRINGS[k])
							) {
								
								if (curTempl->Child(E_PIK_STRINGS[k])->IsNumber()) {
									gamePoseInfo[i].data[k] = curTempl->Child(E_PIK_STRINGS[k])->number_value;
								}
								else {
									gamePoseInfo[i].data[k] = stringToEnum(
										E_SUBTYPE_STRINGS,
										E_SUB_LENGTH,
										curTempl->Child(E_PIK_STRINGS[k])->string_value
									);
									gamePoseInfo[i].stringData[k] = curTempl->Child(E_PIK_STRINGS[k])->string_value;
								}
							}
						}
					}
					curTempl = jv;
				}
				
				rlbnRes = gamePoseInfo[i].data[E_PIK_RLBN];
				numSteps = gamePoseInfo[i].data[E_PIK_NUMSTEPS];
				
				for (k = 0; k < 4; k++) {
					for (m = 0; m < MAX_POSE_STEPS; m++) {
						gamePoseInfo[i].poseSteps[k].fileString[m] = "";
						gamePoseInfo[i].poseSteps[k].gamePoseIndex[m] = -1;
					}
				}
				
				if (i == E_PG_WPSWORD) {
				//	allowLoad = false;
				}
				
				
				
				for ( k = 0; k < 4; k++ ) {
					
					if (hasRLBN(rlbnRes,k)) {
						
						for (m = 0; m < numSteps; m++) {
							curString = E_POSE_GROUP_STRINGS[i];
							curString.append("_");
							curString.append(poseSideStrings[k]);
							curString.append(std::to_string(m));
							
							gamePoseInfo[i].poseSteps[k].fileString[m] = curString;
							gamePoseInfo[i].poseSteps[k].gamePoseIndex[m] = poseCount;
							
							if (justRefresh) {
								
							}
							else {
								gamePoses.push_back(new GameOrg());
							}
							
							
							
							gamePoses[poseCount]->init(
								singleton,
								-1,
								gamePoseInfo[i].data[E_PIK_POSETYPE],
								gamePoseInfo[i].data[E_PIK_SUBTYPE]
								
							);
							
							if (allowLoad) {
								gamePoses[poseCount]->loadOrgFromFile(curString, false);
							}
							
							transformOrg(gamePoses[poseCount], NULL);
							
							
							
							gamePoses[poseCount]->basePose.group = i;
							gamePoses[poseCount]->basePose.RLBN = k;
							gamePoses[poseCount]->basePose.step = m;
							
							poseCount++;
						}
					}
					
				}
				
				
				
				
				
				
				
				
				
			}
			
			
			
			for (i = 0; i < E_ENTTYPE_LENGTH; i++) {
				
				curPose[i].RLBN = RLBN_NEIT;
				curPose[i].step = 0;
				
				switch (i) {
					case E_ENTTYPE_NPC:
						curPose[i].group = E_PG_TPOSE;
					break;
					case E_ENTTYPE_WEAPON:
						curPose[i].group = E_PG_WPSWORD;
					break;
					default:
						curPose[i].group = E_PG_TPOSE;
					break;
					
				}
				getIndexForPose(&(curPose[i]));
				
			}
			
			
		}
		
		
		
	}
GameOrg * GameEntManager::getPose (int targPoseGroup, int targRLBN, int targStep)
          {
		int targPose = gamePoseInfo[targPoseGroup].poseSteps[targRLBN].gamePoseIndex[targStep];
		
		if (targPose > -1) {
			return gamePoses[targPose];
		}
		else {
			return NULL;
		}
	}
string GameEntManager::getPoseString (int targPoseGroup, int targRLBN, int targStep)
          {
		return gamePoseInfo[targPoseGroup].poseSteps[targRLBN].fileString[targStep];
	}
GameOrg * GameEntManager::getCurrentPose ()
                                  {
		return getPose(curPose[curPoseType].group,curPose[curPoseType].RLBN,curPose[curPoseType].step);
	}
string GameEntManager::getCurrentPoseString ()
                                      {
		return getPoseString(curPose[curPoseType].group,curPose[curPoseType].RLBN,curPose[curPoseType].step);
	}
int GameEntManager::getActionStateFromPose (int poseNum)
                                                {
		switch (poseNum) {
			
			case E_PG_JUMP:
				return E_ACT_ISJUMPING;
			break;
			case E_PG_PICKUP:
				return E_ACT_ISPICKINGUP;
			break;
			case E_PG_WALKFORWARD:
				return E_ACT_ISWALKING;
			break;
			case E_PG_FLAIL:
				return E_ACT_ISHIT;
			break;
			
			case E_PG_SLSH:
			case E_PG_BACK:
			case E_PG_HACK:
			case E_PG_STAB:
			case E_PG_HOOK:
			case E_PG_ELBO:
			case E_PG_UPPR:
			case E_PG_JABP:
			case E_PG_ROUN:
			case E_PG_REVR:
			case E_PG_BKIK:
			case E_PG_FRNT:
				return E_ACT_ISSWINGING;
			break;
			
			default:
				return E_ACT_NULL;
			break;
		}
	}
void GameEntManager::changePose (int amount)
                                    {
		
		GameOrg* testOrg = getCurOrg();
		
		do {
			curPose[curPoseType].index += amount;
			
			cout << "poseInd " << " " << curPoseType << " " << curPose[curPoseType].index << "\n";
			
			if (curPose[curPoseType].index == gamePoses.size()) {
				curPose[curPoseType].index = 0;
			}
			if (curPose[curPoseType].index < 0) {
				curPose[curPoseType].index = gamePoses.size()-1;
			}
			
			
		} while(getPoseType(curPose[curPoseType].index) != curPoseType);
		
		
		
		int j;
		float* curData;
		
		cout << "Current Pose: " << getCurrentPoseString() << "\n";
		
		setPoseFromIndex(curPose[curPoseType].index);
		
		
		if (testOrg != NULL) {
					
			testOrg->setTPG(curPose[curPoseType].group, curPose[curPoseType].RLBN);
			
			if (editPose) {
				loadCurrentPose();
			}
			
			if (curPoseType == E_ENTTYPE_WEAPON) {
				refreshActor(getCurActorUID());
			}
			
			
		}
	}
void GameEntManager::saveCurrentPose ()
                               {
		GameOrg* testOrg = getCurOrg();
		
		if (editPose) {
			
			if (testOrg != NULL) {
				testOrg->saveOrgToFile(getCurrentPoseString());
				getCurrentPose()->loadOrgFromFile(getCurrentPoseString(), false);
				transformOrg(getCurrentPose(), NULL);
				
				cout << "Saved Pose " << getCurrentPoseString() << "\n";
				
			}
		}
	}
void GameEntManager::getIndexForPose (PoseKey * tempPose)
                                                {
		tempPose->index = gamePoseInfo[
			tempPose->group
		].poseSteps[
			tempPose->RLBN
		].gamePoseIndex[
			tempPose->step
		];
	}
void GameEntManager::setPoseFromIndex (int i)
                                     {
		curPose[curPoseType].index = i;
		curPose[curPoseType].group = gamePoses[curPose[curPoseType].index]->basePose.group;
		curPose[curPoseType].RLBN = gamePoses[curPose[curPoseType].index]->basePose.RLBN;
		curPose[curPoseType].step = gamePoses[curPose[curPoseType].index]->basePose.step;
	}
int GameEntManager::getPoseType (int poseIndex)
                                       {
		int testPoseInd = gamePoses[poseIndex]->basePose.group;
		return gamePoseInfo[testPoseInd].data[E_PIK_POSETYPE];
	}
void GameEntManager::saveEveryPose ()
                             {
		int i;
		
		
		for (i = 0; i < gamePoses.size(); i++) {
			
			gamePoses[i]->saveOrgToFile(
				getPoseString(
					gamePoses[i]->basePose.group,
					gamePoses[i]->basePose.RLBN,
					gamePoses[i]->basePose.step
				)	
			);
		}
	}
void GameEntManager::loadNonPoseData (int npdPose, int npdSide, int npdStep)
                                                                    {
		GameOrg* testOrg = getCurOrg();
		
		int i;
		int j;
		int k;
		
		float* curData;/// = gamePoseInfo[targetPose].data;
		
		if (editPose) {
			if (testOrg != NULL) {
				
				for (i = 0; i < gamePoses.size(); i++) {
					
					if (getPoseType(i) == curPoseType) {
						setPoseFromIndex(i);
						loadCurrentPose();
						getCurrentPose()->loadOrgFromFile(getPoseString(npdPose,npdSide,npdStep), true);
						transformOrg(getCurrentPose(), NULL);
						testOrg->setToPose(getCurrentPose(),1.0f);
						transformOrg(testOrg, NULL);
						makeDirty();
						cout << "Loaded Non Pose " << getCurrentPoseString() << "\n";
						saveCurrentPose();
					}
					
					
					
				}
				
				curPose[curPoseType].group = npdPose;
				curPose[curPoseType].RLBN = npdSide;
				curPose[curPoseType].step = npdStep;
				getIndexForPose(&(curPose[curPoseType]));
				
				loadCurrentPose();
			}
		}
	}
void GameEntManager::loadCurrentPose ()
                               {
		GameOrg* testOrg = getCurOrg();
		
		if (editPose) {
			if (testOrg != NULL) {
				
				getCurrentPose()->loadOrgFromFile(getCurrentPoseString(), false);
				transformOrg(getCurrentPose(), NULL);
				testOrg->setToPose(getCurrentPose(),1.0f);
				transformOrg(testOrg, NULL);
				makeDirty();
				cout << "Loaded Pose " << getCurrentPoseString() << "\n";
				
			}
		}
	}
int GameEntManager::numberIcons (int pCurCount, int x1, int y1, int x2, int y2)
                                                                       {
	  int i;
	  int j;
	  int curCount = pCurCount;
	  
	  for (j = y1; j <= y2; j++) {
	    for (i = x1; i <= x2; i++) {
				if (curCount >= MAX_OBJ_TYPES) {
					cout << "error curCount " << curCount << "\n";
				}
				else {
					entIdToIcon[curCount] = i + j * ITEMS_PER_ROW;
				}
	    	
	    	if ((i + j * ITEMS_PER_ROW) >= MAX_ICON_ID) {
	    		cout << "error i + j * ITEMS_PER_ROW "  << (i + j * ITEMS_PER_ROW) << "\n";
	    	}
	    	else {
	    		iconToEntId[i + j * ITEMS_PER_ROW] = curCount;
	    	}
	      
	      
	      curCount++;
	    }
	  }
	  
	  
	  return curCount;
	  
	}
string GameEntManager::getStringForObjectId (int objectId)
                                                  {
		int objType = gameObjects[objectId].objectType;
		int iconNum = entIdToIcon[objType];
		
		// if (isContainer[objType]) {
		// 	return i__s(iconNum) + "& Test Container ";
		// }
		// else {
		// 	if (gameObjects[objectId].isEquipped) {
		// 		return "(E) " + i__s(iconNum) + "& Test Object ";
		// 	}
		// 	else {
		// 		return i__s(iconNum) + "& Test Object ";
		// 	}
		// }
		
		if (gameObjects[objectId].isEquipped) {
			return "(E) " + i__s(iconNum) + "& "+objStrings[objType]+" ";
		}
		else {
			return i__s(iconNum) + "& "+objStrings[objType]+" ";
		}
		
	}
void GameEntManager::initAllObjects ()
                              {
		int i;
		int j;
		int k;
		int itemCount = 0;
		
		for (i = 0; i < MAX_ICON_ID; i++) {
			iconToEntId[i] = 0;
		}
		
		for (i = 0; i < MAX_OBJ_TYPES; i++) {
			entIdToIcon[i] = 0;
		}
		
		
		
		itemCount = numberIcons(itemCount,0,0,11,20);
		itemCount = numberIcons(itemCount,12,0,23,15);
		itemCount = numberIcons(itemCount,24,0,35,16);
		itemCount = numberIcons(itemCount,12,16,21,20);
		itemCount = numberIcons(itemCount,22,17,35,31);
		itemCount = numberIcons(itemCount,0,21,15,31);
		itemCount = numberIcons(itemCount,16,21,21,22);
		itemCount = numberIcons(itemCount,0,32,35,35);
		itemCount = numberIcons(itemCount,0,36,15,47);
		itemCount = numberIcons(itemCount,16,36,35,47);
		
		
		for (i = 0; i < MAX_OBJ_TYPES; i++) {
			isContainer[i] = false;
			objStrings[i] = "";
		}
		for (i = 360; i <= 419; i++ ) {
			isContainer[i] = true;
		}
		for (i = 1240; i <= 1671; i++ ) {
			isContainer[i] = true;
		}
		for (i = 525; i <= 527; i++ ) {
			isContainer[i] = true;
		}
		for (i = 537; i <= 539; i++ ) {
			isContainer[i] = true;
		}
		
		
		for (i = 0; i <= 35; i++) {
			objStrings[i] = gemStrings[i%12] + " and Gold Ring";
		}
		
		for (i = 36; i <= 71; i++) {
			objStrings[i] = gemStrings[i%12] + " and Silver Ring";
		}
		
		for (i = 180; i <= 191; i++) {
			objStrings[i] = gemStrings[i%12] + " Necklace";
		}
		
		for (i = 420; i <= 431; i++) {
			objStrings[i] = gemStrings[i%12] + " Ore";
		}
		
		for (i = 432; i <= 443; i++) {
			objStrings[i] = "Polished " + gemStrings[i%12];
		}
		
		for (i = 72; i <= 419; i++) {
			
			j = i/12;
			
			if (j == 15) {
				
			}
			else {
				objStrings[i] = colorStrings[i%12] + " ";
			}
			
			
			switch (j) {
				case 6:
				case 7:
				case 8:
				case 9:
				case 10:
					objStrings[i] += "Cloak";
				break;
				case 11:
					objStrings[i] += "Plate Armor";
				break;
				case 12:
					objStrings[i] += "Leather Armor";
				break;
				case 13:
					objStrings[i] += "Buckler";
				break;
				case 14:
					objStrings[i] += "Kite Shield";
				break;
				case 15:
				
				break;
				case 16:
					objStrings[i] += "Bandana";
				break;
				case 17:
					objStrings[i] += "Boot";
				break;
				case 18:
					objStrings[i] += "Pointed Cap";
				break;
				case 19:
					objStrings[i] += "Plumed Helm";
				break;
				case 20:
					objStrings[i] += "Sailor Cap";
				break;
				case 21:
				case 22:
				case 23:
					objStrings[i] += "Book";
				break;
				case 24:
					objStrings[i] += "Bound Scroll";
				break;
				case 25:
					objStrings[i] += "Scroll";
				break;
				case 26:
				case 27:
					objStrings[i] += "Parchment";
				break;
				case 28:
				case 29:
					objStrings[i] += "Scroll";
				break;
				case 30:
					objStrings[i] += "Bag";
				break;
				case 31:
				case 32:
					objStrings[i] += "Satchel";
				break;
				case 33:
				case 34:
					objStrings[i] += "Gift Box";
				break;
			}
		}
		
		for (i = 698; i <= 907; i++) {
			objStrings[i] = colorStrings[(i+2)%14] + " Potion";
		}
		
		
		for (i = 648; i <= 697; i++) {
			
			j = (i+2)%10;
			
			k = ((i+2)/10) - 65;
			
			objStrings[i] = metalStrings[k] + " ";
			
			
			switch (j) {
				case 0:
					objStrings[i] += "Bullion";
				break;
				case 1:
					objStrings[i] += "Denarii (100)";
				break;
				case 2:
					objStrings[i] += "Denarii (10)";
				break;
				case 3:
					objStrings[i] += "Denarius";
				break;
				case 4:
					objStrings[i] += "Decima";
				break;
				case 5:
					objStrings[i] += "Cent";
				break;
				case 6:
					objStrings[i] += "Medal";
				break;
				case 7:
				case 8:
				case 9:
					objStrings[i] += "Key";
				break;
			}
		}
		
		for (i = 1084; i <= 1095; i++) {
			objStrings[i] = "Parchment";
		}
		
		
		
		for (i = 908; i <= 1083; i++) {
			
			j = (i+4)%16;
			k = ((i+4)/16) - 57;
			
			
			objStrings[i] = elementStrings[j] + " " + weaponStrings[k];
		}
		
		
		objStrings[444] = "Leather Helm";
		objStrings[445] = "Leather Helm";
		objStrings[446] = "Leather Helm";
		objStrings[447] = "Leather Helm";
		objStrings[448] = "Iron Helm";
		objStrings[449] = "Iron Helm";
		objStrings[450] = "Iron Helm";
		objStrings[451] = "Artifact Helm";
		objStrings[452] = "Artifact Helm";
		objStrings[453] = "Artifact Helm";
		objStrings[454] = "Pointed Cap";
		objStrings[455] = "Feathered Cap";
		objStrings[456] = "Cap";
		objStrings[457] = "Mask";
		objStrings[458] = "Top Hat";
		objStrings[459] = "Feathered Hat";
		objStrings[460] = "Cat Ears";
		objStrings[461] = "Rabbit Ears";
		objStrings[462] = "Headband";
		objStrings[463] = "Crown";
		objStrings[464] = "Fur Cap";
		objStrings[465] = "Cap";
		objStrings[466] = "Hat";
		objStrings[467] = "Leather Cap";
		objStrings[468] = "Tunic";
		objStrings[469] = "Tunic";
		objStrings[470] = "Fur Coat";
		objStrings[471] = "Overcoat";
		objStrings[472] = "Leather Armor";
		objStrings[473] = "Leather Armor";
		objStrings[474] = "Iron Plated Armor";
		objStrings[475] = "Iron Plated Armor";
		objStrings[476] = "Iron Plated Armor";
		objStrings[477] = "Artifact Armor";
		objStrings[478] = "Artifact Armor";
		objStrings[479] = "Artifact Armor";
		objStrings[480] = "Slipper";
		objStrings[481] = "Boot";
		objStrings[482] = "Buckled Boot";
		objStrings[483] = "Fur Boot";
		objStrings[484] = "Buckled Boot";
		objStrings[485] = "Shoe";
		objStrings[486] = "Iron Plated Boot";
		objStrings[487] = "Iron Plated Boot";
		objStrings[488] = "Iron Plated Boot";
		objStrings[489] = "Artifact Boot";
		objStrings[490] = "Artifact Boot";
		objStrings[491] = "Artifact Boot";
		objStrings[492] = "Wooden Buckler";
		objStrings[493] = "Wooden Divoted Buckler";
		objStrings[494] = "Wood and Iron Buckler";
		objStrings[495] = "Iron Buckler";
		objStrings[496] = "Iron Buckler";
		objStrings[497] = "Iron Tower Shield";
		objStrings[498] = "Wooden Heater Shield";
		objStrings[499] = "Wood and Iron Heater Shield";
		objStrings[500] = "Iron Heater Shield";
		objStrings[501] = "Decorated Heater Shield";
		objStrings[502] = "Kite Shield";
		objStrings[503] = "Decorated Kite Shield";
		objStrings[504] = "Artifact Shield";
		objStrings[505] = "Artifact Shield";
		objStrings[506] = "Artifact Shield";
		objStrings[507] = "Artifact Shield";
		objStrings[508] = "Belt";
		objStrings[509] = "Belt";
		objStrings[510] = "Belt";
		objStrings[511] = "Artifact Necklace";
		objStrings[512] = "Artifact Necklace";
		objStrings[513] = "Artifact Necklace";
		objStrings[514] = "Artifact Necklace";
		objStrings[515] = "Artifact Necklace";
		objStrings[516] = "Gold Ring";
		objStrings[517] = "Gold Ring";
		objStrings[518] = "Gold Ring";
		objStrings[519] = "Gold Ring";
		objStrings[520] = "Gold Ring";
		objStrings[521] = "Gold Ring";
		objStrings[522] = "Gold Ring";
		objStrings[523] = "Gold Ring";
		objStrings[524] = "Gold Ring";
		objStrings[525] = "Box";
		objStrings[526] = "Box";
		objStrings[527] = "Bag";
		objStrings[528] = "Silver Ring";
		objStrings[529] = "Silver Ring";
		objStrings[530] = "Silver Ring";
		objStrings[531] = "Silver Ring";
		objStrings[532] = "Silver Ring";
		objStrings[533] = "Silver Ring";
		objStrings[534] = "Silver Ring";
		objStrings[535] = "Silver Ring";
		objStrings[536] = "Silver Ring";
		objStrings[537] = "Box";
		objStrings[538] = "Box";
		objStrings[539] = "Bag";
		
		objStrings[540] = "Canine";
		objStrings[541] = "Patch of Fur";
		objStrings[542] = "Hide";
		objStrings[543] = "Claw";
		objStrings[544] = "Feather";
		objStrings[545] = "Horn";
		objStrings[546] = "Mushroom Cap";
		objStrings[547] = "Shell";
		objStrings[548] = "Bone";
		objStrings[549] = "Eyeball";
		objStrings[550] = "Tentacle";
		objStrings[551] = "Bat Wing";
		
		objStrings[552] = "Molar";
		objStrings[553] = "Patch of Fur";
		objStrings[554] = "Hide";
		objStrings[555] = "Claw";
		objStrings[556] = "Feather";
		objStrings[557] = "Horn";
		objStrings[558] = "Mushroom Cap";
		objStrings[559] = "Shell";
		objStrings[560] = "Bone";
		objStrings[561] = "Eyeball";
		objStrings[562] = "Tentacle";
		objStrings[563] = "Bat Wing";
		
		objStrings[564] = "Candle";
		objStrings[565] = "Jelly";
		objStrings[566] = "Mirror";
		objStrings[567] = "Flask";
		objStrings[568] = "Yarn";
		objStrings[569] = "Button";
		objStrings[570] = "Cloth";
		objStrings[571] = "Bell";
		objStrings[572] = "Wood";
		objStrings[573] = "Beak";
		objStrings[574] = "Tail";
		objStrings[575] = "Claw";
		
		objStrings[576] = "Candle";
		objStrings[577] = "Jelly";
		objStrings[578] = "Mirror";
		objStrings[579] = "Flask";
		objStrings[580] = "Yarn";
		objStrings[581] = "Button";
		objStrings[582] = "Cloth";
		objStrings[583] = "Bell";
		objStrings[584] = "Wood";
		objStrings[585] = "Beak";
		objStrings[586] = "Tail";
		objStrings[587] = "Claw";
		
		objStrings[588] = "Apple";
		objStrings[589] = "Lime";
		objStrings[590] = "Orange";
		objStrings[591] = "Passion Fruit";
		objStrings[592] = "Pineapple";
		objStrings[593] = "Banana";
		objStrings[594] = "Cherries";
		objStrings[595] = "Watermelon";
		objStrings[596] = "Bread";
		objStrings[597] = "Cooked Lamb Shank";
		objStrings[598] = "Cooked Egg";
		objStrings[599] = "Cooked Fish";
		objStrings[600] = "Cooked Chicken";
		objStrings[601] = "Sandwich";
		objStrings[602] = "Sliced Potato";
		objStrings[603] = "Steak";
		objStrings[604] = "Sliced Apple";
		objStrings[605] = "Sliced Lime";
		objStrings[606] = "Sliced Orange";
		objStrings[607] = "Sliced Passion Fruit";
		objStrings[608] = "Sliced Pineapple";
		objStrings[609] = "Peeled Banana";
		objStrings[610] = "Cherry";
		objStrings[611] = "Sliced Watermelon";
		objStrings[612] = "Cookie";
		objStrings[613] = "Candy";
		objStrings[614] = "Candy Cane";
		objStrings[615] = "Slice of Cake";
		objStrings[616] = "Dark Chocolate";
		objStrings[617] = "Lollipop";
		objStrings[618] = "Icecream";
		objStrings[619] = "Honey";
		objStrings[620] = "Half Cookie";
		objStrings[621] = "Candy";
		objStrings[622] = "Candy Cane";
		objStrings[623] = "Cake";
		objStrings[624] = "Milk Chocolate";
		objStrings[625] = "Lollipop";
		objStrings[626] = "Icecream";
		objStrings[627] = "Water";
		objStrings[628] = "Cheese";
		objStrings[629] = "Raw Lamb Shank";
		objStrings[630] = "Raw Egg";
		objStrings[631] = "Raw Fish";
		objStrings[632] = "Cooked Chicken";
		objStrings[633] = "Sandwich";
		objStrings[634] = "Potato";
		objStrings[635] = "Raw Steak";
		objStrings[636] = "Cut Emerald";
		objStrings[637] = "Cut Ruby";
		objStrings[638] = "Cut Sapphire";
		objStrings[639] = "Cut Amethyst";
		objStrings[640] = "Cut Beryl";
		objStrings[641] = "Cut Topaz";
		objStrings[642] = "Cut Onyx";
		objStrings[643] = "Cut Diamond";
		objStrings[644] = "Glass";
		objStrings[645] = "Pearl";
		objStrings[646] = "Ash";
		objStrings[647] = "Flint";
		
		
		
		for (i = 0; i < 3; i++) {
			j = i*16;
			objStrings[1240 + j] = "Giant Ant";
			objStrings[1242 + j] = "Giant Rat";
			objStrings[1244 + j] = "Slime";
			objStrings[1246 + j] = "Giant Larva";
			objStrings[1248 + j] = "Giant Wasp";
			objStrings[1250 + j] = "Dread Knight";
			objStrings[1252 + j] = "Carnivorous Plant";
			objStrings[1254 + j] = "Haunted Stump";
			
			objStrings[1288 + j] = "Floating Eye";
			objStrings[1290 + j] = "Gazer";
			objStrings[1292 + j] = "Skeleton";
			objStrings[1294 + j] = "Ghost";
			objStrings[1296 + j] = "Animated Fungus";
			objStrings[1298 + j] = "Necromancer";
			objStrings[1300 + j] = "Electric Eye";
			objStrings[1302 + j] = "Mimic";
			
			objStrings[1336 + j] = "Fire Elemental";
			objStrings[1338 + j] = "Wind Elemental";
			objStrings[1340 + j] = "Earth Elemental";
			objStrings[1342 + j] = "Water Elemental";
			objStrings[1344 + j] = "Golem";
			objStrings[1346 + j] = "Zombie";
			objStrings[1348 + j] = "Imp";
			objStrings[1350 + j] = "Cyclopes";
			
			objStrings[1384 + j] = "Hatchling";
			objStrings[1386 + j] = "Giant Crab";
			objStrings[1388 + j] = "Giant Snake";
			objStrings[1390 + j] = "Giant Frog";
			objStrings[1392 + j] = "Giant Snail";
			objStrings[1394 + j] = "Dark Lord";
			objStrings[1396 + j] = "Animated Armor";
			objStrings[1398 + j] = "Banshee";
		}
		
		for (i = 0; i < 4; i++) {
			j = i*20;
			
			objStrings[1432 + j] = "Female Townsperson";
			objStrings[1436 + j] = "Male Townsperson";
			objStrings[1440 + j] = "Priest";
			objStrings[1444 + j] = "Rogue";
			objStrings[1448 + j] = "Theif";
			
			objStrings[1512 + j] = "Guard";
			objStrings[1516 + j] = "Townsperson";
			objStrings[1520 + j] = "Knight";
			objStrings[1524 + j] = "Assassin";
			objStrings[1528 + j] = "Warlord";
			
			objStrings[1592 + j] = "Ninja";
			objStrings[1596 + j] = "Old Man";
			objStrings[1600 + j] = "Old Woman";
			objStrings[1604 + j] = "Paladin";
			objStrings[1608 + j] = "Wizard";
			
		}
		
	}
#undef LZZ_INLINE
 
// f00351_gamepageholder.h
//

#include "f00351_gamepageholder.e"
#define LZZ_INLINE inline
GamePageHolder::GamePageHolder ()
                         {
		
		boxShape = NULL;
		trimeshShape = NULL;
		meshInterface = NULL;
		body = NULL;
		
		hasData = true;
		hasPath = true;
		
		terVW = NULL;
		
		holderFlags = E_CD_UNKNOWN;
		
		listEmpty = true;
		preGenList = false;
		listGenerated = false;
		pathsInvalid = true;
		idealPathsInvalid = true;
		
		pathsReady = false;
		idealPathsReady = false;
		cellData = NULL;
		extrData = NULL;
		pathData = NULL;
		wasGenerated = false;
	}
void GamePageHolder::init (Singleton * _singleton, int _blockId, int _holderId, int trueX, int trueY, int trueZ, bool _isBlockHolder)
          {

		isBlockHolder = _isBlockHolder;

		//cout << "gph init\n";

		lockRead = false;
		lockWrite = false;

		entityGeomCounter = 0;
		totIdealNodes = 0;
		totGroupIds = 0;

		visitId = 0;

		int i;
		int j;
		int k;
		int ind;
		
		

		blockId = _blockId;
		holderId = _holderId;

		singleton = _singleton;

		
		if (isBlockHolder) {
			cellsPerHolder = singleton->blocksPerWorld;
		}
		else {
			cellsPerHolder = singleton->cellsPerHolder;
		}
		
		
		
		pathSize = cellsPerHolder*cellsPerHolder*cellsPerHolder;
		cellDataSize = cellsPerHolder*cellsPerHolder*cellsPerHolder*4;

		origOffset.setFXYZ(cellsPerHolder/2,cellsPerHolder/2,cellsPerHolder/2);

		offsetInHolders.setIXYZ(trueX,trueY,trueZ);
		//offsetInBlocks.copyFrom(&offsetInHolders);
		//offsetInBlocks.intDivXYZ(singleton->holdersPerBlock);
		
		gphMinInPixels.copyFrom(&offsetInHolders);
		gphMaxInPixels.copyFrom(&offsetInHolders);

		gphMaxInPixels.addXYZ(1);

		
		
		if (isBlockHolder) {
			gphMinInPixels.multXYZ(singleton->cellsPerWorld);
			gphMaxInPixels.multXYZ(singleton->cellsPerWorld);
			
			doTraceVecND("gphMin",&gphMinInPixels);
			doTraceVecND("gphMax",&gphMaxInPixels);
			
		}
		else {
			gphMinInPixels.multXYZ(cellsPerHolder);
			gphMaxInPixels.multXYZ(cellsPerHolder);
		}
		

		gphCenInPixels.averageXYZ(&gphMaxInPixels,&gphMinInPixels);
		

		
	}
int GamePageHolder::getCellAtCoordsLocal (int xx, int yy, int zz)
                                                         {
		int ii = xx;
		int jj = yy;
		int kk = zz;
		
		if (ii < 0) {
			ii += cellsPerHolder;
		}
		if (ii >= cellsPerHolder) {
			ii -= cellsPerHolder;
		}
		
		if (jj < 0) {
			jj += cellsPerHolder;
		}
		if (jj >= cellsPerHolder) {
			jj -= cellsPerHolder;
		}
		
		if (kk < 0) {
			kk += cellsPerHolder;
		}
		if (kk >= cellsPerHolder) {
			kk -= cellsPerHolder;
		}
		
		return getCellAtInd((ii + jj*cellsPerHolder + kk*cellsPerHolder*cellsPerHolder)*4);
	}
int GamePageHolder::getCellAtInd (int ind)
          {
		
		
		int q;
		
		
		if (wasGenerated) {
			
		}
		else {
			//cout << debugVal << " attempted getCellAtCoords without generation\n";
			//genCellData();
			
			return E_CD_SOLID;
		}
		//GamePage* gp = getPageAtCoords(x2, y2, z2, false);
		
		// todo: fix this
		//cout << "Holder is all one type\n";
		
		switch (holderFlags) {
			case E_CD_EMPTY:
				return E_CD_EMPTY;
			break;
			case E_CD_WATER:
				return E_CD_WATER;
			break;
			case E_CD_SOLID:
				return E_CD_SOLID;
			break;
		}
		
		if (cellData == NULL) {
			return E_CD_EMPTY;
		}
		else {
			
			
			if (
				(cellData[ind+E_PTT_TER] != FLUID_UNIT_MIN) ||
				(extrData[ind+E_PTT_BLD] != FLUID_UNIT_MIN)
			) {
				return E_CD_SOLID;
			}
			else {
				
				if (cellData[ind+E_PTT_WAT] != FLUID_UNIT_MIN) {
					return E_CD_WATER;
				}
				else {
					return E_CD_EMPTY;
				}
				
				
			}
		}
	}
void GamePageHolder::getArrAtInd (int ind, int * tempCellData, int * tempCellData2)
          {
		
		
		int q;
		
		if (
			wasGenerated
		) {
			
			if (hasData && (cellData != NULL)) {
				for (q = 0; q < 4; q++) {
					tempCellData[q] = cellData[ind+q];
					tempCellData2[q] = extrData[ind+q];
				}
			}
			else {
				switch (holderFlags) {
					case E_CD_WATER:
						tempCellData[E_PTT_WAT] = FLUID_UNIT_MAX;
						tempCellData[E_PTT_LST] = FLUID_UNIT_MAX;
					break;
					case E_CD_SOLID:
						tempCellData[E_PTT_TER] = FLUID_UNIT_MAX;
					break;
				}
			}
			
			
		}
		
		
	}
void GamePageHolder::setArrAtInd (int ind, int * tempCellData, int * tempCellData2)
          {
			
			int q;
			
			if (
				hasData && wasGenerated && (cellData != NULL)
			) {
				for (q = 0; q < 4; q++) {
					cellData[ind+q] = tempCellData[q];
					extrData[ind+q] = tempCellData2[q];
				}
			}
			
			
	}
void GamePageHolder::clearPathPreserve ()
                                 {
		int i;
		
		if (hasPath) {
			for (i = 0; i < pathSize; i++) {
					if (pathData[i] >= 0) {
						pathData[i] = GROUP_ID_UNMARKED_IDEAL;
					}
					else {
						pathData[i] = GROUP_ID_UNMARKED;
					}
			}
		}
		
		groupIdStack.clear();
		totIdealNodes = 0;
		totGroupIds = 0;
		
	}
void GamePageHolder::clearPathSizes ()
                              {
		int i;
		
		if (hasPath) {
			for (i = 0; i < pathSize; i++) {
				pathData[i] = GROUP_ID_UNMARKED;
			}
		}
		
		groupIdStack.clear();
		groupInfoStack.clear();
		totIdealNodes = 0;
		totGroupIds = 0;
		
	}
void GamePageHolder::checkData (bool checkPath)
                                       {
		
		if (hasData) {
			if (cellData == NULL) {
				cellData = new int[cellDataSize];
			}
			
			if (extrData == NULL) {
				extrData = new int[cellDataSize];
			}
				
		}
		
		if (hasPath&&checkPath) {
			if (pathData == NULL) {
				pathData = new int[pathSize];
			}
		}
		
		
		
		
	}
void GamePageHolder::clearGroupFlags (int targId)
                                         {
		int i;
		for (i = 0; i < groupInfoStack.size(); i++) {
			groupInfoStack[i].visitId = targId;
		}
	}
int GamePageHolder::floodFillAtInd (int firstInd, int newId, bool findCenter, GroupInfoStruct * curGI)
          {
		
		
		
		if (firstInd < 0) {
			cout << "firstInd " << firstInd << "\n";
		}
		
		
		indexStack.clear();
		
		indexStack.push_back(firstInd);
		groupIdStack.push_back(GroupIdStruct());
		groupIdStack.back().ind = firstInd;
		groupIdStack.back().groupId = newId;
		groupIdStack.back().cameFromInd = -1;
		groupIdStack.back().pathCost = 0;
		
		pathData[firstInd] = groupIdStack.size()-1;
		
		bool doProc;
		
		int fillCount = 1;
		
		int groupIdStackInd;
		int dir;
		int ind;
		int testInd;
		int i;
		int j;
		int k;
		int n;
		int q;
		//int foundInd;
		bool didFind = false;
		int testI;
		int testJ;
		int testK;
		int cellsPerHolderM1 = cellsPerHolder-1;
		int lastCost;
		int frontInd = 0;
		
		// for (i = 0; i < 6; i++) {
		// 	curGI->touchesFace[i] = false;
		// }
		curGI->begInd = groupIdStack.size()-1;
		
		
		// find contiguous regions
		while (frontInd < indexStack.size()) {//while (indexStack.size() > 0) {
			
			//ind = indexStack.back();
			
			ind = indexStack[frontInd];
			//frontInd++;
			
			k = ind/(cellsPerHolder*cellsPerHolder);
			j = (ind - k*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
			i = ind - ( j*cellsPerHolder + k*cellsPerHolder*cellsPerHolder );
			
			//foundInd = -1;
			didFind = false;
			
			for (dir = 0; dir < NUM_MOVEABLE_DIRS; dir++) {
				testI = (i+DIR_VECS_MOVE[dir][0]);
				testJ = (j+DIR_VECS_MOVE[dir][1]);
				testK = (k+DIR_VECS_MOVE[dir][2]);
				
				
				if (
					(testI >= 0) &&
					(testI < cellsPerHolder) &&
					(testJ >= 0) &&
					(testJ < cellsPerHolder) &&
					(testK >= 0) &&
					(testK < cellsPerHolder)
				) {
					
					
					
					testInd = 
						testI +
						testJ*cellsPerHolder +
						testK*cellsPerHolder*cellsPerHolder;
					
					if (
							//.groupId
							(pathData[testInd] == GROUP_ID_UNMARKED_IDEAL)
							//&& ((pathData[testInd].flags&E_PVT_LAND_BELOW) != 0)
					) {
						
						
						// foundInd = testInd;
						// goto NEXT_FILL_POINT;
					
						//if (testInd >= 0) {}
					
						
						didFind = true;
						
						indexStack.push_back(testInd);
						
						lastCost = groupIdStack.back().pathCost;
						
						groupIdStack.push_back(GroupIdStruct());
						groupIdStack.back().ind = testInd;
						if (groupIdStack.back().ind < 0) {
							cout << "groupIdStack.back().ind " << groupIdStack.back().ind << "\n";
						}
						
						groupIdStack.back().groupId = newId;
						groupIdStack.back().cameFromInd = ind;
						groupIdStack.back().pathCost = lastCost+1;
						
						//.groupId
						pathData[testInd] = groupIdStack.size()-1;
						
						
						fillCount++;
						
					
					}
				}
			}

// NEXT_FILL_POINT:
			if (didFind) {
				// indexStack.push_back(foundInd);
				
				// lastCost = groupIdStack.back().pathCost;
				
				// groupIdStack.push_back(GroupIdStruct());
				// groupIdStack.back().ind = foundInd;
				// groupIdStack.back().groupId = newId;
				// groupIdStack.back().cameFromInd = ind;
				// groupIdStack.back().pathCost = lastCost+1;
				
				// //.groupId
				// pathData[foundInd] = groupIdStack.size()-1;
				
			}
			else {
				frontInd++;
				//indexStack.pop_back();
			}
			
		}
		
		curGI->endInd = groupIdStack.size();
		
		
		
		
		
		// // if region touches one or fewer faces of bounding volume, remove it
		// // todo: maybe evaluate all regions regardless of pruning criteria
		// for (n = curGI->begInd; n < curGI->endInd; n++) {
			
		// 	ind = groupIdStack[n].ind;
			
		// 	k = ind/(cellsPerHolder*cellsPerHolder);
		// 	j = (ind - k*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
		// 	i = ind - ( j*cellsPerHolder + k*cellsPerHolder*cellsPerHolder );
			
		// 	if (i == 0) 								{curGI->touchesFace[0] = true;}
		// 	if (i == cellsPerHolderM1) 	{curGI->touchesFace[1] = true;}
		// 	if (j == 0) 								{curGI->touchesFace[2] = true;}
		// 	if (j == cellsPerHolderM1) 	{curGI->touchesFace[3] = true;}
		// 	if (k == 0) 								{curGI->touchesFace[4] = true;}
		// 	if (k == cellsPerHolderM1) 	{curGI->touchesFace[5] = true;}
			
		// }
		
		// q = 0;
		// for (n = 0; n < 6; n++) {
		// 	if (curGI->touchesFace[n]) {q++;}
		// }
		
		// // if region touches less than x faces prune it
		// if (q < 1) {
			
		// 	doProc = true;
		// 	while (doProc) {
		// 		if (groupIdStack.size() == 0) {
		// 			doProc = false;
		// 		}
		// 		else {
		// 			if (groupIdStack.back().groupId == newId) {
		// 				groupIdStack.pop_back();
		// 			}
		// 			else {
		// 				doProc = false;
		// 			}
		// 		}
		// 	}
			
		// 	groupInfoStack.pop_back();
			
		// 	return false;
		// }
		
		
		// find the center of the region
		int avgX = 0;
		int avgY = 0;
		int avgZ = 0;
		
		int totCount = 0;
		int testDis;
		int bestDis = 99999;
		int bestInd = -1;
		
		if (findCenter) {
			for (n = curGI->begInd; n < curGI->endInd; n++) {
				ind = groupIdStack[n].ind;
				
				k = ind/(cellsPerHolder*cellsPerHolder);
				j = (ind - k*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
				i = ind - ( j*cellsPerHolder + k*cellsPerHolder*cellsPerHolder );
				
				avgX += i;
				avgY += j;
				avgZ += k;
				
				totCount++;
			}
			
			avgX /= totCount;
			avgY /= totCount;
			avgZ /= totCount;
			
			for (n = curGI->begInd; n < curGI->endInd; n++) {
				ind = groupIdStack[n].ind;
				
				k = ind/(cellsPerHolder*cellsPerHolder);
				j = (ind - k*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
				i = ind - ( j*cellsPerHolder + k*cellsPerHolder*cellsPerHolder );
				
				testInd = ind;
				testDis = abs(i-avgX) + abs(j-avgY) + abs(k-avgZ);
				
				if (testDis < bestDis) {
					bestDis = testDis;
					bestInd = testInd;
				}
				
			}
			
			curGI->centerInd = bestInd;
		}
		
		
		
		
		// // clear visited
		// for (n = curGI->begInd; n < curGI->endInd; n++) {
		// 	ind = groupIdStack[n].ind;
		// 	//.groupId
		// 	pathData[ind] = GROUP_ID_UNMARKED_IDEAL;
		// }
		
		
		// // flood fill again, this time from center point and storing dir traveled and cost
		// indexStack.clear();
		// indexStack.push_back(curGI->centerInd);
		
		
		// groupIdStackInd = pathData[curGI->centerInd];
		
		// if (groupIdStackInd >= 0) {
		// 	groupIdStack[groupIdStackInd].cameFromInd = -1;
		// 	groupIdStack[groupIdStackInd].pathCost = 0;
		// }
		
		// //groupIdStack[bestN] = -1
		// //pathData[curGI->centerInd].cameFromInd = -1;
		// //pathData[curGI->centerInd].pathCost = 0;
		
		// //pathData[curGI->centerInd] = newId;
		
		// int frontInd = 0;
		
		// while (frontInd < indexStack.size()) {
			
		// 	ind = indexStack[frontInd];
		// 	frontInd++;
		// 	//indexStack.pop_front();
			

			
			
		// 	k = ind/(cellsPerHolder*cellsPerHolder);
		// 	j = (ind - k*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
		// 	i = ind - ( j*cellsPerHolder + k*cellsPerHolder*cellsPerHolder );
			
			
		// 	for (dir = 0; dir < NUM_MOVEABLE_DIRS; dir++) {
		// 		testI = (i+DIR_VECS_MOVE[dir][0]);
		// 		testJ = (j+DIR_VECS_MOVE[dir][1]);
		// 		testK = (k+DIR_VECS_MOVE[dir][2]);
				
				
		// 		if (
		// 			(testI >= 0) &&
		// 			(testI < cellsPerHolder) &&
		// 			(testJ >= 0) &&
		// 			(testJ < cellsPerHolder) &&
		// 			(testK >= 0) &&
		// 			(testK < cellsPerHolder)
		// 		) {
					
					
		// 			testInd = 
		// 				testI +
		// 				testJ*cellsPerHolder +
		// 				testK*cellsPerHolder*cellsPerHolder;
					
		// 			if (
		// 					(pathData[testInd] == GROUP_ID_UNMARKED_IDEAL)
		// 					//&& ((pathData[testInd].flags&E_PVT_LAND_BELOW) != 0)
		// 			) {
		// 				pathData[testInd].cameFromInd = ind;
		// 				pathData[testInd].pathCost = pathData[ind].pathCost+1;
		// 				pathData[testInd].groupId = newId;
		// 				indexStack.push_back(testInd);
		// 			}
		// 		}
		// 	}
			
			
		// }
		
		
		
		
		//return true;
		
		return fillCount;
		
	}
void GamePageHolder::findIdealNodes ()
                              {
			idealPathsReady = false;
			
			
			int curFillCount;
			
			int i;
			int j;
			int k;
			int cellVal;
			int cellValAbove;
			//int cellValAbove2;
			int cellValBelow;
			
			int curX;
			int curY;
			int curZ;
			int curInd;
			
			bool doProc;
			
			
			
			if (hasPath) {
				checkData(true);
				clearPathSizes();
				
				for (k = 0; k < cellsPerHolder; k++) {
					for (j = 0; j < cellsPerHolder; j++) {
						for (i = 0; i < cellsPerHolder; i++) {
							cellVal = singleton->gw->getCellAtCoords(
								gphMinInPixels.getIX()+i,
								gphMinInPixels.getIY()+j,
								gphMinInPixels.getIZ()+k
							);
							cellValAbove = singleton->gw->getCellAtCoords(
								gphMinInPixels.getIX()+i,
								gphMinInPixels.getIY()+j,
								gphMinInPixels.getIZ()+k+1
							);
							// cellValAbove2 = singleton->gw->getCellAtCoords(
							// 	gphMinInPixels.getIX()+i,
							// 	gphMinInPixels.getIY()+j,
							// 	gphMinInPixels.getIZ()+k+2
							// );
							cellValBelow = singleton->gw->getCellAtCoords(
								gphMinInPixels.getIX()+i,
								gphMinInPixels.getIY()+j,
								gphMinInPixels.getIZ()+k-1
							);
							
							
							
							// doProc = (
							// 	(cellVal == E_CD_WATER) &&
							// 	(
							// 		(cellValAbove == E_CD_WATER) || (cellValAbove==E_CD_EMPTY)
							// 	)
							// ) || (
							// 	(cellVal == E_CD_EMPTY)&&
							// 	(
							// 		(cellValAbove == E_CD_WATER) || (cellValAbove==E_CD_EMPTY)
							// 	) &&
							// 	(
							// 		cellValBelow == E_CD_SOLID	
							// 	)
							// );
							
							doProc =
								(cellVal < E_CD_SOLID) &&
								(cellValAbove < E_CD_SOLID) &&
								//(cellValAbove2 < E_CD_SOLID) &&
								(cellValBelow == E_CD_SOLID);
							
							
							if (doProc) {
								curInd = i + j*cellsPerHolder + k*cellsPerHolder*cellsPerHolder;
								//.groupId
								pathData[curInd] = GROUP_ID_UNMARKED_IDEAL;
								//pathData[curInd].flags |= E_PVT_LAND_BELOW;
								totIdealNodes++;		
							}
							
							
							
						}
					}
				}
				
				
				//cout << "\n";
				
				curFillCount = 0;
				
				for (i = 0; i < pathSize; i++) {
					if (
						//.groupId
						(pathData[i] == GROUP_ID_UNMARKED_IDEAL)
						// && ((pathData[i].flags&E_PVT_LAND_BELOW) != 0)
					) {
						
						groupInfoStack.push_back(GroupInfoStruct());
						groupInfoStack.back().visitId = 0;
						curFillCount += floodFillAtInd(
							i,
							totGroupIds,
							true,
							&(groupInfoStack.back())
						);
						totGroupIds++;
						
						if (curFillCount >= totIdealNodes) {
							goto FIRST_FILL_DONE;
						}
						
					}
				}
				
FIRST_FILL_DONE:
				
				//cout << "groupIdStack.size()1 " << groupIdStack.size() << "\n";
				
				clearPathPreserve();
				
				// while (groupInfoStack.size() > 1) {
				// 	groupInfoStack.pop_back();
				// }
				
				
				
				for (i = 0; i < groupInfoStack.size(); i++) {
					floodFillAtInd(
						groupInfoStack[i].centerInd,
						i,//totGroupIds,
						false,
						&(groupInfoStack[i])
					);
					//totGroupIds++;
				}
			}
			
			// cout << "groupIdStack.size()2 " << groupIdStack.size() << "\n";
			// cout << "\n";
			
			
			idealPathsReady = true;
			
	}
int GamePageHolder::getGroupId (int pathDataIndex)
                                          {
		
		if (hasPath) {
			if (pathData[pathDataIndex] < 0) {
				
				return pathData[pathDataIndex];
			}
			else {
				return groupIdStack[pathData[pathDataIndex]].groupId;
			}
		}
		else {
			return GROUP_ID_NONEXISTENT;
		}
		
		
		
		
	}
int GamePageHolder::getInfoPD (int pathDataIndex)
                                         {
		
		if (hasPath) {
			return pathData[pathDataIndex];
		}
		else {
			return -100;
		}
		
	}
GroupIdStruct * GamePageHolder::getInfo (int pathDataIndex)
                                                  {
		
		if (hasPath) {
			if (pathData[pathDataIndex] < 0) {
				//cout << "pathDataIndex < 0\n";
				return NULL;
			}
			
			return &(groupIdStack[pathData[pathDataIndex]]);
			
		}
		else {
			return NULL;
		}
		
		
	}
void GamePageHolder::getInfoReport (int pathDataIndex)
                                              {
		
		cout << "\n";
		
		if (hasPath) {
			if (pathData[pathDataIndex] < 0) {
				cout << "pathDataIndex < 0\n";
				return;
			}
			
			cout << "success\n";
			
		}
		else {
			cout << "hasPath==false\n";
			return;
		}
		
		
	}
btVector3 GamePageHolder::holderIndToBTV (GamePageHolder * curPointHolder, int curPointIndex)
                                                                                    {
		btVector3 pVec1;
		
		int ii;
		int jj;
		int kk;
		
		kk = curPointIndex/(cellsPerHolder*cellsPerHolder);
		jj = (curPointIndex-kk*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
		ii = curPointIndex-(kk*cellsPerHolder*cellsPerHolder + jj*cellsPerHolder);
		
		pVec1 = curPointHolder->gphMinInPixels.getBTV();
		pVec1 += btVector3(ii,jj,kk);
		
		return pVec1;
	}
void GamePageHolder::sortConNodes (GamePageHolder * endHolder, int endInd)
                                                                 {
		
		btVector3 endPoint = holderIndToBTV(endHolder, endInd);
		btVector3 curPoint;
		
		ConnectingNodeStruct tempCN;
		GamePageHolder* curHolder;
		
		int i;
		
		for (i = 0; i < bestConnectingNodes.size(); i++) {
			curHolder = singleton->gameLogic->getHolderById(
				bestConnectingNodes[i].blockIdTo,
				bestConnectingNodes[i].holderIdTo
			);
			
			curPoint = holderIndToBTV(
				curHolder,
				curHolder->groupInfoStack[bestConnectingNodes[i].groupIdTo].centerInd
			);
			
			bestConnectingNodes[i].dist = curPoint.distance(endPoint);
		}
		
		sort(bestConnectingNodes.begin(), bestConnectingNodes.end(), sortByDist);
		
		
	}
void GamePageHolder::linkRegions ()
                           {
		int i;
		int j;
		int k;
		
		int ii;
		int jj;
		int kk;
		
		int ic;
		int jc;
		int kc;
		
		int iic;
		int jjc;
		int kkc;
		
		int m;
		int n;
		int q;
		
		int zm;
		
		int ind;
		int mo2;
		
		int baseX;
		int baseY;
		int baseZ;
		
		int holderInd;
		
		bool doProc = false;
		
		int cellsPerHolderM1 = cellsPerHolder-1;
		//GamePageHolder* holderArr[NUM_MOVEABLE_DIRS_ONE_AWAY];
		int boundsArr[NUM_ORIENTATIONS];
		int indArr[NUM_ORIENTATIONS/2];
		int indArrInv[NUM_ORIENTATIONS/2];
		int targetInd;
		int targetGroupId;
		int targetCost;
		int curGroupId;
		
		bool notFound;
		bool foundBetter;
		
		ConnectingNodeStruct* cNode;
		GamePageHolder* targetHolder;
		
		boundsArr[0] = cellsPerHolderM1;
		boundsArr[1] = 0;
		boundsArr[2] = cellsPerHolderM1;
		boundsArr[3] = 0;
		boundsArr[4] = cellsPerHolderM1;
		boundsArr[5] = 0;
		
		
		// for (i = 0; i < NUM_MOVEABLE_DIRS_ONE_AWAY; i++) {
		// 	holderArr[i] = singleton->gw->getHolderAtCoords(
		// 		offsetInHolders.getIX()+DIR_VECS_MOVE[i][0],
		// 		offsetInHolders.getIY()+DIR_VECS_MOVE[i][1],
		// 		offsetInHolders.getIZ()+DIR_VECS_MOVE[i][2],
		// 		true
		// 	);
		// }
		
		bestConnectingNodes.clear();
		
		// find cells that touch side of holder
		
		
		
		for (n = 0; n < groupIdStack.size(); n++) {
			
			ind = groupIdStack[n].ind;
			
			
			curGroupId = groupIdStack[n].groupId;
			
			k = ind/(cellsPerHolder*cellsPerHolder);
			j = (ind - k*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
			i = ind - ( j*cellsPerHolder + k*cellsPerHolder*cellsPerHolder );
			
			indArr[0] = i;
			indArr[1] = j;
			indArr[2] = k;
			
			doProc = false;
			
			
			
			for (m = 0; m < NUM_ORIENTATIONS; m++) {
				mo2 = m/2;
				
				
				
				if (m <= 3) {
					// m is planar
					
					if (indArr[mo2] == boundsArr[m]) {
						// its on the planar edge
						doProc = true;
						break;
					}
					
				}
				else {
					// m is in z direction
					
					if ( abs(indArr[mo2] - boundsArr[m]) <= BASE_MOVEABLE_Z ) {
						doProc = true;
						break;
					}
				}
				
			}
			
			if (doProc) {
				
				baseX = i + gphMinInPixels.getIX();
				baseY = j + gphMinInPixels.getIY();
				baseZ = k + gphMinInPixels.getIZ();
				
				for (m = 0; m < NUM_PLANAR_ORIENTATIONS; m++) {
					
					for (zm = -BASE_MOVEABLE_Z; zm <= BASE_MOVEABLE_Z; zm++) {
						
						

						// indArrInv[0] = i;
						// indArrInv[1] = j;
						// indArrInv[2] = k;

						// if (mo2 == 0) {indArrInv[0] = cellsPerHolderM1-i;}
						// if (mo2 == 1) {indArrInv[1] = cellsPerHolderM1-j;}
						// if (mo2 == 2) {indArrInv[2] = cellsPerHolderM1-k;}

						targetInd = singleton->gw->getCellInd(
							targetHolder,
							baseX + DIR_VECS_I[m][0],
							baseY + DIR_VECS_I[m][1],
							baseZ + zm
						);//indArrInv[0] + indArrInv[1]*cellsPerHolder + indArrInv[2]*cellsPerHolder*cellsPerHolder;
						
						
						if (
							(targetHolder->holderId == holderId) &&
							(targetHolder->blockId == blockId)
						) {
							// same holder, do nothing
						}
						else {
							
							
							
							targetGroupId = targetHolder->getGroupId(targetInd);

							if (targetGroupId > -1) {
								targetCost = targetHolder->getInfo(targetInd)->pathCost + getInfo(ind)->pathCost;
								
								// first see if another connection to this block/holder/groupId exists
								
								notFound = true;
								foundBetter = false;
								
								for (q = 0; q < bestConnectingNodes.size(); q++) {
									cNode = &(bestConnectingNodes[q]);
									
									if (
										(cNode->blockIdTo == targetHolder->blockId) &&
										(cNode->holderIdTo == targetHolder->holderId) &&
										(cNode->groupIdFrom == curGroupId) &&
										(cNode->groupIdTo == targetGroupId)
									) {
										notFound = false;
									
										if (targetCost <= cNode->totCost) {
											
											// tie breaker
											if (targetCost == cNode->totCost) {
												kk = targetInd/(cellsPerHolder*cellsPerHolder);
												jj = (targetInd-kk*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
												ii = targetInd-(kk*cellsPerHolder*cellsPerHolder + jj*cellsPerHolder);
												
												//cNode->cellIndFrom
												kc = cNode->cellIndFrom/(cellsPerHolder*cellsPerHolder);
												jc = (cNode->cellIndFrom-kc*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
												ic = cNode->cellIndFrom-(kc*cellsPerHolder*cellsPerHolder + jc*cellsPerHolder);
												
												//cNode->cellIndTo
												kkc = cNode->cellIndTo/(cellsPerHolder*cellsPerHolder);
												jjc = (cNode->cellIndTo-kkc*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
												iic = cNode->cellIndTo-(kkc*cellsPerHolder*cellsPerHolder + jjc*cellsPerHolder);
												
												
												
												if ((k+kk) < (kc+kkc)) {foundBetter = true;} else {
													if ((j+jj) < (jc+jjc)) {foundBetter = true;} else {
														if ((i+ii) < (ic+iic)) {foundBetter = true;}
													}
												}
											}
											else {
												foundBetter = true;
											}
										}

										break;
									}
								}
								
								if (notFound) {
									bestConnectingNodes.push_back(ConnectingNodeStruct());
									cNode = &(bestConnectingNodes.back());
								}
								else {
									cNode = &(bestConnectingNodes[q]);
								}
								
								if (foundBetter||notFound) {
									
									cNode->blockIdFrom = blockId;
									cNode->holderIdFrom = holderId;
									cNode->blockIdTo = targetHolder->blockId;
									cNode->holderIdTo = targetHolder->holderId;
									cNode->groupIdFrom = curGroupId;
									cNode->groupIdTo = targetGroupId;
									cNode->cellIndFrom = ind;
									cNode->cellIndTo = targetInd;
									cNode->totCost = targetCost;
									
								}
								
								
								
								// otherwise push back a new block/holder/groupId
								
							}

							
							
							
						}
						

						
						
						
						
						
						
					}
					
				}
								
				
			}
			
			
		}
		
	}
bool GamePageHolder::prepPathRefresh (int rad)
                                      {
		int i;
		int j;
		int k;
		
		GamePageHolder* curHolder;
		
		for (k = -rad; k <= rad; k++) {
			for (j = -rad; j <= rad; j++) {
				for (i = -rad; i <= rad; i++) {
					curHolder = singleton->gw->getHolderAtCoords(
						offsetInHolders.getIX()+i,
						offsetInHolders.getIY()+j,
						offsetInHolders.getIZ()+k,
						true
					);
					
					if (curHolder->wasGenerated) {
						
					}
					else {
						return false;
						
					}
					
				}
			}
		}
		
		return true;
		
	}
void GamePageHolder::refreshPaths ()
                            {
		
		pathsReady = false;
		
		int i;
		int j;
		int k;
		
		GamePageHolder* curHolder;
		
		int rad;
		
		rad = 2;
		for (k = -rad; k <= rad; k++) {
			for (j = -rad; j <= rad; j++) {
				for (i = -rad; i <= rad; i++) {
					curHolder = singleton->gw->getHolderAtCoords(
						offsetInHolders.getIX()+i,
						offsetInHolders.getIY()+j,
						offsetInHolders.getIZ()+k,
						true
					);
					
					if (curHolder->idealPathsInvalid) {
						curHolder->findIdealNodes();
						curHolder->idealPathsInvalid = false;
					}
					
				}
			}
		}
		
		rad = 1;
		for (k = -rad; k <= rad; k++) {
			for (j = -rad; j <= rad; j++) {
				for (i = -rad; i <= rad; i++) {
					curHolder = singleton->gw->getHolderAtCoords(
						offsetInHolders.getIX()+i,
						offsetInHolders.getIY()+j,
						offsetInHolders.getIZ()+k,
						true
					);
					
					if (curHolder->pathsInvalid) {
						curHolder->linkRegions();
						curHolder->pathsInvalid = false;
					}
				}
			}
		}
		
		
		// findIdealNodes();
		// // fetch all neighboring paths
		// for (i = 0; i < NUM_ORIENTATIONS; i++) {
		// 	curHolder = singleton->gw->getHolderAtCoords(
		// 		offsetInHolders.getIX()+DIR_VECS_I[i][0],
		// 		offsetInHolders.getIY()+DIR_VECS_I[i][1],
		// 		offsetInHolders.getIZ()+DIR_VECS_I[i][2],
		// 		true
		// 	);
			
		// 	curHolder->findIdealNodes();
		// }
		//linkRegions();
		
		// find complete array map of regions for just this holder
		
		
		// if (groupInfoStack.size() == 0) {
		// 	if (pathData != NULL) {delete[] pathData;}
		// 	pathData = NULL;
		// 	hasPath = false;
		// }
		
		
		
		
		
		pathsReady = true;
		
		
		
		
	}
void GamePageHolder::genCellData ()
                           {
		
		
		int i;
		int j;
		int k;
		
		int ii;
		int jj;
		int kk;
		
		int p;
		int q;
		
		int ind;
		
		float fi;
		float fj;
		float fk;
		
		float zv;
		
		float fiAbs;
		float fjAbs;
		float fkAbs;
		
		float terHeight;
		float simplexVal;
		float simplexVal1;
		float simplexVal2;
		
		float disVal;
		
		float fSimp;
		int iTer;
		int iWat;
		
		checkData(false);
		
		for (i = 0; i < cellDataSize; i++) {
			cellData[i] = FLUID_UNIT_MIN;
			extrData[i] = FLUID_UNIT_MIN;
		}
		
		
		
		
		
		VolumeWrapper* curVW;
		
		if (isBlockHolder) {
			curVW = (singleton->volumeWrappers[E_VW_WORLD]);
			cout << "genBlockHolder\n";
		}
		else {
			curVW = (singleton->volumeWrappers[E_VW_HOLDER]);
		}
		
		
		singleton->gw->drawVol(
			curVW,
			&gphMinInPixels,
			&gphMaxInPixels,
			true,
			true,
			false,
			isBlockHolder
		);
		FBOWrapper* fbow = curVW->fboSet.getFBOWrapper(0);
		
		if (isBlockHolder) {
			wasGenerated = true;
			return;
		}
		
		// if (terVW == NULL) {
		// 	terVW = new VolumeWrapper();
		// 	terVW->init(cellsPerHolder,GL_REPEAT,false);
		// }
		// FBOWrapper* fbow = terVW->fboSet.getFBOWrapper(0);
		// singleton->gw->drawVol(terVW, &gphMinInPixels, &gphMaxInPixels, true, true);
		
		
		unsigned char* vdPtr = fbow->pixelsChar;
		
		
		float watHeight = singleton->getSeaHeightScaled();
		
		int cdo4 = cellDataSize/4;
		
		for (p = 0; p < cdo4; p++) {
			
			kk = p/(cellsPerHolder*cellsPerHolder);
			jj = (p-kk*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
			ii = p-(kk*cellsPerHolder*cellsPerHolder + jj*cellsPerHolder);
			
			if (isBlockHolder) {
				fk = gphMinInPixels[2] + kk*singleton->cellsPerBlock;
			}
			else {
				fk = gphMinInPixels[2] + kk;
			}
			
			
			
			ind = p*4;
			
			
			
			if (
				vdPtr[ind + 0] > 128 // 0.5f
			) {
				iTer = FLUID_UNIT_MAX;
			}
			else {
				iTer = FLUID_UNIT_MIN;
			}
			
			if (iTer == FLUID_UNIT_MAX) {
				iWat = FLUID_UNIT_MIN;
			}
			else {
				if (fk < watHeight) {
					iWat = FLUID_UNIT_MAX;
				}
				else {
					iWat = FLUID_UNIT_MIN;
				}
			}
			
			
			
			
			for (q = 0; q < 4; q++) {
				cellData[ind+q] = FLUID_UNIT_MIN;
				extrData[ind+q] = FLUID_UNIT_MIN;
			}
			
			
			cellData[ind+E_PTT_TER] = iTer;
			cellData[ind+E_PTT_WAT] = iWat;
			cellData[ind+E_PTT_LST] = iWat;
		}
		
		
		wasGenerated = true;
		
	}
void GamePageHolder::createMesh ()
        {
		btTransform trans;
		trans.setIdentity();
		
		float objRad;
		
		if (trimeshShape == NULL) {
			
		}
		else {
			
			//cout << "regen\n";
			
			singleton->gamePhysics->example->removeRigidBody(body);
			delete meshInterface;
			meshInterface = NULL;
			delete trimeshShape;
			trimeshShape = NULL;
			//delete body;
			//body = NULL;
			
			if (body != NULL) {
				
				delete body;
				body = NULL;
				
				//cout << "body not null\n";
			}
		}
		
		if (boxShape == NULL) {
			
		}
		else {
			singleton->gamePhysics->example->removeRigidBody(body);
			delete boxShape;
			boxShape = NULL;
		}
		
		
		if ((holderFlags == E_CD_SOLID)&&listEmpty) {
			objRad = (gphMaxInPixels[0]-gphMinInPixels[0])*0.5f;
			
			boxShape = new btBoxShape(btVector3(objRad,objRad,objRad));
			trans.setOrigin(btVector3(
				(gphMinInPixels[0]+gphMaxInPixels[0])*0.5f,
				(gphMinInPixels[1]+gphMaxInPixels[1])*0.5f,
				(gphMinInPixels[2]+gphMaxInPixels[2])*0.5f
			));

			body = singleton->gamePhysics->example->createRigidBodyMask(
				0,
				trans,
				boxShape
				,COL_STATIC,
				terCollidesWith
			);
			
		}
		else {
			
			meshInterface = new btTriangleIndexVertexArray();
			
			part.m_vertexBase = (const unsigned char*)(&(vertexVec[0]));
			part.m_vertexStride = sizeof(btScalar) * 3;
			part.m_numVertices = vertexVec.size()/3;
			part.m_triangleIndexBase = (const unsigned char*)(&(indexVec[0]));
			part.m_triangleIndexStride = sizeof(short) * 3;
			part.m_numTriangles = indexVec.size()/3;
			part.m_indexType = PHY_SHORT;

			meshInterface->addIndexedMesh(part,PHY_SHORT);

			
			trimeshShape = new btBvhTriangleMeshShape(meshInterface,true,true);
			
			trans.setOrigin(btVector3(
				gphMinInPixels[0],
				gphMinInPixels[1],
				gphMinInPixels[2]
			));

			body = singleton->gamePhysics->example->createRigidBodyMask(
				0,
				trans,
				trimeshShape
				,COL_STATIC,
				terCollidesWith
			);
			
			
		}
		

		
		body->setFriction(btScalar(0.9));
		body->bodyUID = -1;
		body->limbUID = -1;
		
		singleton->gamePhysics->example->updateGraphicsObjects();
		
		
		
	}
void GamePageHolder::fillVBO ()
                       {
		
		if (singleton->gamePhysics == NULL) {
			return;
		}
		
		int q;
		
		int p;
		int ii;
		int jj;
		int kk;
		
		int p2;
		// int ii2;
		// int jj2;
		int kk2;
		
		
		
		
		
		/////////////////////
		
		if (
			(holderFlags == E_CD_SOLID) ||
			(holderFlags == E_CD_EMPTY)	
		) {
			if (cellData != NULL) {delete[] cellData;}
			if (extrData != NULL) {delete[] extrData;}
			
			cellData = NULL;
			extrData = NULL;
			
			hasData = false;
		}
		
		
		
		/////////////////////
		
		
		float fk;
		
		// if (GEN_COLLISION) {
		// 	for (q = 0; q < collideIndices.size(); q += 2) {
				
		// 		p = collideIndices[q];
		// 		p2 = collideIndices[q+1];
				
		// 		kk = p/(cellsPerHolder*cellsPerHolder);
		// 		jj = (p-kk*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
		// 		ii = p-(kk*cellsPerHolder*cellsPerHolder + jj*cellsPerHolder);
				
		// 		kk2 = p2/(cellsPerHolder*cellsPerHolder);
				
		// 		fk = (kk2-kk)+1;
				
				
		// 		btTransform trans;
		// 		trans.setOrigin(btVector3(
		// 			ii,jj,(kk+kk2)*0.5f
		// 		));
				
		// 		// todo: mem leak
				
		// 		btCapsuleShapeZ* capsuleShape = new btCapsuleShapeZ(0.5f,fk);
		// 		btRigidBody* myBody = singleton->gamePhysics->example->createRigidBody(0,trans,capsuleShape);
		// 		myBody->setFriction(btScalar(0.9));
				
		// 		// q3BoxDef boxDef;
		// 		// boxDef.SetRestitution( 0 );
		// 		// q3Transform tx;
		// 		// q3Identity( tx );
		// 		// tx.position.Set(ii,jj,(kk+kk2)*0.5f);
		// 		// boxDef.Set( tx, q3Vec3( 1.0f, 1.0f, fk ) );
		// 		// body->AddBox( boxDef );
				
				
		// 	}
		// }
		
		//singleton->gamePhysics->example->updateGraphicsObjects();
		
		//cout << "collideIndices.size() " << collideIndices.size() << "\n";
		
		
		
		////////////////////
		
		
		if (
			// (isBlockHolder&&GEN_POLYS_WORLD) ||
			((!isBlockHolder)&&POLY_COLLISION)	
		) {
			if (
				listEmpty
				// && (holderFlags != E_CD_SOLID)
			) {
				
			}
			else {

				createMesh();
				
				
				// vboWrapper.init(
				// 	&(vertexVec[0]),
				// 	vertexVec.size(),
				// 	&(indexVec[0]),
				// 	indexVec.size()
				// );
				
				
				// todo: not needed?
				//glFlush();
				//glFinish();
			}
		}
		
		
		
		
		
		listGenerated = true;
		
	}
void GamePageHolder::generateList ()
                            { //int fboNum
		
		if (singleton->gamePhysics == NULL) {
			return;
		}
		
		preGenList = false;
		
		int cellsPerHolderM1 = cellsPerHolder-1;
		float fres = cellsPerHolder;
		int i, j, k, m, q;
		
		int curInd;
		
		int procCount = 0;
		
		bool edgeK;
		bool edgeJ;
		bool edgeI;
		
		
		int ii;
		int jj;
		int kk;
		
		
		float cellPitch;
		
		if (isBlockHolder) {
			cellPitch = singleton->cellsPerBlock;
		}
		else {
			cellPitch = 1.0f;
		}
		
		float iv0 = 0.0f;
		float iv1 = cellPitch;
		
		
		float fi = 0.0f;
		float fj = 0.0f;
		float fk = 0.0f;
		
		int iX;
		int iY;
		int iZ;
		
		float bpX = 0.0f;
		float bpY = 0.0f;
		float bpZ = 0.0f;
		
		int cellVal;
		int cellVal2;
		
		
		uint dirFlags;
		uint flagVals[6];
		flagVals[0] = 1;
		flagVals[1] = 2;
		flagVals[2] = 4;
		flagVals[3] = 8;
		flagVals[4] = 16;
		flagVals[5] = 32;
		
		const uint AIR_VAL = 0;
		
		
		bool doProcAny;
		bool doProc[6];// = false;

		uint tempHF = E_CD_UNKNOWN;

		// if (GEN_COLLISION) {
		// 	collideIndices.clear();
		// }
		
		vertexVec.clear();
		indexVec.clear();
		
		//bindHolderDL();
		
		
		//glBegin(GL_QUADS);
		
		
		
		int empCount = 0;
		int watCount = 0;
		int solCount = 0;
		int errCount = 0;
		
		int minRad = -1;
		int maxRad = cellsPerHolder;
		
		if (isBlockHolder) {
			minRad = 0;
			maxRad = cellsPerHolder-1;
		}
		
		
		for (k = minRad; k <= maxRad; k++) {
			for (j = minRad; j <= maxRad; j++) {
				for (i = minRad; i <= maxRad; i++) {
					
					iX = gphMinInPixels.getIX() + i;
					iY = gphMinInPixels.getIY() + j;
					iZ = gphMinInPixels.getIZ() + k;
					
					if (isBlockHolder) {
						cellVal = getCellAtCoordsLocal(iX,iY,iZ);
						
						switch (cellVal) {
							case E_CD_EMPTY:
								empCount++;
							break;
							case E_CD_WATER:
								watCount++;
							break;
							case E_CD_SOLID:
								solCount++;
							break;
							default:
								errCount++;
							break;
						}
						
					}
					else {
						cellVal = singleton->gw->getCellAtCoords(iX,iY,iZ);
					}
					
					
					tempHF = tempHF|cellVal;
				}
			}	
		}
		
		
		
		if (isBlockHolder) {
			
			cout << "\n\n\n";
			cout << "cellsPerHolder" << cellsPerHolder << "\n";
			cout << "empCount " << empCount << "\n";
			cout << "watCount " << watCount << "\n";
			cout << "solCount " << solCount << "\n";
			cout << "errCount " << errCount << "\n";
			cout << "\n\n\n";
		}
		
		bool fillPolys = 
			// (isBlockHolder&&GEN_POLYS_WORLD) ||
			((!isBlockHolder)&&POLY_COLLISION);
		
		
		
		bool rleOn = false;
		bool isLast = false;
		int begInd;
		int endInd;
		
		int baseInd;
		int tempVal;
		int cellGrid[27];
		int maskVals[8];
		
		
		// if (GEN_COLLISION) {
			
		// 	if (
		// 		(tempHF == E_CD_SOLID) ||
		// 		(tempHF == E_CD_EMPTY)	
		// 	) {
				
		// 	}
		// 	else {
		// 		for (i = 0; i < cellsPerHolder; i++) {
		// 			for (j = 0; j < cellsPerHolder; j++) {
		// 				for (k = 0; k < cellsPerHolder; k++) {
							
		// 					isLast = (k == (cellsPerHolder-1));
							
		// 					curInd = (i + j*cellsPerHolder + k*cellsPerHolder*cellsPerHolder);
							
		// 					cellVal = getCellAtInd(curInd*4);
							
		// 					if (cellVal == E_CD_SOLID) {
		// 						if (rleOn) {
									
		// 						}
		// 						else {
		// 							rleOn = true;
		// 							begInd = curInd;
		// 							collideIndices.push_back(begInd);
		// 						}
		// 					}
		// 					else {
		// 						if (rleOn) {
		// 							rleOn = false;
		// 							endInd = curInd-(cellsPerHolder*cellsPerHolder);
									
		// 							collideIndices.push_back(endInd);
		// 						}
		// 					}
							
		// 					if (rleOn&&isLast) {
		// 						rleOn = false;
		// 						endInd = curInd;
		// 						collideIndices.push_back(endInd);
		// 					}
		// 				}
		// 			}
		// 		}
		// 	}
		// }
		
		
		
		if (fillPolys) {
			
			if (
				(tempHF == E_CD_SOLID) ||
				(tempHF == E_CD_EMPTY)	
			) {
				
			}
			else {
				for (k = 0; k < cellsPerHolder; k++) {
					
					for (j = 0; j < cellsPerHolder; j++) {
						
						for (i = 0; i < cellsPerHolder; i++) {
							
							
							iX = gphMinInPixels.getIX() + i;
							iY = gphMinInPixels.getIY() + j;
							iZ = gphMinInPixels.getIZ() + k;
							bpX = i*cellPitch;
							bpY = j*cellPitch;
							bpZ = k*cellPitch;
							
							if (isBlockHolder) {
								cellVal = getCellAtCoordsLocal(iX,iY,iZ);
							}
							else {
								cellVal = singleton->gw->getCellAtCoords(iX,iY,iZ);
							}
							
							
							if ( cellVal == E_CD_SOLID ) {
								
								doProcAny = false;
								
								for (q = 0; q < NUM_ORIENTATIONS; q++) {
									
									if (isBlockHolder) {
										cellVal2 = getCellAtCoordsLocal(
											iX + DIR_VECS_I[q][0],
											iY + DIR_VECS_I[q][1],
											iZ + DIR_VECS_I[q][2]	
										);
									}
									else {
										cellVal2 = singleton->gw->getCellAtCoords(
											iX + DIR_VECS_I[q][0],
											iY + DIR_VECS_I[q][1],
											iZ + DIR_VECS_I[q][2]
										);
									}
									
									
									doProc[q] = cellVal2 != E_CD_SOLID;
									
									doProcAny = doProcAny | doProc[q];
									
								}
								
								// if (GEN_COLLISION) {
								// 	if (doProcAny) {
								// 		collideIndices.push_back(i + j*cellsPerHolder + k*cellsPerHolder*cellsPerHolder);
								// 	}
								// }
								
								
								
								if (doProcAny) {
									
									// gather nearest 27 points for mask
									
									for (kk = -1; kk <= 1; kk++) {
										for (jj = -1; jj <= 1; jj++) {
											for (ii = -1; ii <= 1; ii++) {
												
												if (
													singleton->gw->getCellAtCoords(
														iX + ii,
														iY + jj,
														iZ + kk
													) == E_CD_SOLID
												) {
													tempVal = 1;
												}
												else {
													tempVal = 0;
												}
												
												
												cellGrid[
													(ii+1) +
													(jj+1)*3 +
													(kk+1)*9	
												] = tempVal;
											}	
										}
									}
									
									for (kk = 0; kk < 2; kk++) {
										for (jj = 0; jj < 2; jj++) {
											for (ii = 0; ii < 2; ii++) {
												baseInd = ii + jj*3 + kk*9;
												
												
												maskVals[ii+jj*2+kk*4] = 
												((cellGrid[baseInd+0+0+0])<<0) |
												((cellGrid[baseInd+1+0+0])<<1) |
												((cellGrid[baseInd+0+3+0])<<2) |
												((cellGrid[baseInd+1+3+0])<<3) |
												
												((cellGrid[baseInd+0+0+9])<<4) |
												((cellGrid[baseInd+1+0+9])<<5) |
												((cellGrid[baseInd+0+3+9])<<6) |
												((cellGrid[baseInd+1+3+9])<<7);
												
											}	
										}
									}
									
								}
								
								
								if (doProc[0]) { // x+
									
									getPixVal(bpX,bpY,bpZ, iv1,iv1,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv1,iv0,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv1,iv1,iv0, maskVals);
									getPixVal(bpX,bpY,bpZ, iv1,iv0,iv0, maskVals);
									
									getIndVal(procCount);
									procCount++;
									
									
								}
								if (doProc[1]) { // x-
									
									getPixVal(bpX,bpY,bpZ, iv0,iv1,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv0,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv1,iv0, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv0,iv0, maskVals);
									
									getIndVal2(procCount);
									procCount++;
									
								}
								if (doProc[2]) { // y+
									
									getPixVal(bpX,bpY,bpZ, iv1,iv1,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv1,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv1,iv1,iv0, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv1,iv0, maskVals);
									
									getIndVal2(procCount);
									procCount++;
									
								}
								if (doProc[3]) { // y-
									
									
									getPixVal(bpX,bpY,bpZ, iv1,iv0,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv0,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv1,iv0,iv0, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv0,iv0, maskVals);
									
									getIndVal(procCount);
									procCount++;
								}
								if (doProc[4]) { // z+
									
									getPixVal(bpX,bpY,bpZ, iv1,iv1,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv1,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv1,iv0,iv1, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv0,iv1, maskVals);
									
									getIndVal(procCount);
									procCount++;
								}
								if (doProc[5]) { // z-
									
									getPixVal(bpX,bpY,bpZ, iv1,iv1,iv0, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv1,iv0, maskVals);
									getPixVal(bpX,bpY,bpZ, iv1,iv0,iv0, maskVals);
									getPixVal(bpX,bpY,bpZ, iv0,iv0,iv0, maskVals);
									
									getIndVal2(procCount);
									procCount++;
								}
								
								
								
								
							}
						}
					}
				}
			}
			
			
		}
		
		

		
		listEmpty = (vertexVec.size() == 0);
		holderFlags = tempHF;
		
		preGenList = true;
		
	}
#undef LZZ_INLINE
 
// f00352_gameblock.h
//

#include "f00352_gameblock.e"
#define LZZ_INLINE inline
GameBlock::GameBlock ()
                    {
		terData = NULL;
		buildingData = NULL;
	}
void GameBlock::init (Singleton * _singleton, int _blockId, int _x, int _y, int _z, int _xw, int _yw, int _zw)
          {

		plantScale = 2.0f;

		dirModX[0] = 1;
		dirModX[1] = -1;
		dirModX[2] = 0;
		dirModX[3] = 0;
		dirModX[4] = 0;
		dirModX[5] = 0;

		dirModY[0] = 0;
		dirModY[1] = 0;
		dirModY[2] = 1;
		dirModY[3] = -1;
		dirModY[4] = 0;
		dirModY[5] = 0;

		dirModZ[0] = 0;
		dirModZ[1] = 0;
		dirModZ[2] = 0;
		dirModZ[3] = 0;
		dirModZ[4] = 1;
		dirModZ[5] = -1;

		opDir[0] = 1;
		opDir[1] = 0;
		opDir[2] = 3;
		opDir[3] = 2;
		opDir[4] = 5;
		opDir[5] = 4;

		forceUpdate = false;

		singleton = _singleton;
		blockId = _blockId;
		offsetInBlocks.setIXYZ(_x, _y, _z);
		offsetInBlocksWrapped.setIXYZ(_xw, _yw, _zw);


		origin.setFXYZ(0.0f, 0.0f, 0.0f);




		int i;
		int j;
		int k;
		int m;
		int n;
		int p;
		int q;
		
		int tempInt;
		int incVal;
		
		int minRot = 0;
		int maxRot = 0;


		for (i = 0; i < E_CT_LENGTH; i++) {
			isTraversable[i] = false;
			isRoom[i] = false;
			isBase[i] = false;
			isBuilding[i] = false;
			isRoad[i] = false;
			ctClasses[i] = E_CTC_NOTHING;
			layerHash[i] = 0;
		}
		
		
		layerHash[E_CT_FOUNDATION] = 2;
		
		layerHash[E_CT_LANTERN] = 3;
		layerHash[E_CT_WINDOWFRAME] = 1;
		layerHash[E_CT_WINDOW] = 1;
		layerHash[E_CT_DOORWAY] = 1;
		layerHash[E_CT_DOOR] = 1;
		
		
		
		isTraversable[E_CT_ROAD] = true;
		isTraversable[E_CT_CONNECTED] = true;
		
		isRoad[E_CT_ROAD] = true;
		
		isBuilding[E_CT_ROOM_BRICK] = true;
		isBuilding[E_CT_ROOM_TUDOR] = true;
		isBuilding[E_CT_WALKWAY] = true;
		isBuilding[E_CT_ROOF] = true;

		isRoom[E_CT_ROOM_BRICK] = true;
		isRoom[E_CT_ROOM_TUDOR] = true;
		isRoom[E_CT_WALKWAY] = true;

		isBase[E_CT_ROOM_BRICK] = true;
		isBase[E_CT_ROAD] = true;
		
		
		ctClasses[E_CT_NULL] = E_CTC_NOTHING;
		ctClasses[E_CT_CONNECTED] = E_CTC_NOTHING;
		ctClasses[E_CT_ROAD] = E_CTC_ROAD;
		ctClasses[E_CT_ROOF] = E_CTC_ROOF;
		ctClasses[E_CT_WALKWAY_TOP] = E_CTC_ROOM;
		ctClasses[E_CT_ROOM_BRICK] = E_CTC_ROOM;
		ctClasses[E_CT_ROOM_TUDOR] = E_CTC_ROOM;
		ctClasses[E_CT_WALKWAY] = E_CTC_ROOM;
		ctClasses[E_CT_STAIRS] = E_CTC_STAIRS;
		ctClasses[E_CT_LANTERN] = E_CTC_LANTERN;
		ctClasses[E_CT_LENGTH] = E_CTC_NOTHING;

		int nMax;

		int curAlign = 0;

		float x1;
		float y1;
		float z1;

		float x2;
		float y2;
		float z2;


		float hingeDis = 0.0f;

		//float z;

		float zmax;


		int curDir = 0; // 0:x, 1:y, 2:z

		int roofType = 0;

		maxFloors = 3;

		terDataTexScale = singleton->terDataTexScale;

		holdersPerBlock = singleton->holdersPerBlock;

		cellsPerBlock = singleton->cellsPerBlock;
		fCellsPerBlock = (float)cellsPerBlock;

		float uvSizeInCells = 1.0;
		float uvSizeInPixels = uvSizeInCells; // 64

		float offsetPerFloor = 0.25;
		float floorOffset;

		bool notFound;
		bool foundA;
		bool foundB;
		bool foundC;
		
		bool isInside;
		bool isWingBeg;
		bool isWingEnd;
		bool isWingBeg2;
		bool isWingEnd2;
		
		
		float wingMult;
		float newWingMult;
		float nDir;

		float hm = 0.0f;

		float cr1;
		float cr2;
		float cr3;
		float cr4;

		float doorMod = 0.0f;

		gw = singleton->gw;

		FBOWrapper *fbow = singleton->getFBOWrapper("hmFBO", 0);
		FBOWrapper *fbow2 = singleton->getFBOWrapper("cityFBO", 0);

		int maxLoop;
		int lotX;
		int lotY;
		int lotZ;


		float xmod1;
		float ymod1;
		float zmod1;

		float xmod2;
		float ymod2;
		float zmod2;


		int curLev = 0;
		int kt = 0;
		int kmax = 0;
		int kmin = 0;
		int kstep = 0;

		int testX;
		int testY;


		int baseI = 0;
		int baseJ = 0;


		int res;
		int res2;
		int res3;

		unsigned int nodeFlags = 0;

		int counter;

		int houseColor = 0;
		int lotSizeO2 = singleton->cellsPerHolder / 2;

		int XP = 0;
		int XN = 1;
		int YP = 2;
		int YN = 3;
		int curChannel = 0;

		int ktemp = 0;
		int curId = 0;
		int curBT = 0;
		int curBT2 = 0;
		int curBT3 = 0;
		int curHeight = 0;

		int wingDir;

		floorHeightInCells = singleton->floorHeightInCells;
		float roofHeightInCells;// = singleton->roofHeightInCells;
		float wallRadInCells;
		float flushRadInCells;
		float fi;
		float fj;
		float fk;

		float tempf;
		float pv1;
		float pv2;
		float pv3;
		float pv4;

		float perc1;
		float perc2;
		float baseOffset = 0.0f;
		float cellsPerHolder = singleton->cellsPerHolder;

		bool doProc = false;
		bool isVert;
		bool isDif;

		int curInd = 0;
		int testInd = 0;
		int testInd2 = 0;
		int testInd3 = 0;
		int testVal;
		int testVal2;
		int conType;
		int testConType;
		int seaLev;

		int curType;
		uint uiSimp;
		float fSimp;
		
		float fSimpLow;
		float fSimpHigh;

		int newCount = 0;
		int io, jo, ko;
		
		float doorThickness = 0.0625f;
		float lanternOffset = 0.1875f;
		float doorInset = 0.0f;
		float doorScale = 0.625f;
		
		int iNodeDivsPerHolder = singleton->iNodeDivsPerHolder;

		iHolderSize = holdersPerBlock * holdersPerBlock * holdersPerBlock;
		holderData = new GamePageHolder*[iHolderSize];
		for (i = 0; i < iHolderSize; i++) {
			holderData[i] = NULL;
		}


		terDataBufAmount = singleton->terDataBufAmount;
		terDataVisSize = singleton->terDataVisSize;
		terDataBufSize = singleton->terDataBufSize;

		terDataVisPitchXY = singleton->terDataVisPitchXY;
		fTerDataVisPitchXY = singleton->terDataVisPitchXY;
		terDataBufPitchXY = singleton->terDataBufPitchXY;
		terDataBufPitchScaledXY = singleton->terDataBufPitchScaledXY;

		terDataVisPitchZ = singleton->terDataVisPitchZ;
		fTerDataVisPitchZ = singleton->terDataVisPitchZ;
		terDataBufPitchZ = singleton->terDataBufPitchZ;
		terDataBufPitchScaledZ = singleton->terDataBufPitchScaledZ;

		
		seaLev = singleton->getSLNormalized()*fTerDataVisPitchZ + terDataBufAmount;

		float fTerDataBufAmount = (float)(singleton->terDataBufAmount);
		float bmodXY = fTerDataBufAmount / (fTerDataVisPitchXY);
		float bmodZ = fTerDataBufAmount / (fTerDataVisPitchZ);

		blockMinBufInPixels.copyFrom(&(offsetInBlocks));
		blockMinBufInPixels.addXYZ(-bmodXY, -bmodXY, -bmodZ);
		blockMinBufInPixels.multXYZ(fCellsPerBlock);


		blockMaxBufInPixels.copyFrom(&(offsetInBlocks));
		blockMaxBufInPixels.addXYZ(1.0f + bmodXY, 1.0f + bmodXY, 1.0f + bmodZ);
		blockMaxBufInPixels.multXYZ(fCellsPerBlock);



		// TODO: REIMPLEMENT BUILDING DATA AND REMOVE THIS RETURN
		return;


		



		terData = new uint[terDataBufSize];
		buildingData = new BuildingNode[terDataBufSize];

		for (i = 0; i < terDataBufSize; i++) {
			terData[i] = 0;

			buildingData[i].id = -1;
			buildingData[i].visited = 0;
			buildingData[i].mazeIndex = -1;
			buildingData[i].nearTerrain = false;
			buildingData[i].nearAir = false;

			for (j = 0; j < TOT_NODE_VALS; j++) {
				curCon = &(buildingData[i].con[j]);
				curCon->conType = E_CT_NULL;
				curCon->nodeFlags = 0;
				curCon->heightDelta = 0;
				curCon->wingMult = 1.0f;
				curCon->wallRadInCells = singleton->wallRadInCells;
			}


		}

		// Create Map Data


		
		// iBuildingNodesPerSideM1 = holdersPerBlock*iNodeDivsPerHolder;
		// fBuildingNodesPerSideM1 = (float)iBuildingNodesPerSideM1;
		// iBuildingNodesPerSide = iBuildingNodesPerSideM1 + 1;
		int iMapBufSize = terDataBufPitchXY * terDataBufPitchXY;

		mapData = new MapNode[iMapBufSize];

		for (i = 0; i < iMapBufSize; i++) {
			mapData[i].id = 0;
			for (j = 0; j < TOT_MAP_DIRS; j++) {
				mapData[i].connectionProps[j] = E_CT_NULL;
			}
		}


		
		
		

		// Create Ter Data

		p = 1;
		for (i = 0; i < terDataBufPitchXY; i++) {
			fi = (float)((i / p) * p);
			for (j = 0; j < terDataBufPitchXY; j++) {
				fj = (float)((j / p) * p);
				for (k = 0; k < terDataBufPitchZ; k++) {
					fk = (float)k;


					curInd = getNodeIndex(i, j, k, 0);

					// fSimp = simplexScaledNoise(
					//  4.0f, //octaves
					//  2.0f, //persistence (amount added in each successive generation)
					//  1.0f/32.0f, //scale (frequency)
					//  0.0f, // lo bound
					//  1.0f, // hi bound
					//  fi + offsetInBlocks.getFX()*((float)terDataVisPitchXY) - 1.0f,
					//  fj + offsetInBlocks.getFY()*((float)terDataVisPitchXY) - 1.0f,
					//  fk + offsetInBlocks.getFZ()*((float)terDataVisPitchZ) - 1.0f
					// );
					// uiSimp = clampfZO(fSimp)*255.0f;


					tempVec.setFXYZ(
						fi + offsetInBlocks.getFX()*fTerDataVisPitchXY - fTerDataBufAmount,
						fj + offsetInBlocks.getFY()*fTerDataVisPitchXY - fTerDataBufAmount,
						fk + offsetInBlocks.getFZ()*fTerDataVisPitchZ - fTerDataBufAmount
					);
					tempVec.multXYZ(
						fCellsPerBlock / fTerDataVisPitchXY,
						fCellsPerBlock / fTerDataVisPitchXY,
						fCellsPerBlock / fTerDataVisPitchZ	
					);

					tempf = singleton->getHeightAtPixelPos(tempVec.getFX(), tempVec.getFY());

					if ( tempVec.getFZ() < tempf) {
						uiSimp = 255;
					} else {
						uiSimp = 0;
					}


					terData[curInd] = (uiSimp << 24) | (uiSimp << 16) | (uiSimp << 8) | uiSimp;
				}
			}
		}
		
		


		// Get Ter Data Height

		for (i = 0; i < terDataBufPitchXY; i++) {
			for (j = 0; j < terDataBufPitchXY; j++) {

				testInd2 = -1;
				for (k = 0; k < terDataBufPitchZ; k++) {
					curInd = getNodeIndex(i, j, k, 0);

					if (terData[curInd] != 0) {
						singleton->rbHeightStack[curInd] = 0;
					} else {

						if (testInd2 == -1) {
							testInd2 = k;
						}

						testInd = getNodeIndex(i, j, k - 1, 0);

						if (testInd > -1) {
							singleton->rbHeightStack[curInd] = singleton->rbHeightStack[testInd] + 1;
						} else {
							singleton->rbHeightStack[curInd] = 0;
						}
					}
				}

				

				mapData[getMapNodeIndex(i, j, 0)].terHeight = testInd2;
				mapData[getMapNodeIndex(i, j, 0)].adjustedHeight = testInd2;
			}
		}


		



















		// Layout Map Roads

		for (i = -1; i <= holdersPerBlock; i++) {
			for (j = -1; j <= holdersPerBlock; j++) {


				for (m = 0; m < 2; m++) {

					switch (m) {
					case 0:
						//curChannel = gw->stChannel;
						curChannel = gw->pathChannel;
						break;
					case 1:
						curChannel = gw->btChannel;
						break;
					}

					//one lot = one map pixel
					lotX = holdersPerBlock * (offsetInBlocks.getIX()) + i;
					lotY = holdersPerBlock * (offsetInBlocks.getIY()) + j;
					res = fbow2->getPixelAtWrapped(lotX, lotY, curChannel);


					// if (
					// 	singleton->getHeightAtPixelPos(lotX*singleton->cellsPerHolder,lotY*singleton->cellsPerHolder) <=
					// 	singleton->getSeaHeightScaled()  + 1.0f
					// ) {
					// 	curType = E_CT_DOCK;
					// }
					// else {
						curType = E_CT_ROAD;
					//}




					// roads
					for (k = 0; k < TOT_MAP_DIRS; k++) {

						if ( (res & gw->dirFlagsO[k]) > 0) { // has road

							baseI = i * iNodeDivsPerHolder + terDataBufAmount;
							baseJ = j * iNodeDivsPerHolder + terDataBufAmount;

							for (m = 0; m < iNodeDivsPerHolder; m++) {
								switch (k) {
								case 0: // x+
									connectMapNodes(baseI + iNodeDivsPerHolder, baseJ + m, baseI + iNodeDivsPerHolder, baseJ + m + 1, curType, -1, 0);
									break;
								case 1: // x-
									connectMapNodes(baseI, baseJ + m, baseI, baseJ + m + 1, curType, -1, 0);
									break;
								case 2: // y+
									connectMapNodes(baseI + m, baseJ + iNodeDivsPerHolder, baseI + m + 1, baseJ + iNodeDivsPerHolder, curType, -1, 0);
									break;
								case 3: // y-
									connectMapNodes(baseI + m, baseJ, baseI + m + 1, baseJ, curType, -1, 0);
									break;

								}
							}

						}
					}
				}


			}
		}

		// houses

		for (i = 0; i < holdersPerBlock; i++) {
			for (j = 0; j < holdersPerBlock; j++) {

				lotX = holdersPerBlock * (offsetInBlocks.getIX()) + i;
				lotY = holdersPerBlock * (offsetInBlocks.getIY()) + j;


				res = fbow2->getPixelAtWrapped(lotX, lotY, gw->houseChannel);
				res3 = fbow2->getPixelAtWrapped(lotX, lotY, gw->btChannel);

				if (res != 0) {
					for (k = 0; k < TOT_MAP_DIRS; k++) {

						res2 = fbow2->getPixelAtWrapped(lotX + dirModX[k], lotY + dirModY[k], gw->houseChannel);

						if ( (res == res2)  && ( touchesMap(i,j,E_CT_ROAD,0) == 0 ) ) { // house id matches, there is a house in that direction




							baseI = i * iNodeDivsPerHolder + terDataBufAmount + iNodeDivsPerHolder / 2;
							baseJ = j * iNodeDivsPerHolder + terDataBufAmount + iNodeDivsPerHolder / 2;

							for (m = 0; m < iNodeDivsPerHolder / 2; m++) {

								
								switch (k) {
								case 0: // x+
									connectMapNodes(baseI + m, baseJ, baseI + m + 1, baseJ, E_CT_MAINHALL, res % 6, terDataBufAmount+1);
									break;
								case 1: // x-
									connectMapNodes(baseI - (m + 1), baseJ, baseI - m, baseJ, E_CT_MAINHALL, res % 6, terDataBufAmount+1);
									break;
								case 2: // y+
									connectMapNodes(baseI, baseJ + m, baseI, baseJ + m + 1, E_CT_MAINHALL, res % 6, terDataBufAmount+1);
									break;
								case 3: // y-
									connectMapNodes(baseI, baseJ - (m + 1), baseI, baseJ - m, E_CT_MAINHALL, res % 6, terDataBufAmount+1);
									break;

								}


							}


						}
					}
				}

			}
		}



		// connect wings

		for (i = 0; i < terDataBufPitchXY; i++) {
			for (j = 0; j < terDataBufPitchXY; j++) {
				if ( touchesMap(i, j, E_CT_NULL, 0) == 4 ) {

					notFound = true;
					for (k = 0; (k < 4) && notFound; k++) {

						isVert = k >= 2;

						testX = i + dirModX[k];
						testY = j + dirModY[k];

						if ( touchesMap(testX, testY, E_CT_MAINHALL, 0) >= 1 ) {

							if (
								(touches2Map(i, j, E_CT_WING, 0) == 0)
								
								// TODO: must ensure any random number
								// is persistent across the world with iSeedRand2
								
							) {

								if (true) {

									testInd = getMapNodeIndex(testX, testY, 0);

									if (testInd > -1) {
										testInd2 = mapData[testInd].id;
									} else {
										testInd2 = 0;
									}

									connectMapNodes(i, j, testX, testY, E_CT_WING, testInd2, 0 );

									testX = i + dirModX[ gw->opDir[k] ];
									testY = j + dirModY[ gw->opDir[k] ];

									if (touchesMap(testX, testY, E_CT_ROAD, 0) >= 1) {
										connectMapNodes(i, j, testX, testY, E_CT_ROAD, -1, 0);

										

									}
									
									notFound = false;
								}

							}
						}
					}
				}
			}
		}
		
		
		tempVec2.setFXYZ(93.989f, 67.345f, 54.256f);
		
		
		for (i = 0; i < terDataBufPitchXY; i++) {
			for (j = 0; j < terDataBufPitchXY; j++) {
				testInd = getMapNodeIndex(i, j, 0);
				tempVec.setFXYZ(i*2.132f,j*4.10523f,15.23523f);

				mapData[testInd].houseHeight = iGetRandSeeded(&tempVec,&tempVec2, 0, 1);
			}
		}
		
		
		
		
		
		
		
		
		if (singleton->treesOn) {
			for (i = terDataBufAmount*2; i < terDataBufPitchXY-terDataBufAmount*2; i++) {
				for (j = terDataBufAmount*2; j < terDataBufPitchXY-terDataBufAmount*2; j++) {
					if ( (touchesWithinRadMap(i,j,E_CT_TREE, 3, 0) == 0) && (touches2Map(i,j,E_CT_NULL,0) == 16) ) {

						lotX = holdersPerBlock * (offsetInBlocks.getIX()) + i;
						lotY = holdersPerBlock * (offsetInBlocks.getIY()) + j;

						x1 = lotX + (i*cellsPerBlock)/terDataBufPitchXY;
						y1 = lotY + (j*cellsPerBlock)/terDataBufPitchXY;

						testInd = getMapNodeIndex(i, j, 0);
						
						tempVec.setFXYZ(i,j,15.0);

						if (
							
							//singleton->getHeightAtPixelPos(x1,y1) >
							//singleton->getSeaHeightScaled() + 2.0f
							
							( ((float)(mapData[testInd].terHeight))/fTerDataVisPitchZ ) >
							(singleton->getSLNormalized() + 1.0f/255.0f)
							
						) {
							
							if ( iGetRandSeeded(&tempVec,&tempVec2, 0, 100) > 10 ) {
								mapData[testInd].connectionProps[0] = E_CT_TREE;
							}
						}
					}
				}
			}
		}




		// even out adjusted heights for terrain to be within one unit of eachother

		counter = 0;
		
		int newSeaLev = seaLev+1;
		
		do {

			notFound = false;

			for (i = 0; i < terDataBufPitchXY; i++) {
				for (j = 0; j < terDataBufPitchXY; j++) {

					curInd = getMapNodeIndex(i, j, 0);
					
					if (curInd > -1) {
						m = mapData[curInd].adjustedHeight;

						p = 0;

						for (k = 0; k < TOT_MAP_DIRS; k++) {
							testX = i + dirModX[k];// * q;
							testY = j + dirModY[k];// * q;
							testInd = getMapNodeIndex(testX, testY, 0);

							if (testInd > -1) {
								p = max(p, mapData[testInd].adjustedHeight);
							}
						}

						if (p - m > 1) {
							mapData[curInd].adjustedHeight = p - 1;
							notFound = true;
						}
						
						if ( newSeaLev > mapData[curInd].adjustedHeight) {
							mapData[curInd].adjustedHeight = max(mapData[curInd].adjustedHeight, newSeaLev);
							notFound = true;
						}
					}
					


				}
			}

			counter++;

		} while (notFound && (counter < 16));
















		



		


		// building layout

		for (n = 0; n < E_BG_LENGTH; n++) {

			if (n == E_BG_DOORS) {
				incVal = 1;
			}
			else {
				incVal = 2;
			}

			for (ktemp = 0; ktemp < terDataBufPitchZ; ktemp++) {

				if (n == E_BG_FILL_TERRAIN) {
					k = (terDataBufPitchZ - 1) - ktemp;
				}
				else {
					k = ktemp;
				}


				fk = (float)k;
				for (j = 0; j < terDataBufPitchXY; j++) {
					fj = (float)j;
					for (i = 0; i < terDataBufPitchXY; i++) {
						fi = (float)i;

						curInd = getNodeIndex(i, j, k, 0);




						if (curInd > -1) {

							for (m = 0; m < 6; m += incVal) {



								conType = buildingData[curInd].con[m].conType;
								nodeFlags = 0;

								switch (n) {

								case E_BG_ROADS_AND_BUILDINGS:




									if (m < 4) {
										testInd = getMapNodeIndex(i, j, 0);
										testInd2 = getMapNodeIndex(i + dirModX[m], j + dirModY[m], 0);

										if (
											(testInd > -1) &&
											(testInd2 > -1)
										) {

											curBT = mapData[testInd].connectionProps[m];
											//curBT2 = mapData[testInd2].connectionProps[m];

											testVal = mapData[testInd].adjustedHeight;
											testVal2 = mapData[testInd2].adjustedHeight;


											/*
											int _x1,
											int _y1,
											int _z1,
											int _x2,
											int _y2,
											int _z2,
											int ct,
											int id = -1,
											int _heightDelta = 0,
											int _direction = 0,
											float _wallRadInCells = -1.0f
											*/


											switch (curBT) {
												case E_CT_ROAD:
												case E_CT_MAINHALL:
												case E_CT_WING:
													
													
													if (
														testVal == (k+1)
													) {
														connectNodes(
															i,
															j,
															k,
															i + dirModX[m],
															j + dirModY[m],
															k + dirModZ[m],

															E_CT_FOUNDATION,
															-1,
															testVal2 - testVal, // heightDelta,
															0,
															singleton->wallRadInCells + 1.0f
														);
													}												
												break;
											}

											switch (curBT) {
											case E_CT_ROAD:

												if (
													testVal == k
												) {
													connectNodes(
														i,
														j,
														k,
														i + dirModX[m],
														j + dirModY[m],
														k + dirModZ[m],

														E_CT_ROAD,
														-1,
														testVal2 - testVal // heightDelta
													);
												}

												break;


											case E_CT_TREE:

												if (
													testVal == k
												) {
													connectNodes(
														i,
														j,
														k,
														i + dirModX[m],
														j + dirModY[m],
														k + dirModZ[m],

														E_CT_TREE,
														-1,
														0 // heightDelta
													);
												}

												break;


											


											/*
											int _x1,
											int _y1,
											int _z1,
											int _x2,
											int _y2,
											int _z2,
											
											int ct,
											int id = -1,
											int _heightDelta = 0,
											int _direction = 0,
											float _wallRadInCells = -1.0f,
											unsigned int _nodeFlags = 0
											*/


												
											case E_CT_MAINHALL:
											case E_CT_WING:
												if (
													// max(
													// 	mapData[testInd].adjustedHeight,
													// 	mapData[testInd2].adjustedHeight
													// )
													// == k
													
													(
														(k >= mapData[testInd].adjustedHeight) &&
														(k <= mapData[testInd].adjustedHeight + mapData[testInd].houseHeight)
													)
													||
													(
														(k >= mapData[testInd2].adjustedHeight) &&
														(k <= mapData[testInd2].adjustedHeight)
													)
												) {

													tempf = -1.0f;
												
													// if (
													// 	((mapData[testInd].adjustedHeight + mapData[testInd].houseHeight - k) == 0) &&
													// 	(mapData[testInd].houseHeight == 1)
													// ) {
													// 	tempf = singleton->wallRadInCells + 1.0;
													// }

													connectNodes(
														i,
														j,
														k,
														i + dirModX[m],
														j + dirModY[m],
														k + dirModZ[m],

														E_CT_ROOM_TUDOR,
														mapData[testInd].id,
														0,
														0,
														tempf
													);


												}
												break;
											}


										}


									}


									break;

								// case E_BG_STAIRS: // add stairs
								// 	if (m == 4) {

								// 		// only put stairs in placed building segments
								// 		if (conType > E_CT_CONNECTED) {
								// 			foundA = false;
								// 			testInd = -1;

								// 			// find best direction for stairs
								// 			for (p = 0; p < 4; p++) {
								// 				if (buildingData[curInd].con[p].conType == conType) {
								// 					foundA = true;
								// 					if (p % 2 == 0) {
								// 						if (testInd == -1) {
								// 							testInd = p;
								// 						} else {

								// 						}

								// 					}
								// 					break;
								// 				}
								// 			}

								// 			if (foundA) { // make stairs straight
								// 				if (testInd > -1) {
								// 					connectNodes(
								// 						i,
								// 						j,
								// 						k,
								// 						i + dirModX[testInd],
								// 						j + dirModY[testInd],
								// 						k + dirModZ[testInd],

								// 						E_CT_STAIRS,

								// 						
								// 					);
								// 				}

								// 			} else { // is tower, make winding stairs
								// 				connectNodes(
								// 					i,
								// 					j,
								// 					k,
								// 					i + dirModX[m],
								// 					j + dirModY[m],
								// 					k + dirModZ[m],

								// 					E_CT_STAIRS,

								// 					
								// 				);
								// 			}
								// 		}

								// 	}
								// 	break;


								// case E_BG_REMOVE_REDUNDANT_Z_SEGMENTS:
								
									

								// 	if (m == 4) {
										
								// 		doProc = false;
										
								// 		if ( ctClasses[conType] == E_CTC_ROAD ) {
								// 			if ( touchesPlanarClass(i,j,k+1,E_CTC_ROAD, 0) ) {
								// 				doProc = true;
								// 			}
								// 		}
										
								// 		if (touchesRoomOnLevel(i, j, k)) {
								// 			doProc = true;
								// 		}
										
								// 		if (doProc) {
								// 			connectNodes(
								// 				i,
								// 				j,
								// 				k,
								// 				i,
								// 				j,
								// 				k + 1,

								// 				E_CT_CONNECTED
								// 			);
								// 		}
										
								// 	}


								// 	break;


								case E_BG_ROOFS:





									//if (m < 4) {

									roofType = E_CT_NULL;


									if (conType == E_CT_ROOM_TUDOR) {
										roofType = E_CT_ROOF;
										
									}
									if (conType == E_CT_WALKWAY) {
										roofType = E_CT_WALKWAY_TOP;
									}




									if (roofType != E_CT_NULL) {

										testInd = getNodeIndex(i, j, k + 1, 0);

										if (testInd > -1) {
											testConType = buildingData[testInd].con[m].conType;
											if (testConType <= E_CT_CONNECTED) {


												if (m == 4) {
													foundA = !( touchesRoomOnLevel(i, j, k + 1) );
												} else {
													foundA = true;
												}

												if (foundA) {
													connectNodes(
														i,
														j,
														k + 1,
														i + dirModX[m],
														j + dirModY[m],
														k + dirModZ[m] + 1,

														roofType,

														buildingData[curInd].id,
														
														0,
														0,
														singleton->wallRadInCells + 0.5f

													);
												}
											}
										}
									}
									//}



									break;

								// case E_BG_BASEMENTS:



								// 	// if (isRoom[conType] && (conType != E_CT_ROOM_BRICK)) {


								// 	// 	if ( !hasRoomBelow(i, j, k, m) ) { //hasTerrainBelow(i,j,k,m,false) ) {
								// 	// 		connectNodes(
								// 	// 			i,
								// 	// 			j,
								// 	// 			k - 1,
								// 	// 			i + dirModX[m],
								// 	// 			j + dirModY[m],
								// 	// 			k + dirModZ[m] - 1,

								// 	// 			E_CT_ROOM_BRICK
								// 	// 		);
								// 	// 	}


								// 	// }
								
									
								// 	if (
								// 		(ctClasses[conType] == E_CTC_ROAD)
								// 		 || (ctClasses[conType] == E_CTC_ROOM)
								// 	) {


										

								// 		if ( !hasRoomBelow(i, j, k, m) ) { //hasTerrainBelow(i,j,k,m,false) ) {
								// 			connectNodes(
								// 				i,
								// 				j,
								// 				k - 1,
								// 				i + dirModX[m],
								// 				j + dirModY[m],
								// 				k + dirModZ[m] - 1,

								// 				E_CT_FOUNDATION,
								// 				-1,
								// 				buildingData[curInd].con[m].heightDelta,
								// 				0,
								// 				singleton->wallRadInCells - 1.0f
								// 			);
								// 		}


								// 	}
								


								// 	break;

								case E_BG_WING_TIPS:
									if (m < 4) {


										


										testInd = getMapNodeIndex(i, j, 0);
										testInd2 = getMapNodeIndex(i + dirModX[m], j + dirModY[m], 0);
										testInd3 = getMapNodeIndex(i - dirModX[m], j - dirModY[m], 0);

										tempf = 1.0f;
										foundA = false;
										foundB = false;

										if (
											(testInd > -1) && (testInd2 > -1) && (testInd3 > -1)
										) {

											curBT = mapData[testInd].connectionProps[m];
											curBT2 = mapData[testInd2].connectionProps[m];
											curBT3 = mapData[testInd3].connectionProps[m];
											
											
											
											
											// if ( (curBT == E_CT_WING) && (curBT2 == E_CT_ROAD) ) {
											// 	tempf = 0.75f;
											// }
											// if ( (curBT == E_CT_ROAD) && (curBT2 == E_CT_WING) ) {
											// 	tempf = 1.25f;
											// }
											
											if ( (curBT == E_CT_WING) && (curBT2 == E_CT_ROAD) ) {
												foundB = true;
											}
											if ( (curBT == E_CT_ROAD) && (curBT2 == E_CT_WING) ) {
												foundB = true;
											}
											
											if ( (curBT == E_CT_WING) && (curBT3 == E_CT_ROAD) ) {
												foundA = true;
											}
											if ( (curBT == E_CT_ROAD) && (curBT3 == E_CT_WING) ) {
												foundA = true;
											}
											
											
											if (foundA || foundB) {
												if (isBuilding[conType]) {
													//tempf = 0.75f;
												}
												else {//if (isRoad[conType]) {
													//tempf = 1.25f;
												}
											}
											
											
											// if (tempf != 1.0f) {
											// 	foundA = (touchesPlanarClass(i, j, k, ctClasses[conType], 0) == 1);
											// 	foundB = (touchesPlanarClass(i + dirModX[m], j + dirModY[m], k, ctClasses[conType], 0) == 1);
											// }
											
										}
										
										
										for (q = 0; q < MAX_NODE_VALS; q++) {
											
											if (q != layerHash[E_CT_FOUNDATION]) {
												applyWingValues(
													i,
													j,
													k,
													i + dirModX[m],
													j + dirModY[m],
													k + dirModZ[m],
													q,
													foundA,
													foundB,
													tempf
													
												);
											}
											
											
										}
										

										
									}
									break;
								
								case E_BG_DOORS:
								
								
									if (m < 4) {
										
										
										isWingBeg = (buildingData[curInd].con[m].nodeFlags & BC_FLAG_WING_BEG)>0;
										isWingEnd = (buildingData[curInd].con[m].nodeFlags & BC_FLAG_WING_END)>0;
										
										//if ( (m%2) == 0 ) {}
										
										
										
										
										if (
											(ctClasses[conType] == E_CTC_ROOM) &&
											(isWingEnd)
										) {
											
											curBT = E_CT_WINDOWFRAME;
											
											testInd = getNodeIndex(i + dirModX[m], j + dirModY[m], k, 0);
											if (testInd > -1) {
												if (
													ctClasses[buildingData[testInd].con[m].conType] == E_CTC_ROAD	
												) {
													curBT = E_CT_DOORWAY;
												}
											}
											
											
											if ( (m%2) == 0 ) {
												curDir = 1;
											}
											else {
												curDir = -1;
											}
											
											connectNodes(
												i,
												j,
												k,
												i + dirModX[m],
												j + dirModY[m],
												k + dirModZ[m],
												curBT,
												-1,
												0,
												curDir

											);
											
											
											
											
											
											if (curBT == E_CT_DOORWAY) {
												
											}
											else {
												nodeFlags |= BC_FLAG_INSIDE;
											}
											
											/*
											void connectNodes(
												int _x1,
												int _y1,
												int _z1,
												int _x2,
												int _y2,
												int _z2,
												
												int ct,
												int id = -1,
												
												int _heightDelta = 0,
												int _direction = 0,
												
												float _wallRadInCells = -1.0f,
												unsigned int _nodeFlags = 0
											)
											*/
											
											connectNodes(
												i,
												j,
												k,
												i + dirModX[m],
												j + dirModY[m],
												k + dirModZ[m],
												
												E_CT_LANTERN,
												-1,
												
												0,
												curDir,
												
												-1.0f,
												nodeFlags

											);
											
											
											
											
										}
										
										
										
										
										
										
										
										
										
										if (conType <= E_CT_CONNECTED) {
											
											doProc = true;
											
											for (q = 0; q < 4; q++) {
												if (
													
													(
														( (q%2) == 1 ) &&
														( (buildingData[curInd].con[q].nodeFlags&BC_FLAG_WING_BEG) > 0)
													)
												) {
													doProc = false;
												}
											}
											
											
											if (doProc) {
												if (touchesPlanarClass(i, j, k, E_CTC_ROOM, 0) > 0) {
													
													if ( (m%2) == 0 ) {
														curDir = 1;
													}
													else {
														curDir = -1;
													}
													
													connectNodes(
														i,
														j,
														k,
														i + dirModX[m],
														j + dirModY[m],
														k + dirModZ[m],
														E_CT_WINDOWFRAME,
														-1,
														0,
														curDir

													);
													//int touchesPlanarClass(int x, int y, int z, int classType, int bufAmount)
													/*
													void connectNodes(
														int _x1,
														int _y1,
														int _z1,
														int _x2,
														int _y2,
														int _z2,
														
														int ct,
														int id = -1,
														
														int _heightDelta = 0,
														int _direction = 0,
														
														float _wallRadInCells = -1.0f,
														unsigned int _nodeFlags = 0
													)
													*/
													
													if (touchesPlanarClass2(i, j, k, E_CTC_LANTERN, 0) == 0) {
														nodeFlags |= BC_FLAG_INSIDE;
														connectNodes(
															i,
															j,
															k,
															i + dirModX[m],
															j + dirModY[m],
															k + dirModZ[m],
															
															E_CT_LANTERN,
															-1,
															
															0,
															curDir,
															
															-1.0f,
															nodeFlags

														);
													}
													
													
												}
											}
											
											
											
											
											
										}
										
									}
									
									break;
									
									
									
									
								case E_BG_FILL_TERRAIN:
									if (terData[curInd] == 0) {

										testInd = getNodeIndex(i, j, k + 1, 0);

										if (testInd > -1) {
											testVal = terData[testInd];
											if (touchesBaseOnLevel(i, j, k+1, 2) || (testVal != 0)) {
												uiSimp = 255;
												terData[curInd] = (uiSimp << 24) | (uiSimp << 16) | (uiSimp << 8) | uiSimp;
											}
										}
										
									}
									break;
									
								}

							}
						}
					}
				}
			}
		}
		
		
		
		
		
		
		
		
		
		
		
		
		


		// simplex noise caves

		// fSimpLow = 9999.0f;
		// fSimpHigh = -9999.0f;
		
		
		// for (k = terDataBufPitchZ-2; k >= 0; k--) {
		// 	fk = k;
		// 	for (j = 0; j < terDataBufPitchXY; j++) {
		// 		fj = j;
		// 		for (i = 0; i < terDataBufPitchXY; i++) {
		// 			fi = i;


		// 			curInd = getNodeIndex(i, j, k, 0);
		// 			testInd = getNodeIndex(i, j, k+1, 0);
					
		// 			if (terData[curInd] != 0) {
		// 				if (terData[testInd] != 0) {
							
							
							
		// 					fSimp = simplexScaledNoise(
		// 					 4.0f, //octaves
		// 					 2.0f, //persistence (amount added in each successive generation)
		// 					 1.0f/4.0f, //scale (frequency)
		// 					 0.0f, // lo bound
		// 					 1.0f, // hi bound
		// 					 fi + offsetInBlocks.getFX()*((float)terDataVisPitchXY) - 1.0f,
		// 					 fj + offsetInBlocks.getFY()*((float)terDataVisPitchXY) - 1.0f,
		// 					 fk + offsetInBlocks.getFZ()*((float)terDataVisPitchZ) - 1.0f
		// 					);
							
		// 					if (fSimp < fSimpLow) {
		// 						fSimpLow = fSimp;
		// 					}
		// 					if (fSimp > fSimpHigh) {
		// 						fSimpHigh = fSimp;
		// 					}
							
		// 					if (fSimp > 0.6f) {
		// 						terData[curInd] = 0;
		// 					}
							
							
							
		// 				}
		// 			}
		// 		}
		// 	}
		// }

		// cout << "LOW " << fSimpLow << "\n";
		// cout << "HIGH " << fSimpHigh << "\n\n";




		
		
		
		
		
		
		if (singleton->cavesOn) {
			makeMazeUG();
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		int minRad = 1;
		int minRadZ = 1;
		
		
		bool nearAir = false;
		
		for (k = 0; k < terDataBufPitchZ; k++) {
			for (j = 0; j < terDataBufPitchXY; j++) {
				for (i = 0; i < terDataBufPitchXY; i++) {

					curInd = getNodeIndex(i, j, k, 0);

					

					if (curInd > -1) {
						nearAir = false;
						
						
						
						for (ko = -minRadZ; ko <= minRadZ; ko++) {
							for (jo = -minRad; jo <= minRad; jo++) {
								for (io = -minRad; io <= minRad; io++) {
									testInd = getNodeIndex(i + io, j + jo, k + ko, 0);

									if (testInd > -1) {
										if (terData[testInd] == 0) {
											buildingData[curInd].nearAir = true;
											nearAir = true;
										}
										else {
											buildingData[curInd].nearTerrain = true;
										}
									}
								}
							}
						}
					}
				}
			}
		}



		// geometry generation
		
		lotX = cellsPerBlock * offsetInBlocks.getIX();
		lotY = cellsPerBlock * offsetInBlocks.getIY();
		lotZ = 0;

		for (k = 0; k <= terDataBufPitchZ; k++) {

			for (i = 0; i < terDataBufPitchXY; i++) {

				for (j = 0; j < terDataBufPitchXY; j++) {
					
					

					curInd = getNodeIndex(i, j, k, terDataBufAmount); //terDataBufAmount

					

					if (curInd > -1) {
						for (q = 0; q < TOT_NODE_VALS; q += 2) {

							m = q % MAX_NODE_DIRS;

							curDir = m / 2;

							conType = buildingData[curInd].con[q].conType;

							if (conType != E_CT_NULL) {

								
								

								xmod1 = 0.0f;
								ymod1 = 0.0f;
								zmod1 = 0.0f;
								xmod2 = dirModX[m];
								ymod2 = dirModY[m];
								zmod2 = buildingData[curInd].con[q].heightDelta;

								if (conType == E_CT_FOUNDATION) {
									zmod1 -= 1.0f;
									zmod2 -= 1.0f;
									
									testInd = getMapNodeIndex(i, j, 0);
									testInd2 = getMapNodeIndex(i + dirModX[m], j + dirModY[m], 0);
									
									if ( (testInd > -1) && (testInd2 > -1) ) {
										if (
											mapData[testInd].adjustedHeight == mapData[testInd2].adjustedHeight
										) {
											zmod2 += 1.0;
										}
									}
									
									
								}
								
								
								
								isInside = (buildingData[curInd].con[q].nodeFlags & BC_FLAG_INSIDE) > 0;
								isWingBeg = (buildingData[curInd].con[q].nodeFlags & BC_FLAG_WING_BEG) > 0;
								isWingEnd = (buildingData[curInd].con[q].nodeFlags & BC_FLAG_WING_END) > 0;
								wingMult = buildingData[curInd].con[q].wingMult;
								newWingMult = (wingMult - 1.0f);
								nDir = buildingData[curInd].con[q].direction;
								
								
								
								// todo: fix this!
								wallRadInCells = buildingData[curInd].con[q].wallRadInCells;
								flushRadInCells = wallRadInCells;
								for (n = 0; n < 4; n++) {
									
									if (
										ctClasses[buildingData[curInd].con[ n ].conType] == E_CTC_ROOM
									) {
										flushRadInCells = max(
											flushRadInCells,
											buildingData[curInd].con[ n ].wallRadInCells
										);
									}
									
									
								}
									
								
								
								
								for (n = 0; n < 2; n++) {
									if (n == 0) {
										
									}
									else {
										
										
										
										if (curDir == E_DIR_X) {
											if (isWingBeg) {
												xmod1 -= newWingMult;
											}
											if (isWingEnd) {
												xmod2 += newWingMult;
											}
										}
										if (curDir == E_DIR_Y) {
											if (isWingBeg) {
												ymod1 -= newWingMult;
											}
											if (isWingEnd) {
												ymod2 += newWingMult;
											}
										}
										
										
										if (
											(conType == E_CT_DOORWAY) ||
											(conType == E_CT_WINDOWFRAME) ||
											(conType == E_CT_LANTERN)
										) {
											
											
											if (isWingBeg||isWingEnd) {
												
													if (curDir == E_DIR_X) {
														if (isWingBeg) {
															xmod2 = xmod1;
														}
														if (isWingEnd) {
															xmod1 = xmod2;
														}
														
													}
													if (curDir == E_DIR_Y) {
														if (isWingBeg) {
															ymod2 = ymod1;
														}
														if (isWingEnd) {
															ymod1 = ymod2;
														}
														
													}
													
													if (nDir == 1.0f) {
														tempf = -1.0f;
													}
													else {
														tempf = 1.0f;
													}
													
													if (conType == E_CT_LANTERN) {
														
														if (isInside) {
															tempf *= 7.0f;	
														}
														else {
															tempf *= -2.0f;	
														}
														
														
													}
													
													
													
													xmod1 += tempf*doorThickness*dirModX[m]*0.5f;
													ymod1 += tempf*doorThickness*dirModY[m]*0.5f;
													xmod2 += tempf*doorThickness*dirModX[m]*0.5f;
													ymod2 += tempf*doorThickness*dirModY[m]*0.5f;
													
													
													
													if (conType == E_CT_LANTERN) {
														
															if (isInside) {
																																
															}
															else {
																xmod1 += lanternOffset*dirModY[m];
																ymod1 += lanternOffset*dirModX[m];
																xmod2 += lanternOffset*dirModY[m];
																ymod2 += lanternOffset*dirModX[m];
															}
														
															
													}
													else {
														xmod1 -= doorThickness*dirModX[m]*0.5f;
														ymod1 -= doorThickness*dirModY[m]*0.5f;
														xmod2 += doorThickness*dirModX[m]*0.5f;
														ymod2 += doorThickness*dirModY[m]*0.5f;
													}
													
													
												}
												else {
													if (nDir == 1.0f) {
														tempf = (flushRadInCells)/(fCellsPerBlock / fTerDataVisPitchXY);
													}
													else {
														tempf = 1.0f-(flushRadInCells)/(fCellsPerBlock / fTerDataVisPitchXY);
													}
													
													xmod1 = tempf*dirModX[m];
													ymod1 = tempf*dirModY[m];
													xmod2 = xmod1;
													ymod2 = ymod1;
													
													if (conType == E_CT_LANTERN) {
														if (nDir == 1.0f) {
															tempf = -1.0f;
														}
														else {
															tempf = 1.0f;
														}
														
														if (isInside) {
															tempf *= 7.0f;	
														}
														else {
															tempf *= -2.0f;	
														}
														
														xmod1 += tempf*doorThickness*dirModX[m]*0.5f;
														ymod1 += tempf*doorThickness*dirModY[m]*0.5f;
														xmod2 += tempf*doorThickness*dirModX[m]*0.5f;
														ymod2 += tempf*doorThickness*dirModY[m]*0.5f;
														
														
													}
													else {
														if (nDir == 1.0f) {
															xmod1 -= doorThickness*dirModX[m];
															ymod1 -= doorThickness*dirModY[m];
														}
														else {
															xmod2 += doorThickness*dirModX[m];
															ymod2 += doorThickness*dirModY[m];
														}
													}
													
													
												}
												
												if (conType == E_CT_LANTERN) {
													
													if (isInside) {
														zmod1 += 0.375f;
														zmod2 += 0.375f;
													}
												}
												
											
										}
										
										
									}
										
									x1 = lotX + ( ((float)(i - terDataBufAmount) + xmod1 + 0.5f) * fCellsPerBlock) / fTerDataVisPitchXY;
									y1 = lotY + ( ((float)(j - terDataBufAmount) + ymod1 + 0.5f) * fCellsPerBlock) / fTerDataVisPitchXY;
									z1 = lotZ + ( ((float)(k - terDataBufAmount) + zmod1 + 0.5f) * fCellsPerBlock) / fTerDataVisPitchZ;

									x2 = lotX + ( ((float)(i - terDataBufAmount) + xmod2 + 0.5f) * fCellsPerBlock) / fTerDataVisPitchXY;
									y2 = lotY + ( ((float)(j - terDataBufAmount) + ymod2 + 0.5f) * fCellsPerBlock) / fTerDataVisPitchXY;
									z2 = lotZ + ( ((float)(k - terDataBufAmount) + zmod2 + 0.5f) * fCellsPerBlock) / fTerDataVisPitchZ;
									
									if (n == 0) {
										centerPoint.setFXYZ(
											(x1+x2)*0.5f,
											(y1+y2)*0.5f,
											(z1+z2)*0.5f
										);
									}
									
									
								}
								

							
								

								p1.setFXYZ(x1, y1, z1);
								p2.setFXYZ(x2, y2, z2);


								


								switch (conType) {
								case E_CT_NULL:
								case E_CT_CONNECTED:
								case E_CT_ROAD:
									nMax = 0;
									break;
								case E_CT_DOORWAY:
								case E_CT_WINDOWFRAME:
									nMax = 3;
									break;
								default:
									nMax = 1;
									break;

								}


								// todo: fix this
								if (ctClasses[conType] == E_CTC_ROOM) {
									roofHeightInCells = singleton->wallRadInCells;
								}
								else {
									roofHeightInCells = wallRadInCells;
									
								}



								

								for (n = 0; n < nMax; n++) {
									
									curBT = conType;
									rad.setFXYZ(
										wallRadInCells,
										wallRadInCells,
										(floorHeightInCells * 0.5f + roofHeightInCells)
									);
									cornerRad.setFXYZ(
										wallRadInCells,
										wallRadInCells,
										roofHeightInCells
									);
									powerVals.setFXYZ(2.0f, 1.0f, 0.0f);
									powerVals2.setFXYZ(2.0f, 1.0f, 0.0f);
									
									
									switch (buildingData[curInd].con[q].heightDelta) {
										case -1:
											powerVals.setFZ(1.0f);
											powerVals2.setFZ(0.0f);
										break;
										
										case 0:
											powerVals.setFZ(0.0f);
											powerVals2.setFZ(0.0f);
											
										break;
										
										case 1:
											powerVals.setFZ(0.0f);
											powerVals2.setFZ(1.0f);
											
										break;
										default:
											cout << "invalid height delta of " << buildingData[curInd].con[q].heightDelta << "\n";
										break;
									}
									
									
									
									
									thickVals.setFXYZ(0.0f, floorHeightInCells, 0.0f);
									baseOffset = 0.0f;
									curAlign = E_ALIGN_MIDDLE;
									minRot = 0;
									maxRot = 0;
									anchorPoint.setFXYZRef(&centerPoint);

									switch (conType) {
										
										case E_CT_NULL:
												
											break;
										
										
										case E_CT_TREE:
											baseOffset = 0.0f;
											matParams.setFXYZ(E_MAT_PARAM_TREE, 0.0, 0.0f);

											visInsetFromMin.setFXYZ(0.0f,0.0f,0.0f);
											visInsetFromMax.setFXYZ(0.0f,0.0f,0.0f);
											
											tempVec4.setFXYZRef(&p1);
											tempVec4.addXYZ(0.0f,0.0f,2.0f);

											tempVec.setIXYZ(i,j,k);
											tempVec.multXYZ(102.33,305.44,609.121);
											tempVec2.setFXYZ(93.989f, 67.345f, 54.256f);
											
											//0: palm
											//1: oak
											//2: bare
											tempInt = iGetRandSeeded(&tempVec,&tempVec2,0,E_PT_LENGTH/2 - 1);
											
											
											
											singleton->gamePlants[tempInt]->init(
												singleton,
												&(GamePlant::allPlantRules[tempInt*2+1]),
												&(GamePlant::allPlantRules[tempInt*2]),
												&origin
											);
											matParams.setFY(tempInt*2+1);
											addPlantNodes(singleton->gamePlants[tempInt]->rootsNode, &tempVec4, plantScale);
											matParams.setFY(tempInt*2);
											addPlantNodes(singleton->gamePlants[tempInt]->trunkNode, &tempVec4, plantScale);
											
											
											
											goto SKIP_ADD_GEOM;
											
										break;
										
										
										case E_CT_LANTERN:
										

											matParams.setFXYZ(E_MAT_PARAM_LANTERN, 0.0, 0.0f);

											curAlign = E_ALIGN_MIDDLE;

											// floorHeight = 0.5f;
											// roofHeight = 0.25f;
											// baseOffset = 0.0f;
											rad.setFXYZ(
												(0.5f),
												(0.5f),
												(0.75f)
											);
											cornerRad.setFXYZ(
												(0.125f),
												(0.125f),
												(0.25f)
											);
											thickVals.setFX(0.25f);											

											visInsetFromMin.setFXYZ(0.0f,0.0f,cornerRad.getFZ() - 0.125);
											visInsetFromMax.setFXYZ(0.0f,0.0f,0.0f);

											powerVals.setFXYZ(2.0f, 1.0f, 0.0f);
											powerVals2.setFXYZRef(&powerVals);

											curBT = E_CT_LANTERN;




											
										break;
										
										case E_CT_DOORWAY:
										case E_CT_WINDOWFRAME:
										
											if (conType == E_CT_DOORWAY) {
												tempf = 0.0f;
											}
											else {
												tempf = 1.0f;
											}
										
											if (n == 0) {
												matParams.setFXYZ(E_MAT_PARAM_DOORWAY, 0.0f, tempf);
												doorMod = 0.0f;

											}
											else {
												matParams.setFXYZ(E_MAT_PARAM_DOOR, 0.0f, tempf);
												doorMod = 0.25f;
											}
											
											curAlign = E_ALIGN_BOTTOM;
											baseOffset = -(rad.getFZ() - (cornerRad.getFZ()+(0.25+doorMod)) ) + tempf*2.0f;
											

											
											floorHeight = 2.0f-doorMod;
											roofHeight = 2.25f-doorMod;
											
											rad.setFXYZ(
												(roofHeight),
												(roofHeight),
												(floorHeight*0.5f + roofHeight + tempf*0.5f)
											);
											cornerRad.setFXYZ(
												(roofHeight),
												(roofHeight),
												roofHeight
											);
											thickVals.setFX(0.25f);	
										
											doorInset = doorMod*1.25f;
											
											
											anchorPoint.averageXYZ(&p1,&p2);
											
											hingeDis = p1.distance(&p2)*0.5f;
											
											switch (n) {
												case 0:
												
													if (conType == E_CT_DOORWAY) {
														curBT = E_CT_DOORWAY;
													}
													else {
														curBT = E_CT_WINDOWFRAME;
													}
												
													cr1 = 0.0f;
													cr2 = 0.0f;
												break;
												
												case 1:
												
													if (conType == E_CT_DOORWAY) {
														curBT = E_CT_DOOR;
													}
													else {
														curBT = E_CT_WINDOW;
													}
												
													
													cr1 = 0.0f;
													cr2 = 1.0f;
													
													if (curDir == E_DIR_Y) {
														anchorPoint.addXYZ(-(rad.getFX()+hingeDis),0.0f,0.0f);
													}
													else {
														anchorPoint.addXYZ(0.0f,-(rad.getFY()+hingeDis),0.0f);
													}
													
													
													if (
														((curDir == E_DIR_Y)&&(nDir==1)) ||
														((curDir == E_DIR_X)&&(nDir==-1))
													) { //(m == 1) || (m == 2) ) {
														minRot = 0;
														maxRot = 1;
													}
													else {
														minRot = -1;
														maxRot = 0;
													}
													
												
													
												break;
												
												case 2:
													
													
													if (conType == E_CT_DOORWAY) {
														curBT = E_CT_DOOR;
													}
													else {
														curBT = E_CT_WINDOW;
													}
													
													cr1 = 1.0f;
													cr2 = 0.0f;
													
													if (curDir == E_DIR_Y) {
														anchorPoint.addXYZ(rad.getFX()+hingeDis,0.0f,0.0f);
													}
													else {
														anchorPoint.addXYZ(0.0f,rad.getFY()+hingeDis,0.0f);
													}
													

													if (
														((curDir == E_DIR_X)&&(nDir==1)) ||
														((curDir == E_DIR_Y)&&(nDir==-1))
													) { //(m == 0) || (m == 3) ) {
														minRot = 0;
														maxRot = 1;
													}
													else {
														minRot = -1;
														maxRot = 0;
													}
													
													
												break;
											}
											
											if (curDir == E_DIR_X) {
												visInsetFromMin.setFXYZ(cornerRad.getFX()+doorInset, cr1*rad.getFY(), cornerRad.getFZ());
												visInsetFromMax.setFXYZ(cornerRad.getFX()+doorInset, cr2*rad.getFY(), 0.0f);
											}
											else {
												visInsetFromMin.setFXYZ(cr1*rad.getFX(), cornerRad.getFY()+doorInset, cornerRad.getFZ());
												visInsetFromMax.setFXYZ(cr2*rad.getFX(), cornerRad.getFY()+doorInset, 0.0f);
											}

											
											
											powerVals.setFX(2.0f);
											powerVals.setFY(2.0f);
											powerVals2.setFX(2.0f);
											powerVals2.setFY(2.0f);
											
											
										
											
											
											
										
											break;
											
										case E_CT_FOUNDATION:

											//testInd = getMapNodeIndex(i, j, 0);
											//testInd2 = getMapNodeIndex(i + dirModX[m], j + dirModY[m], 0);

											visInsetFromMin.setFXYZ(0.0f, 0.0f, roofHeightInCells);
											visInsetFromMax.setFXYZ(0.0f, 0.0f, roofHeightInCells);
											
											
											baseOffset = 0.0f;// -(floorHeightInCells);
											rad.addXYZ(
												0.0f,
												0.0f,
												(floorHeightInCells+1.0f)
											);

											
											rad.addXYZ(
												0.0f,
												0.0f,
												(2.0f)
											);
											
											if (
												singleton->getHeightAtPixelPos(p1.getFX(), p1.getFY()) <=
												singleton->getSeaHeightScaled()  + 2.0f
											) {
												matParams.setFXYZ(E_MAT_PARAM_FOUNDATION, E_MAT_SUBPARAM_DOCK, 0.0f);
											}
											else {
												matParams.setFXYZ(E_MAT_PARAM_FOUNDATION, E_MAT_SUBPARAM_BRICK, 0.0f);
											}

											

											

											break;
										case E_CT_ROOM_BRICK:
											matParams.setFXYZ(E_MAT_PARAM_BUILDING, E_MAT_SUBPARAM_BRICK, 0.0f);
											visInsetFromMin.setFXYZ(0.0f, 0.0f, roofHeightInCells);
											visInsetFromMax.setFXYZ(0.0f, 0.0f, roofHeightInCells);
											break;
										case E_CT_ROOM_TUDOR:

											//rad.addXYZ(-0.5f,-0.5f,0.0f);
											//cornerRad.addXYZ(-0.5f);

											matParams.setFXYZ(E_MAT_PARAM_BUILDING, E_MAT_SUBPARAM_TUDOR, 0.0f);
											visInsetFromMin.setFXYZ(0.0f, 0.0f, roofHeightInCells);
											visInsetFromMax.setFXYZ(0.0f, 0.0f, roofHeightInCells);
											break;

										// case E_CT_WALKWAY:

										// 	matParams.setFXYZ(E_MAT_PARAM_WALKWAY, E_MAT_SUBPARAM_BRICK_ARCH, 0.0f);
										// 	visInsetFromMin.setFXYZ(0.0f, 0.0f, roofHeightInCells);
										// 	visInsetFromMax.setFXYZ(0.0f, 0.0f, roofHeightInCells);

										// 	break;

										// case E_CT_WALKWAY_TOP:
										// 	matParams.setFXYZ(E_MAT_PARAM_WALKWAY_TOP, E_MAT_SUBPARAM_BRICK_ARCH, 0.0f);
										// 	visInsetFromMin.setFXYZ(0.0f, 0.0f, roofHeightInCells);
										// 	visInsetFromMax.setFXYZ(0.0f, 0.0f, (roofHeightInCells + (floorHeightInCells * 0.75)));

										// 	break;

										case E_CT_ROOF:
											baseOffset = -floorHeightInCells;
											matParams.setFXYZ(E_MAT_PARAM_ROOF, E_MAT_SUBPARAM_TUDOR, buildingData[curInd].id);

											if (curDir == E_DIR_Z) {
												visInsetFromMin.setFXYZ(0.0f, 0.0f, (roofHeightInCells + floorHeightInCells * 2.0f));
											} else {
												visInsetFromMin.setFXYZ(0.0f, 0.0f, (roofHeightInCells + floorHeightInCells));
											}
											visInsetFromMax.setFXYZ(0.0f, 0.0f, 0.0f);
											break;

										// case E_CT_STAIRS:

										// 	switch (curDir) {
										// 	case E_DIR_X:
										// 		rad.multXYZ(0.5f, 0.5f, 1.0f);
										// 		cornerRad.multXYZ(0.5f, 0.5f, 1.0f);

										// 		if ((k % 2) == 0) {
										// 			visInsetFromMin.setFXYZ(cornerRad.getFX(), rad.getFY(), roofHeightInCells);
										// 			visInsetFromMax.setFXYZ(cornerRad.getFX(), 0.0f, roofHeightInCells);
										// 		} else {
										// 			visInsetFromMin.setFXYZ(cornerRad.getFX(), 0.0f, roofHeightInCells);
										// 			visInsetFromMax.setFXYZ(cornerRad.getFX(), rad.getFY(), roofHeightInCells);
										// 		}
										// 		break;

										// 	case E_DIR_Y:
										// 		rad.multXYZ(0.5f, 0.5f, 1.0f);
										// 		cornerRad.multXYZ(0.5f, 0.5f, 1.0f);

										// 		if ((k % 2) == 0) {
										// 			visInsetFromMin.setFXYZ(rad.getFX(), cornerRad.getFY(), roofHeightInCells);
										// 			visInsetFromMax.setFXYZ(0.0f, cornerRad.getFY(), roofHeightInCells);
										// 		} else {
										// 			visInsetFromMin.setFXYZ(0.0f, cornerRad.getFY(), roofHeightInCells);
										// 			visInsetFromMax.setFXYZ(rad.getFX(), cornerRad.getFY(), roofHeightInCells);
										// 		}

										// 		break;

										// 	case E_DIR_Z:
										// 		rad.multXYZ(0.75f, 0.75f, 1.0f);
										// 		cornerRad.multXYZ(0.75f, 0.75f, 1.0f);
										// 		visInsetFromMin.setFXYZ(0.0f, 0.0f, roofHeightInCells);
										// 		visInsetFromMax.setFXYZ(0.0f, 0.0f, roofHeightInCells);

										// 		break;
										// 	}

										// 	matParams.setFXYZ(E_MAT_PARAM_STAIRS, E_MAT_SUBPARAM_NONE, (float)(k % 2));
										// 	baseOffset = 1.0f;

										// 	break;

										
									}

									if (curDir != E_DIR_Z) {
										

										switch (conType) {
										case E_CT_ROAD:
										case E_CT_ROOF:
										case E_CT_ROOM_TUDOR:
										case E_CT_ROOM_BRICK:

											// }

											if (curDir == E_DIR_X) {
												if (isWingBeg) {
													visInsetFromMin.setFX(cornerRad.getFX());
												}
												if (isWingEnd) {
													visInsetFromMax.setFX(cornerRad.getFX());
												}
											}
											if (curDir == E_DIR_Y) {
												if (isWingBeg) {
													visInsetFromMin.setFY(cornerRad.getFY());
												}
												if (isWingEnd) {
													visInsetFromMax.setFY(cornerRad.getFY());
												}
											}


											break;
										}
									}


									addNewGeom(
										curBT,
										curAlign,
										baseOffset,
										&p1,
										&p2,
										&rad,
										&cornerRad,
										&visInsetFromMin,
										&visInsetFromMax,
										&powerVals,
										&powerVals2,
										&thickVals,
										&matParams,
										&anchorPoint,
										minRot,
										maxRot
									);
									
SKIP_ADD_GEOM:
									
									;

								}

							}
						}


					}


				}
			}
		}



	}
int GameBlock::getNodeIndexClamped (int _x, int _y, int _z)
                                                        {

	
			int x = clamp(_x,0,terDataBufPitchXY-1);
			int y = clamp(_y,0,terDataBufPitchXY-1);
			int z = clamp(_z,0,terDataBufPitchZ-1);
		
			return x + y * terDataBufPitchXY + z * terDataBufPitchXY * terDataBufPitchXY;
		
	}
int GameBlock::getNodeIndex (int x, int y, int z, int bufAmount)
                                                             {

		if (
			(x < bufAmount) ||
			(y < bufAmount) ||
			(z < bufAmount) ||
			(x >= terDataBufPitchXY - bufAmount) ||
			(y >= terDataBufPitchXY - bufAmount) ||
			(z >= terDataBufPitchZ - bufAmount)
		) {
			return -1;
		} else {
			return x + y * terDataBufPitchXY + z * terDataBufPitchXY * terDataBufPitchXY;
		}
	}
int GameBlock::touchesPlanarBN (int x, int y, int z, int buildingType, int bufAmount)
                                                                                  {
		int i;
		int tot = 0;
		int ind;

		ind = getNodeIndex(x, y, z, bufAmount);

		if (ind > -1) {
			for (i = 0; i < 4; i++) {
				if (buildingData[ind].con[i].conType == buildingType) {
					tot++;
				}
			}
		}

		return tot;
	}
int GameBlock::touchesPlanarClass (int x, int y, int z, int classType, int bufAmount)
                                                                                  {
		int i;
		int j;
		int tot = 0;
		int ind;

		ind = getNodeIndex(x, y, z, bufAmount);

		if (ind > -1) {
			for (i = 0; i < 4; i++) {
				
				for (j = 0; j < MAX_NODE_VALS; j++) {
					if (ctClasses[buildingData[ind].con[i+j*MAX_NODE_DIRS].conType] == classType) {
						tot++;
					}
				}
				
				
			}
		}

		return tot;
	}
int GameBlock::touchesPlanarClass2 (int x, int y, int z, int classType, int bufAmount)
                                                                                   {
		int i;
		int tot = 0;
		int testX;
		int testY;

		for (i = 0; i < 4; i++) {

			testX = x + dirModX[i];
			testY = y + dirModY[i];

			tot += touchesPlanarClass(testX, testY, z, classType, bufAmount);

		}

		return tot;

	}
bool GameBlock::isLCorner (int x, int y, int z, int classType, bool includeSingle)
                                                                               {
		int i;
		int tot = 0;
		int ind;
		

		ind = getNodeIndex(x, y, z, 0);

		if (ind > -1) {
			for (i = 0; i < 4; i++) {
				if ( ctClasses[buildingData[ind].con[i].conType] == classType) {
					tot++;
				}
			}
			
			if ((tot == 1)&&includeSingle) {
				return true;
			}
			
			if (tot == 2) {
				tot = 0;
				for (i = 0; i < 2; i++) {
					if (ctClasses[buildingData[ind].con[i].conType] == classType) {
						tot++;
					}
				}
				
				if (tot == 1) {
					return true;
				}
				
			}
			
		}
		
		

		return false;
	}
void GameBlock::applyWingValues (int _x1, int _y1, int _z1, int _x2, int _y2, int _z2, int cnum, bool isWingBeg, bool isWingEnd, float multiplier)
          {


		// 0: x+
		// 1: x-
		// 2: y+
		// 3: y-
		// 4: z+
		// 5: z-

		int x1 = _x1;
		int y1 = _y1;
		int x2 = _x2;
		int y2 = _y2;
		int z1 = _z1;
		int z2 = _z2;

		if (x1 > x2) {
			std::swap(x1, x2);
		}
		if (y1 > y2) {
			std::swap(y1, y2);
		}
		if (z1 > z2) {
			std::swap(z1, z2);
		}

		int baseDir = 0;

		int ind1 = getNodeIndex(x1, y1, z1, 0);
		int ind2 = getNodeIndex(x2, y2, z2, 0);
		
		int finalInd1;
		int finalInd2;
		
		uint tempFlags;

		if ((ind1 < 0) || (ind2 < 0)) {
			// invalid connection
		} else {

			if ((x1 == x2) && (y1 == y2)) {
				// up/down connection
				baseDir = 4;
			} else {
				if (x1 == x2) {
					// north/south connection
					baseDir = 2;
				}
				if (y1 == y2) {
					// east/west connection
					baseDir = 0;
				}
			}

			finalInd1 = baseDir + cnum * MAX_NODE_DIRS;
			finalInd2 = baseDir + 1 + cnum * MAX_NODE_DIRS;
			
			
			
			// WAS DOING: MAKE SURE TO SET FLAGS EXPLICITLY, NO OR "|" operator
			
			
			tempFlags = 0;
			if (isWingBeg) {
				tempFlags |= BC_FLAG_WING_BEG;
			}
			if (isWingEnd) {
				tempFlags |= BC_FLAG_WING_END;
			}
			
			buildingData[ind1].con[finalInd1].nodeFlags &= ~(BC_FLAG_WING_BEG|BC_FLAG_WING_END);
			buildingData[ind2].con[finalInd2].nodeFlags &= ~(BC_FLAG_WING_BEG|BC_FLAG_WING_END);
			
			buildingData[ind1].con[finalInd1].nodeFlags |= tempFlags;
			buildingData[ind1].con[finalInd1].wingMult = multiplier;

			tempFlags = 0;
			if (isWingEnd) {
				tempFlags |= BC_FLAG_WING_BEG;
			}
			if (isWingBeg) {
				tempFlags |= BC_FLAG_WING_END;
			}

			buildingData[ind2].con[finalInd2].nodeFlags |= tempFlags;
			//buildingData[ind2].con[finalInd2].wingMult = 2.0f-multiplier;
			
			

		}
	}
void GameBlock::addPlantNodes (GamePlantNode * curPlantNode, FIVector4 * orig, float scale)
                                                                                       {
		int i;

		float begThickness;
		float endThickness;

		if (curPlantNode->parent == NULL) {

		}
		else {

			if (curPlantNode->parent->parent == NULL) {
				tempVec.setFXYZ(0.0f,0.0f,0.0f); //Ref(&(curPlantNode->parent->begPoint));

				begThickness = curPlantNode->midThickness;
				endThickness = curPlantNode->midThickness;

			}
			else {
				tempVec.averageXYZ(
					&(curPlantNode->parent->begPoint),
					&(curPlantNode->parent->endPoint)
				);

				begThickness = curPlantNode->parent->midThickness;
				endThickness = curPlantNode->midThickness;
			}

			
			
			tempVec2.averageXYZ(
				&(curPlantNode->begPoint),
				&(curPlantNode->endPoint)
			);
			
			tempVec3.setFXYZRef(&(curPlantNode->begPoint));

			tempVec.multXYZ(scale);
			tempVec2.multXYZ(scale);
			tempVec3.multXYZ(scale);

			tempVec.addXYZRef(orig);
			tempVec2.addXYZRef(orig);
			tempVec3.addXYZRef(orig);

			gameEnts[E_ET_GEOM].data.push_back(baseEnt);
			gameEnts[E_ET_GEOM].data.back().initTree(
				
				E_CT_TREE,
				
				&tempVec,
				&tempVec2,
				&tempVec3,

				begThickness*scale,//curPlantNode->begThickness,
				endThickness*scale,//curPlantNode->endThickness,	
				curPlantNode->sphereRad, // *scale,			
										
				&matParams
			);
		}

		

		for (i = 0; i < curPlantNode->numChildren; i++) {
			addPlantNodes( &(curPlantNode->children[i]), orig, scale);
		}
	}
void GameBlock::addNewGeom (int _curBT, int _curAlign, float _baseOffset, FIVector4 * _p1, FIVector4 * _p2, FIVector4 * _rad, FIVector4 * _cornerRad, FIVector4 * _visInsetFromMin, FIVector4 * _visInsetFromMax, FIVector4 * _powerVals, FIVector4 * _powerVals2, FIVector4 * _thickVals, FIVector4 * _matParams, FIVector4 * _anchorPoint, int _minRot, int _maxRot)
          {
		
		
		
		
		
		gameEnts[E_ET_GEOM].data.push_back(baseEnt);
		gameEnts[E_ET_GEOM].data.back().initBounds(
			_curBT,
			_curAlign,
			_baseOffset,
			_p1,
			_p2,
			_rad,
			_cornerRad,
			_visInsetFromMin,
			_visInsetFromMax,
			_powerVals,
			_powerVals2,
			_thickVals,
			_matParams,
			_anchorPoint,
			_minRot,
			_maxRot
		);
		
		if (_curBT == E_CT_LANTERN) {
			lightVec.setFXYZ(1.0f,0.5f,0.1f);
			
			gameEnts[E_ET_LIGHT].data.push_back(baseEnt);
			gameEnts[E_ET_LIGHT].data.back().initLight(
				_p1,
				&lightVec,
				16.0f
			);
			gameEnts[E_ET_LIGHT].data.back().toggled = true;
			gameEnts[E_ET_GEOM].data.back().light = &(gameEnts[E_ET_LIGHT].data.back());
		}
		
		
		
	}
void GameBlock::connectNodes (int _x1, int _y1, int _z1, int _x2, int _y2, int _z2, int ct, int id, int _heightDelta, int _direction, float _wallRadInCells, unsigned int _nodeFlags)
          {


		// 0: x+
		// 1: x-
		// 2: y+
		// 3: y-
		// 4: z+
		// 5: z-

		float wallRad = _wallRadInCells;
		if (wallRad == -1.0f) {
			wallRad = singleton->wallRadInCells;
		}

		int x1 = _x1;
		int y1 = _y1;
		int x2 = _x2;
		int y2 = _y2;
		int z1 = _z1;
		int z2 = _z2;

		if (x1 > x2) {
			std::swap(x1, x2);
		}
		if (y1 > y2) {
			std::swap(y1, y2);
		}
		if (z1 > z2) {
			std::swap(z1, z2);
		}

		int ind1 = getNodeIndex(x1, y1, z1, 0);
		int ind2 = getNodeIndex(x2, y2, z2+_heightDelta, 0);
		int baseDir = 0;
		
		int resInd1;
		int resInd2;
		
		int cnum = layerHash[ct];

		if ((ind1 < 0) || (ind2 < 0)) {
			// invalid connection
		} else {

			if (id >= 0) {
				buildingData[ind1].id = id;
				buildingData[ind2].id = id;
			}


			if ((x1 == x2) && (y1 == y2)) {
				// up/down connection
				baseDir = 4;
			} else {
				if (x1 == x2) {
					// north/south connection
					baseDir = 2;
				}
				if (y1 == y2) {
					// east/west connection
					baseDir = 0;
				}
			}

			

			resInd1 = baseDir + cnum * MAX_NODE_DIRS;
			resInd2 = baseDir + 1 + cnum * MAX_NODE_DIRS;

			buildingData[ind1].con[resInd1].conType = ct;
			buildingData[ind2].con[resInd2].conType = ct;
			buildingData[ind1].con[resInd1].heightDelta = _heightDelta;
			buildingData[ind2].con[resInd2].heightDelta = -_heightDelta;
			buildingData[ind1].con[resInd1].direction = _direction;
			buildingData[ind2].con[resInd2].direction = -_direction;
			
			buildingData[ind1].con[resInd1].nodeFlags |= _nodeFlags;
			buildingData[ind2].con[resInd2].nodeFlags |= _nodeFlags;
			
			buildingData[ind1].con[resInd1].wallRadInCells = wallRad;
			buildingData[ind2].con[resInd2].wallRadInCells = wallRad;
			
			
		}
	}
int GameBlock::getMapNodeIndex (int x, int y, int bufAmount)
                                                         {

		if (
			(x < bufAmount) ||
			(y < bufAmount) ||
			(x >= terDataBufPitchXY - bufAmount) ||
			(y >= terDataBufPitchXY - bufAmount)
		) {
			return -1;
		} else {
			return x + y * terDataBufPitchXY;
		}

	}
int GameBlock::touchesMap (int x, int y, int buildingType, int bufAmount)
                                                                      {
		int i;
		int tot = 0;

		int ind;

		ind = getMapNodeIndex(x, y, bufAmount);
		if (ind > -1) {
			for (i = 0; i < 4; i++) {
				if (mapData[ind].connectionProps[i] == buildingType) {
					tot++;
				}
			}
		}

		return tot;
	}
int GameBlock::touchesWithinRadMap (int x, int y, int buildingType, int rad, int bufAmount)
                                                                                        {
		int i;
		int j;
		
		int tot = 0;
		int testX;
		int testY;
		

		for (i = -rad; i <= rad; i++) {
			for (j = -rad; j <= rad; j++) {
				testX = x + i;
				testY = y + j;

				tot += touchesMap(testX, testY, buildingType, bufAmount);
			}
		}

		return tot;

	}
int GameBlock::touches2Map (int x, int y, int buildingType, int bufAmount)
                                                                       {
		int i;
		int tot = 0;
		int testX;
		int testY;

		for (i = 0; i < 4; i++) {

			testX = x + dirModX[i];
			testY = y + dirModY[i];

			tot += touchesMap(testX, testY, buildingType, bufAmount);

		}

		return tot;

	}
void GameBlock::connectMapNodes (int _x1, int _y1, int _x2, int _y2, int buildingType, int id, int bufAmount)
                                                                                                          {


		// 0: x+
		// 1: x-
		// 2: y+
		// 3: y-

		int x1 = _x1;
		int y1 = _y1;
		int x2 = _x2;
		int y2 = _y2;

		int boff = 0;

		int i;

		int ind1;
		int ind2;

		if (x1 > x2) {
			std::swap(x1, x2);
		}
		if (y1 > y2) {
			std::swap(y1, y2);
		}

		int n[2];


		n[0] = getMapNodeIndex(x1, y1, bufAmount);
		n[1] = getMapNodeIndex(x2, y2, bufAmount);

		if (
			(n[0] < 0) ||
			(n[1] < 0)
		) {
			
		} else {

			if (id >= 0) {
				mapData[n[0]].id = id;
				mapData[n[1]].id = id;
			}

			if (x1 == x2) { // is vertical
				boff = 2;
			} else {
				boff = 0;
			}

			for (i = 0; i < 2; i++) {
				mapData[n[i]].connectionProps[i + boff] = buildingType;
			}

		}


	}
int GameBlock::getAdjustedHeightInHolders (int xInHolders, int yInHolders)
                                                                       {

		float cellsPerHolder = singleton->cellsPerHolder;

		tempVec.setFXYZ(xInHolders*cellsPerHolder, yInHolders*cellsPerHolder, 0.0f);

		tempVec.addXYZ(
			-fCellsPerBlock * offsetInBlocks.getFX(),
			-fCellsPerBlock * offsetInBlocks.getFY(),
			0.0f
		);

		tempVec.multXYZ(
			fTerDataVisPitchXY / fCellsPerBlock,
			fTerDataVisPitchXY / fCellsPerBlock,
			fTerDataVisPitchZ / fCellsPerBlock
		);
		tempVec.addXYZ((float)terDataBufAmount);

		tempVec.addXYZ(0.5f);


		
		int ind = getMapNodeIndex(tempVec.getIX(), tempVec.getIY(), 0);
		int res = 0;
		float fres = 0.0f;

		if (ind > -1) {
			fres = ((float)(mapData[ind].terHeight))/fTerDataVisPitchZ; //adjustedHeight
			
			res = fres*singleton->holdersPerWorld;
			
		} else {
			res = 0;
		}
		
		return res;

	}
float GameBlock::fIsNearTerrain (FIVector4 * worldMinVisInPixels)
          {

		int ind;
		int ind2;
		
		int i;
		int j;
		int k;
		
		tempVec.copyFrom(worldMinVisInPixels);

		tempVec.addXYZ(
			-fCellsPerBlock * offsetInBlocks.getFX(),
			-fCellsPerBlock * offsetInBlocks.getFY(),
			0.0f
		);

		tempVec.multXYZ(
			fTerDataVisPitchXY / fCellsPerBlock,
			fTerDataVisPitchXY / fCellsPerBlock,
			fTerDataVisPitchZ / fCellsPerBlock
		);
		tempVec.addXYZ((float)terDataBufAmount);

		for (i = 0; i <= 1; i++) {
			for (j = 0; j <= 1; j++) {
				for (k = 0; k <= 1; k++) {
					ind = getNodeIndexClamped(
						tempVec.getIX() + i,
						tempVec.getIY() + j,
						tempVec.getIZ() + k
					);
					ind2 = k*4 + j*2 + i;
					if (terData[ind] > 0) {
						trilin[ind2] = 1.0f;
					}
					else {
						trilin[ind2] = 0.0f;
					}
				}
				
			}
		}
		
		// 0 1
		// 2 3
		
		// 4 5
		// 6 7

		float lerpX = tempVec.getFX() - tempVec.getIX();
		float lerpY = tempVec.getFY() - tempVec.getIY();
		float lerpZ = tempVec.getFZ() - tempVec.getIZ();
		float ilerpX = 1.0f - lerpX;
		float ilerpY = 1.0f - lerpY;
		float ilerpZ = 1.0f - lerpZ;
		
		trilin[0] = trilin[0]*ilerpX + trilin[1]*lerpX;
		trilin[2] = trilin[2]*ilerpX + trilin[3]*lerpX;
		trilin[4] = trilin[4]*ilerpX + trilin[5]*lerpX;
		trilin[6] = trilin[6]*ilerpX + trilin[7]*lerpX;
		
		trilin[0] = trilin[0]*ilerpY + trilin[2]*lerpY;
		trilin[4] = trilin[4]*ilerpY + trilin[6]*lerpY;
		
		trilin[0] = trilin[0]*ilerpZ + trilin[4]*lerpZ;

		return trilin[0];
	}
void GameBlock::modifyTerrain (FIVector4 * worldPos, bool doSub)
          {

		int ind;
		int curInd;
		int testInd;
		int i;
		int j;
		int k;
		int n;
		
		int io;
		int jo;
		int ko;
		
		uint newValue = 255;
		if (doSub) {
			newValue = 0;
		}
		
		
		tempVec.copyFrom(worldPos);
		

		tempVec.addXYZ(
			-fCellsPerBlock * offsetInBlocks.getFX(),
			-fCellsPerBlock * offsetInBlocks.getFY(),
			0.0f
		);

		tempVec.multXYZ(
			fTerDataVisPitchXY / fCellsPerBlock,
			fTerDataVisPitchXY / fCellsPerBlock,
			fTerDataVisPitchZ / fCellsPerBlock
		);
		tempVec.addXYZ((float)terDataBufAmount);

		//tempVec.addXYZ(0.5f);
		
		
		
		i = tempVec.getIX();
		j = tempVec.getIY();
		k = tempVec.getIZ();
		
		float xm = tempVec.getFX() - tempVec.getIX();
		float ym = tempVec.getFY() - tempVec.getIY();
		float zm = tempVec.getFZ() - tempVec.getIZ();
		
		
		if ((xm >= ym) && (xm >= zm)) {
			n = 0;
		}
		if ((ym >= xm) && (ym >= zm)) {
			n = 1;
		}
		if ((zm >= xm) && (zm >= ym)) {
			n = 2;
		}
		
		
		int counterMod = 1;
		
		if (doSub) {
			counterMod = -1;
		}
		
		int counterK = 0;
		while (true) {
			
			
			
			switch(n) {
				case 0:
					i = tempVec.getIX()+counterK*counterMod;
					j = tempVec.getIY();
					k = tempVec.getIZ();
				break;
				case 1:
					i = tempVec.getIX();
					j = tempVec.getIY()+counterK*counterMod;
					k = tempVec.getIZ();
				break;
				case 2:
					i = tempVec.getIX();
					j = tempVec.getIY();
					k = tempVec.getIZ()+counterK*counterMod;
				break;
			}
			
			
			ind = getNodeIndex(i, j, k, 0);
			if (ind > -1) {
				if ( (!doSub) && (terData[ind] == 0) ) {
					// found a place to add
					goto FOUND_ADD_SUB;
				}
				
				if ( (doSub) && (terData[ind] != 0) ) {
					// found a place to sub
					goto FOUND_ADD_SUB;
				}
			}
			else {				
				return;
			}
			
			
			
			counterK++;
		}
		
		
		FOUND_ADD_SUB:
		
		
		
		
		terData[ind] = (newValue << 24) | (newValue << 16) | (newValue << 8) | newValue;

		
		
		
		int rad2 = 3;
		int rad = 2;
		
		
		
		for (i = -rad2; i <= rad2; i++) {
			for (j = -rad2; j <= rad2; j++) {
				for (k = -rad2; k <= rad2; k++) {
					curInd = getNodeIndex(i, j, k, 0);

					if (curInd > -1) {
						buildingData[curInd].nearAir = false;
						buildingData[curInd].nearTerrain = false;
					}
					
				}
			}
		}
		
		for (i = -rad2; i <= rad2; i++) {
			for (j = -rad2; j <= rad2; j++) {
				for (k = -rad2; k <= rad2; k++) {
					curInd = getNodeIndex(i, j, k, 0);

					

					if (curInd > -1) {
						
						for (ko = -rad; ko <= rad; ko++) {
							for (jo = -rad; jo <= rad; jo++) {
								for (io = -rad; io <= rad; io++) {
									testInd = getNodeIndex(i + io, j + jo, k + ko, 0);

									if (testInd > -1) {
										if (terData[testInd] == 0) {
											buildingData[curInd].nearAir = true;
										}
										else {
											buildingData[curInd].nearTerrain = true;
										}
									}
								}
							}
						}
					}
					
				}
			}
		}
		
		forceUpdate = true;

		//copyTerToTexture(true);
		

	}
int GameBlock::isNearTerrain (FIVector4 * worldPosInPix)
                                                    {

		int ind;
		
		int i;
		int j;
		int k;
		
		tempVec.copyFrom(worldPosInPix);
		tempVec.addXYZ(
			-fCellsPerBlock * offsetInBlocks.getFX(),
			-fCellsPerBlock * offsetInBlocks.getFY(),
			0.0f
		);

		tempVec.multXYZ(
			fTerDataVisPitchXY / fCellsPerBlock,
			fTerDataVisPitchXY / fCellsPerBlock,
			fTerDataVisPitchZ / fCellsPerBlock
		);
		tempVec.addXYZ((float)terDataBufAmount);

		tempVec.addXYZ(0.5f);

		bool nearT = false;
		bool nearA = false;

		
		i = tempVec.getIX();
		j = tempVec.getIY();
		k = tempVec.getIZ();
		ind = getNodeIndex(i, j, k, 0);
		if (ind > -1) {
			nearT = buildingData[ind].nearTerrain;
			nearA = buildingData[ind].nearAir;
		}

		if (nearT) {
			if (nearA) {
				return E_TER_GROUNDLEVEL;
			}
			else {
				return E_TER_UNDERGROUND;
			}
		}
		
		return E_TER_AIR;

	}
int GameBlock::findNearestNode (FIVector4 * worldPositionInPixelsIn, FIVector4 * posInNodesOut, FIVector4 * posInPixelsOut)
                                                                                                                      {

		int i;
		int j;
		int k;
		int m;
		int curInd;
		int offset;
		int bestInd = -1;
		
		float zBias = floorHeightInCells*0.5f;

		bool notFound = true;
		
		
		tempVec.copyFrom(worldPositionInPixelsIn);
		tempVec.addXYZ(
			-fCellsPerBlock * offsetInBlocks.getFX(),
			-fCellsPerBlock * offsetInBlocks.getFY(),
			zBias
		);

		tempVec.multXYZ(
			fTerDataVisPitchXY / fCellsPerBlock,
			fTerDataVisPitchXY / fCellsPerBlock,
			fTerDataVisPitchZ / fCellsPerBlock
		);
		tempVec.addXYZ((float)terDataBufAmount);

		
		i = tempVec.getIX();
		j = tempVec.getIY();
		k = tempVec.getIZ();
		
		
		for (m = 0; m < 3; m++) {
			switch (m) {
				case 0:
					offset = 0;
				break;
				case 1:
					offset = -1;
				break;
				case 2:
					offset = 1;
				break;
			}
			
			curInd = getNodeIndex(i,j,k+offset,0);
			
			if (curInd > -1) {
				if (touchesPlanarClass(i,j,k+offset,E_CTC_ROAD,0)) {
					bestInd = curInd;
					break;
				}
			}
		}
		
		
		
		
		if (bestInd > -1) {
			posInNodesOut->setIXYZ(
				i + offsetInBlocks.getIX()*terDataVisPitchXY - terDataBufAmount,
				j + offsetInBlocks.getIY()*terDataVisPitchXY - terDataBufAmount,
				k + offset - terDataBufAmount
			);
			nodeIndexToWorldSpaceInPixels(bestInd,posInPixelsOut);
		}
		
		
		return bestInd;

	}
void GameBlock::nodeIndexToWorldSpaceInPixels (int ind, FIVector4 * posInPixelsOut)
                                                                                {


		int k = ind / (terDataBufPitchXY * terDataBufPitchXY);
		int j = (ind - k * terDataBufPitchXY * terDataBufPitchXY) / terDataBufPitchXY;
		int i = ind - (k * terDataBufPitchXY * terDataBufPitchXY + j * terDataBufPitchXY);
				
		posInPixelsOut->setFXYZ(
			cellsPerBlock * offsetInBlocks.getIX() + ( ((float)(i - terDataBufAmount) + 0.5f) * fCellsPerBlock) / fTerDataVisPitchXY,
			cellsPerBlock * offsetInBlocks.getIY() + ( ((float)(j - terDataBufAmount) + 0.5f) * fCellsPerBlock) / fTerDataVisPitchXY,
			0 + ( ((float)(k - terDataBufAmount) + 0.5f) * fCellsPerBlock) / fTerDataVisPitchZ
		);

	}
bool GameBlock::hasTerrainBelow (int i, int j, int k, int conDir, bool bothEnds)
                                                                             {
		bool foundA = false;
		bool foundB = false;

		int testInd = getNodeIndex(i, j, k - 1, 0);
		int testInd2 = getNodeIndex(i + dirModX[conDir], j + dirModY[conDir], k + dirModZ[conDir] - 1, 0);


		if (conDir < 4) {
			if (testInd > -1) {
				if (terData[testInd] != 0) {
					foundA = true;
				}
			}

			if (testInd2 > -1) {
				if (terData[testInd2] != 0) {
					foundB = true;
				}
			}

		} else {
			if (testInd > -1) {
				if (
					(terData[testInd] != 0)
				) {
					foundA = true;
					foundB = true;
				}
			}
		}

		if (bothEnds) {
			return foundA && foundB;
		} else {
			return foundA || foundB;
		}
	}
bool GameBlock::hasRoomBelow (int i, int j, int k, int conDir)
                                                           {

		int testInd = getNodeIndex(i, j, k - 1, 0);
		int p;

		if (testInd > -1) {
			if (isRoom[buildingData[testInd].con[conDir].conType]) {
				return true;
			}

			if (conDir >= 4) {
				for (p = 0; p < 4; p++) {
					if (isRoom[buildingData[testInd].con[p].conType]) {
						return true;
					}
				}
			}
		}

		return false;
	}
bool GameBlock::isSupportedBelow (int i, int j, int k, int conDir, bool bothEnds)
                                                                              {

		bool foundA = false;
		bool foundB = false;

		int testInd = getNodeIndex(i, j, k - 1, 0);
		int testInd2 = getNodeIndex(i + dirModX[conDir], j + dirModY[conDir], k + dirModZ[conDir] - 1, 0);

		int p;

		if (conDir < 4) {
			if (testInd > -1) {
				if (terData[testInd] != 0) {
					foundA = true;
				}

				for (p = 0; p < 5; p++) {
					if (isRoom[buildingData[testInd].con[p].conType]) {
						foundA = true;
					}
				}

			}

			if (testInd2 > -1) {
				if (terData[testInd2] != 0) {
					foundB = true;
				}

				for (p = 0; p < 5; p++) {
					if (isRoom[buildingData[testInd2].con[p].conType]) {
						foundB = true;
					}
				}

			}

		} else {
			if (testInd > -1) {
				if (
					(terData[testInd] != 0)
				) {
					foundA = true;
					foundB = true;
				}



				for (p = 0; p < 5; p++) {
					if (isRoom[buildingData[testInd].con[p].conType]) {
						foundA = true;
						foundB = true;
					}
				}


			}
		}

		if (bothEnds) {
			return foundA && foundB;
		} else {
			return foundA || foundB;
		}


	}
bool GameBlock::touchesRoomOnLevel (int i, int j, int k)
                                                     {

		int testInd = getNodeIndex(i, j, k, 0);
		int p;

		if (testInd > -1) {
			for (p = 0; p < 4; p++) {
				if (isRoom[buildingData[testInd].con[p].conType]) {
					return true;
				}
			}
		}

		return false;
	}
bool GameBlock::touchesBaseOnLevel (int i, int j, int k, int layer)
                                                                {

		int testInd;
		int p;
		int m;
		int conType;

		//for (m = 0; m < 2; m++) {}
		
		m = 0;
		
		testInd = getNodeIndex(i, j, k+m, 0);
		if (testInd > -1) {
			for (p = 0; p < 4; p++) {
				conType = buildingData[testInd].con[p+layer*MAX_NODE_DIRS].conType;
				
				if (conType == E_CT_FOUNDATION) {
					return true;
				}
				
				
				// if (m == 0) {
				// 	if (
				// 		isBase[conType]
				// 		&& (!isRoad[conType])
				// 	) {
				// 		return true;
				// 	}
				// }
				// else {
				// 	if (isRoad[conType]) {
				// 		return true;
				// 	}
				// }
				
				
			}
		}

		
		
		
		return false;
	}
bool GameBlock::buildingAbove (int x, int y, int z)
                                                {

		int newInd = getNodeIndex(x, y, z, 0);
		int i;
		int testConType;

		if (newInd > -1) {
			for (i = 0; i < 5; i++) { // skip downwards direction
				testConType = buildingData[newInd].con[i].conType;
				if (isRoom[testConType]) {
					return true;
				}
			}
		}

		return false;
	}
void GameBlock::makeMazeUG ()
                                  {

			//cout << "q\n";

			int i;
			int rbInd = 0;
			int curInd = 0;
			int startDir = 0;
			int count = 0;

			int testX = 0;
			int testY = 0;
			int testZ = 0;

			int curX = 0;
			int curY = 0;
			int curZ = 0;
			
			int ind1;
			int ind2;

			int testInd = 0;
			int bestInd = 0;
			int bestDir = 0;
			int curDir = 0;
			int blockOffset = offsetInBlocks.getIX() + offsetInBlocks.getIY();

			int ct;

			bool isOddX, isOddY, isOddZ;
			bool doProc;

			int divSize = 4;
			int tunnelCount = 0;

			rbInd = 0;
			


			//ind1 = getMapNodeIndex(terDataBufSize/2,terDataBufSize/2, 0);
			
			singleton->rbStack[0] = getNodeIndex(
				terDataBufPitchXY/2,
				terDataBufPitchXY/2,
				terDataBufPitchZ/2,
				0
			);


			while (rbInd > -1) {



				curInd = singleton->rbStack[rbInd];
				buildingData[curInd].visited = 1;
				buildingData[curInd].mazeIndex = rbInd;

				curZ = curInd / (terDataBufPitchXY * terDataBufPitchXY);
				curY = (curInd - curZ * terDataBufPitchXY * terDataBufPitchXY) / terDataBufPitchXY;
				curX = curInd - (curZ * terDataBufPitchXY * terDataBufPitchXY + curY * terDataBufPitchXY);

				startDir = rbInd * 37 + blockOffset;
				count = 0;

				isOddX = ((curX + terDataBufAmount) % divSize) != 0;
				isOddY = ((curY + terDataBufAmount) % divSize) != 0;
				isOddZ = ((curZ + terDataBufAmount) % divSize) != 0;

				do {

					curDir = (startDir + count) % 6;

					testX = curX + dirModX[curDir];
					testY = curY + dirModY[curDir];
					testZ = curZ + dirModZ[curDir];

					testInd = getNodeIndex(testX, testY, testZ, 0);



					if (testInd >= 0) {
						
						//cout << "b\n";

						if ( true ) { // terData[testInd] != 0
							if ( buildingData[testInd].visited == 0 ) {

								

								doProc = false;

								if (isOddX) {
									if (curDir <= 1) {
										doProc = true;
									}
								}
								else {
									if (isOddY) {
										if ((curDir == 2) || (curDir == 3)) {
											doProc = true;
										}
									}
									else {
										if (isOddZ) {
											if (curDir >= 4) {
												doProc = true;
											}
										}
										else {
											doProc = true;
										}
									}
								}
								if (doProc) {
									//not visited, proceed

									

									bestDir = curDir;
									bestInd = testInd;
									goto DONE_SEARCHING;
								}



							}
						}


					}



					count++;


				} while (count < 6);

	DONE_SEARCHING:

				if (count >= 6) { // dead end, back up
					rbInd--;
				} else {

					//ct = E_CT_CONNECTED;//iGenRand(E_CT_ROAD,E_CT_ROOM_TUDOR);
					//connectNodes( curX, curY, curZ, testX, testY, testZ, E_CT_CONNECTED);
					
					//cout << "a\n";
					
					ind1 = getNodeIndex(curX,curY,curZ, 0);
					ind2 = getNodeIndex(testX,testY,testZ, 0);
					
					if (ind1 > -1) {
						terData[ind1] = 0;
					}
					if (ind2 > -1) {
						terData[ind2] = 0;
					}

					rbInd++;

					


					singleton->rbStack[rbInd] = bestInd;
					
					
					tunnelCount++;
					
					if (tunnelCount >= terDataBufSize/16) {
						return;
					}
					
				}



			}

		}
#undef LZZ_INLINE
 
// f00355_volumewrapper.h
//

#include "f00355_volumewrapper.e"
#define LZZ_INLINE inline
VolumeWrapper::VolumeWrapper ()
                        {
		isReady = false;
	}
void VolumeWrapper::init (int z, GLenum clampMethod, bool _isFloat, int filterType)
                                                                            {
		
		int tx = 0;
		int ty = 0;
		
		switch (z) {
			case 16:
				tx = 64;
				ty = 64;
			break;
			case 32:
				tx = 256;
				ty = 128;
			break;
			case 64:
				tx = 512;
				ty = 512;
			break;
			case 128:
				tx = 2048;
				ty = 1024;
			break;
			case 256:
				tx = 4096;
				ty = 4096;
			break;
			default:
				cout << "Invalid VolumeWrapper dim\n";
			break;
		}
		
		int x = tx;
		int y = ty;
		
		
		isFloat = _isFloat;
		
		
		terGenDim.setFXYZ(x,y,z); //4096.0f,4096.0f,256.0f
		
		glGenTextures(1, &(volId));
		
		glBindTexture(GL_TEXTURE_3D, volId);
		
		if (isFloat) {
			glTexImage3D(
				GL_TEXTURE_3D,
				0,
				GL_RGBA32F, //GL_RGBA, // GL_RGBA32F
				z,
				z,
				z,
				0,
				GL_RGBA,
				GL_FLOAT, // GL_UNSIGNED_BYTE, // GL_FLOAT
				0
			);
		}
		else {
			glTexImage3D(
				GL_TEXTURE_3D,
				0,
				GL_RGBA, //GL_RGBA, // GL_RGBA32F
				z,
				z,
				z,
				0,
				GL_RGBA,
				GL_UNSIGNED_BYTE, // GL_UNSIGNED_BYTE, // GL_FLOAT
				0
			);
		}
		
		
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MIN_FILTER, filterType);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_MAG_FILTER, filterType);
		//glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_BORDER_COLOR, 0); // causes crash on getError()?
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_S, clampMethod);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_T, clampMethod);
		glTexParameteri(GL_TEXTURE_3D, GL_TEXTURE_WRAP_R, clampMethod);
		glBindTexture(GL_TEXTURE_3D, 0);
		
		if (isFloat) {
			fboSet.init(1, tx, ty, 4, false);
		}
		else {
			fboSet.init(1, tx, ty, 1, false);
		}
		
		isReady = true;
		
	}
void VolumeWrapper::copyFloatArr (float * floatArr)
                                           {
		glBindTexture(GL_TEXTURE_3D, volId);
		glTexSubImage3D(
			GL_TEXTURE_3D,
			0,

			0,
			0,
			0,

			terGenDim[2],
			terGenDim[2],
			terGenDim[2],

			GL_RGBA,
			GL_FLOAT, //GL_UNSIGNED_BYTE,

			floatArr
		);
		glBindTexture(GL_TEXTURE_3D, 0);
	}
void VolumeWrapper::copyCharArr (unsigned char * charArr)
                                                 {
		glBindTexture(GL_TEXTURE_3D, volId);
		glTexSubImage3D(
			GL_TEXTURE_3D,
			0,

			0,
			0,
			0,

			terGenDim[2],
			terGenDim[2],
			terGenDim[2],

			GL_RGBA,
			GL_UNSIGNED_BYTE, //GL_UNSIGNED_BYTE,

			charArr
		);
		glBindTexture(GL_TEXTURE_3D, 0);
	}
#undef LZZ_INLINE
 
// f00360_threadpoolwrapper.h
//

#include "f00360_threadpoolwrapper.e"
#define LZZ_INLINE inline
ThreadPoolWrapper::ThreadPoolWrapper ()
                            {
		
	}
void ThreadPoolWrapper::init (Singleton * _singleton, int _maxThreads, bool _singleThreaded)
                                                                                {
		int i;
		
		singleton = _singleton;
		
		singleThreaded = _singleThreaded;
		maxThreads = _maxThreads;
		threadPool = new ThreadWrapper[maxThreads];
		
		
		
		for (i = 0; i < maxThreads; i++) {
			threadPool[i].init();
			availIds.push_back(i);
		}
		
		for (i = 0; i < THREAD_DATA_COUNT; i++) {
			intData[i] = 0;
		}
	}
void ThreadPoolWrapper::funcTP (int threadId)
                                  {
		
		GamePageHolder* curHolder;
		
		threadPool[threadId].setRunningLocked(true);
		
		curHolder = singleton->gw->getHolderAtId(
			threadPool[threadId].threadDataInt[1],
			threadPool[threadId].threadDataInt[2]
		);
		
		switch(threadPool[threadId].threadDataInt[0]) {
			case E_TT_GENPATHS:
				curHolder->refreshPaths();
			break;
			case E_TT_GENLIST:
				curHolder->generateList();
			break;
		}
		
		//curHolder->genCellData();
		
		threadPool[threadId].setRunningLocked(false);
	}
void ThreadPoolWrapper::startTP (int threadId)
                                   {
		if (threadPool[threadId].threadRunning) {
			
		}
		else {
			threadPool[threadId].threadRunning = true;
			
			if (singleThreaded) {
				funcTP(threadId);
			}
			else {
				threadPool[threadId].threadMain = std::thread(&ThreadPoolWrapper::funcTP, this, threadId);
			}
			
		}
		
	}
bool ThreadPoolWrapper::stopTP (int threadId)
                                  {
		
		GamePageHolder* curHolder;
		
		bool didStop = false;
		if (threadPool[threadId].threadRunning) {
			
			if (singleThreaded) {
				
			}
			else {
				threadPool[threadId].threadMain.join();
			}
			
			curHolder = singleton->gw->getHolderAtId(
				threadPool[threadId].threadDataInt[1],
				threadPool[threadId].threadDataInt[2]
			);
			
			switch(threadPool[threadId].threadDataInt[0]) {
				case E_TT_GENPATHS:
					
				break;
				case E_TT_GENLIST:
					curHolder->fillVBO();
					
				break;
			}
			
			curHolder->lockWrite = false;
			threadPool[threadId].threadRunning = false;
			didStop = true;
			
			availIds.push_back(threadId);
			
		}
		return didStop;
	}
bool ThreadPoolWrapper::startThread ()
                           {
		int i;
		int q;
		
		
		if (availIds.size() == 0) {
			anyRunning();
		}
		
		if (availIds.size() == 0) {
			return false;
		}
		
		int curId = availIds.back();
		availIds.pop_back();
		
		for (i = 0; i < THREAD_DATA_COUNT; i++) {
			threadPool[curId].threadDataInt[i] = intData[i];
		}
		
		GamePageHolder* curHolder = singleton->gw->getHolderAtId(
			threadPool[curId].threadDataInt[1],
			threadPool[curId].threadDataInt[2]
		);
		
		curHolder->lockWrite = true;
		
		startTP(curId);
		
		return true;
	}
bool ThreadPoolWrapper::anyRunning ()
                          {
		
		int q;
		
		bool bAnyRunning = false;
		for (q = 0; q < maxThreads; q++) {
			if (threadPool[q].threadRunning) {
				if (threadPool[q].isReady()) {
					stopTP(q);
				}
				else {
					bAnyRunning = true;
				}
			}
		}
		
		return bAnyRunning;
	}
void ThreadPoolWrapper::stopAll ()
                       {
		int q;
		for (q = 0; q < maxThreads; q++) {
			stopTP(q);
		}
	}
ThreadPoolWrapper::~ ThreadPoolWrapper ()
                             {
		stopAll();
		delete[] threadPool;
	}
#undef LZZ_INLINE
 
// f00370_gamelogic.h
//

#include "f00370_gamelogic.e"
#define LZZ_INLINE inline
GameLogic::GameLogic ()
                    {
		
	}
void GameLogic::setEntTargPath (int sourceUID, int destUID)
                                                        {
		
		if (sourceUID < 0) {
			return;
		}
		if (destUID < 0) {
			return;
		}
		
		BaseObj* sEnt = &(singleton->gem->gameObjects[sourceUID]);
		BaseObj* dEnt = &(singleton->gem->gameObjects[destUID]);

		sEnt->targPath.points[0] = sEnt->tbPos;
		sEnt->targPath.points[1] = dEnt->tbPos;
		sEnt->targPath.searchedForPath = false;
		sEnt->targPath.didFindPath = false;
		sEnt->targPath.nextInd = -1;
		sEnt->targPath.finalPoints.clear();
		
		getPath(&(sEnt->targPath));
		
	}
void GameLogic::init (Singleton * _singleton)
                                         {
		singleton = _singleton;
		
		testPath.searchedForPath = false;
		testPath.didFindPath = false;
		testPath.points[0] = btVector3(0.0f,0.0f,0.0f);
		testPath.points[1] = btVector3(0.0f,0.0f,0.0f);
		
		idCounter = 1;
		//pathCount = 0;
		
		threadPoolPath = new ThreadPoolWrapper();
		threadPoolPath->init(singleton, 8, true||SINGLE_THREADED);
		
		threadPoolList = new ThreadPoolWrapper();
		threadPoolList->init(singleton, 8, false||SINGLE_THREADED);
		
	}
void GameLogic::applyTBBehavior ()
                               {
		BaseObj* ca = singleton->gem->getActiveActor();
		
		if (ca == NULL) {
			return;
		}
		
		if (ca->isDead()) {
			return;
		}
		
		if (ca->isHidden) {
			return;
		}
		
		BaseObj* nearestEnemy = NULL;
		BaseObj* nearestWeapon = NULL;
		
		btVector3 xyzDisEnemy;
		btVector3 xyzDisWeapon;
		
		int xyDisEnemy = 9999;
		int xyDisWeapon = 9999;
		
		int nearestEnemyInd;
		int nearestWeaponInd;
		
		int i;
		
		bool findWeapon = false;
		bool doMove = false;
		
		btVector3 actorFinalVec;
		
		nearestEnemyInd = singleton->gem->getClosestActor(
				ca->uid,
				E_ENTTYPE_NPC,
				200.0f,
				E_CF_AREENEMIES|E_CF_ISALIVE
		);
		if (nearestEnemyInd > 0) {
			// hostiles nearby
			nearestEnemy = &(singleton->gem->gameObjects[nearestEnemyInd]);
			xyzDisEnemy = singleton->gem->getUnitDistance(ca->uid, nearestEnemy->uid);
			xyDisEnemy = (xyzDisEnemy.getX() + xyzDisEnemy.getY());
			
			nearestWeaponInd = singleton->gem->getClosestActor(
					ca->uid,
					E_ENTTYPE_WEAPON,
					200.0f,
					E_CF_NOTGRABBED
			);
			if (nearestWeaponInd > 0) {
				nearestWeapon = &(singleton->gem->gameObjects[nearestWeaponInd]);
				xyzDisWeapon = singleton->gem->getUnitDistance(ca->uid, nearestWeapon->uid);
				xyDisWeapon = (xyzDisWeapon.getX() + xyzDisWeapon.getY());
				
				
				if (ca->holdingWeapon(-1)) {
					// already holding weapon
				}
				else {
					// find nearest weapon
					
					//if (xyDisWeapon <= xyDisEnemy) {
						findWeapon = true;
					//}
				}
			}
			
			if (findWeapon) {
				if (xyDisWeapon <= 1) {
					singleton->gem->makeTurnTowardsTB(ca->uid, nearestWeapon->tbPos);
					singleton->gem->makeGrab(ca->uid, -1);
				}
				else {
					setEntTargPath(ca->uid,nearestWeapon->uid);
					doMove = true;
				}
			}
			else {
				if (xyDisEnemy <= 1) {
					singleton->gem->makeTurnTowardsTB(ca->uid, nearestEnemy->tbPos);
					singleton->gem->makeSwing(ca->uid, iGenRand(0,1));
				}
				else {
					setEntTargPath(ca->uid,nearestEnemy->uid);
					doMove = true;
				}
			}
			
			
		}
		else {
			// no hostiles nearby
		}
		
		
		if (doMove) {
			if (ca->targPath.didFindPath) {
				
				
				for (i = 0; i < ca->targPath.finalPoints.size(); i++) {
					
					if (
						singleton->gem->getUnitDisXY(
							ca->targPath.finalPoints[i],
							ca->tbPos
						) == 0
					) {
						break;
					}
					
				}
				
				i++;
				
				if (i >= ca->targPath.finalPoints.size()) {
					
				}
				else {
					ca->targPath.nextInd = i;
					
					singleton->gem->makeTurnTowardsTB(ca->uid, ca->targPath.finalPoints[ca->targPath.nextInd]);
					singleton->gem->makeMoveTB(ca->uid, 1);
					
				}
				
				
				
			}
			else {
				cout << "did not find path\n";
			}
		}
		
		
		
		
		
	}
void GameLogic::applyBehavior ()
                             {
		int i;
		int j;
		//float targCount = 0.0f;
		float bestWepDis;
		float bestNPCDis;
		int bestWepUID;
		int bestNPCUID;
		
		float testDis;
		float deltaAng;
		float curDis;
		
		int curActor = singleton->gem->getCurActorUID();
		
		btVector3 tVec;
		btVector3 offsetVec;
		btVector3 readCenter;
		btVector3 writeCenter;
		
		BaseObj* writeObj;
		BaseObj* readObj;
		
		for (i = 0; i < singleton->gem->visObjects.size(); i++) {
			writeObj = &(singleton->gem->gameObjects[
				singleton->gem->visObjects[i]	
			]);
			writeObj->npcRepel = btVector3(0.0f,0.0f,0.0f);
			writeObj->behaviorTarget = btVector3(0.0f,0.0f,0.0f);
			//targCount = 0.0f;
			
			if (
				(writeObj->isHidden) ||
				(writeObj->entType != E_ENTTYPE_NPC) ||
				(writeObj->uid == curActor) // dont apply behavior to active actor
			) {
				
			}
			else {
				
				writeCenter = writeObj->getCenterPoint(E_BDG_CENTER);
				
				
				bestWepDis = 99999.0f;
				bestNPCDis = 99999.0f;
				bestWepUID = -1;
				bestNPCUID = -1;
				
				for (j = 0; j < singleton->gem->visObjects.size(); j++) {
					readObj = &(singleton->gem->gameObjects[
						singleton->gem->visObjects[j]
					]);
					
					if (
						(readObj->isHidden) ||
						(readObj->uid == writeObj->uid)
					) {
						
					}
					else {
						
						// found a unique pair of NPCs
						// determine seek, avoid, neutral
						
						readCenter = readObj->getCenterPoint(E_BDG_CENTER);
						
						if (readObj->entType == E_ENTTYPE_NPC) {
							
							offsetVec = writeCenter-readCenter;
							if (offsetVec.fuzzyZero()) {
								
							}
							else {
								offsetVec.normalize();
								curDis = readCenter.distance(writeCenter);
								writeObj->npcRepel += offsetVec*clampf(3.0f-curDis,-0.05f, 1.0f);
							}
							
							
							if (writeObj->holdingWeapon(-1)) {
								
								if (
									(readObj->isAlive())
									// && (readObj->uid == curActor) 	
								) {
									
									// has weapon, seek out human opponent
									
									testDis = readObj->getCenterPoint(E_BDG_CENTER).distance(
										writeObj->getCenterPoint(E_BDG_CENTER)
									);
								
									// if (bestNPCUID == curActor) {
										
									// }
									// else {
										if ((testDis < bestNPCDis)) { //||(readObj->uid == curActor)
											bestNPCDis = testDis;
											bestNPCUID = readObj->uid;
											writeObj->behaviorTarget = readObj->getCenterPoint(E_BDG_CENTER);
										}
									//}
									
									
									
									//targCount += 1.0f;
								}
								
							}
							else {
								
							}
						}
						else {
							
							if (writeObj->holdingWeapon(-1)) {
								
							}
							else {
								// find a weapon
								
								if (
									(readObj->entType == E_ENTTYPE_WEAPON) &&
									(readObj->isGrabbedById < 0)
								) {
									
									testDis = readObj->getCenterPoint(E_BDG_CENTER).distance(
										writeObj->getCenterPoint(E_BDG_CENTER)
									);
									if (testDis < bestWepDis) {
										bestWepDis = testDis;
										bestWepUID = readObj->uid;
										writeObj->behaviorTarget = readObj->getCenterPoint(E_BDG_CENTER);
									}
									
									
									//targCount += 1.0f;
								}
							}
							
							
							
						}
						
						
					}
					
				}
				
				// if (targCount > 0.0f) {
				// 	writeObj->behaviorTarget /= targCount;
				// }
				
			}
		}
		
		
		for (i = 0; i < singleton->gem->visObjects.size(); i++) {
			writeObj = &(singleton->gem->gameObjects[
				singleton->gem->visObjects[i]	
			]);
			
			if (
				(writeObj->isHidden) ||
				(writeObj->entType != E_ENTTYPE_NPC)
			) {
				
			}
			else {
				
				writeObj->bindingPower += singleton->conVals[E_CONST_BINDING_POW_INC];
				
				if (writeObj->isDead()) {
					writeObj->bindingPower += (
						singleton->conVals[E_CONST_BINDING_POW_ON_DEATH] -
						writeObj->bindingPower						
					)/128.0f;
				}
				
				if (writeObj->bindingPower > 1.0f) {
					writeObj->bindingPower = 1.0f;
				}
				
				if (writeObj->baseContact()) {
					writeObj->airCount = 0.0f;
				}
				else {
					writeObj->airCount += 1.0f;
				}
				
				writeObj->jumpCooldown--;
				if (writeObj->jumpCooldown < 0) {
					writeObj->jumpCooldown = 0;
				}
				
				writeObj->hitCooldown--;
				if (writeObj->hitCooldown < 0) {
					writeObj->hitCooldown = 0;
				}
				
				writeObj->setActionState(E_ACT_ISHIT,RLBN_NEIT,(writeObj->hitCooldown > 0));
				
				writeObj->setActionState(E_ACT_ISWALKING,RLBN_NEIT,false);
				
				
				if (writeObj->isAlive()) {
					
					if (singleton->gem->turnBased) {
						
						deltaAng = writeObj->turnTowardsTargAng(TBDIR_ARR[writeObj->tbDir]);
						
						singleton->gem->makeTurn(writeObj->uid,deltaAng*4.0f);
						
						// tVec = (writeObj->tbPos+btVector3(0.5f,0.5f,0.5f))-writeObj->getCenterPoint(E_BDG_CENTER);
						// tVec *= btVector3(1.0f,1.0f,0.0f);
						
						// singleton->gem->makeMoveVec(
						// 	writeObj->uid,
						// 	tVec
						// );
					}
					else {
						if (writeObj->behaviorTarget.isZero()) {
							
						}
						else {
							deltaAng = writeObj->turnTowardsPointDelta(writeObj->behaviorTarget);
							
							singleton->gem->makeTurn(writeObj->uid,deltaAng*16.0f);
							
							curDis = writeObj->behaviorTarget.distance(writeObj->getCenterPoint(E_BDG_CENTER));
							
							if (curDis > singleton->conVals[E_CONST_AI_SEEK_THRESH]) {
								singleton->gem->makeMove(writeObj->uid, btVector3(0.0f,1.0f,0.0f), true, true);
							}
							if (curDis < singleton->conVals[E_CONST_AI_REPEL_THRESH]) {
								singleton->gem->makeMove(writeObj->uid, btVector3(0.0f,-1.0f,0.0f), true, true);
							}
							
							singleton->gem->makeMoveVec(writeObj->uid,writeObj->npcRepel);
							
							if (curDis > 6.0f) {
								writeObj->blockCount += clampfZO(1.0 - abs(curDis - writeObj->lastBlockDis)*100.0f);
								
							}
							
							if (writeObj->holdingWeapon(-1)) {
								if (
									(curDis > 1.0f) &&
									(curDis < 5.0f)	
								) {
									writeObj->swingCount += 1.0f;
								
									if (writeObj->swingCount > singleton->conVals[E_CONST_SWING_DELAY]) {
										writeObj->swingCount = 0.0f;
										singleton->gem->makeSwing(writeObj->uid,iGenRand(0,1));
									}
									
								}
							}
							else {
								if (
									(curDis > 1.0f) &&
									(curDis < 4.0f)	
								) {
									singleton->gem->makeGrab(writeObj->uid, -1);
								}
							}
							
							
							
							if (writeObj->blockCount > 100.0f) {
								writeObj->blockCount = 0.0f;
								singleton->gem->makeJump(writeObj->uid, true,
									clampfZO(curDis-6.0f)*0.75f + 0.25f	
								);
							}
							writeObj->blockCount *= 0.999f;
							writeObj->lastBlockDis = curDis;
							
							
						}
					}
					
				}
				else { // is dead
					if (writeObj->holdingWeapon(RLBN_LEFT)) {
						singleton->gem->makeGrab(writeObj->uid, RLBN_LEFT);
					}
					
					if (writeObj->holdingWeapon(RLBN_RIGT)) {
						singleton->gem->makeGrab(writeObj->uid, RLBN_RIGT);
					}
				}
				
				
				
			}
			
			
			
		}
		
	}
GamePageHolder * GameLogic::getHolderById (int blockId, int holderId)
                                                                 {
		
		if ((blockId < 0) || (holderId < 0)) {
			return NULL;
		}
		
		GameBlock* curBlock = singleton->gw->blockData[blockId];
		GamePageHolder* curHolder;
		if (curBlock != NULL) {
			curHolder = curBlock->holderData[holderId];
			return curHolder;
		}
		else {
			return NULL;
		}
	}
GamePageHolder * GameLogic::getHolderByPR (PathResult * pr)
                                                      {
		int blockId = pr->blockId;
		int holderId = pr->holderId;
		
		GamePageHolder* curHolder;
		GameBlock* curBlock = singleton->gw->blockData[blockId];
		if (curBlock != NULL) {
			curHolder = curBlock->holderData[holderId];
			return curHolder;
		}
		else {
			return NULL;
		}
	}
bool GameLogic::holdersEqual (GamePageHolder * h0, GamePageHolder * h1)
                                                                  {
		return (
			(h0->blockId == h1->blockId) &&
			(h0->holderId == h1->holderId)
		);
	}
void GameLogic::addHolderToStack (GamePageHolder * curHolder)
                                                         {
		pathSearchStack.push_back(PathResult());
		pathSearchStack.back().blockId = curHolder->blockId;
		pathSearchStack.back().holderId = curHolder->holderId;
		curHolder->visitId = idCounter;
	}
void GameLogic::remHolderFromStack (int opCode)
                                            {
		
		GamePageHolder* curHolder = getHolderByPR(&(pathSearchStack.back()));
		
		switch(opCode) {
			case E_PFO_CLEAR_GROUPS:
				curHolder->clearGroupFlags(idCounter);
				if (holdersEqual(globEndHolder,curHolder)) {
					globFoundTarg = true;
				}
			break;
		}
		
		pathSearchStack.pop_back();
	}
void GameLogic::fillAllPaths (GamePageHolder * begHolder, GamePageHolder * endHolder, int begInd, int endInd, int opCode)
          {
		int i;
		
		pathSearchStack.clear();
		
		GamePageHolder* curHolder;
		GamePageHolder* testHolder;
		
		addHolderToStack(begHolder); //true
		
		bool notFound;
		
		while (pathSearchStack.size() > 0) {
			
			curHolder = getHolderByPR(&(pathSearchStack.back()));
			
			notFound = true;
			
			for (i = 0; i < NUM_ORIENTATIONS; i++) {
				testHolder = singleton->gw->getHolderAtCoords(
					curHolder->offsetInHolders.getIX()+DIR_VECS_I[i][0],
					curHolder->offsetInHolders.getIY()+DIR_VECS_I[i][1],
					curHolder->offsetInHolders.getIZ()+DIR_VECS_I[i][2],
					false
				);
				
				if (testHolder != NULL) {
					if (testHolder->pathsReady) {
						if (testHolder->visitId == idCounter) {
							
						}
						else {
							notFound = false;
							addHolderToStack(testHolder);
						}
					}
				}
			}
			
			if (notFound) {
				remHolderFromStack(opCode);
			}
			
		}
		
		
		idCounter++;
	}
bool GameLogic::addGroupToStack (ConnectingNodeStruct * testConNode, GamePageHolder * curHolder, int groupId, GamePageHolder * lastHolder, int lastGroupId, int lastIndex)
          {
		
		
		
		bool foundIt = false;
		
		pathSearchStack.push_back(PathResult());
		PathResult* lastRes = &(pathSearchStack.back());
		
		lastRes->blockId = curHolder->blockId;
		lastRes->holderId = curHolder->holderId;
		lastRes->groupId = groupId;
		
		
		//curHolderFrom->getInfo(curInd)->cameFromInd
		
		if (testConNode == NULL) {
			
			lastRes->conNode.blockIdFrom = -1;
			lastRes->conNode.holderIdFrom = -1;
			lastRes->conNode.blockIdTo = -1;
			lastRes->conNode.holderIdTo = -1;
			lastRes->conNode.groupIdFrom = -1;
			lastRes->conNode.groupIdTo = -1;
			lastRes->conNode.cellIndFrom = -1;
			lastRes->conNode.cellIndTo = -1;
			lastRes->conNode.totCost = -1;
		}
		else {
			lastRes->conNode = *testConNode;
		}
		
		if (lastHolder == NULL) {
			lastRes->lastBlockId = -1;
			lastRes->lastHolderId = -1;
			lastRes->lastGroupId = -1;
			lastRes->lastIndex = -1;
		}
		else {
			lastRes->lastBlockId = lastHolder->blockId;
			lastRes->lastHolderId = lastHolder->holderId;
			lastRes->lastGroupId = groupId;
			lastRes->lastIndex = lastIndex;
		}
		
		
		curHolder->groupInfoStack[groupId].visitId = idCounter;
		
		
		//////////
		
		
		if (
			holdersEqual(globEndHolder,curHolder) &&
			(groupId == globEndGroupId)	
		) {
			globFoundTarg = true;
			foundIt = true;
		}
		
		return foundIt;
		
		
		/*
		GamePageHolder* curHolder = getHolderByPR(&(pathSearchStack.back()));
		int curGroupId = pathSearchStack.back().groupId;
		
		switch(opCode) {
			case E_PFO_CLEAR_GROUPS:
				// curHolder->clearGroupFlags(idCounter);
				// if (groupsEqual(globEndHolder,curHolder)) {
				// 	globFoundTarg = true;
				// }
			break;
			case E_PFO_SEARCH_GROUPS:
				if (
					holdersEqual(globEndHolder,curHolder) &&
					(curGroupId == globEndGroupId)	
				) {
					globFoundTarg = true;
				}
			break;
		}
		
		pathFinalStack.push_back(pathSearchStack.back());
		*/
		
		
		
		
	}
void GameLogic::remGroupFromStack (int opCode)
                                           {
		
		
		
		pathSearchStack.pop_back();
	}
void GameLogic::fillAllGroups (GamePageHolder * begHolder, GamePageHolder * endHolder, int begInd, int endInd, int opCode)
          {
		int i;
		
		pathSearchStack.clear();
		pathFinalStack.clear();
		
		GamePageHolder* curHolder;
		GamePageHolder* testHolder;
		
		int begGroupId = begHolder->getGroupId(begInd);
		int endGroupId = endHolder->getGroupId(endInd);
		
		if ((begGroupId > -1) && (endGroupId > -1)) {
			
		}
		else {
			goto FILL_GROUPS_RETURN;
		}
		
		globEndGroupId = endGroupId;
		int curGroupId = 0;
		int groupIdTo = 0;
		
		ConnectingNodeStruct* testConNode;
		
		bool foundIt = false;
		
		int lastIndex = -1;
		
		foundIt = addGroupToStack(
			NULL,
			begHolder,
			begGroupId,
			NULL,
			-1,
			lastIndex
		);
		if (foundIt) {
			goto FOUND_TARG_GROUP;
		}
		
		bool notFound;
		
		int frontIndex = 0;
		
		while (
			(frontIndex < pathSearchStack.size()) && //(pathSearchStack.size() > 0) &&
			(globFoundTarg == false)	
		) {
			
			
			
			curHolder = getHolderByPR(&(pathSearchStack[frontIndex]));
			curGroupId = pathSearchStack[frontIndex].groupId;
			lastIndex = frontIndex;//pathSearchStack.size()-1;
			
			//frontIndex++;
			
			notFound = true;
			
			curHolder->sortConNodes(endHolder,endInd);
			
			for (i = 0; i < curHolder->bestConnectingNodes.size(); i++) {
				testConNode = &(curHolder->bestConnectingNodes[i]);
				
				if (testConNode->groupIdFrom == curGroupId) {
					
					testHolder = getHolderById(testConNode->blockIdTo,testConNode->holderIdTo);
					groupIdTo = testConNode->groupIdTo;
					
					if (testHolder != NULL) {
						if (testHolder->pathsReady) {
							if (testHolder->groupInfoStack[groupIdTo].visitId == idCounter) {
								// already visited current group
								
							}
							else {
								notFound = false;
								foundIt = addGroupToStack(
									testConNode,
									testHolder,
									groupIdTo,
									curHolder,
									curGroupId,
									lastIndex
								);
								if (foundIt) {
									goto FOUND_TARG_GROUP;
								}
							}
						}
					}
				}
			}
			
			if (notFound) {
				frontIndex++;
			//	remGroupFromStack(opCode);
			}
			
		}
		
		FOUND_TARG_GROUP:
		
		if (pathSearchStack.size() < 1) {
			goto FILL_GROUPS_RETURN;
		}
		
		
		lastIndex = pathSearchStack.back().lastIndex;
		pathFinalStack.push_back(pathSearchStack.back());
		
		while (lastIndex > -1) {
			pathFinalStack.push_back(pathSearchStack[lastIndex]);
			lastIndex = pathSearchStack[lastIndex].lastIndex;
		}
		
FILL_GROUPS_RETURN:
	idCounter++;
		
		
	}
bool GameLogic::findNaivePath (PathInfo * pathInfo)
                                               {
		
		// attempt to find a naive greedy path
		
		int testInd;
		int deltaXA;
		int deltaYA;
		int deltaX;
		int deltaY;
		
		int toggleMod = 0;
		
		bool keepTesting = true;
		GamePageHolder* testHolder;
		
		btVector3 testPos = pathInfo->points[0];
		btVector3 destPos = pathInfo->points[1];
		
		btVector3 tempBTV;
		
		do {
			testInd = getClosestPathRad(testPos, testHolder);
			
			if (testInd > -1) {
				tempBTV = holderIndToBTV(testHolder, testInd, true);
				pathInfo->finalPoints.push_back(tempBTV);
				testPos.setZ(tempBTV.getZ());
			}
			
			deltaX = (destPos.getX() - testPos.getX());
			deltaY = (destPos.getY() - testPos.getY());
			deltaXA = abs(deltaX);
			deltaYA = abs(deltaY);
			
			keepTesting = (
				(testInd > -1) &&
				((deltaXA+deltaYA) > 0)
			);
			
			
			if ( (toggleMod%2) == 0 ) {
				if (deltaXA > 0) {
					testPos += btVector3(
						qSign(deltaX),
						0.0f,
						0.0f
					);
				}
				else if (deltaYA > 0) {
					testPos += btVector3(
						0.0f,
						qSign(deltaY),
						0.0f
					);
				}
			}
			else {
				if (deltaYA > 0) {
					testPos += btVector3(
						0.0f,
						qSign(deltaY),
						0.0f
					);
				}
				else if (deltaXA > 0) {
					testPos += btVector3(
						qSign(deltaX),
						0.0f,
						0.0f
					);
				}
			}
			
			toggleMod++;
			
		} while (keepTesting);
		
		return (
			(testInd > -1) &&
			((deltaXA+deltaYA) == 0)
		);
		
	}
bool GameLogic::findBestPath (PathInfo * pathInfo, GamePageHolder * closestHolder, GamePageHolder * closestHolder2, int bestInd, int bestInd2)
          {
		
		
		
		// clear
		globEndHolder = closestHolder2;
		globFoundTarg = false;
		fillAllPaths(
			closestHolder,
			closestHolder2,
			bestInd,
			bestInd2,
			E_PFO_CLEAR_GROUPS
		);
		
		
		if (globFoundTarg) {
			//cout << "Found linking holders\n";
		}
		else {
			//cout << "No available path, or path data not ready\n";
			return false;
		}
		
		
		globFoundTarg = false;
		fillAllGroups(
			closestHolder,
			closestHolder2,
			bestInd,
			bestInd2,
			E_PFO_SEARCH_GROUPS
		);
		

		
		if (globFoundTarg) {
			//cout << "Found linking groups\n";
		}
		else {
			//cout << "Could not find linking groups\n";
			return false;
		}
		
		return true;
		
	}
void GameLogic::drawFinalPath (PathInfo * pathInfo)
                                               {
		
		
		GamePageHolder* closestHolder;
		GamePageHolder* closestHolder2;
		
		int bestInd = getClosestPathRad(pathInfo->points[0], closestHolder);
		int bestInd2 = getClosestPathRad(pathInfo->points[1], closestHolder2);
		
		drawPointAtIndex(closestHolder, bestInd, 0,128+singleton->smoothTime*127.0f,0, singleton->smoothTime);
		drawPointAtIndex(closestHolder2, bestInd2, 128+singleton->smoothTime*127.0f,0,0, singleton->smoothTime);
		
		int i;
		
		singleton->setShaderVec3("matVal", 255, 0, 255);
		
		float curRad;
		double fi;
		
		for (i = 0; i < pathInfo->finalPoints.size(); i++) {
			fi = i;
			
			curRad = 0.25f + 0.15*sin( fi*0.5 + singleton->curTime/200.0 );
			
			if (i == pathInfo->nextInd) {
				singleton->setShaderVec3("matVal", 0, 255, 255);
			}
			
			singleton->drawBoxRad(pathInfo->finalPoints[i],btVector3(curRad,curRad,curRad));
			
			if (i == pathInfo->nextInd) {
				singleton->setShaderVec3("matVal", 255, 0, 255);
			}
			
		}
		
		
	}
void GameLogic::getPath (PathInfo * pathInfo)
                                         {
		
		pathInfo->finalPoints.clear();
		
		int i;
		int j;
		int k;
		
		// GamePageHolder* curHolder = singleton->gw->getHolderAtCoords(
		// 	singleton->lastHolderPos.getIX(),
		// 	singleton->lastHolderPos.getIY(),
		// 	singleton->lastHolderPos.getIZ(),
		// 	true
		// );
		
		// if (singleton->refreshPaths) {
		// 	singleton->refreshPaths = false;
		// 	curHolder->refreshPaths();
		// }
		
		
		////////////////////
		
		
		GamePageHolder* conHolder1;
		GamePageHolder* conHolder2;
		
		GamePageHolder* tempHolder;
		GamePageHolder* tempHolder2;
		
		int tempInd;
		int tempInd2;
		
		GamePageHolder* closestHolder;
		GamePageHolder* closestHolder2;
		GamePageHolder* closestHolder3;
		int bestInd;
		int bestInd2;
		int bestInd3;
		PathResult* curPR;
		
		//pathCount = 0;
		
		
		
		bestInd = getClosestPathRad(pathInfo->points[0], closestHolder);
		bestInd2 = getClosestPathRad(pathInfo->points[1], closestHolder2);
		
		
		
		
		// current mouse position
		// bestInd3 = getClosestPathRad(&(singleton->mouseMovePD), closestHolder3);
		
		
		//drawPointAtIndex(closestHolder, bestInd, 0,128+singleton->smoothTime*127.0f,0, singleton->smoothTime);
		//drawPointAtIndex(closestHolder2, bestInd2, 128+singleton->smoothTime*127.0f,0,0, singleton->smoothTime);
		
		
		
		// if (
		// 	(bestInd > -1) &&
		// 	singleton->doPathReport
		// ) {
		// 	singleton->doPathReport = false;
		// 	;
			
		// 	drawPointAtIndex(closestHolder, bestInd, 0,255,0, 0.5f);
			
		// }
		
		// if (
		// 	(bestInd > -1)
		// ) {
		// 	if (closestHolder->getInfo(bestInd) != NULL) {
		// 		if (closestHolder->getInfo(bestInd)->cameFromInd > -1) {
		// 			drawPointAtIndex(closestHolder, closestHolder->getInfo(bestInd)->cameFromInd, 255,255,0, 0.5f);
		// 		}
		// 	}
		// }
		
		
		if ((bestInd > -1)  && (bestInd2 > -1)) {
			
			pathInfo->didFindPath = findNaivePath(pathInfo);
			
			if (pathInfo->didFindPath) {
				//cout << "found naive\n";
			}
			else {
				pathInfo->finalPoints.clear();
				
				pathInfo->didFindPath = findBestPath(
					pathInfo,
					closestHolder,
					closestHolder2,
					bestInd,
					bestInd2
				);
				
				if (pathInfo->didFindPath) {
					
					//cout << "found complex\n";
					
					getPointsForPath(closestHolder, bestInd, pathInfo, true);
					
					for (i = 0; i < pathFinalStack.size(); i++) {
						curPR = &(pathFinalStack[i]);
						
						tempHolder = getHolderById(curPR->blockId,curPR->holderId);
						if ((tempHolder != NULL)) {
							tempInd = tempHolder->groupInfoStack[curPR->groupId].centerInd;
							// if (tempInd > -1) {
							// 	drawPointAtIndex(tempHolder, tempInd, 255, 128, 0, singleton->smoothTime);	
							// }
						}
						
						conHolder1 = getHolderById(curPR->conNode.blockIdFrom, curPR->conNode.holderIdFrom);
						conHolder2 = getHolderById(curPR->conNode.blockIdTo, curPR->conNode.holderIdTo); 
						
						if (conHolder1 != NULL) {
							getPointsForPath(conHolder1, curPR->conNode.cellIndFrom, pathInfo, false);
						}
						if (conHolder2 != NULL) {
							getPointsForPath(conHolder2, curPR->conNode.cellIndTo, pathInfo, true);
						}
						
					}
					
					getPointsForPath(closestHolder2, bestInd2, pathInfo, false);
					
					
				}
			}
			
			
			
			pathInfo->searchedForPath = true;
		}
		
		
		
		// if (bestInd3 > -1) {
		// 	drawPathToPoint(closestHolder3, bestInd3, 255, 128, 0);
			
		// 	if (singleton->doPathReport) {
		// 		if (closestHolder3->getInfo(bestInd3) == NULL) {
		// 			cout << "NULL!!!\n";
		// 		}
		// 		else {
		// 			cout << closestHolder3->holderId << " " <<
		// 				closestHolder3->getInfo(bestInd3)->groupId << " " <<
		// 				closestHolder3->getInfoPD(bestInd3) << " " <<
		// 				bestInd3 << "/" << singleton->cellsPerHolder*singleton->cellsPerHolder*singleton->cellsPerHolder << " " <<
		// 				closestHolder3->groupInfoStack.size() << " " << 
		// 				"\n";
					
		// 		}
		// 		singleton->doPathReport = false;
		// 	}
			
		// }
		
		
		
		
		// for (k = -1; k <= 1; k++) {
		// 	for (j = -1; j <= 1; j++) {
		// 		for (i = -1; i <= 1; i++) {
		// 			drawRegions(
		// 				i,
		// 				j,
		// 				k
		// 			);
		// 		}
		// 	}
		// }
		
		
		
		
		
		
		
		
		
		
		////////////////////
		
	}
void GameLogic::update ()
                      {
			
			int i;
			BaseObj* ca;
			
			if (singleton->pathfindingOn) {
				
				if (singleton->pathfindingTestOn) {
					if (
						(!testPath.searchedForPath) && (singleton->pathFindingStep == 2)
					) {
						getPath(&testPath);
					}
					drawFinalPath(&testPath);
				}
				
				
				if (singleton->drawTargPaths) {
					for (i = 0; i < singleton->gem->turnList.size(); i++) {
						
						ca = &(singleton->gem->gameObjects[ singleton->gem->turnList[i] ]); 
						
						if (ca->isHidden) {
							
						}
						else {
							if (ca->targPath.didFindPath) {
								drawFinalPath(&(ca->targPath));
							}
						}
						
						
					}
				}
					
			}
			
			
			
			
			
			
	}
void GameLogic::drawLineAtIndices (GamePageHolder * curPointHolder, int curPointIndex, GamePageHolder * curPointHolder2, int curPointIndex2)
          {
		
		if (curPointIndex < 0) {
			return;
		}
		
		if (curPointHolder == NULL) {
			return;
		}
		
		int ii;
		int jj;
		int kk;
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		FIVector4 pVec1;
		FIVector4 pVec2;
		
		//singleton->setShaderVec3("matVal", r, g, b);
		// draw highlighted cube here if necessary
		
		kk = curPointIndex/(cellsPerHolder*cellsPerHolder);
		jj = (curPointIndex-kk*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
		ii = curPointIndex-(kk*cellsPerHolder*cellsPerHolder + jj*cellsPerHolder);
		
		pVec1.copyFrom(&(curPointHolder->gphMinInPixels));
		pVec1.addXYZ(ii,jj,kk);
		pVec1.addXYZ(0.5f);
		
		kk = curPointIndex2/(cellsPerHolder*cellsPerHolder);
		jj = (curPointIndex2-kk*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
		ii = curPointIndex2-(kk*cellsPerHolder*cellsPerHolder + jj*cellsPerHolder);
		
		pVec2.copyFrom(&(curPointHolder2->gphMinInPixels));
		pVec2.addXYZ(ii,jj,kk);
		pVec2.addXYZ(0.5f);
		
		
		singleton->drawLine(&pVec1, &pVec2);
	}
btVector3 GameLogic::holderIndToBTV (GamePageHolder * curPointHolder, int curPointIndex, bool addHalfOff)
                                                                                                     {
		int ii;
		int jj;
		int kk;
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		btVector3 pVec1;
		
		kk = curPointIndex/(cellsPerHolder*cellsPerHolder);
		jj = (curPointIndex-kk*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
		ii = curPointIndex-(kk*cellsPerHolder*cellsPerHolder + jj*cellsPerHolder);
		
		pVec1 = curPointHolder->gphMinInPixels.getBTV();
		pVec1 += btVector3(ii,jj,kk);
		
		if (addHalfOff) {
			pVec1 += btVector3(0.5f,0.5f,0.5f);
		}
		
		return pVec1;
	}
void GameLogic::drawPointAtIndex (GamePageHolder * curPointHolder, int curPointIndex, int r, int g, int b, float rad)
                                                                                                                 {
		
		if (curPointIndex < 0) {
			return;
		}
		
		if (curPointHolder == NULL) {
			return;
		}
		
		int ii;
		int jj;
		int kk;
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		FIVector4 pVec1;
		
		singleton->setShaderVec3("matVal", r, g, b);
		// draw highlighted cube here if necessary
		
		kk = curPointIndex/(cellsPerHolder*cellsPerHolder);
		jj = (curPointIndex-kk*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
		ii = curPointIndex-(kk*cellsPerHolder*cellsPerHolder + jj*cellsPerHolder);
		
		pVec1.copyFrom(&(curPointHolder->gphMinInPixels));
		pVec1.addXYZ(ii,jj,kk);
		pVec1.addXYZ(0.5f);
		singleton->drawCubeCentered(&pVec1, rad);
	}
void GameLogic::getPointsForPath (GamePageHolder * curHolderFrom, int _curInd, PathInfo * pathInfo, bool reverseOrder)
                                                                                                                 {
		
		//pathCount++;
		
		int curInd = _curInd;
		int cameFromInd;
		
		int ii;
		int jj;
		int kk;
		int ii2;
		int jj2;
		int kk2;
		
		int i;
		
		//int totPath = 0;
		
		
		btVector3 pVec1;
		
		//FIVector4 pVec1;
		//FIVector4 pVec2;
		
		if (curHolderFrom == NULL) {
			return;
		}
		
		if (curHolderFrom->wasGenerated) {
			
		}
		else {
			return;
		}
		
		if (curHolderFrom->pathsReady) {
			
		}
		else {
			return;
		}
		
		if (curHolderFrom->hasData) {
			
		}
		else {
			//cout << "NO DATA\n";
			return;
		}
		
		if (reverseOrder) {
			tempStack.clear();
		}
		
		btVector3 newMin = curHolderFrom->gphMinInPixels.getBTV();
		
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		//singleton->setShaderVec3("matVal", rr, gg, bb);
		
		
		if (curHolderFrom->getInfo(curInd) != NULL) {
			cameFromInd = curHolderFrom->getInfo(curInd)->cameFromInd;
		}
		else {
			cameFromInd = -1;
		}
		
		while (
			(cameFromInd > -1) &&
			(curInd > -1)	
		) {
			
			
			//totPath++;
			
			if (curHolderFrom->getInfo(curInd) != NULL) {
				cameFromInd = curHolderFrom->getInfo(curInd)->cameFromInd;
			}
			else {
				cameFromInd = -1;
			}
			
			if (cameFromInd == curInd) {
				cameFromInd = -1;
			}
			
			
			if (
				(curInd > -1) &&
				(cameFromInd > -1) &&
				(curInd < (cellsPerHolder*cellsPerHolder*cellsPerHolder)) &&
				(cameFromInd < (cellsPerHolder*cellsPerHolder*cellsPerHolder))
			) {
				kk = curInd/(cellsPerHolder*cellsPerHolder);
				jj = (curInd-kk*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
				ii = curInd-(kk*cellsPerHolder*cellsPerHolder + jj*cellsPerHolder);
				
				kk2 = cameFromInd/(cellsPerHolder*cellsPerHolder);
				jj2 = (cameFromInd-kk2*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
				ii2 = cameFromInd-(kk2*cellsPerHolder*cellsPerHolder + jj2*cellsPerHolder);
				
				
				pVec1 = newMin + btVector3(ii+0.5f,jj+0.5f,kk+0.5f);
				
				if (reverseOrder) {
					tempStack.push_back(pVec1);
				}
				else {
					pathInfo->finalPoints.push_back(pVec1);
				}
				
				
				
				// pVec2.copyFrom(&minv);
				// pVec2.addXYZ(ii2,jj2,kk2);
				// pVec2.addXYZ(0.5f);
				
				// singleton->drawLine(&pVec1, &pVec2);
				
				
				
			}
			
			curInd = cameFromInd;
			
		}
		
		if (reverseOrder) {
			for (i = (tempStack.size()-1); i >= 0; i--) {
				pathInfo->finalPoints.push_back(tempStack[i]);
			}
		}
		
		
		
		
		// if (totPath == 0) {
			
		// 	drawPointAtIndex(curHolderFrom, curInd, 0, 255, 255, singleton->smoothTime);	
			
			
		// 	// cout << "0 path " << cameFromInd << " " << curInd << "\n";
			
		// 	// if (curHolderFrom->getInfo(curInd) == NULL) {
		// 	// 		cout << "NULL IND DATA\n";
		// 	// }
			
		// }
		
	}
void GameLogic::drawRegions (int offX, int offY, int offZ)
          {
		
		
		
		int i;
		int j;
		int k;
		int n;
		int q;
		
		int ii;
		int jj;
		int kk;
		int ii2;
		int jj2;
		int kk2;
		
		int ind;
		int lastId;
		int curId;
		int curInd;
		int cameFromInd;
		int cellVal;
		
		int targetGroup;
		int targetBlockId;
		int targetHolderId;
		
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		bool doProc = false;
		
		FIVector4 lhPos;
		lhPos.copyFrom(&(singleton->lastHolderPos));
		lhPos.addXYZ(offX,offY,offZ);
		
		GamePageHolder* curHolderFrom = singleton->gw->getHolderAtCoords(
			lhPos.getIX(),
			lhPos.getIY(),
			lhPos.getIZ(),
			true
		);
		
		GamePageHolder* curHolderTo;
		
		
		minv.copyFrom(&(curHolderFrom->gphMinInPixels));
		maxv.copyFrom(&minv);
		maxv.addXYZ(cellsPerHolder);
		
		if (curHolderFrom->pathsReady) {
			
		}
		else {
			return;
		}
		
		ConnectingNodeStruct* testConNode;
		float curPathCost;
		
		FIVector4 pVec1;
		FIVector4 pVec2;
		FIVector4 pVec3;
		
		
		// draw all path points
		lastId = -1;
		for (q = 0; q < curHolderFrom->groupIdStack.size(); q++) {
			
			curId = curHolderFrom->groupIdStack[q].groupId;
			curInd = curHolderFrom->groupIdStack[q].ind;
			
			if (lastId != curId) {
				singleton->setShaderfVec3("matVal", &(singleton->colVecs[curId%16]));
			}
			
			// if (curInd == curHolderFrom->groupInfoStack[curId].centerInd) {
			// 	singleton->setShaderVec3("matVal", 254, 128, 0);
			// }
			
			kk = curInd/(cellsPerHolder*cellsPerHolder);
			jj = (curInd-kk*cellsPerHolder*cellsPerHolder)/cellsPerHolder;
			ii = curInd-(kk*cellsPerHolder*cellsPerHolder + jj*cellsPerHolder);
			
			pVec1.copyFrom(&minv);
			pVec1.addXYZ(ii,jj,kk);
			pVec1.addXYZ(0.5f);
			
			if (curHolderFrom->getInfo(curInd) != NULL) {
				curPathCost = curHolderFrom->getInfo(curInd)->pathCost;
				singleton->drawCubeCentered(
					&pVec1, 
					0.15//mixf(0.05f,0.45f,clampfZO(curPathCost/32.0f))
				);
			}
			
			
			// if (curInd == curHolderFrom->groupInfoStack[curId].centerInd) {
			// 	singleton->setShaderfVec3("matVal", &(singleton->colVecs[curId%16]));
			// }
			
			lastId = curId;
		}
		
		
		
		singleton->setShaderVec3("matVal", singleton->smoothTime*255.0f, 0, 0);
		
		for (q = 0; q < curHolderFrom->bestConnectingNodes.size(); q++) {
			
			testConNode = &(curHolderFrom->bestConnectingNodes[q]);
			
			curId = testConNode->groupIdFrom;
			curInd = testConNode->cellIndFrom;
			
			
			curHolderTo = getHolderById(testConNode->blockIdTo,testConNode->holderIdTo);
			
			if (curHolderTo != NULL) {
				drawLineAtIndices(
					curHolderFrom, testConNode->cellIndFrom,
					curHolderTo, testConNode->cellIndTo
					
				);
			}
			
			
		}
		
		
		
	}
int GameLogic::getClosestPathRad (btVector3 cpBTV, GamePageHolder * & closestHolder)
                                                                               {
		
		int rad = BASE_MOVEABLE_Z;
		
		btVector3 newCoord;
		
		//FIVector4 closestPoint;
		//
		
		int i;
		int j;
		int k;
		int n;
		int q;
		int ind;
		
		int testInd;
		int testDis;
		int bestDis = 99999;
		int bestInd = -1;
		
		int cellsPerHolder = singleton->cellsPerHolder;
		int curInd;
		
		
		for (q = -rad; q <= rad; q++) {
			newCoord = cpBTV + btVector3(0.0f,0.0f,q);
			//closestPoint.setBTV(newCoord);
			
			curInd = singleton->gw->getCellInd(newCoord, closestHolder);
			
			if (closestHolder != NULL) {
				if (closestHolder->idealPathsReady) {
					if (curInd > -1) {
						if (closestHolder->getGroupId(curInd) > -1) {
							return curInd;
						}
					} 
				}
			}
			
			
			
		}
		
		return -1;
	}
void GameLogic::loadNearestHolders ()
                                  {
		
		FIVector4 tempVec;
		
		int i, j, k;
		int ii, jj, kk;
		int incVal;
		int maxLoadRad = 0;
		int genCount = 0;
		int mink;
		int maxk;
		int minj;
		int maxj;
		int mini;
		int maxi;
		int curLoadRadius;
		int radStep = 1;
		intPair curId;
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		switch(cellsPerHolder) {
			case 16:
				maxLoadRad = 4;
			break;
			
			case 32:
				maxLoadRad = 4;
			break;
			
			case 64:
				maxLoadRad = 2;
			break;
			
			case 128:
				maxLoadRad = 1;
			break;
		}
		
		bool doPaths;
		
		// check if any are done running and stop them if necessary
		if (threadPoolList->anyRunning()) {
			
		}
		else {
			
		}
		if (threadPoolPath->anyRunning()) {
			doPaths = false;
		}
		else {
			doPaths = true;
		}
		
		
		
		
		tempVec.copyFrom(singleton->cameraGetPosNoShake());
		tempVec.intDivXYZ(singleton->cellsPerHolder);

		GamePageHolder* curHolder;
		GameBlock *curBlock;

		singleton->gw->ensureBlocks();
		
		// if (singleton->pathfindingOn) {
			
		// }
		// else {
		// 	return;
		// }
		
		for (curLoadRadius = 0; curLoadRadius < maxLoadRad; curLoadRadius++) {
			
			mink = max(tempVec.getIZ() - curLoadRadius,0);
			maxk = min(
				tempVec.getIZ() + curLoadRadius,
				singleton->holdersPerWorld - 1
			);
			minj = tempVec.getIY() - curLoadRadius;
			maxj = tempVec.getIY() + curLoadRadius;
			mini = tempVec.getIX() - curLoadRadius;
			maxi = tempVec.getIX() + curLoadRadius;
			
			for (jj = minj; jj <= maxj; jj += radStep) {
				
				if (curLoadRadius <= 2) {
					incVal = 1;
				}
				else {
					if ( (jj == minj) || (jj == maxj) ) {
						incVal = radStep;
					}
					else {
						incVal = maxi - mini;
					}
				}
				
				for (ii = maxi; ii >= mini; ii -= incVal) {
					
					
					for (kk = mink; kk <= maxk; kk += radStep) {
						
						
						curHolder = singleton->gw->getHolderAtCoords(ii, jj, kk, true);
						curBlock = singleton->gw->getBlockAtId(curHolder->blockId);
						
						
						if (curBlock == NULL) {
							cout << "NULL BLOCK\n";
						}
						else {
							if (curHolder->wasGenerated) {
								
								
								if ((curLoadRadius < 2)&&(singleton->pathfindingGen)&&doPaths) {
									if (curHolder->pathsReady || curHolder->lockWrite) {
										
									}
									else {
										
										if(curHolder->prepPathRefresh(2)) {
											
											
											threadPoolPath->intData[0] = E_TT_GENPATHS;
											threadPoolPath->intData[1] = curHolder->blockId;
											threadPoolPath->intData[2] = curHolder->holderId;
											
											if (threadPoolPath->startThread()) {
												genCount++;
											}
										}
										
									}
								}
								
								if (curHolder->listGenerated || curHolder->lockWrite) {
									
								}
								else {
									//cout << "genList\n";
									
									if(curHolder->prepPathRefresh(1)) {
										
										
										
										threadPoolList->intData[0] = E_TT_GENLIST;
										threadPoolList->intData[1] = curHolder->blockId;
										threadPoolList->intData[2] = curHolder->holderId;
										
										if (threadPoolList->startThread()) {
											genCount++;
										}
										
										//curHolder->generateList();
									}
									
									
								}
								
								
							}
							else {
								// curHolder->genCellData();
								// genCount++;
							}
						}
						
						
						// if (genCount >= 2) {
						// 	return;
						// }
						
					}
					
				}
			}
			
		}
	}
#undef LZZ_INLINE
 
// f00373_myshapedrawer.h
//

#include "f00373_myshapedrawer.e"
#define LZZ_INLINE inline
MyShapeDrawer::MyShapeDrawer (Singleton * _singleton)
                {
			singleton = _singleton;
			
			//m_texturehandle			=	0;
			//m_textureenabled		=	false;
			//m_textureinitialized	=	false;
		}
void MyShapeDrawer::init ()
                            {
			
		}
bool MyShapeDrawer::enableTexture (bool enable)
                                                {
			return false;//bool p=m_textureenabled;m_textureenabled=enable;return(p);
		}
bool MyShapeDrawer::hasTextureEnabled () const
                                               {
			return false;//m_textureenabled;
		}
void MyShapeDrawer::drawCoordSystem ()
                                        {
			// glBegin(GL_LINES);
			// //glColor3f(1, 0, 0);
			// glVertex3d(0, 0, 0);
			// glVertex3d(1, 0, 0);
			// //glColor3f(0, 1, 0);
			// glVertex3d(0, 0, 0);
			// glVertex3d(0, 1, 0);
			// //glColor3f(0, 0, 1);
			// glVertex3d(0, 0, 0);
			// glVertex3d(0, 0, 1);
			// glEnd();

		}
void MyShapeDrawer::drawSphere (btScalar radius, int lats, int longs)
                {
			
			int i, j;
			for(i = 0; i <= lats; i++) {
				btScalar lat0 = SIMD_PI * (-btScalar(0.5) + (btScalar) (i - 1) / lats);
				btScalar z0  = radius*sin(lat0);
				btScalar zr0 =  radius*cos(lat0);

				btScalar lat1 = SIMD_PI * (-btScalar(0.5) + (btScalar) i / lats);
				btScalar z1 = radius*sin(lat1);
				btScalar zr1 = radius*cos(lat1);

				// TODO: reimplement with tris

				glBegin(GL_QUAD_STRIP);
				for(j = 0; j <= longs; j++) {
					btScalar lng = 2 * SIMD_PI * (btScalar) (j - 1) / longs;
					btScalar x = cos(lng);
					btScalar y = sin(lng);
					glNormal3f(-(x * zr1), -(y * zr1), -z1);
					glVertex3f(x * zr1, y * zr1, z1);
					glNormal3f(-(x * zr0), -(y * zr0), -z0);
					glVertex3f(x * zr0, y * zr0, z0);
				}
				glEnd();
			}
		}
ShapeCache * MyShapeDrawer::cache (btConvexShape * shape)
                {
			ShapeCache*		sc=(ShapeCache*)shape->getUserPointer();
			if(!sc)
			{
				sc=new(btAlignedAlloc(sizeof(ShapeCache),16)) ShapeCache(shape);
				sc->m_shapehull.buildHull(shape->getMargin());
				m_shapecaches.push_back(sc);
				shape->setUserPointer(sc);
				/* Build edges	*/ 
				const int			ni=sc->m_shapehull.numIndices();
				const int			nv=sc->m_shapehull.numVertices();
				const unsigned int*	pi=sc->m_shapehull.getIndexPointer();
				const btVector3*	pv=sc->m_shapehull.getVertexPointer();
				btAlignedObjectArray<ShapeCache::Edge*>	edges;
				sc->m_edges.reserve(ni);
				edges.resize(nv*nv,0);
				for(int i=0;i<ni;i+=3)
				{
					const unsigned int* ti=pi+i;
					const btVector3		nrm=btCross(pv[ti[1]]-pv[ti[0]],pv[ti[2]]-pv[ti[0]]).normalized();
					for(int j=2,k=0;k<3;j=k++)
					{
						const unsigned int	a=ti[j];
						const unsigned int	b=ti[k];
						ShapeCache::Edge*&	e=edges[btMin(a,b)*nv+btMax(a,b)];
						if(!e)
						{
							sc->m_edges.push_back(ShapeCache::Edge());
							e=&sc->m_edges[sc->m_edges.size()-1];
							e->n[0]=nrm;e->n[1]=-nrm;
							e->v[0]=a;e->v[1]=b;
						}
						else
						{
							e->n[1]=nrm;
						}
					}
				}
			}
			return(sc);
		}
void MyShapeDrawer::renderSquareA (float x, float y, float z)
                {
			// glBegin(GL_LINE_LOOP);
			// glVertex3f(x, y, z);
			// glVertex3f(x + 10.f, y, z);
			// glVertex3f(x + 10.f, y + 10.f, z);
			// glVertex3f(x, y + 10.f, z);
			// glEnd();
		}
void MyShapeDrawer::setId (int bodyUID, int limbUID)
                  {
			singleton->setShaderFloat("bodyUID", bodyUID);
			singleton->setShaderFloat("limbUID", limbUID);
		}
void MyShapeDrawer::updateMat2 ()
                                  {
			
			glGetFloatv(GL_MODELVIEW_MATRIX, singleton->viewMatrix.get());
			singleton->setShaderMatrix4x4("objmat",singleton->viewMatrix.get(),1);
		}
void MyShapeDrawer::updateMat ()
                                 {
			int i;
			
			singleton->curObjMatrix.identity();
			
			for (i = 0; i < singleton->objMatrixStack.size(); i++) {
				singleton->curObjMatrix *= singleton->objMatrixStack[i];
			}
			//glGetFloatv(GL_MODELVIEW_MATRIX, singleton->viewMatrix.get());
			singleton->setShaderMatrix4x4("objmat",singleton->curObjMatrix.get(),1);
			
			singleton->curObjMatrix3.set4(singleton->curObjMatrix.get());
			singleton->curObjMatrix3.invert();
			singleton->curObjMatrix3.transpose();
			
			singleton->setShaderMatrix3x3("normalRot",singleton->curObjMatrix3.get(),1);
			
			
			
			//btTransform tr;
			// tr.setFromOpenGLMatrix(singleton->curObjMatrix.get());
			// btQuaternion orn = tr.getRotation();
			// singleton->setShaderVec4("objQuat",orn.getX(),orn.getY(),orn.getZ(),orn.getW());
			
		}
void MyShapeDrawer::pushNewMat (btScalar * m)
                                             {
			singleton->objMatrixStack.push_back(Matrix4(
				m[0],
				m[1],
				m[2],	
				m[3],
				
				m[4],
				m[5],
				m[6],
				m[7],
				
				m[8],
				m[9],
				m[10],
				m[11],
				
				m[12],
				m[13],
				m[14],
				m[15]
			));
			updateMat();
		}
void MyShapeDrawer::popMat ()
                              {
			singleton->objMatrixStack.pop_back();
			updateMat();
		}
void MyShapeDrawer::drawOrient (int uid)
                                         {
			
			
			if (uid == singleton->gem->getCurActorUID()) {
				
			}
			else {
				return;
			}
			
			//cout << "yay\n";
			
			int oldUID = uid;
			
			//setId(0);
			
			singleton->setShaderVec3("matVal", 255, 0, 0);
			glBegin(GL_LINES);
			//glNormal3f(0, 0, 1);
			glVertex3d(0, 0, 0);
			glVertex3d(4, 0, 0);
			glEnd();
			
			singleton->setShaderVec3("matVal", 0, 255, 0);
			glBegin(GL_LINES);
			//glNormal3f(0, 0, 1);
			glVertex3d(0, 0, 0);
			glVertex3d(0, 4, 0);
			glEnd();
			
			singleton->setShaderVec3("matVal",0, 0, 255);
			glBegin(GL_LINES);
			//glNormal3f(0, 0, 1);
			glVertex3d(0, 0, 0);
			glVertex3d(0, 0, 4);
			glEnd();
			
			//setId(oldUID);
			singleton->setShaderVec3("matVal", 1, 1, 1);
			
		}
void MyShapeDrawer::drawOpenGL (btScalar * m, btCollisionShape const * shape, btVector3 const & color, int debugMode, btVector3 const & worldBoundsMin, btVector3 const & worldBoundsMax, int uid)
                  {
			
			if (shape->getShapeType() == CUSTOM_CONVEX_SHAPE_TYPE)
			{
				btVector3 org(m[12], m[13], m[14]);
				btVector3 dx(m[0], m[1], m[2]);
				btVector3 dy(m[4], m[5], m[6]);
		//		btVector3 dz(m[8], m[9], m[10]);
				const btBoxShape* boxShape = static_cast<const btBoxShape*>(shape);
				btVector3 halfExtent = boxShape->getHalfExtentsWithMargin();
				dx *= halfExtent[0];
				dy *= halfExtent[1];
		//		dz *= halfExtent[2];
				//glColor3f(1,1,1);
				//glDisable(GL_LIGHTING);

				// glBegin(GL_LINE_LOOP);
				// glDrawVector(org - dx - dy);
				// glDrawVector(org - dx + dy);
				// glDrawVector(org + dx + dy);
				// glDrawVector(org + dx - dy);
				// glEnd();
				return;
			} 
			else if((shape->getShapeType() == BOX_SHAPE_PROXYTYPE) && (debugMode & btIDebugDraw::DBG_FastWireframe))
			{
				btVector3 org(m[12], m[13], m[14]);
				btVector3 dx(m[0], m[1], m[2]);
				btVector3 dy(m[4], m[5], m[6]);
				btVector3 dz(m[8], m[9], m[10]);
				const btBoxShape* boxShape = static_cast<const btBoxShape*>(shape);
				btVector3 halfExtent = boxShape->getHalfExtentsWithMargin();
				dx *= halfExtent[0];
				dy *= halfExtent[1];
				dz *= halfExtent[2];
				// glBegin(GL_LINE_LOOP);
				// glDrawVector(org - dx - dy - dz);
				// glDrawVector(org + dx - dy - dz);
				// glDrawVector(org + dx + dy - dz);
				// glDrawVector(org - dx + dy - dz);
				// glDrawVector(org - dx + dy + dz);
				// glDrawVector(org + dx + dy + dz);
				// glDrawVector(org + dx - dy + dz);
				// glDrawVector(org - dx - dy + dz);
				// glEnd();
				// glBegin(GL_LINES);
				// glDrawVector(org + dx - dy - dz);
				// glDrawVector(org + dx - dy + dz);
				// glDrawVector(org + dx + dy - dz);
				// glDrawVector(org + dx + dy + dz);
				// glDrawVector(org - dx - dy - dz);
				// glDrawVector(org - dx + dy - dz);
				// glDrawVector(org - dx - dy + dz);
				// glDrawVector(org - dx + dy + dz);
				// glEnd();
				return;
			}

			//cout << "a\n";
			//glPushMatrix(); 
			//btglMultMatrix(m);
			//updateMat2();
			pushNewMat(m);
			//singleton->gem->gameObjects[uid].rotMat = singleton->curObjMatrix3;


			if (shape->getShapeType() == UNIFORM_SCALING_SHAPE_PROXYTYPE)
			{
				const btUniformScalingShape* scalingShape = static_cast<const btUniformScalingShape*>(shape);
				const btConvexShape* convexShape = scalingShape->getChildShape();
				float	scalingFactor = (float)scalingShape->getUniformScalingFactor();
				{
					btScalar tmpScaling[4][4]={{scalingFactor,0,0,0},
					{0,scalingFactor,0,0},
					{0,0,scalingFactor,0},
					{0,0,0,1}};

					drawOpenGL( (btScalar*)tmpScaling,convexShape,color,debugMode,worldBoundsMin,worldBoundsMax, uid);
				}
				//cout << "b\n";
				//glPopMatrix();
				//updateMat2();
				popMat();
				return;
			}

			if (shape->getShapeType() == COMPOUND_SHAPE_PROXYTYPE)
			{
				const btCompoundShape* compoundShape = static_cast<const btCompoundShape*>(shape);
				for (int i=compoundShape->getNumChildShapes()-1;i>=0;i--)
				{
					btTransform childTrans = compoundShape->getChildTransform(i);
					const btCollisionShape* colShape = compoundShape->getChildShape(i);
					ATTRIBUTE_ALIGNED16(btScalar) childMat[16];
					childTrans.getOpenGLMatrix(childMat);
					drawOpenGL(childMat,colShape,color,debugMode,worldBoundsMin,worldBoundsMax, uid);
				}

			} else
			{
				// if(m_textureenabled&&(!m_textureinitialized))
				// {
				// 	GLubyte*	image=new GLubyte[256*256*4];
				// 	for(int y=0;y<256;++y)
				// 	{
				// 		const int	t=y>>4;
				// 		GLubyte*	pi=image+y*256*3;
				// 		for(int x=0;x<256;++x)
				// 		{
				// 			const int		s=x>>4;
				// 			const GLubyte	b=180;					
				// 			GLubyte			c=b+((s+(t&1))&1)*(255-b);
				// 			pi[0]=pi[1]=pi[2]=pi[3]=c;pi+=3;
				// 		}
				// 	}

				// 	glGenTextures(1,(GLuint*)&m_texturehandle);
				// 	glBindTexture(GL_TEXTURE_2D,m_texturehandle);


		  //             glGenTextures(1,(GLuint*)&m_texturehandle);
		  //              glBindTexture(GL_TEXTURE_2D,m_texturehandle);
				// glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
		  //               glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
		  //               glTexImage2D(GL_TEXTURE_2D, 0, 3, 256 , 256 , 0, GL_RGB, GL_UNSIGNED_BYTE, image);
				// //glGenerateMipmap(GL_TEXTURE_2D);
				//   delete[] image;

					
				// }

				// glMatrixMode(GL_TEXTURE);
				// glLoadIdentity();
				// glScalef(0.025f,0.025f,0.025f);
				// glMatrixMode(GL_MODELVIEW);

				// static const GLfloat	planex[]={1,0,0,0};
				// //	static const GLfloat	planey[]={0,1,0,0};
				// 	static const GLfloat	planez[]={0,0,1,0};
				// 	glTexGenfv(GL_S,GL_OBJECT_PLANE,planex);
				// 	glTexGenfv(GL_T,GL_OBJECT_PLANE,planez);
				// 	glTexGeni(GL_S,GL_TEXTURE_GEN_MODE,GL_OBJECT_LINEAR);
				// 	glTexGeni(GL_T,GL_TEXTURE_GEN_MODE,GL_OBJECT_LINEAR);
					//glEnable(GL_TEXTURE_GEN_S);
					//glEnable(GL_TEXTURE_GEN_T);
					//glEnable(GL_TEXTURE_GEN_R);
				//	m_textureinitialized=true;

				
					

				//drawCoordSystem();

				//glEnable(GL_COLOR_MATERIAL);
				// if(m_textureenabled) 
				// {
				// 	//glEnable(GL_TEXTURE_2D);
				// 	glBindTexture(GL_TEXTURE_2D,m_texturehandle);
				// } else
				// {
				// 	//glDisable(GL_TEXTURE_2D);
				// }


				//glColor3f(color.x(),color.y(), color.z());		

				//bool useWireframeFallback = true;

				if (!(debugMode & btIDebugDraw::DBG_DrawWireframe))
				{
					///you can comment out any of the specific cases, and use the default

					///the benefit of 'default' is that it approximates the actual collision shape including collision margin
					//int shapetype=m_textureenabled?MAX_BROADPHASE_COLLISION_TYPES:shape->getShapeType();
					int shapetype=shape->getShapeType();
					switch (shapetype)
					{

						case SPHERE_SHAPE_PROXYTYPE:
						{
							const btSphereShape* sphereShape = static_cast<const btSphereShape*>(shape);
							float radius = sphereShape->getMargin();//radius doesn't include the margin, so draw with margin
							drawSphere(radius,10,10);
							//useWireframeFallback = false;
							break;
						}

						case BOX_SHAPE_PROXYTYPE:
						{
							//ffffffffff
							
							const btBoxShape* boxShape = static_cast<const btBoxShape*>(shape);
							btVector3 halfExtent = boxShape->getHalfExtentsWithMargin();
							
							static int indices[36] = {
								0,1,2,
								3,2,1,
								4,0,6,
								6,0,2,
								5,1,4,
								4,1,0,
								7,3,1,
								7,1,5,
								5,4,7,
								7,4,6,
								7,2,3,
								7,6,2};

							 btVector3 vertices[8]={	
								btVector3(halfExtent[0],halfExtent[1],halfExtent[2]),
								btVector3(-halfExtent[0],halfExtent[1],halfExtent[2]),
								btVector3(halfExtent[0],-halfExtent[1],halfExtent[2]),	
								btVector3(-halfExtent[0],-halfExtent[1],halfExtent[2]),	
								btVector3(halfExtent[0],halfExtent[1],-halfExtent[2]),
								btVector3(-halfExtent[0],halfExtent[1],-halfExtent[2]),	
								btVector3(halfExtent[0],-halfExtent[1],-halfExtent[2]),	
								btVector3(-halfExtent[0],-halfExtent[1],-halfExtent[2])};
		#if 1
							
							if (singleton->drawOrient) {
								drawOrient(uid);
							}
							else {
								glBegin (GL_TRIANGLES);
								int si=36;
								for (int i=0;i<si;i+=3)
								{
									const btVector3& v1 = vertices[indices[i]];;
									const btVector3& v2 = vertices[indices[i+1]];
									const btVector3& v3 = vertices[indices[i+2]];
									btVector3 normal = (v3-v1).cross(v2-v1);
									normal.normalize ();
									glNormal3f(normal.getX(),normal.getY(),normal.getZ());
									glVertex3f (v1.x(), v1.y(), v1.z());
									glVertex3f (v2.x(), v2.y(), v2.z());
									glVertex3f (v3.x(), v3.y(), v3.z());
									
								}
								glEnd();
							}
							
							
							
		#endif

							//useWireframeFallback = false;
							break;
						}



		#if 0
					
					case CONE_SHAPE_PROXYTYPE:
						{
							const btConeShape* coneShape = static_cast<const btConeShape*>(shape);
							int upIndex = coneShape->getConeUpIndex();
							float radius = coneShape->getRadius();//+coneShape->getMargin();
							float height = coneShape->getHeight();//+coneShape->getMargin();
							switch (upIndex)
							{
							case 0:
								glRotatef(90.0, 0.0, 1.0, 0.0);
								break;
							case 1:
								glRotatef(-90.0, 1.0, 0.0, 0.0);
								break;
							case 2:
								break;
							default:
								{
								}
							};

							glTranslatef(0.0, 0.0, -0.5*height);
							glutSolidCone(radius,height,10,10);
							//useWireframeFallback = false;
							break;

						}
		#endif

					case STATIC_PLANE_PROXYTYPE:
						{
							const btStaticPlaneShape* staticPlaneShape = static_cast<const btStaticPlaneShape*>(shape);
							btScalar planeConst = staticPlaneShape->getPlaneConstant();
							const btVector3& planeNormal = staticPlaneShape->getPlaneNormal();
							btVector3 planeOrigin = planeNormal * planeConst;
							btVector3 vec0,vec1;
							btPlaneSpace1(planeNormal,vec0,vec1);
							btScalar vecLen = 100.f;
							btVector3 pt0 = planeOrigin + vec0*vecLen;
							btVector3 pt1 = planeOrigin - vec0*vecLen;
							btVector3 pt2 = planeOrigin + vec1*vecLen;
							btVector3 pt3 = planeOrigin - vec1*vecLen;
							// glBegin(GL_LINES);
							// glVertex3f(pt0.getX(),pt0.getY(),pt0.getZ());
							// glVertex3f(pt1.getX(),pt1.getY(),pt1.getZ());
							// glVertex3f(pt2.getX(),pt2.getY(),pt2.getZ());
							// glVertex3f(pt3.getX(),pt3.getY(),pt3.getZ());
							// glEnd();


							break;

						}




					case MULTI_SPHERE_SHAPE_PROXYTYPE:
					{
						const btMultiSphereShape* multiSphereShape = static_cast<const btMultiSphereShape*>(shape);

						btTransform childTransform;
						childTransform.setIdentity();

						
						for (int i = multiSphereShape->getSphereCount()-1; i>=0;i--)
						{
							btSphereShape sc(multiSphereShape->getSphereRadius(i));
							childTransform.setOrigin(multiSphereShape->getSpherePosition(i));
							ATTRIBUTE_ALIGNED16(btScalar) childMat[16];
							childTransform.getOpenGLMatrix(childMat);
							drawOpenGL(childMat,&sc,color,debugMode,worldBoundsMin,worldBoundsMax, uid);
						}

						break;
					}

					default:
						{
							if (shape->isConvex())
							{
								const btConvexPolyhedron* poly = shape->isPolyhedral() ? ((btPolyhedralConvexShape*) shape)->getConvexPolyhedron() : 0;
								if (poly)
								{
									int i;
									
									if (singleton->drawOrient) {
										drawOrient(uid);
									}
									else {
										
										glBegin (GL_TRIANGLES);
										for (i=0;i<poly->m_faces.size();i++)
										{
											btVector3 centroid(0,0,0);
											int numVerts = poly->m_faces[i].m_indices.size();
											if (numVerts>2)
											{
												btVector3 v1 = poly->m_vertices[poly->m_faces[i].m_indices[0]];
												for (int v=0;v<poly->m_faces[i].m_indices.size()-2;v++)
												{
													
													btVector3 v2 = poly->m_vertices[poly->m_faces[i].m_indices[v+1]];
													btVector3 v3 = poly->m_vertices[poly->m_faces[i].m_indices[v+2]];
													btVector3 normal = (v3-v1).cross(v2-v1);
													normal.normalize ();
													glNormal3f(normal.getX(),normal.getY(),normal.getZ());
													glVertex3f (v1.x(), v1.y(), v1.z());
													glVertex3f (v2.x(), v2.y(), v2.z());
													glVertex3f (v3.x(), v3.y(), v3.z());
												}
											}
										}
										glEnd ();
									}
									
									
								} else
								{
									ShapeCache*	sc=cache((btConvexShape*)shape);
									//glutSolidCube(1.0);
									btShapeHull* hull = &sc->m_shapehull/*(btShapeHull*)shape->getUserPointer()*/;

									if (hull->numTriangles () > 0)
									{
										int index = 0;
										const unsigned int* idx = hull->getIndexPointer();
										const btVector3* vtx = hull->getVertexPointer();

										if (singleton->drawOrient) {
											drawOrient(uid);
										}
										else {
											glBegin (GL_TRIANGLES);

											for (int i = 0; i < hull->numTriangles (); i++)
											{
												int i1 = index++;
												int i2 = index++;
												int i3 = index++;
												btAssert(i1 < hull->numIndices () &&
													i2 < hull->numIndices () &&
													i3 < hull->numIndices ());

												int index1 = idx[i1];
												int index2 = idx[i2];
												int index3 = idx[i3];
												btAssert(index1 < hull->numVertices () &&
													index2 < hull->numVertices () &&
													index3 < hull->numVertices ());

												btVector3 v1 = vtx[index1];
												btVector3 v2 = vtx[index2];
												btVector3 v3 = vtx[index3];
												btVector3 normal = (v3-v1).cross(v2-v1);
												normal.normalize();
												glNormal3f(normal.getX(),normal.getY(),normal.getZ());
												glVertex3f (v1.x(), v1.y(), v1.z());
												glVertex3f (v2.x(), v2.y(), v2.z());
												glVertex3f (v3.x(), v3.y(), v3.z());

											}
											glEnd ();
										}
										

									}
								}
							}
							else {
								
								
								// btBvhTriangleMeshShape* concaveMesh = (btBvhTriangleMeshShape*) shape;
								// GlDrawcallback drawCallback;
								// drawCallback.m_wireframe = false;
								
								// glBegin(GL_TRIANGLES);
								
								// concaveMesh->processAllTriangles(&drawCallback,worldBoundsMin,worldBoundsMax);
								
								// glEnd();
								
								
							}
						}
					}

				}


				//glNormal3f(0,1,0);
			

				/// for polyhedral shapes
				if (debugMode==btIDebugDraw::DBG_DrawFeaturesText && (shape->isPolyhedral()))
				{
					btPolyhedralConvexShape* polyshape = (btPolyhedralConvexShape*) shape;

					{

						//glColor3f(1.f, 1.f, 1.f);
						int i;
						for (i=0;i<polyshape->getNumVertices();i++)
						{
							btVector3 vtx;
							polyshape->getVertex(i,vtx);
							char buf[12];
							sprintf(buf," %d",i);
							//btDrawString(BMF_GetFont(BMF_kHelvetica10),buf);
						}

						for (i=0;i<polyshape->getNumPlanes();i++)
						{
							btVector3 normal;
							btVector3 vtx;
							polyshape->getPlane(normal,vtx,i);
							//btScalar d = vtx.dot(normal);

							//char buf[12];
							//sprintf(buf," plane %d",i);
							//btDrawString(BMF_GetFont(BMF_kHelvetica10),buf);

						}
					}

				}








			}
			//cout << "c\n";
			//glPopMatrix();
			//updateMat2();
			popMat();

			//glDisable(GL_TEXTURE_2D);
		}
MyShapeDrawer::~ MyShapeDrawer ()
                {
			int i;
			for (i=0;i<m_shapecaches.size();i++)
			{
				m_shapecaches[i]->~ShapeCache();
				btAlignedFree(m_shapecaches[i]);
			}
			m_shapecaches.clear();
			/*if(m_textureinitialized)
			{
			//	glDeleteTextures(1,(const GLuint*) &m_texturehandle);
			}*/
		}
void MyShapeDrawer::drawSceneInternal (btDiscreteDynamicsWorld const * dynamicsWorld, int pass)
                {

			btAssert(dynamicsWorld);

			
			btScalar	m[16];
			btMatrix3x3	rot;rot.setIdentity();
			const int	numObjects=dynamicsWorld->getNumCollisionObjects();
			btVector3 wireColor(1,0,0);
			
			
			
			for(int i=0;i<numObjects;i++)
			{
				const btCollisionObject*	colObj=dynamicsWorld->getCollisionObjectArray()[i];
				const btRigidBody*		body=btRigidBody::upcast(colObj);
				
				setId( body->bodyUID, body->limbUID );//max(,0) );
				
				if(body&&body->getMotionState())
				{
					btDefaultMotionState* myMotionState = (btDefaultMotionState*)body->getMotionState();
					myMotionState->m_graphicsWorldTrans.getOpenGLMatrix(m);
					rot=myMotionState->m_graphicsWorldTrans.getBasis();
				}
				else
				{
					colObj->getWorldTransform().getOpenGLMatrix(m);
					rot=colObj->getWorldTransform().getBasis();
				}
				btVector3 wireColor(1.f,1.0f,0.5f); //wants deactivation
				if(i&1) wireColor=btVector3(0.f,0.0f,1.f);
				///color differently for active, sleeping, wantsdeactivation states
				if (colObj->getActivationState() == 1) //active
				{
					if (i & 1)
					{
						wireColor += btVector3 (1.f,0.f,0.f);
					}
					else
					{
						wireColor += btVector3 (.5f,0.f,0.f);
					}
				}
				if(colObj->getActivationState()==2) //ISLAND_SLEEPING
				{
					if(i&1)
					{
						wireColor += btVector3 (0.f,1.f, 0.f);
					}
					else
					{
						wireColor += btVector3 (0.f,0.5f,0.f);
					}
				}

				btVector3 aabbMin(0,0,0),aabbMax(0,0,0);
				//m_dynamicsWorld->getBroadphase()->getBroadphaseAabb(aabbMin,aabbMax);

				aabbMin-=btVector3(BT_LARGE_FLOAT,BT_LARGE_FLOAT,BT_LARGE_FLOAT);
				aabbMax+=btVector3(BT_LARGE_FLOAT,BT_LARGE_FLOAT,BT_LARGE_FLOAT);
			//		printf("aabbMin=(%f,%f,%f)\n",aabbMin.getX(),aabbMin.getY(),aabbMin.getZ());
			//		printf("aabbMax=(%f,%f,%f)\n",aabbMax.getX(),aabbMax.getY(),aabbMax.getZ());
			//		m_dynamicsWorld->getDebugDrawer()->drawAabb(aabbMin,aabbMax,btVector3(1,1,1));

				//switch(pass)
				
				//if (!(getDebugMode()& btIDebugDraw::DBG_DrawWireframe))
				int debugMode = 0;//getDebugMode()
				//btVector3 m_sundirection(-1,-1,-1);
				btVector3 m_sundirection(btVector3(1,-2,1)*1000);
						
				// switch(pass)
				// {
				// 	// case	0:	drawOpenGL(m,colObj->getCollisionShape(),wireColor,debugMode,aabbMin,aabbMax);break;
				// 	// case	1:	drawShadow(m,m_sundirection*rot,colObj->getCollisionShape(),aabbMin,aabbMax);break;
				// 	//case	2:	drawOpenGL(m,colObj->getCollisionShape(),wireColor*btScalar(0.3),0,aabbMin,aabbMax);break;
					
					
				// }
				
				
				bool doProc = true;
				
				if (body->bodyUID >= 0) {
					BaseObj* ge = &(singleton->gem->gameObjects[body->bodyUID]);
					
					if (body->limbUID >= 0) {
						doProc = ge->bodies[body->limbUID].isVisible;
					}
				}
				
				
				
				// if (
				// 	(body->bodyUID == singleton->gem->getCurActorUID())&&singleton->orgOn
				// ) {
					
				// }
				// else {
				
				if (doProc) {
					drawOpenGL(m,colObj->getCollisionShape(),wireColor,debugMode,aabbMin,aabbMax, body->bodyUID);
				}
				
					
				//}
				
				
				//drawOpenGL(m,colObj->getCollisionShape(),wireColor*btScalar(0.3),0,aabbMin,aabbMax);
			}

		}
void MyShapeDrawer::drawScene (btDiscreteDynamicsWorld const * dynamicsWorld, bool useShadows)
                {
		/*
			GLfloat light_ambient[] = { btScalar(0.2), btScalar(0.2), btScalar(0.2), btScalar(1.0) };
			GLfloat light_diffuse[] = { btScalar(1.0), btScalar(1.0), btScalar(1.0), btScalar(1.0) };
			GLfloat light_specular[] = { btScalar(1.0), btScalar(1.0), btScalar(1.0), btScalar(1.0 )};
			
			GLfloat light_position0[] = { btScalar(1.0), btScalar(10.0), btScalar(1.0), btScalar(0.0 )};
			GLfloat light_position1[] = { btScalar(-1.0), btScalar(-10.0), btScalar(-1.0), btScalar(0.0) };

			glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
			glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
			glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
			glLightfv(GL_LIGHT0, GL_POSITION, light_position0);

			glLightfv(GL_LIGHT1, GL_AMBIENT, light_ambient);
			glLightfv(GL_LIGHT1, GL_DIFFUSE, light_diffuse);
			glLightfv(GL_LIGHT1, GL_SPECULAR, light_specular);
			glLightfv(GL_LIGHT1, GL_POSITION, light_position1);

			glEnable(GL_LIGHTING);
			glEnable(GL_LIGHT0);
			glEnable(GL_LIGHT1);


			glShadeModel(GL_SMOOTH);
			glEnable(GL_DEPTH_TEST);
			glDepthFunc(GL_LESS);

			glClearColor(btScalar(0.7),btScalar(0.7),btScalar(0.7),btScalar(0));


			if(useShadows)
				{
					glClear(GL_STENCIL_BUFFER_BIT);
					glEnable(GL_CULL_FACE);
					drawSceneInternal(dynamicsWorld,0);

					glDisable(GL_LIGHTING);
					glDepthMask(GL_FALSE);
					glDepthFunc(GL_LEQUAL);
					glEnable(GL_STENCIL_TEST);
					glColorMask(GL_FALSE,GL_FALSE,GL_FALSE,GL_FALSE);
					glStencilFunc(GL_ALWAYS,1,0xFFFFFFFFL);
					glFrontFace(GL_CCW);
					glStencilOp(GL_KEEP,GL_KEEP,GL_INCR);
					drawSceneInternal(dynamicsWorld,1);
					glFrontFace(GL_CW);
					glStencilOp(GL_KEEP,GL_KEEP,GL_DECR);
					drawSceneInternal(dynamicsWorld,1);
					glFrontFace(GL_CCW);

					glPolygonMode(GL_FRONT,GL_FILL);
					glPolygonMode(GL_BACK,GL_FILL);
					glShadeModel(GL_SMOOTH);
					glEnable(GL_DEPTH_TEST);
					glDepthFunc(GL_LESS);
					glEnable(GL_LIGHTING);
					glDepthMask(GL_TRUE);
					glCullFace(GL_BACK);
					glFrontFace(GL_CCW);
					glEnable(GL_CULL_FACE);
					glColorMask(GL_TRUE,GL_TRUE,GL_TRUE,GL_TRUE);

					glDepthFunc(GL_LEQUAL);
					glStencilFunc( GL_NOTEQUAL, 0, 0xFFFFFFFFL );
					glStencilOp( GL_KEEP, GL_KEEP, GL_KEEP );
					glDisable(GL_LIGHTING);
					drawSceneInternal(dynamicsWorld,2);
					glEnable(GL_LIGHTING);
					glDepthFunc(GL_LESS);
					glDisable(GL_STENCIL_TEST);
					glDisable(GL_CULL_FACE);
				}
				else
				{
					glDisable(GL_CULL_FACE);
					drawSceneInternal(dynamicsWorld,0);
				}
			*/
				
			drawSceneInternal(dynamicsWorld,0);
		}
#undef LZZ_INLINE
 
// f00374_myglhelper.h
//

#include "f00374_myglhelper.e"
#define LZZ_INLINE inline
MyGLHelper::MyGLHelper (Singleton * _singleton, CommonGraphicsApp * glApp)
        {
		singleton = _singleton;
		m_data = new MyGLHelperInternalData;
		m_data->m_glApp = glApp;
		m_data->m_debugDraw = 0;
		

		m_data->m_gl2ShapeDrawer = new MyShapeDrawer(singleton);
	}
MyGLHelper::~ MyGLHelper ()
        {
		delete m_data->m_gl2ShapeDrawer;
		delete m_data;
	}
struct CommonRenderInterface * MyGLHelper::getRenderInterface ()
        {
		return m_data->m_glApp->m_renderer;
	}
void MyGLHelper::createRigidBodyGraphicsObject (btRigidBody * body, btVector3 const & color)
        {
		createCollisionObjectGraphicsObject(body,color);
	}
void MyGLHelper::createCollisionObjectGraphicsObject (btCollisionObject * body, btVector3 const & color)
        {
		if (body->getUserIndex()<0)
		{
			btCollisionShape* shape = body->getCollisionShape();
			btTransform startTransform = body->getWorldTransform();
			int graphicsShapeId = shape->getUserIndex();
			if (graphicsShapeId>=0)
			{
			//	btAssert(graphicsShapeId >= 0);
				//the graphics shape is already scaled
				btVector3 localScaling(1,1,1);
				int graphicsInstanceId = m_data->m_glApp->m_renderer->registerGraphicsInstance(graphicsShapeId, startTransform.getOrigin(), startTransform.getRotation(), color, localScaling);
				body->setUserIndex(graphicsInstanceId);
			}
		}
	}
int MyGLHelper::registerGraphicsShape (float const * vertices, int numvertices, int const * indices, int numIndices)
        {
		int shapeId = m_data->m_glApp->m_renderer->registerShape(vertices, numvertices,indices,numIndices);
		return shapeId;
	}
int MyGLHelper::registerGraphicsInstance (int shapeIndex, float const * position, float const * quaternion, float const * color, float const * scaling)
        {
		return m_data->m_glApp->m_renderer->registerGraphicsInstance(shapeIndex,position,quaternion,color,scaling);
	}
void MyGLHelper::createCollisionShapeGraphicsObjectInternal (btCollisionShape * collisionShape, btTransform const & parentTransform, btAlignedObjectArray <GLInstanceVertex> & verticesOut, btAlignedObjectArray <int> & indicesOut)
        {
	//todo: support all collision shape types
		switch (collisionShape->getShapeType())
		{
			case SOFTBODY_SHAPE_PROXYTYPE:
			{
				//skip the soft body collision shape for now
				break;
			}
			case STATIC_PLANE_PROXYTYPE:
			{
				//draw a box, oriented along the plane normal
				const btStaticPlaneShape* staticPlaneShape = static_cast<const btStaticPlaneShape*>(collisionShape);
				btScalar planeConst = staticPlaneShape->getPlaneConstant();
				const btVector3& planeNormal = staticPlaneShape->getPlaneNormal();
				btVector3 planeOrigin = planeNormal * planeConst;
				btVector3 vec0,vec1;
				btPlaneSpace1(planeNormal,vec0,vec1);
				btScalar vecLen = 100.f;
				btVector3 verts[4];

				verts[0] = planeOrigin + vec0*vecLen + vec1*vecLen;
				verts[1] = planeOrigin - vec0*vecLen + vec1*vecLen;
				verts[2] = planeOrigin - vec0*vecLen - vec1*vecLen;
				verts[3] = planeOrigin + vec0*vecLen - vec1*vecLen;
					
				int startIndex = verticesOut.size();
				indicesOut.push_back(startIndex+0);
				indicesOut.push_back(startIndex+1);
				indicesOut.push_back(startIndex+2);
				indicesOut.push_back(startIndex+0);
				indicesOut.push_back(startIndex+2);
				indicesOut.push_back(startIndex+3);

				btVector3 triNormal = parentTransform.getBasis()*planeNormal;
					

				for (int i=0;i<4;i++)
				{
					GLInstanceVertex vtx;
					btVector3 pos =parentTransform*verts[i];
					vtx.xyzw[0] = pos.x();
					vtx.xyzw[1] = pos.y();
					vtx.xyzw[2] = pos.z();
					vtx.xyzw[3] = 0.f;

					vtx.normal[0] =triNormal.x();
					vtx.normal[1] =triNormal.y();
					vtx.normal[2] =triNormal.z();

					vtx.uv[0] = 0.5f;
					vtx.uv[1] = 0.5f;
					verticesOut.push_back(vtx);
				}
				break;
			}
			case TRIANGLE_MESH_SHAPE_PROXYTYPE:
			{
				

				btBvhTriangleMeshShape* trimesh = (btBvhTriangleMeshShape*) collisionShape;
				btVector3 trimeshScaling = trimesh->getLocalScaling();
				btStridingMeshInterface* meshInterface = trimesh->getMeshInterface();
				btAlignedObjectArray<btVector3> vertices;
				btAlignedObjectArray<int> indices;
					
				for (int partId=0;partId<meshInterface->getNumSubParts();partId++)
				{
						
					const unsigned char *vertexbase = 0;
					int numverts = 0;
					PHY_ScalarType type = PHY_INTEGER;
					int stride = 0;
					const unsigned char *indexbase = 0;
					int indexstride = 0;
					int numfaces = 0;
					PHY_ScalarType indicestype = PHY_INTEGER;
					//PHY_ScalarType indexType=0;
						
					btVector3 triangleVerts[3];
					meshInterface->getLockedReadOnlyVertexIndexBase(&vertexbase,numverts,	type,stride,&indexbase,indexstride,numfaces,indicestype,partId);
					btVector3 aabbMin,aabbMax;
						
					for (int triangleIndex = 0 ; triangleIndex < numfaces;triangleIndex++)
					{
						unsigned int* gfxbase = (unsigned int*)(indexbase+triangleIndex*indexstride);
							
						for (int j=2;j>=0;j--)
						{
								
							int graphicsindex = indicestype==PHY_SHORT?((unsigned short*)gfxbase)[j]:gfxbase[j];
							if (type == PHY_FLOAT)
							{
								float* graphicsbase = (float*)(vertexbase+graphicsindex*stride);
								triangleVerts[j] = btVector3(
																graphicsbase[0]*trimeshScaling.getX(),
																graphicsbase[1]*trimeshScaling.getY(),
																graphicsbase[2]*trimeshScaling.getZ());
							}
							else
							{
								double* graphicsbase = (double*)(vertexbase+graphicsindex*stride);
								triangleVerts[j] = btVector3( btScalar(graphicsbase[0]*trimeshScaling.getX()),
																btScalar(graphicsbase[1]*trimeshScaling.getY()),
																btScalar(graphicsbase[2]*trimeshScaling.getZ()));
							}
						}
						indices.push_back(vertices.size());
						vertices.push_back(triangleVerts[0]);
						indices.push_back(vertices.size());
						vertices.push_back(triangleVerts[1]);
						indices.push_back(vertices.size());
						vertices.push_back(triangleVerts[2]);

						btVector3 triNormal = (triangleVerts[1]-triangleVerts[0]).cross(triangleVerts[2]-triangleVerts[0]);
						triNormal.normalize();

						for (int v=0;v<3;v++)
						{
							GLInstanceVertex vtx;
							btVector3 pos =parentTransform*triangleVerts[v];
							vtx.xyzw[0] = pos.x();
							vtx.xyzw[1] = pos.y();
							vtx.xyzw[2] = pos.z();
							vtx.xyzw[3] = 0.f;


							vtx.normal[0] =triNormal.x();
							vtx.normal[1] =triNormal.y();
							vtx.normal[2] =triNormal.z();

							vtx.uv[0] = 0.5f;
							vtx.uv[1] = 0.5f;

							indicesOut.push_back(verticesOut.size());
							verticesOut.push_back(vtx);
						}

						
					}
				}
				
				break;
			}
			default:
			{
				if (collisionShape->isConvex())
				{
					btConvexShape* convex = (btConvexShape*)collisionShape;
					{
						btShapeHull* hull = new btShapeHull(convex);
						hull->buildHull(0.0);

						{
							//int strideInBytes = 9*sizeof(float);
							//int numVertices = hull->numVertices();
							//int numIndices =hull->numIndices();

							for (int t=0;t<hull->numTriangles();t++)
							{

								btVector3 triNormal;

								int index0 = hull->getIndexPointer()[t*3+0];
								int index1 = hull->getIndexPointer()[t*3+1];
								int index2 = hull->getIndexPointer()[t*3+2];
								btVector3 pos0 =parentTransform*hull->getVertexPointer()[index0];
								btVector3 pos1 =parentTransform*hull->getVertexPointer()[index1];
								btVector3 pos2 =parentTransform*hull->getVertexPointer()[index2];
								triNormal = (pos1-pos0).cross(pos2-pos0);
								triNormal.normalize();

								for (int v=0;v<3;v++)
								{
									int index = hull->getIndexPointer()[t*3+v];
									GLInstanceVertex vtx;
									btVector3 pos =parentTransform*hull->getVertexPointer()[index];
									vtx.xyzw[0] = pos.x();
									vtx.xyzw[1] = pos.y();
									vtx.xyzw[2] = pos.z();
									vtx.xyzw[3] = 0.f;

									vtx.normal[0] =triNormal.x();
									vtx.normal[1] =triNormal.y();
									vtx.normal[2] =triNormal.z();

									vtx.uv[0] = 0.5f;
									vtx.uv[1] = 0.5f;

									indicesOut.push_back(verticesOut.size());
									verticesOut.push_back(vtx);
								}
							}
						}
					}
				} else
				{
					if (collisionShape->isCompound())
					{
						btCompoundShape* compound = (btCompoundShape*) collisionShape;
						for (int i=0;i<compound->getNumChildShapes();i++)
						{

							btTransform childWorldTrans = parentTransform * compound->getChildTransform(i);
							createCollisionShapeGraphicsObjectInternal(compound->getChildShape(i),childWorldTrans,verticesOut,indicesOut);
						}
					} else
					{
						btAssert(0);
					}
						
				}
			}
		};
	}
void MyGLHelper::createCollisionShapeGraphicsObject (btCollisionShape * collisionShape)
        {
		//already has a graphics object?
		if (collisionShape->getUserIndex()>=0)
			return;

		btAlignedObjectArray<GLInstanceVertex> vertices;
		btAlignedObjectArray<int> indices;
		btTransform startTrans;startTrans.setIdentity();

		createCollisionShapeGraphicsObjectInternal(collisionShape,startTrans,vertices,indices);

		if (vertices.size() && indices.size())
		{
			int shapeId = m_data->m_glApp->m_renderer->registerShape(&vertices[0].xyzw[0],vertices.size(),&indices[0],indices.size());
			collisionShape->setUserIndex(shapeId);
		}
			
	}
void MyGLHelper::syncPhysicsToGraphics (btDiscreteDynamicsWorld const * rbWorld)
        {
		int numCollisionObjects = rbWorld->getNumCollisionObjects();
		for (int i = 0; i<numCollisionObjects; i++)
		{
						
			
			btCollisionObject* colObj = rbWorld->getCollisionObjectArray()[i];
			btVector3 pos = colObj->getWorldTransform().getOrigin();
			btQuaternion orn = colObj->getWorldTransform().getRotation();
			int index = colObj->getUserIndex();
			if (index >= 0)
			{
				m_data->m_glApp->m_renderer->writeSingleInstanceTransformToCPU(pos, orn, index);
			}
		}
		m_data->m_glApp->m_renderer->writeTransforms();
	}
void MyGLHelper::render (btDiscreteDynamicsWorld const * rbWorld)
        {
		

		m_data->m_glApp->m_renderer->renderScene();
		//backwards compatible OpenGL2 rendering

		if (m_data->m_gl2ShapeDrawer && rbWorld)
		{
			
			
			//m_data->m_gl2ShapeDrawer->enableTexture(true);
			m_data->m_gl2ShapeDrawer->drawScene(rbWorld,true);
		}
	}
void MyGLHelper::createPhysicsDebugDrawer (btDiscreteDynamicsWorld * rbWorld)
        {
		btAssert(rbWorld);
	    m_data->m_debugDraw = new MyDebugDrawer(m_data->m_glApp);
	    rbWorld->setDebugDrawer(m_data->m_debugDraw );


	    m_data->m_debugDraw->setDebugMode(
	        btIDebugDraw::DBG_DrawWireframe
	        +btIDebugDraw::DBG_DrawAabb
	        //btIDebugDraw::DBG_DrawContactPoints
	        );

	}
struct Common2dCanvasInterface * MyGLHelper::get2dCanvasInterface ()
        {
		return m_data->m_glApp->m_2dCanvasInterface;
	}
CommonParameterInterface * MyGLHelper::getParameterInterface ()
        {
		return m_data->m_glApp->m_parameterInterface;
	}
void MyGLHelper::setUpAxis (int axis)
        {
		m_data->m_glApp->setUpAxis(axis);
	}
void MyGLHelper::resetCamera (float camDist, float pitch, float yaw, float camPosX, float camPosY, float camPosZ)
        {
		if (getRenderInterface() && getRenderInterface()->getActiveCamera())
		{
			getRenderInterface()->getActiveCamera()->setCameraDistance(camDist);
			getRenderInterface()->getActiveCamera()->setCameraPitch(pitch);
			getRenderInterface()->getActiveCamera()->setCameraYaw(yaw);
			getRenderInterface()->getActiveCamera()->setCameraTargetPosition(camPosX,camPosY,camPosZ);
		}
	}
void MyGLHelper::autogenerateGraphicsObjects (btDiscreteDynamicsWorld * rbWorld)
        {
		//sort the collision objects based on collision shape, the gfx library requires instances that re-use a shape to be added after eachother

		btAlignedObjectArray<btCollisionObject*> sortedObjects;
		sortedObjects.reserve(rbWorld->getNumCollisionObjects());
		for (int i=0;i<rbWorld->getNumCollisionObjects();i++)
		{
			btCollisionObject* colObj = rbWorld->getCollisionObjectArray()[i];
			sortedObjects.push_back(colObj);
		}
		sortedObjects.quickSort(shapePointerCompareFunc);
		for (int i=0;i<sortedObjects.size();i++)
		{
			btCollisionObject* colObj = sortedObjects[i];
			//btRigidBody* body = btRigidBody::upcast(colObj);
			//does this also work for btMultiBody/btMultiBodyLinkCollider?
			createCollisionShapeGraphicsObject(colObj->getCollisionShape());
			int colorIndex = colObj->getBroadphaseHandle()->getUid() & 3;

			btVector3 color= sColors[colorIndex];
			createCollisionObjectGraphicsObject(colObj,color);
				
		}
	}
void MyGLHelper::drawText3D (char const * txt, float posX, float posY, float posZ, float size)
        {
	    btAssert(m_data->m_glApp);
	    m_data->m_glApp->drawText3D(txt,posX,posY,posZ,size);
	}
struct CommonGraphicsApp * MyGLHelper::getAppInterface ()
        {
		return m_data->m_glApp;
	}
#undef LZZ_INLINE
 
// f00375_gamephysics.h
//

#include "f00375_gamephysics.e"
#define LZZ_INLINE inline
GamePhysics::GamePhysics ()
                      {
		
		lastBodyPick = NULL;
		lastBodyUID = -1;
		
		
	}
void GamePhysics::init (Singleton * _singleton)
        {
		orig = btVector3(0.0f,0.0f,0.0f);
		xyMask = btVector3(1.0f,1.0f,0.0f);
		zMask = btVector3(0.0f,0.0f,1.0f);
		
		CONTACT_THRESH = 0.2f;
		//totTime = 0.0;
		BASE_ENT_HEIGHT = 2.0f*ORG_SCALE_BASE;
		BASE_ENT_RAD = 1.0f*ORG_SCALE_BASE;
		
		cout << "GamePhysics:init()\n";
		
		singleton = _singleton;
		myOGLApp = new MyOGLApp("yo", 640, 480);
		guiHelper = new MyGLHelper(singleton, myOGLApp);
		example = new BenchmarkDemo(guiHelper,5);
		example->initPhysics();
		
		
		example->getWorld()->getPairCache()->setOverlapFilterCallback(new CustFilterCallback());
		
		
	}
void GamePhysics::pickBody (FIVector4 * mouseMoveOPD)
                                               {
		
		if (!(singleton->gem->editPose)) {
			lastBodyPick = NULL;
			lastBodyUID = -1;
			return;
		}
		
		int bodyUID = mouseMoveOPD->getFW();
		int limbUID = mouseMoveOPD->getFZ();
		BaseObj* ge;
		
		if (
			(bodyUID > 0) &&
			(limbUID > -1)	
		) {
			ge = &(singleton->gem->gameObjects[bodyUID]);
			lastBodyPick = ge->bodies[limbUID].body;
			lastBodyUID = bodyUID;
		}
		else {
			lastBodyPick = NULL;
			lastBodyUID = -1;
		}
	}
void GamePhysics::collectDebris ()
                             {
		int i;
		FIVector4 tempVec;
		int entNum;
		
		for (i = 0; i < singleton->debrisStack.size(); i++) {
			
			tempVec.setBTV(singleton->debrisStack[i].pos);
			entNum = singleton->gem->placeNewEnt(false, E_ENTTYPE_DEBRIS, &tempVec);
			
			//addDebris(singleton->debrisStack[i].pos);
		}
		singleton->debrisStack.clear();
	}
void GamePhysics::beginDrop ()
                         {
		
		cout << "GamePhysics:beginDrop()\n";
		
		example->beginDrop(
			singleton->cameraGetPosNoShake()->getFX(),
			singleton->cameraGetPosNoShake()->getFY(),
			singleton->cameraGetPosNoShake()->getFZ()
		);
	}
void GamePhysics::remBoxFromObj (BaseObjType _uid)
                                             {
		
		BaseObj* ge = &(singleton->gem->gameObjects[_uid]);
		
		int bodInd;
		
		bool hasRig = (
			(ge->orgId > -1) &&
			(ge->actorId > -1)	
		);
		
		GamePhysRig* curPhysRig;
		
		int i;
		
		
		
		singleton->gem->makeDropAll(ge->uid);
		
		
		
		if (hasRig) {
			curPhysRig = singleton->gem->gamePhysRigs[ge->actorId];
			curPhysRig->removeAllBodies();
			
			while (ge->bodies.size() > E_BDG_LENGTH ) {
				ge->bodies.pop_back();
			}
			
		}
		
		for (bodInd = 0; bodInd < ge->bodies.size(); bodInd++) { // E_BDG_LENGTH
			example->removeRigidBody(ge->bodies[bodInd].body);
		}
		
		
		
		
		
		// if (hasRig) {
		// 	//curPhysRig = singleton->gem->gamePhysRigs[ge->actorId];
		// 	delete singleton->gem->gamePhysRigs[ge->actorId];
		// 	singleton->gem->gamePhysRigs[ge->actorId] = NULL;
			
		// 	delete singleton->gem->gameOrgs[ge->orgId];
		// 	singleton->gem->gameOrgs[ge->orgId] = NULL;
		// }
		
		// ge->actorId = -1;
		// ge->orgId = -1;
		
		ge->bodies.clear();
	}
void GamePhysics::addBoxFromObj (BaseObjType _uid, bool refreshLimbs)
                                                                {
		
		
		
		//cout << "\n\nADD BOX\n\n";
		
		int i;
		int bodInd;
		GameOrg* curOrg = NULL;
		
		if (_uid < 0) {
			return;
		}
		
		BaseObj* ge = &(singleton->gem->gameObjects[_uid]);
		
		if (ge->isHidden) {
			return;
		}
		
		btTransform trans;
		trans.setIdentity();
		trans.setOrigin(ge->startPoint);
		
		GamePhysRig* curPhysRig;
		
		float objRad = 0.5f;
		bool isOrg = false;
		
		int bodyOffset = 0;
		
		switch (ge->entType) {
			case E_ENTTYPE_NPC:
			case E_ENTTYPE_WEAPON:
				{
					
					isOrg = true;
					
					
					if (ge->entType == E_ENTTYPE_WEAPON) {
						
					}
					else {
						
						
						////////////////////////////
						
						if (refreshLimbs) {
							// todo: add stuff
						}
						else {
							for (i = 0; i < E_BDG_LENGTH; i++) {
								//btCapsuleShapeZ* capsuleShapeZ = new btCapsuleShapeZ(1.0f,BASE_ENT_HEIGHT);
								
								switch (i) {
									case E_BDG_CENTER:
										trans.setIdentity();
										trans.setOrigin(ge->startPoint);
									break;
									// case E_BDG_LFOOT:
									// 	trans.setIdentity();
									// 	trans.setOrigin(ge->startPoint + btVector3(-1.0f, 0.0f, -1.0f));
									// break;
									// case E_BDG_RFOOT:
									// 	trans.setIdentity();
									// 	trans.setOrigin(ge->startPoint + btVector3( 1.0f, 0.0f, -1.0f));
									// break;
								}
								
								ge->bodies.push_back(BodyStruct());
								
								if (i == E_BDG_CENTER) {
									ge->bodies[i].body = example->createRigidBodyMask(
										MASS_PER_LIMB, // 0.1
										trans,
										new btCapsuleShapeZ(BASE_ENT_RAD,BASE_ENT_HEIGHT),//capsuleShapeZ, //btSphereShape(BASE_ENT_HEIGHT),//
										COL_MARKER,
										markerCollidesWith
									);
								}
								else {
									// ge->bodies[i].body = example->createRigidBodyMask(
									// 	MASS_PER_LIMB, // 0.1
									// 	trans,
									// 	new btSphereShape(0.25f),//new btCapsuleShapeZ(1.0f,BASE_ENT_HEIGHT),//capsuleShapeZ,
									// 	COL_MARKER,
									// 	markerCollidesWith
									// );
								}
								
								
								ge->bodies[i].body->setAngularFactor(orig);
								ge->bodies[i].boneId = -1;
								ge->bodies[i].jointType = E_JT_CONT;
							}
							
							bodyOffset = E_BDG_LENGTH;
							
						}
						
						
						
						
						////////////////////////////
						
						
					}
					
					
					
					
					if (refreshLimbs) {
						
						delete singleton->gem->gamePhysRigs[ge->actorId];
						
						singleton->gem->gamePhysRigs[ge->actorId] = new GamePhysRig(
							singleton,
							ge->uid,
							example->getWorld(),
							ge->getCenterPoint(E_BDG_CENTER)
						);
						
					}
					else {
						singleton->gem->gameOrgs.push_back(new GameOrg());
						singleton->gem->gameOrgs.back()->init(singleton, ge->uid, ge->entType, ge->subType);
						ge->orgId = singleton->gem->gameOrgs.size()-1;
						
						singleton->gem->loadDefaultPose(ge->uid);
						
						singleton->gem->gamePhysRigs.push_back(new GamePhysRig(
							singleton,
							ge->uid,
							example->getWorld(),
							ge->startPoint
						));
						ge->actorId = singleton->gem->gamePhysRigs.size()-1;
					}
					
					
					curPhysRig = (singleton->gem->gamePhysRigs[ge->actorId]);
					
					if (refreshLimbs) {
						curPhysRig->reinit();	
					}
					
					
					for (i = 0; i < curPhysRig->rigJoints.size(); i++) {
						
						if (!refreshLimbs) {
							ge->bodies.push_back(BodyStruct());
						}
						
						bodInd = i + bodyOffset;
						
						ge->bodies[bodInd].body = curPhysRig->rigJoints[i].body;
						ge->bodies[bodInd].boneId = curPhysRig->rigJoints[i].boneId;
						ge->bodies[bodInd].jointType = curPhysRig->rigJoints[i].jointType;
						ge->bodies[bodInd].rad = curPhysRig->rigJoints[i].rad;
						ge->bodies[bodInd].length = curPhysRig->rigJoints[i].length;
						ge->bodies[bodInd].actorJointId = i;
						
						// if (i == 0) {
						// 	//ge->body = curPhysRig->rigJoints[i].body;
						// 	//ge->body->setLinearFactor(orig);
						// 	ge->bodies.back().body->setAngularFactor(orig);
						// }
						// else {
							
						// }
					}
				}
			break;
			default:
				{
					
					if (refreshLimbs) {
						cout << "Error, should not hit this point (refreshLimbs)\n";
						return;
					}
					
					btBoxShape* boxShape = new btBoxShape(btVector3(objRad,objRad,objRad));
					ge->bodies.push_back(BodyStruct());
					ge->bodies.back().body = example->createRigidBodyMask(
						MASS_PER_LIMB,
						trans,
						boxShape
						,COL_DYN,
						dynCollidesWith
					);
					ge->bodies.back().boneId = -1;
					ge->bodies.back().jointType = E_JT_OBJ;
					
					if (ge->entType == E_ENTTYPE_DEBRIS) {
						
						ge->bodies.back().body->setAngularVelocity(btVector3(
							(fGenRand2()*2.0f-1.0f),
							(fGenRand2()*2.0f-1.0f),
							(fGenRand2()*2.0f-1.0f)	
						)*4.0f);
					}
					
					
				}
			break;
		}
		
		
		
		for (bodInd = 0; bodInd < ge->bodies.size(); bodInd++) {
			ge->bodies[bodInd].body->bodyUID = _uid;
			ge->bodies[bodInd].body->limbUID = bodInd;
			
			
			ge->bodies[bodInd].body->setDamping(0.1f,0.9f);
			
			ge->bodies[bodInd].body->setContactProcessingThreshold(CONTACT_THRESH);
			
			ge->bodies[bodInd].isVisible = true;
			
			if (isOrg) {
				curOrg = singleton->gem->gameOrgs[ge->orgId];
				ge->bodies[bodInd].isVisible = false;//(bodInd == 0);// false;//(bodInd < E_BDG_LENGTH);//
				
			}
			
			
			ge->bodies[bodInd].body->setGravity(
				btVector3(
					0.0f,
					0.0f,
					singleton->conVals[E_CONST_DEFAULT_GRAVITY]
				)
			);
			ge->bodies[bodInd].mass = MASS_PER_LIMB;
			ge->bodies[bodInd].hasContact = false;
			ge->bodies[bodInd].isInside = false;
			ge->bodies[bodInd].isFalling = true;
			ge->bodies[bodInd].inWater = false;
			ge->bodies[bodInd].lastVel = orig;
			ge->bodies[bodInd].totAV = orig;
			ge->bodies[bodInd].totLV = orig;
			
			
		}
		
		
		
		
	}
void GamePhysics::flushImpulses ()
                             {
		
		int k;
		BaseObj* ge;
		
		for(k = 0; k < singleton->gem->visObjects.size(); k++) {
			ge = &(singleton->gem->gameObjects[singleton->gem->visObjects[k]]);
			
			if (
				(ge->isHidden)
			) {
				
			}
			else {
				ge->flushImpulses();
			}
		}
	}
void GamePhysics::procCol (BaseObj * * geArr, BodyStruct * * curBodyArr)
          {
		
		int k;
		int otherK;
		BaseObj* grabber;
		int otherUID;
		bool doProc;
		int curBone;
		
		for (k = 0; k < 2; k++) {
			otherK = 1-k;
			
			if (geArr[k] == NULL) {
				
			}
			else {
				
				curBone = getCorrectedName(curBodyArr[k]->boneId);
				
				if (geArr[otherK] == NULL) {
					// hit static obj
					//singleton->playSoundEnt("metalhit5",geArr[k],0.2,0.5f);
					otherUID = -1;
				}
				else {
					otherUID = geArr[otherK]->uid;
					
					if (
						(geArr[k]->entType == E_ENTTYPE_NPC) &&
						(geArr[otherK]->entType == E_ENTTYPE_NPC)	
					) {
						
						if (curBodyArr[k] == NULL) {
							
						}
						else {
							
							
							
							doProc = false;
							
							switch(curBone) {
								case E_BONE_L_METACARPALS:
								case E_BONE_L_TALUS:
									if (geArr[k]->getActionState(E_ACT_ISSWINGING,RLBN_LEFT)) {
										if (curBone == E_BONE_L_METACARPALS) {
											if (singleton->gem->isPunching(geArr[k]->uid, RLBN_LEFT)) {
												doProc = true;
											}
										}
										else {
											if (singleton->gem->isKicking(geArr[k]->uid, RLBN_LEFT)) {
												doProc = true;
											}
										}
									}
								break;
								case E_BONE_R_TALUS:
								case E_BONE_R_METACARPALS:
									if (geArr[k]->getActionState(E_ACT_ISSWINGING,RLBN_RIGT)) {
										if (curBone == E_BONE_R_METACARPALS) {
											if (singleton->gem->isPunching(geArr[k]->uid, RLBN_RIGT)) {
												doProc = true;
											}
										}
										else {
											if (singleton->gem->isKicking(geArr[k]->uid, RLBN_RIGT)) {
												doProc = true;
											}
										}
									}
								break;
							}
						}
						if (doProc) {
							singleton->gem->makeHit(false, geArr[k]->uid, geArr[otherK]->uid, -1);
						}
					}
				}
				
				if (geArr[k]->entType == E_ENTTYPE_WEAPON) {
					
					
					
					
					
					if (
						(geArr[k]->isGrabbedById > -1) &&
						(geArr[k]->isGrabbedById != otherUID)
					) {
						grabber = &(singleton->gem->gameObjects[geArr[k]->isGrabbedById]);
						
						doProc = false;
						if (grabber->getActionState(E_ACT_ISSWINGING,RLBN_LEFT)) {
							if (singleton->gem->isSwingingWeapon(grabber->uid,RLBN_LEFT)) {
								doProc = true;
							}
						}
						if (grabber->getActionState(E_ACT_ISSWINGING,RLBN_RIGT)) {
							if (singleton->gem->isSwingingWeapon(grabber->uid,RLBN_RIGT)) {
								doProc = true;
							}
						}
						
						switch(curBone) {
							case E_BONE_WEAPON_BLADER:
							case E_BONE_WEAPON_BLADEL:
							case E_BONE_WEAPON_BLADEU:
							
							break;
							default:
								doProc = false;
							break;
						}
						
						
						if (doProc) {
							if (geArr[otherK] == NULL) {
								singleton->gem->makeHit(false, grabber->uid, -1, geArr[k]->uid);
							}
							else {
								singleton->gem->makeHit(false, grabber->uid, geArr[otherK]->uid, geArr[k]->uid);
							}
						}
					}
				}
			}
		}
	}
void GamePhysics::collideWithWorld (double curStepTime)
                                                  {
		
		
		int i;
		int j;
		int k;
		int m;
		int p;
		int q;
		
		
		
		
		int bodInd;
		float totForce;
		float bindingPower;
		float cellVal[4];
		btVector3 newVel;
		btVector3 segPos[2];
		btVector3 norVal;
		btVector3 norVal2;
		int segCount;
		bool lastInside;
		BodyStruct* curBody;
		
		BaseObj* ge;
		
		BaseObj* geArr[2];
		BodyStruct* curBodyArr[2];
		
		GameOrg* grabberOrg = NULL;
		BaseObj* grabber;
		
		
		FIVector4* curCenterPoint;
		btDiscreteDynamicsWorld* world = example->getWorld();
		
		btVector3 tempBTV;
		btVector3 tempBTV2;
		btVector3 nv0;
		btVector3 nv1;
		
		
		bool doProc = false;
		bool hasContact = false;
		
		int entNum;
		
		FIVector4 tempVec;
		
		
		float ho = singleton->conVals[E_CONST_HALF_OFFSET];
		btVector3 halfOffset = btVector3(ho,ho,ho); // <-- lol
		
		
		float curDis;
		float totMass;
		btVector3 dirForce;
		GameOrg* curOrg = NULL;
		GameOrgNode* curOrgNode = NULL;
		GamePhysRig* curPhysRig = NULL;
		btVector3 basePos;
		btVector3 targPos;
		
		
		
		collectDebris();
		
		
		
		
		for(k = 0; k < singleton->gem->visObjects.size(); k++) {
			ge = &(singleton->gem->gameObjects[singleton->gem->visObjects[k]]);
			
			if (
				(ge->isHidden)
			) {
				
			}
			else {
				
				for (bodInd = 0; bodInd < ge->bodies.size(); bodInd++) {
					ge->bodies[bodInd].hasContact = false;
					ge->bodies[bodInd].isFalling = true;
				}
				
			}
		}
		
		
		const btCollisionObject* bds[2];
		
		int numManifolds = world->getDispatcher()->getNumManifolds();
		for (i=0;i<numManifolds;i++) {
			btPersistentManifold* contactManifold =  world->getDispatcher()->getManifoldByIndexInternal(i);
			
			
			
			const btCollisionObject* obA = (contactManifold->getBody0());
			const btCollisionObject* obB = (contactManifold->getBody1());

			bds[0] = obA;
			bds[1] = obB;

			hasContact = false;
			
			int numContacts = contactManifold->getNumContacts();
			for (j=0;j<numContacts;j++) {
				btManifoldPoint& pt = contactManifold->getContactPoint(j);
				if (pt.getDistance() <= CONTACT_THRESH) {
					
					hasContact = true;
					
					// const btVector3& ptA = pt.getPositionWorldOnA();
					// const btVector3& ptB = pt.getPositionWorldOnB();
					// const btVector3& normalOnB = pt.m_normalWorldOnB;
				}
			}
			
			
			geArr[0] = NULL;
			geArr[1] = NULL;
			curBodyArr[0] = NULL;
			curBodyArr[1] = NULL;
			
			if (bds[0]->bodyUID == bds[1]->bodyUID) {
				// don't register contacts within same entity
			}
			else {
				for (k = 0; k < 2; k++) {
					if (
						(bds[k]->bodyUID > -1) &&
						(bds[k]->limbUID > -1)
					) {
						ge = &(singleton->gem->gameObjects[ bds[k]->bodyUID ]);
						curBody = &(ge->bodies[ bds[k]->limbUID ]);
						
						
						
						if (
							(ge->isHidden)
						) {
							
						}
						else {
							
							if (hasContact) {
								geArr[k] = ge;
								curBodyArr[k] = curBody;
								
								curBody->hasContact = true;
								curBody->isFalling = false;
							}
							
						}
					}
				}
				
				// if (
				// 	(geArr[0] == NULL) ||
				// 	(geArr[1] == NULL) ||	
				// 	(curBodyArr[0] == NULL) ||
				// 	(curBodyArr[1] == NULL)
				// ) {
					
				// }
				// else {
					
					
				procCol(geArr,curBodyArr);
					
				//}
				
			}
		}
		
		
		
		btVector3 difVec = orig;
		//btVector3 totVec = orig;
		bool hasRig = false;
		bool animatedRig = false;
		doProc = false;
		float angDamp = singleton->conVals[E_CONST_ANGDAMP];
		
		
		if (VOXEL_COLLISION) {
			for(k = 0; k < singleton->gem->visObjects.size(); k++) {
				ge = &(singleton->gem->gameObjects[singleton->gem->visObjects[k]]);
				
				if (
					(ge->isHidden)
				) {
					
				}
				else {
					for (bodInd = 0; bodInd < ge->bodies.size(); bodInd++) {
						curBody = &(ge->bodies[bodInd]);
						
						switch (curBody->jointType) {
							case E_JT_LIMB:
							case E_JT_BALL:
							case E_JT_OBJ:
								segCount = 1;
								segPos[0] = curBody->body->getCenterOfMassPosition() + halfOffset -
									btVector3(0.0f,0.0f,singleton->conVals[E_CONST_COLDEPTH_LIMB]);
							break;
							break;
							case E_JT_NORM:
								segCount = 0;
							break;
							case E_JT_CONT:
							
								if (singleton->gem->turnBased) {
									segCount = 0;
									
									curBody->hasContact = true;
									curBody->isFalling = !(curBody->hasContact);
									basePos = (ge->tbPos+btVector3(0.5f,0.5f,0.5f+singleton->conVals[E_CONST_TBSNAP_ZOFFSET]));
									difVec = basePos - curBody->body->getCenterOfMassPosition();
									
									
									// move limbs towards pose
									
									
									ge->setLinVel(
										difVec*singleton->conVals[E_CONST_TBSNAP_MULT],
										bodInd
									);
									
									if (ge->getPlanarVel() > 0.1) {
										ge->setActionState(E_ACT_ISWALKING,RLBN_NEIT,true);
									}
									
									
								}
								else {
									segCount = 2;
									segPos[0] = curBody->body->getCenterOfMassPosition() + halfOffset -
										btVector3(0.0f,0.0f,singleton->conVals[E_CONST_COLDEPTH_CONT]);
										
									newVel = curBody->body->getLinearVelocity();
									newVel *= xyMask;
									if (newVel.fuzzyZero()) {
										//segCount = 1;
									}
									else {
										newVel.normalize();
										
									}
									
									
									newVel *= singleton->conVals[E_CONST_COLDEPTH_WALL_XY];
									newVel += btVector3(0.0f,0.0f,singleton->conVals[E_CONST_COLDEPTH_WALL_Z]);
									
									segPos[1] = 
										curBody->body->getCenterOfMassPosition() +
										halfOffset +
										newVel;
									
										
									// segPos[1] = curBody->body->getCenterOfMassPosition() +
									// 	zMask;
								}
							
								
								
								
								
							break;
							
						}
						
						
						for (p = 0; p < segCount; p++) {
							
							norVal = singleton->gw->getNormalAtCoord(
								segPos[p], cellVal
							);
							
							if (p == 0) {
								// collision below body
								
								lastInside = curBody->isInside;
								curBody->isInside = (cellVal[3] > 0.5f);
								
								curBody->hasContact = (curBody->hasContact)||(cellVal[3] > 0.01f);
								curBody->isFalling = !(curBody->hasContact);
								
								if (
									(cellVal[3] > 0.01f) &&
									(
										//(curBody->jointType == E_JT_CONT) ||
										(
											(ge->entType == E_ENTTYPE_WEAPON) &&
											(ge->isGrabbedById < 0)
										) ||
										(curBody->boneId < 0)
									)
								) {
									ge->multVel(bodInd, btVector3(
										singleton->conVals[E_CONST_WALKING_FRIC],
										singleton->conVals[E_CONST_WALKING_FRIC],
										1.0f
									));
								}
								else {
									ge->multVel(bodInd, btVector3(
										singleton->conVals[E_CONST_AIR_RESIST],
										singleton->conVals[E_CONST_AIR_RESIST],
										1.0f
									));
								}
								
								
								
								
								if (cellVal[3] > 0.01f) {
									
									if (!ge->isDead()) {
										ge->multVelAng(bodInd, btVector3(angDamp,angDamp,angDamp));
									}
									
									
									// curBody->body->setGravity(
									// 	btVector3(
									// 		0.0f,
									// 		0.0f,
									// 		(cellVal[3])*singleton->conVals[E_CONST_ANTIGRAV]
									// 	)
									// );
									
									// curBody->body->setGravity(
									// 	btVector3(
									// 		0.0f,
									// 		0.0f,
									// 		(cellVal[3]-0.5f)*singleton->conVals[E_CONST_ANTIGRAV]
									// 	)
									// );
									
									if (
										(curBody->body->getLinearVelocity().getZ() < 0.0f) &&
										(cellVal[3] > singleton->conVals[E_CONST_VEL_STOP_THRESH]) 
									) {
										ge->multVel(bodInd, xyMask);
										//ge->moveOffset(btVector3(0,0,clampfZO(cellVal[3]-0.1f)), bodInd);
									}
									
									ge->addVel(bodInd,btVector3(
										0.0f, 0.0f, clampfZO(
											cellVal[3]-singleton->conVals[E_CONST_VEL_STOP_THRESH]
										)*singleton->conVals[E_CONST_PUSH_UP_AMOUNT]
									));
									
									if (norVal.fuzzyZero()) {
										
									}
									else {
										
											if (ge->getActionState(E_ACT_ISWALKING,RLBN_NEIT)) {
												ge->addVel(bodInd,
													norVal*xyMask * 
													cellVal[3]*singleton->conVals[E_CONST_NOR_PUSH]
												);
											}
										
											
									}
									
									
									
									if (
										(ge->entType == E_ENTTYPE_WEAPON) &&
										(ge->isGrabbedById > -1) &&
										(cellVal[3] > 0.4f)								
									) {
										geArr[0] = ge;
										geArr[1] = NULL;
										curBodyArr[0] = curBody;
										curBodyArr[1] = NULL;
										procCol(geArr,curBodyArr);
									}
									
									
									
									
									// if (cellVal[3] > 0.2f) {
									// 	ge->multVel(bodInd, btVector3(1.0f,1.0f,-1.0f));
									// }
									
									
									// ge->multVel(bodInd, btVector3(
									// 	1.0f,
									// 	1.0f,
									// 	singleton->conVals[E_CONST_ZDAMP_GROUND]
									// ));
									
									
								}
								else {
									// curBody->body->setGravity(
									// 	btVector3(
									// 		0.0f,
									// 		0.0f,
									// 		singleton->conVals[E_CONST_DEFAULT_GRAVITY]
									// 	)
									// );
								}
								curBody->body->setActivationState(ACTIVE_TAG);
							}
							else {
								// collision in direction of body velocity
								
								if (norVal.fuzzyZero()) {
									
								}
								else {
									newVel = curBody->body->getLinearVelocity();
									if (newVel.fuzzyZero()) {
										
									}
									else {
										newVel.normalize();
										// ge->addVel(
										// 	bodInd,
										// 	btVector3(
										// 		newVel.getX()*norVal.getX()*cellVal[3]*singleton->conVals[E_CONST_WALL_RESIST],
										// 		newVel.getY()*norVal.getY()*cellVal[3]*singleton->conVals[E_CONST_WALL_RESIST],
										// 		0.0f // newVel.getZ()*norVal.getZ()	
										// 	)
										// );
										
										if (newVel.getZ() > 0.0f) {
											ge->multVel(
												bodInd,
												btVector3(
													clampfZO(0.5f-cellVal[3]),
													clampfZO(0.5f-cellVal[3]),
													1.0f
												)
											);
										}
										
										
										
									}
								}
								
								
							}
							
							// if (ge->isDead()) {
							// 	curBody->body->setGravity(btVector3(0.0f,0.0f,-5.0f));
							// }
							
							
							// newVel = curBody->body->getLinearVelocity();
							// if ((newVel.fuzzyZero())) {
								
							// }
							// else {
							// 	newVel.normalize();
								
							// 	if (
							// 		(cellVal[3] > 0.5f)
							// 		//&& (newVel.dot(norVal) < -0.2f)	
							// 	) {
							// 		ge->setLinVel(norVal*10.0f,bodInd);
							// 	}
								
							// }
							
							// if (norVal.getZ() > 0.0f) {
							// 	ge->multVel(bodInd, btVector3(abs(norVal.getZ()),abs(norVal.getZ()),1.0f));
								
							// 	//ge->addVel(bodInd, btVector3(0.0f,0.0f,(1.0-norVal.getZ()));
							// }
							
							
							
							
							
							// ge->applyImpulse(
							// 	cellVal[3]*norVal*curStepTime*singleton->conVals[E_CONST_PUSH_UP_AMOUNT],
							// 	bodInd,
							// 	false
							// );
							
							
							// ge->multVel(bodInd, btVector3(
							// 	1.0f-cellVal[0],
							// 	1.0f-cellVal[1],
							// 	1.0f-cellVal[2]
							// ));
							
							//ge->addVel(bodInd, norVal2*curStepTime*200.0f);
							
							// curBody->body->setGravity(
							// 	btVector3(
							// 		0.0f,
							// 		0.0f,
							// 		mixf(-10.0f,10.0f,cellVal[3])
							// 	)
							// );
							// if (
							// 	(cellVal[3] > 0.5f)
							// 	// && (curBody->body->getLinearVelocity().getZ() < 0.0)
							// ) {
							// 	ge->multVel(bodInd, btVector3(-1.0f,-1.0f,-1.0f));
							// }
							
							//ge->addVel(bodInd, norVal*curStepTime*20.0f);
							
							
							
							
							// tempBTV = curBody->body->getLinearVelocity();
							// tempBTV *= xyMask;
							
							// if ((tempBTV.fuzzyZero())) {
								
							// }
							// else {
							// 	tempBTV.normalize();
							// }
							// tempBTV *= 0.5f;
							
							
							// cellVal[0] = singleton->gw->getCellAtCoordsLin(
							// 	segPos[p] + btVector3(0.0,0.0,-0.5f)
							// );
							
							
							// tempBTV += btVector3(0.0f,0.0f,1.5f);
							
							
							// cellVal[1] = singleton->gw->getCellAtCoordsLin(
							// 	segPos[p] + tempBTV
							// );
							
							
							
							
							
							
							
							
							
							// curBody->body->setGravity(
							// 	btVector3(
							// 		0.0f,
							// 		0.0f,
							// 		mixf(-10.0f,10.0f,cellVal[0])
							// 	)
							// );
							// if (
							// 	(cellVal[0] > 0.5f) &&
							// 	(curBody->body->getLinearVelocity().getZ() < 0.0)
							// ) {
							// 	ge->multVel(bodInd, xyMask);
							// }
							
							// if (cellVal[1] > 0.1) {
							// 	ge->multVel(bodInd, btVector3(1.0f-cellVal[1],1.0f-cellVal[1],1.0f));
							// 	ge->addVel(bodInd, xyMask);
							// }
							
							
							
							//if (lastInside != curBody->isInside) {
								// if (curBody->isInside) {
									
								// 	if (q == 0) {
								// 		//ge->multVelocity(bodInd, xyMask);
								// 		curBody->body->setGravity(btVector3(0.0f,0.0f,10.0f));
								// 	}
								// 	else {
								// 		//ge->multVelocity(bodInd, btVector3(-0.9f,-0.9f,1.0f));
								// 	}
									
									
								// }
								// else {
								// 	curBody->body->setGravity(btVector3(0.0f,0.0f,-10.0f));
								// }
							//}
							
							
							
							
							
						}
						
						
					}
				}
			}
		}
		
		
		
		
		for(k = 0; k < singleton->gem->visObjects.size(); k++) {
			ge = &(singleton->gem->gameObjects[singleton->gem->visObjects[k]]);
			
			hasRig = false;
			animatedRig = false;
			
			if (
				(ge->isHidden)
			) {
				
			}
			else {
				
				
				hasRig = (
					(ge->orgId > -1) &&
					(ge->actorId > -1)	
				);
				
				
				//totVec = orig;
				
				
				if (hasRig) {
					curPhysRig = singleton->gem->gamePhysRigs[ge->actorId];
					curOrg = singleton->gem->gameOrgs[ge->orgId];
					animatedRig = (ge->entType == E_ENTTYPE_NPC);
					ge->clearAABB(&(ge->aabbMinSkel),&(ge->aabbMaxSkel));
					
					if (animatedRig) {
						
						// if (ge->getActionState(E_ACT_ISWALKING,RLBN_NEIT)) {
						// 	ge->bodies[E_BDG_CENTER].body->setFriction(singleton->conVals[E_CONST_WALKING_FRIC]);
						// }
						// else {
						// 	ge->bodies[E_BDG_CENTER].body->setFriction(singleton->conVals[E_CONST_STANDING_FRIC]);
						// }
						
						
						
						
						if (ge->isDead()) {
							curOrg->setTPG(E_PG_DEAD,RLBN_NEIT);
						}
						else if (ge->getActionState(E_ACT_ISHIT,RLBN_NEIT)) {
							curOrg->setTPG(E_PG_FLAIL,RLBN_NEIT);
						}
						else if (ge->getActionState(E_ACT_ISSWINGING,RLBN_RIGT)) {
							curOrg->setTPG(ge->swingType[RLBN_RIGT], RLBN_RIGT);
						}
						else if (ge->getActionState(E_ACT_ISSWINGING,RLBN_LEFT)) {
							curOrg->setTPG(ge->swingType[RLBN_LEFT], RLBN_LEFT);
						}
						else if (
							ge->getActionState(E_ACT_ISJUMPING,RLBN_NEIT) &&
							(ge->bodies[E_BDG_CENTER].body->getLinearVelocity().getZ() >= 0.0f)
						) {
							curOrg->setTPG(E_PG_JUMP,RLBN_NEIT);
						}
						else if (ge->getActionState(E_ACT_ISPICKINGUP,RLBN_NEIT)) {
							curOrg->setTPG(E_PG_PICKUP,RLBN_NEIT);
						}
						else if (
							ge->getActionState(E_ACT_ISWALKING,RLBN_NEIT)
							
							// && (ge->getPlanarVel() > E_CONST_WALKANIM_THRESH)
						) {
							curOrg->setTPG(E_PG_WALKFORWARD,RLBN_NEIT);
						}
						else {
							curOrg->setTPG(E_PG_IDLE,RLBN_NEIT);
						}
						
						if (curOrg->targetPose.group != E_PG_JUMP) {
							ge->setActionState(E_ACT_ISJUMPING,RLBN_NEIT,false);
						}
						
						
						curOrg->updatePose(curStepTime);
						
						ge->wakeAll();
						
					}
					
					
				}
				
				for (bodInd = 0; bodInd < ge->bodies.size(); bodInd++) {
					curBody = &(ge->bodies[bodInd]);
					
					
					
					
					//$$$$$$$$$$$
					
					
					
					//////////////////////
					// APPLY FORCES
					//////////////////////
					
					ge->applyImpulses(curStepTime, bodInd);
					
					
					
					if (
						hasRig
						&& (
							animatedRig ||
							(ge->isGrabbedById > -1)
						)
					) {
						
						if (curBody->boneId > -1) {
							curOrgNode = curOrg->allNodes[curBody->boneId];
						}
						else {
							curOrgNode = NULL;
						}
						
						
						
						if (curOrgNode == NULL) {
							
							// difVec = orig;
							
							// switch (bodInd) {
							// 	case E_BDG_CENTER:
									
							// 		// targPos = 
							// 		// 	ge->bodies[E_BDG_LFOOT].body->getCenterOfMassPosition()*0.5f +
							// 		// 	ge->bodies[E_BDG_RFOOT].body->getCenterOfMassPosition()*0.5f
							// 		// 	//+ btVector3(0.0f, 0.0f, 1.5f)
							// 		// ;
									
							// 		// difVec = targPos - curBody->body->getCenterOfMassPosition();
							// 		// //difVec = basePos - curBody->body->getCenterOfMassPosition();
							// 	break;
							// 	case E_BDG_LFOOT:
							// 		targPos = ge->bodies[E_BDG_CENTER].body->getCenterOfMassPosition();
							// 		curDis = ge->bodies[E_BDG_LFOOT].body->getCenterOfMassPosition().distance(
							// 			targPos
							// 		);
							// 		if (curDis > 2.5f) {
							// 			difVec = targPos - curBody->body->getCenterOfMassPosition();
							// 		}
							// 		if (curDis < 0.5f) {
							// 			difVec = -(targPos - curBody->body->getCenterOfMassPosition());
							// 		}
									
							// 	break;
							// 	case E_BDG_RFOOT:
							// 		targPos = ge->bodies[E_BDG_CENTER].body->getCenterOfMassPosition();
							// 		curDis = ge->bodies[E_BDG_RFOOT].body->getCenterOfMassPosition().distance(
							// 			targPos
							// 		);
							// 		if (curDis > 2.5f) {
							// 			difVec = targPos - curBody->body->getCenterOfMassPosition();
							// 		}
							// 		if (curDis < 0.5f) {
							// 			difVec = -(targPos - curBody->body->getCenterOfMassPosition());
							// 		}
							// 	break;
							// }
							
							// ge->applyImpulse(
							// 	difVec*curStepTime*curBody->mass*200.0f, // *MASS_PER_LIMB*2.0f*10.0f*curStepTime,
							// 	false,
							// 	bodInd
							// );
							
						}
						else {
							
							
							if (ge->isGrabbedById > -1) {
								grabber = &(singleton->gem->gameObjects[ge->isGrabbedById]);
								bindingPower = 1.0f;
							}
							else {
								grabber = ge;
								bindingPower = ge->bindingPower*singleton->conVals[E_CONST_BINDING_POW_MAX];
							}
							
							
							
							grabber->bodies[E_BDG_CENTER].body->getWorldTransform().getOpenGLMatrix(myMat);
							myMatrix4 = Matrix4(myMat);
							
							switch(curBody->jointType) {
								case E_JT_LIMB:
									tempBTV = curOrgNode->orgTrans[1].getBTV();
								break;
								case E_JT_BALL:
									tempBTV = curOrgNode->orgTrans[2].getBTV();
								break;
								case E_JT_NORM:
									
								break;
							}
							
							
							
								myVector4 = Vector4(
									tempBTV.getX(),
									tempBTV.getY(),
									tempBTV.getZ(),
									1.0f
								);
								resVector4 = myMatrix4*myVector4;
								basePos = btVector3(resVector4.x,resVector4.y,resVector4.z);
								
								ge->addAABBPoint(&(ge->aabbMinSkel), &(ge->aabbMaxSkel), basePos);
								
								basePos += grabber->skelOffset;
								
								difVec = basePos - curBody->body->getCenterOfMassPosition();
								
								
								// move limbs towards pose
								
								
								ge->setLinVel(
									curBody->body->getLinearVelocity()*(1.0f-bindingPower)
									+ difVec*singleton->conVals[E_CONST_BINDING_MULT]*bindingPower,
									bodInd
								);
								
						}
						
						
					}
					
					
					if (
						(singleton->gem->selObjInd == ge->uid) &&
						singleton->markerFound &&
						singleton->gem->isDraggingObject &&
						(singleton->gem->draggingFromType == E_DT_WORLD_OBJECT)
					) {
						
						if (lastBodyPick == NULL) {
							
						}
						else {
							if (
								lastBodyPick->limbUID ==
								curBody->body->limbUID
							) {
								
								//totMass = ge->getTotalMass();
								
								//ge->applyAngularImpulse(btVector3(0,0,-0.02)/STEP_TIME_IN_SEC, false, curBody->body->limbUID);
								
								
							}
						}
						
						
						// ge->applyImpulse(
						// 	btVector3(
						// 		( singleton->worldMarker.getFX() - curBody->body->getCenterOfMassPosition().getX() ),
						// 		( singleton->worldMarker.getFY() - curBody->body->getCenterOfMassPosition().getY() ),
						// 		-(curBody->body->getCenterOfMassPosition().getZ() - (8.0f + singleton->worldMarker.getFZ()))
						// 	)*totMass*100.0f*curStepTime,
						// 	false,
						// 	0
						// );
						
						
						
						
						
					}
					
					
					
					for (m = 0; m < singleton->sphereStack.size(); m++) {
						tempBTV = curBody->body->getCenterOfMassPosition();
						tempBTV2 = singleton->sphereStack[m].position.getBTV();
						
						totForce = (
							1.0f-clampfZO(
								tempBTV.distance(tempBTV2)/(singleton->sphereStack[m].curRad*5.0f)	
							)
						)*5.0f; // * singleton->sphereStack[m].power;
						dirForce = tempBTV-tempBTV2;
						dirForce.normalize();
						dirForce = dirForce*totForce;
						
						dirForce.setZ(totForce);
						
						if (dirForce.length() > 2.0f) {
							ge->hitCooldown = max(ge->hitCooldown,2);
						}
						
						ge->applyImpulse(dirForce*curStepTime*5.0f*curBody->mass, false, bodInd);
					}
					
					
					//////////////////////
					// END APPLY FORCES
					//////////////////////
					
					
					
					
					
					nv0 = curBody->body->getLinearVelocity();
					nv1 = curBody->lastVel;
					
					if ((nv0.fuzzyZero()) || (nv1.fuzzyZero())) {
						
					}
					else {
						nv0.normalize();
						nv1.normalize();
						
						
						if (
							//(!(curBody->isInside)) &&
							(
								curBody->lastVel.length() > 0.5f
							) &&
							(
								(nv0.dot(nv1)) < 0.8f
							) &&
							(bodInd == 0) &&
							(ge->isGrabbedById < 0) 
							
						) {
							
							
							singleton->gw->fireEvent(
								ge->uid,
								EV_COLLISION,
								clampfZO( (curBody->lastVel.length()-0.5f)/16.0f )*
								(1.0f-clampfZO(ge->getCenterPointFIV(bodInd)->distance(singleton->cameraGetPosNoShake())/(50.0f)))
							);
						}
					}
					
					
					
					curBody->lastVel = curBody->body->getLinearVelocity();
					
					
					
					if (ge->entType == E_ENTTYPE_BULLET) {
						if (
							(!(curBody->isFalling)) && 
							(curBody->body->getLinearVelocity().length() < 0.5)
						) {
							singleton->explodeBullet(ge);
						}
					}
					
					
					
					
					//$$$$$$$$$$$
					
				}
				
				ge->zeroZ = false;
				
				//ge->skelOffset *= 0.99;
				
				if (ge->baseContact()&&hasRig&&animatedRig) {
					
					
					
					ge->skelOffset = btVector3(
						0.0f,
						0.0f,
						
						
							
						(
							(ge->getCenterPoint(E_BDG_CENTER).getZ()-(BASE_ENT_HEIGHT+BASE_ENT_RAD)*0.5f) -
							ge->aabbMinSkel.getZ()	
						)
							
						
							
					);
					
					if (singleton->gem->editPose) {
						ge->skelOffset += btVector3(
							0.0,
							0.0,
							1.0f
						);
					}
					else {
						
					}
					
										
					
					
				}
				else {
					ge->skelOffset *= 0.99;
				}
				
			}
			
			
		}
		
		singleton->explodeStack.clear();
		
		
		
	}
void GamePhysics::remFarAway ()
                          {
		int k;
		BaseObj* ge;
		
		btVector3 camPos;
		
		if (singleton->gem->getCurActor() == NULL) {
			camPos = singleton->cameraGetPosNoShake()->getBTV();
		}
		else {
			camPos = singleton->gem->getCurActor()->getCenterPoint(E_BDG_CENTER);
		}
		
		
		
		
		for(k = 0; k < singleton->gem->visObjects.size(); k++) {
			ge = &(singleton->gem->gameObjects[singleton->gem->visObjects[k]]);
			
			if (
				(ge->isHidden)
			) {
				
			}
			else {
				if (ge->getCenterPoint(E_BDG_CENTER).distance(camPos) > singleton->conVals[E_CONST_REM_DIS_THRESH]) {
					singleton->gem->removeVisObject(ge->uid,singleton->gem->isRecycledFunc(ge->entType));
					k--;
				}
			}
		}
	}
void GamePhysics::updateAll ()
                         {
		int i;
		for (i = 0; i < singleton->conVals[E_CONST_PHYS_STEPS_PER_FRAME]; i++) {
			collideWithWorld(STEP_TIME_IN_SEC);
			example->stepSimulation(STEP_TIME_IN_SEC);
		}
		
		//while (singleton->totTimePassedPhysics > singleton->conVals[E_CONST_STEP_TIME_IN_MICRO_SEC]) {
			//totTime += STEP_TIME_IN_SEC;
			// collideWithWorld(STEP_TIME_IN_SEC);
			// example->stepSimulation(STEP_TIME_IN_SEC);
			//singleton->totTimePassedPhysics -= singleton->conVals[E_CONST_STEP_TIME_IN_MICRO_SEC];
		//}
		
		flushImpulses();
		remFarAway();
	}
GamePhysics::~ GamePhysics ()
                       {
		example->exitPhysics();
		delete example;
	}
#undef LZZ_INLINE
 
// f00380_gameworld.h
//

#include "f00380_gameworld.e"
#define LZZ_INLINE inline
GameWorld::GameWorld ()
        {

		// Notes
		// -----
		// Depth: 16 bits
		// Material: 16 bits
		// AO val: 8 bits, normal: 24 bits

		blockHolder = NULL;

	}
void GameWorld::init (Singleton * _singleton)
        {

		singleton = _singleton;
		

		int i;
		int j;
		
		shiftCounter = 0;
		
		curTargFBO[0] = "terTargFBO";
		curTargFBO[1] = "sphTargFBO";
		curTargFBO[2] = "prmTargFBO";
		
		curDepthFBO[0] = "terDepthFBO";
		curDepthFBO[1] = "sphDepthFBO";
		curDepthFBO[2] = "prmDepthFBO";
		
		lastHitObjUID = 0;
		renderCount = 0;
		invalidCount = 0.0f;
		invalidCountMax = 10.0f;
		
		//finalInd = -1;
		
		lightCount = 1;

		noiseGenerated = false;

		//finalPath = NULL;
		
		
		float deltVal = -1.5f;
		offsetVal[0] = btVector3(deltVal,0.0f,0.0f);
		offsetVal[1] = btVector3(0.0f,deltVal,0.0f);
		offsetVal[2] = btVector3(0.0f,0.0f,deltVal);
		offsetVal[3] = btVector3(0.0f,0.0f,0.0f);
		

		holdersPerBlock = singleton->holdersPerBlock;

		dirFlagsO[0] = 1;
		dirFlagsO[1] = 2;
		dirFlagsO[2] = 4;
		dirFlagsO[3] = 8;

		dirFlagsOpO[0] = 2;
		dirFlagsOpO[1] = 1;
		dirFlagsOpO[2] = 8;
		dirFlagsOpO[3] = 4;

		dirFlags[0] = ~1;
		dirFlags[1] = ~2;
		dirFlags[2] = ~4;
		dirFlags[3] = ~8;

		dirFlagsOp[0] = ~2;
		dirFlagsOp[1] = ~1;
		dirFlagsOp[2] = ~8;
		dirFlagsOp[3] = ~4;

		dirModX[0] = 1;
		dirModX[1] = -1;
		dirModX[2] = 0;
		dirModX[3] = 0;
		dirModX[4] = 0;
		dirModX[5] = 0;

		dirModY[0] = 0;
		dirModY[1] = 0;
		dirModY[2] = 1;
		dirModY[3] = -1;
		dirModY[4] = 0;
		dirModY[5] = 0;

		dirModZ[0] = 0;
		dirModZ[1] = 0;
		dirModZ[2] = 0;
		dirModZ[3] = 0;
		dirModZ[4] = 1;
		dirModZ[5] = -1;

		opDir[0] = 1;
		opDir[1] = 0;
		opDir[2] = 3;
		opDir[3] = 2;

		dirFlagClear = ~15;
		visFlag = 16;
		visFlagO = ~16;

		foundPath = false;

		activeFBO = 0;
		mapLockOn = false;

		numProvinces = 16;
		provinceGrid = new int[numProvinces * numProvinces];
		provinceX = new int[numProvinces];
		provinceY = new int[numProvinces];

		mapSwapFlag = 0;
		mapStep = 0.0f;

		pageCount = 0;
		maxThreads = 7;
		availThreads = maxThreads;

		for (i = 0; i < maxThreads; i++)
		{
			ocThreads.push_back(-1);
		}

		hmChannel = 0;
		idChannel = 1;
		densityChannel = 2;
		blockChannel = 3;

		stChannel = 0;
		btChannel = 1;
		pathChannel = 2;
		houseChannel = 3;




		MIN_MIP = 0;
		MAX_MIP = 1;
		AVG_MIP = 2;


		doDrawFBO = false;


		renderMethod = (int)E_RENDER_VOL;

		cellsPerWorld = singleton->cellsPerWorld;
		holdersPerWorld = singleton->holdersPerWorld;
		blocksPerWorld = singleton->blocksPerWorld;


		iBlockSize = blocksPerWorld * blocksPerWorld * blocksPerWorld;



		blockData = new GameBlock*[iBlockSize];
		for (i = 0; i < iBlockSize; i++)
		{
			blockData[i] = NULL;
		}

		if (GEN_POLYS_WORLD) {
			blockHolder = new GamePageHolder();
			blockHolder->init(singleton, -1, -1, 0,0,0, true);
		}
		
		
		
	}
GameBlock * GameWorld::getBlockAtCoords (int xInBlocks, int yInBlocks, int zInBlocks, bool createOnNull)
          {





		int newX = wrapCoord(xInBlocks, blocksPerWorld);
		int newY = wrapCoord(yInBlocks, blocksPerWorld);
		int newZ = wrapCoord(zInBlocks, blocksPerWorld);

		//zInBlocks;//


		int ind =
			newZ * blocksPerWorld*blocksPerWorld +
			newY * blocksPerWorld +
			newX;

		if (blockData[ind] == NULL) {
			if (createOnNull) {
				blockData[ind] = new GameBlock();
				blockData[ind]->init(singleton, ind, xInBlocks, yInBlocks, zInBlocks, newX, newY, newZ);
			}
		}

		return blockData[ind];

	}
GamePageHolder * GameWorld::getHolderAtCoords (int x, int y, int z, bool createOnNull)
        {

		GamePageHolder **holderData;

		int newX = wrapCoord(x, holdersPerWorld);
		int newY = wrapCoord(y, holdersPerWorld);
		int newZ = z;

		int holderX = newX - intDiv(newX, holdersPerBlock) * holdersPerBlock;
		int holderY = newY - intDiv(newY, holdersPerBlock) * holdersPerBlock;
		int holderZ = newZ - intDiv(newZ, holdersPerBlock) * holdersPerBlock;

		int holderId = holderZ * holdersPerBlock * holdersPerBlock + holderY * holdersPerBlock + holderX;


		GameBlock *curBlock = getBlockAtCoords(
			intDiv(x, holdersPerBlock),
			intDiv(y, holdersPerBlock),
			intDiv(z, holdersPerBlock),
			createOnNull
		);

		if (curBlock == NULL)
		{
			return NULL;
		}
		else
		{
			holderData = curBlock->holderData;


			if (holderData[holderId] == NULL)
			{
				if (createOnNull)
				{
					holderData[holderId] = new GamePageHolder();
					holderData[holderId]->init(singleton, curBlock->blockId, holderId, x, y, z); //, x, y, z
				}
			}

			return holderData[holderId];


		}



	}
GamePageHolder * GameWorld::getHolderAtId (int blockId, int holderId)
        {

		if (blockData[blockId] == NULL)
		{
			return NULL;
		}
		else
		{
			return blockData[blockId]->holderData[holderId];
		}
	}
GameBlock * GameWorld::getBlockAtId (int id)
        {


		if ((id < 0) || (id >= iBlockSize))
		{
			doTraceND("BLOCK INDEX OUT OF RANGE");
			return NULL;
		}
		else
		{
			if (blockData[id] == NULL)
			{
				doTraceND("BLOCK DATA IS NULL");
				return NULL;
			}
			else
			{
				return blockData[id];
			}
		}


	}
int GameWorld::getCellInd (btVector3 cParam, GamePageHolder * & curHolder)
          {
		
		int xv = cParam.getX();
		int yv = cParam.getY();
		int zv = cParam.getZ();
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		int newX = wrapCoord(xv,cellsPerWorld);
		int newY = wrapCoord(yv,cellsPerWorld);
		int newZ = zv;
		
		int x2 = intDiv(newX,cellsPerHolder);
		int y2 = intDiv(newY,cellsPerHolder);
		int z2 = intDiv(newZ,cellsPerHolder);
		
		
		curHolder = (getHolderAtCoords(x2, y2, z2, true));
		if (curHolder->wasGenerated) {
			
		}
		else {
			//cout << "attempted getCellInd without generation\n";
			//curHolder->genCellData();
			return -1;
		}
		//GamePage* gp = getPageAtCoords(x2, y2, z2, false);
		
		int xr = newX - x2*cellsPerHolder;
		int yr = newY - y2*cellsPerHolder;
		int zr = newZ - z2*cellsPerHolder;
		
		return (zr*cellsPerHolder*cellsPerHolder + yr*cellsPerHolder + xr);
	}
int GameWorld::getCellInd (GamePageHolder * & curHolder, int xv, int yv, int zv)
          {
		
		
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		int newX = wrapCoord(xv,cellsPerWorld);
		int newY = wrapCoord(yv,cellsPerWorld);
		int newZ = zv;
		
		int x2 = intDiv(newX,cellsPerHolder);
		int y2 = intDiv(newY,cellsPerHolder);
		int z2 = intDiv(newZ,cellsPerHolder);
		
		
		curHolder = (getHolderAtCoords(x2, y2, z2, true));
		if (curHolder->wasGenerated) {
			
		}
		else {
			//cout << "attempted getCellInd without generation\n";
			//curHolder->genCellData();
			return -1;
		}
		//GamePage* gp = getPageAtCoords(x2, y2, z2, false);
		
		int xr = newX - x2*cellsPerHolder;
		int yr = newY - y2*cellsPerHolder;
		int zr = newZ - z2*cellsPerHolder;
		
		return (zr*cellsPerHolder*cellsPerHolder + yr*cellsPerHolder + xr);
	}
int GameWorld::getCellAtCoords (int xv, int yv, int zv)
          {
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		int newX = wrapCoord(xv,cellsPerWorld);
		int newY = wrapCoord(yv,cellsPerWorld);
		int newZ = zv;
		
		int x2 = intDiv(newX,cellsPerHolder);
		int y2 = intDiv(newY,cellsPerHolder);
		int z2 = intDiv(newZ,cellsPerHolder);
		
		int q;
		
		
		GamePageHolder* curHolder = getHolderAtCoords(x2, y2, z2, true);
		
		if (curHolder == NULL) {
			return E_CD_EMPTY;
		}
		
		if (curHolder->lockRead) {
			return E_CD_EMPTY;
		}
		
		if (curHolder->wasGenerated) {
			
		}
		else {
			return E_CD_EMPTY;
		}
		
		int xr = newX - x2*cellsPerHolder;
		int yr = newY - y2*cellsPerHolder;
		int zr = newZ - z2*cellsPerHolder;
		
		int ind = (zr*cellsPerHolder*cellsPerHolder + yr*cellsPerHolder + xr)*4;
		
		return curHolder->getCellAtInd(ind);
		
	}
float GameWorld::getCellAtCoordsLin (btVector3 pos)
                                                {
		
		int xv = pos.getX();
		int yv = pos.getY();
		int zv = pos.getZ();
		
		float fx = pos.getX()-xv;
		float fy = pos.getY()-yv;
		float fz = pos.getZ()-zv;
		
		float res[8];
		
		int q;
		int i;
		int j;
		int k;
		
		int curRes;
		
		for (q = 0; q < 8; q++) {
			k = q/4;
			j = q - (k*4);
			i = q - (k*4+j*2);
			
			curRes = getCellAtCoords(xv+i,yv+j,zv+k);
			
			if (curRes == E_CD_SOLID) {
				res[q] = 1.0f;
			}
			else {
				res[q] = 0.0f;
			}
			
		}
		
		res[0] = res[0]*(1.0f-fz) + res[4]*fz;
		res[1] = res[1]*(1.0f-fz) + res[5]*fz;
		res[2] = res[2]*(1.0f-fz) + res[6]*fz;
		res[3] = res[3]*(1.0f-fz) + res[7]*fz;
		
		res[0] = res[0]*(1.0f-fy) + res[2]*fy;
		res[1] = res[1]*(1.0f-fy) + res[3]*fy;
		
		return res[0]*(1.0f-fx) + res[1]*fx;
	}
btVector3 GameWorld::getNormalAtCoord (btVector3 coord, float * cellVal)
                                                                    {
		
		btVector3 norVal;
		int q;
		
		for (q = 0; q < 4; q++) {
			cellVal[q] = singleton->gw->getCellAtCoordsLin(
				coord + offsetVal[q]
			);
		}
		
		norVal = btVector3(
			(cellVal[0]-cellVal[3]),
			(cellVal[1]-cellVal[3]),
			(cellVal[2]-cellVal[3])
		);
		
		safeNorm(norVal);
		
		
		return norVal;
	}
void GameWorld::setArrAtCoords (int xv, int yv, int zv, int * tempCellData, int * tempCellData2)
          {
		int cellsPerHolder = singleton->cellsPerHolder;
		
		int newX = wrapCoord(xv,cellsPerWorld);
		int newY = wrapCoord(yv,cellsPerWorld);
		int newZ = zv;
		
		int x2 = intDiv(newX,cellsPerHolder);
		int y2 = intDiv(newY,cellsPerHolder);
		int z2 = intDiv(newZ,cellsPerHolder);
		
		GamePageHolder* curHolder = getHolderAtCoords(x2, y2, z2, true);
		
		if (curHolder == NULL) {
			return;
		}
		
		if (curHolder->lockWrite) {
			return;
		}
		
		
		int xr = newX - x2*cellsPerHolder;
		int yr = newY - y2*cellsPerHolder;
		int zr = newZ - z2*cellsPerHolder;
		
		int ind = (zr*cellsPerHolder*cellsPerHolder + yr*cellsPerHolder + xr)*4;
		
		if (singleton->refreshPaths) {
			curHolder->pathsInvalid = true;
			curHolder->idealPathsInvalid = true;
			curHolder->pathsReady = false;
			curHolder->idealPathsReady = false;			
			curHolder->listGenerated = false;
		}
		
		curHolder->setArrAtInd(ind,tempCellData,tempCellData2);
	}
void GameWorld::getArrAtCoords (int xv, int yv, int zv, int * tempCellData, int * tempCellData2)
          {
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		int newX = wrapCoord(xv,cellsPerWorld);
		int newY = wrapCoord(yv,cellsPerWorld);
		int newZ = zv;
		
		int x2 = intDiv(newX,cellsPerHolder);
		int y2 = intDiv(newY,cellsPerHolder);
		int z2 = intDiv(newZ,cellsPerHolder);
		
		int q;
		
		if (tempCellData != NULL) {
			for (q = 0; q < 4; q++) {
				tempCellData[q] = FLUID_UNIT_MIN;
				tempCellData2[q] = FLUID_UNIT_MIN;
			}
		}
		
		GamePageHolder* curHolder = getHolderAtCoords(x2, y2, z2, true);
		
		if (curHolder == NULL) {
			return;
		}
		
		int xr = newX - x2*cellsPerHolder;
		int yr = newY - y2*cellsPerHolder;
		int zr = newZ - z2*cellsPerHolder;
		
		int ind = (zr*cellsPerHolder*cellsPerHolder + yr*cellsPerHolder + xr)*4;
		
		curHolder->getArrAtInd(ind,tempCellData,tempCellData2);
		
	}
void GameWorld::fireEvent (BaseObjType uid, int opCode, float fParam)
                                                                  {
		BaseObj* ge = &(singleton->gem->gameObjects[uid]);
		switch (opCode) {
			case EV_COLLISION:
			
				switch(ge->entType) {
					case E_ENTTYPE_BULLET:
						singleton->playSoundEnt("bump0", ge,0.0,0.25f);
					break;
					case E_ENTTYPE_WEAPON:
						singleton->playSoundEnt("metalclash0", ge, 0.25, 0.25f);
					break;
					default:
						singleton->playSoundEnt("land0", ge, 0.1, fParam*0.2);
					break;
				}
			
				
				singleton->performCamShake(ge, fParam);
			break;
		}
	}
void GameWorld::generateBlockHolder ()
                                   {
		
		if (noiseGenerated || (blockHolder == NULL)) {
			
		}
		else {
			return;
		}
		
		
		
		if (blockHolder->wasGenerated) {
			
		}
		else {
			glFlush();
			glFinish();
			
			
			blockHolder->genCellData();
			
			
			glFlush();
			glFinish();
		}
		
		// if (blockHolder->preGenList) {
			
		// }
		// else {
			
		// 	blockHolder->generateList();
		// }
		
		// if (blockHolder->listGenerated) {
			
		// }
		// else {
		// 	glFlush();
		// 	glFinish();
			
			
		// 	blockHolder->fillVBO();
			
			
		// 	glFlush();
		// 	glFinish();
			
			
			
		// }
	}
void GameWorld::update ()
                      {
		
		singleton->updateLock = true;


		if (noiseGenerated) {

		}
		else {
			noiseGenerated = true;
			singleton->bindShader("NoiseShader");
			singleton->bindFBO("noiseFBO");
			singleton->drawFSQuad();
			singleton->unbindFBO();
			singleton->unbindShader();
			
			singleton->copyFBO("noiseFBO","noiseFBOLinear");
			
			tempVec1.setFXYZ(0.0f,0.0f,0.0f);
			tempVec2.setFXYZ(256.0,256.0f,256.0f);
			
			drawVol((singleton->volumeWrappers[E_VW_VORO]), &tempVec1, &tempVec2, true, true, true);
			
			
			
		}
		
		updateLimbTBOData(true);

		
		
		camBlockPos.copyFrom( singleton->cameraGetPosNoShake() );
		camBlockPos.intDivXYZ(singleton->cellsPerBlock);

		if (singleton->gem->getCurActor() == NULL) {
			camHolderPos.copyFrom( singleton->cameraGetPosNoShake() );
			camHolderPos.intDivXYZ(singleton->cellsPerHolder);
			camHolderPos.addXYZRef(&(singleton->lookAtVec),4.0);
		}
		else {
			camHolderPos.setBTV(singleton->gem->getCurActor()->getCenterPoint(0));
			camHolderPos.intDivXYZ(singleton->cellsPerHolder);
		}

		
		
		//loadNearestHolders();
		
		
		
		if (singleton->depthInvalidMove) {
			invalidCount += 1.25f + singleton->amountInvalidMove*0.25f;
		}
		// if (singleton->depthInvalidRotate) {
		// 	invalidCount += 1.25f + singleton->amountInvalidRotate*200.0f;
		// }
		invalidCount = min(invalidCount,invalidCountMax);
		invalidCount -= 1.0f;
		if (invalidCount < 0.0f) {
			invalidCount = 0.0f;
		}
		
		// if was moving and just stopped moving, render sphere map once
		
		// if (singleton->gameFluid[E_FID_BIG]->posShifted) {
		// 	drawVol((singleton->volumeWrappers[E_VW_TERGEN]));
		// }
		
		
		if (singleton->gameFluid[E_FID_BIG]->posShifted) {
			shiftCounter = 10;
			singleton->gameFluid[E_FID_BIG]->posShifted = false;
		}
		
		shiftCounter--;
		if (shiftCounter < 0) {
			shiftCounter = 0;
		}
		
		
		
		
		
		
		
		glEnable(GL_DEPTH_TEST);
		singleton->perspectiveOn = true;
		renderGeom();
		renderDebug();
		singleton->perspectiveOn = false;
		glDisable(GL_DEPTH_TEST);
		
		
		
		// if (
			
		// 	(
			
		// 		( shiftCounter == 1 ) ||
		// 		(
		// 			(singleton->lastDepthInvalidMove) &&
		// 			(!singleton->depthInvalidMove)
		// 		)	
				
		// 	)
		// 	&&
		// 	USE_SPHERE_MAP
		// ) {
		// 	drawPrim(true,true,false);
		// }
		
		
		// if (GEN_POLYS_WORLD||POLY_COLLISION) {
		// 	glEnable(GL_DEPTH_TEST);
		// 	//glEnable(GL_CULL_FACE);
			
		// 	//back face
		// 	//glDepthFunc(GL_GREATER);
		// 	// glCullFace(GL_FRONT);
		// 	// drawPolys(polyFBOStrings[1], 4,-1);
			
		// 	//front face
		// 	//glDepthFunc(GL_LESS);
		// 	//glCullFace(GL_BACK);
		// 	//glDepthFunc(GL_LEQUAL);
			
		// 	//glDepthRange(singleton->clipDist[0],singleton->clipDist[1]);
		// 	singleton->perspectiveOn = true;
			
		// 	if (GEN_POLYS_WORLD) {
		// 		drawPolys(polyFBOStrings[0], 0, 0,true);
		// 	}
		// 	if (POLY_COLLISION) {
		// 		drawPolys(polyFBOStrings[0], 0, DEF_VOL_SIZE/singleton->cellsPerHolder + 1,false);
		// 	}
			
		// 	singleton->perspectiveOn = false;
			
		// 	//glDisable(GL_CULL_FACE);
		// 	glDisable(GL_DEPTH_TEST);
			
		// 	//polyCombine();
		// }
		
		
		


		drawPrim(false,true,false);
		drawPrim(false,false,false);
		
		
		
		
		
		
		
		
		//singleton->copyFBO2("solidBaseTargFBO","solidTargFBO");
		
		singleton->bindShader("SolidCombineShader");
		singleton->bindFBO("solidTargFBO");//, -1, 0);
		singleton->sampleFBO("solidBaseTargFBO",0);
		singleton->sampleFBO("geomTargFBO",2);
		singleton->drawFSQuad();
		singleton->unsampleFBO("geomTargFBO",2);
		singleton->unsampleFBO("solidBaseTargFBO",0);
		singleton->unbindFBO();
		singleton->unbindShader();
		
	
		
		
		postProcess();
		
		
		
		drawMap();
		
		

		glutSwapBuffers();
		//glFlush();
		
		singleton->updateLock = false;

	}
void GameWorld::toggleVis (GameEnt * se)
                                    {
		
		if (se == NULL) {

		}
		else {
			se->visible = !(se->visible);
		}
	}
void GameWorld::ensureBlocks ()
                            {
		// first fetch all the blocks to make sure they get created
		// don't remove this, necessary for overlapping geom
		
		int i;
		int j;
		int k;
		int ii;
		int jj;
		int kk;
		int blockRad = 1;
		
		for (k = -blockRad; k <= blockRad; k++)
		{
			for (j = -blockRad; j <= blockRad; j++)
			{
				for (i = -blockRad; i <= blockRad; i++)
				{
					ii = i + camBlockPos.getIX();
					jj = j + camBlockPos.getIY();
					kk = k + camBlockPos.getIZ();

					getBlockAtCoords(ii, jj, kk, true);

				}
			}
		}
		
	}
void GameWorld::findNearestEnt (EntSelection * entSelection, int entType, int maxLoadRad, int radStep, FIVector4 * testPoint, bool onlyInteractive, bool ignoreDistance)
          {
		
		GameEnt* myEnt;
		
		int curInd = 0;
		float bestDis;
		float curDis;
		
		bool doProc = false;
		
		entSelection->selEntList.clear();
		entSelection->selEntMap.clear();
		entSelection->selEntListInd = 0;

		bestDis = 99999.0f;
		
		
		
		
		//////////////////////
		
		
		
		int i, j, k;
		int ii, jj, kk;
		int incVal;
		
		int tot = 0;


		int mink;
		int maxk;
		int minj;
		int maxj;
		int mini;
		int maxi;
		int curLoadRadius;
		intPair curId;
		
		tempVec.copyFrom(testPoint);
		tempVec.intDivXYZ(singleton->cellsPerHolder);


		GamePageHolder* curHolder;
		GameBlock *curBlock;


		ensureBlocks();
		
		
		

		for (curLoadRadius = 0; curLoadRadius < maxLoadRad; curLoadRadius++) {
			
			mink = max(tempVec.getIZ() - curLoadRadius,0);
			maxk = min(tempVec.getIZ() + curLoadRadius,holdersPerWorld-1);
			minj = tempVec.getIY() - curLoadRadius;
			maxj = tempVec.getIY() + curLoadRadius;
			mini = tempVec.getIX() - curLoadRadius;
			maxi = tempVec.getIX() + curLoadRadius;
			
			for (jj = minj; jj <= maxj; jj += radStep) {
				
				if (curLoadRadius <= 2) {
					incVal = 1;
				}
				else {
					if ( (jj == minj) || (jj == maxj) ) {
						incVal = radStep;
					}
					else {
						incVal = maxi - mini;
					}
				}
				
				for (ii = maxi; ii >= mini; ii -= incVal) {
					
					
					for (kk = mink; kk <= maxk; kk += radStep) {
						
						
						
						curHolder = getHolderAtCoords(ii, jj, kk, true);
						curBlock = getBlockAtId(curHolder->blockId);
						
						if (curBlock == NULL) {
							cout << "NULL BLOCK\n";
						}
						else {
							
							for (k = 0; k < curHolder->containsEntIds[entType].data.size(); k++) { //curBlock->gameEnts[entType].data.size()
								
								curId = curHolder->containsEntIds[entType].data[k];
								myEnt = &(blockData[curId.v0]->gameEnts[entType].data[curId.v1]);
								
								
								
								if (
									ignoreDistance||
									testPoint->inBoundsXYZSlack(
										myEnt->getVisMinInPixelsT(),
										myEnt->getVisMaxInPixelsT(),
										0.0625
									)
								)
								{
									
									if (entSelection->selEntMap.count(curId) == 0 ) {
										
										entSelection->selEntList.push_back(myEnt);
										entSelection->selEntMap[curId] = 1;
										
										
										
										curDis = 
										abs(myEnt->getVisMaxInPixelsT()->getFX()-testPoint->getFX()) +
										abs(myEnt->getVisMaxInPixelsT()->getFY()-testPoint->getFY()) +
										abs(myEnt->getVisMaxInPixelsT()->getFZ()-testPoint->getFZ());
										
										//myEnt->getVisMinInPixelsT()->distance(testPoint) +
										//myEnt->getVisMaxInPixelsT()->distance(testPoint);

										if (myEnt->visible) {
											
										}
										else {
											curDis *= 16.0f;
										}

										if (onlyInteractive) {
											doProc = singleton->isInteractiveEnt[myEnt->buildingType];
										}
										else {
											doProc = true;
										}

										if ((curDis < bestDis)&&doProc) {
											bestDis = curDis;
											entSelection->selEntListInd = curInd;
										}
										
										
										curInd++;
										
									}
									
									

								}
							}
							
							
						}
						
						
						
					}
					
				}
			}
			
		}
		
		
		
		
		//////////////////////
		
		
		//return resEnt;
	}
void GameWorld::drawVol (VolumeWrapper * curVW, FIVector4 * minc, FIVector4 * maxc, bool copyToTex, bool forceFinish, bool getVoro, bool getBlockHolders)
          {
		
		
		curVW->genPosMin.copyFrom( minc );
		curVW->genPosMax.copyFrom( maxc );
		
		//curVW->genPosMin.copyFrom( &(singleton->gameFluid[E_FID_BIG]->volMinReadyInPixels) );
		//curVW->genPosMax.copyFrom( &(singleton->gameFluid[E_FID_BIG]->volMaxReadyInPixels) );
		
		singleton->bindShader("TerGenShader");
		singleton->bindFBODirect(&(curVW->fboSet));
		singleton->sampleFBO("hmFBOLinearBig",2);
		
		if (!getVoro) {
			singleton->setShaderTexture3D(13, singleton->volumeWrappers[E_VW_VORO]->volId);
		}
		
		if (!getBlockHolders) {
			singleton->setShaderTexture3D(14, singleton->volumeWrappers[E_VW_WORLD]->volId);
		}
		
		singleton->setShaderfVec3("bufferDim", &(curVW->terGenDim) );
		
		singleton->setShaderFloat("voroSize",singleton->volumeWrappers[E_VW_VORO]->terGenDim.getFZ());
		
		singleton->setShaderFloat("mapPitch", singleton->mapPitch);
		singleton->setShaderFloat("seaLevel", singleton->getSLNormalized() );
		singleton->setShaderFloat("heightMapMaxInCells", singleton->heightMapMaxInCells);
		singleton->setShaderfVec4("mapFreqs", &(singleton->mapFreqs) );
		singleton->setShaderfVec4("mapAmps", &(singleton->mapAmps) );
		
		singleton->setShaderfVec3("volMinReadyInPixels", &(curVW->genPosMin) );
		singleton->setShaderfVec3("volMaxReadyInPixels", &(curVW->genPosMax) );
		//singleton->setShaderfVec3("volMinReadyInPixels", &(singleton->gameFluid[E_FID_BIG]->volMinInPixels) );
		//singleton->setShaderfVec3("volMaxReadyInPixels", &(singleton->gameFluid[E_FID_BIG]->volMaxInPixels) );
		
		singleton->setShaderInt("getVoro", (int)(getVoro));
		singleton->setShaderInt("getBlockHolders", (int)(getBlockHolders));
		
		singleton->setShaderFloat("cellsPerWorld", cellsPerWorld );
		
		singleton->fsQuad.draw();
		
		if (!getBlockHolders) {
			singleton->setShaderTexture3D(14, 0);
		}
		if (!getVoro) {
			singleton->setShaderTexture3D(13, 0);
		}
		singleton->unsampleFBO("hmFBOLinearBig",2);
		singleton->unbindFBO();
		singleton->unbindShader();
		
		if (forceFinish) {
			glFlush();
			glFinish();
		}
		
		FBOWrapper* fbow = curVW->fboSet.getFBOWrapper(0);
		fbow->getPixels();
		
		if (forceFinish) {
			glFlush();
			glFinish();
		}
		
		if (copyToTex) {
			if (curVW->isFloat) {
				curVW->copyFloatArr(fbow->pixelsFloat);
			}
			else {
				curVW->copyCharArr(fbow->pixelsChar);
			}
		}
		
	}
void GameWorld::updateLimbTBOData (bool showLimbs)
                                               {
		int i;
		int j;
		int q;
		
		BodyStruct* curBody;
		
		BaseObj* ge;
		
		btVector3 centerPoint;
		btVector3 tanVec;
		btVector3 bitVec;
		btVector3 norVec;
		btVector3 len0;
		btVector3 len1;
		btMatrix3x3 basis;
		
		GameOrg* curOrg = NULL;
		GameOrgNode* curOrgNode = NULL;
		
		float buffer = 0.5f;
		
		int dataInd = 0;
		int actorCount = 0;
		int headerStart;
		
		float myMat[16];
		btVector3 basePos;
		btVector3 tempBTV;
		Matrix4 myMatrix4;
		Vector4 myVector4;
		Vector4 resVector4;
		
		
		BaseObj* grabber;
		
		// if (singleton->doPathReport) {
		// 	cout << "\n\n";
		// }
		
		
		singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
		singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
		singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
		singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
		
		dataInd = 0;
		
		if (!showLimbs) {
			return;
		}
		
		
		
		for (i = 0; i < singleton->gem->visObjects.size(); i++) {
			ge = &(singleton->gem->gameObjects[singleton->gem->visObjects[i]]);
			
			if (
				(!(ge->isHidden)) &&
				(ge->orgId > -1) &&
				(ge->actorId > -1)	
			) {
				
				actorCount++;
				
				ge->clearAABB(&(ge->aabbMinVis),&(ge->aabbMaxVis));
				for (j = 0; j < ge->bodies.size(); j++) {
					curBody = &(ge->bodies[j]);
					ge->addAABBPoint(
						&(ge->aabbMinSkel),
						&(ge->aabbMaxSkel),
						curBody->body->getCenterOfMassPosition()
					);
				}
				
				curOrg = singleton->gem->gameOrgs[ge->orgId];
				
				if (ge->isGrabbedById > -1) {
					grabber = &(singleton->gem->gameObjects[ge->isGrabbedById]);
				}
				else {
					grabber = ge;
				}
				
				grabber->bodies[E_BDG_CENTER].body->getWorldTransform().getOpenGLMatrix(myMat);
				myMatrix4 = Matrix4(myMat);
				
				
				// header info
				headerStart = dataInd;
				singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
				singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
				singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
				singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
			
				singleton->limbTBOData[dataInd] = ge->aabbMinVis.getX() - buffer; dataInd++;
				singleton->limbTBOData[dataInd] = ge->aabbMinVis.getY() - buffer; dataInd++;
				singleton->limbTBOData[dataInd] = ge->aabbMinVis.getZ() - buffer; dataInd++;
				singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
				
				
				singleton->limbTBOData[dataInd] = ge->aabbMaxVis.getX() + buffer; dataInd++;
				singleton->limbTBOData[dataInd] = ge->aabbMaxVis.getY() + buffer; dataInd++;
				singleton->limbTBOData[dataInd] = ge->aabbMaxVis.getZ() + buffer; dataInd++;
				singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
				
				float randOff;
				
				for (j = 0; j < ge->bodies.size(); j++) {
					curBody = &(ge->bodies[j]);
					
					if (
						(curBody->jointType != E_JT_LIMB) ||
						(curBody->boneId < 0) ||
						(curBody->boneId == E_BONE_C_BASE) ||
						(
							singleton->gem->firstPerson &&
							(curBody->boneId == E_BONE_C_SKULL) &&
							(ge->uid == singleton->gem->getCurActorUID())
						)
						
					) {
						
					}
					else {
						
						
						
						curOrgNode = curOrg->allNodes[curBody->boneId];
						
						centerPoint = curBody->body->getCenterOfMassPosition();
						//centerPoint += btVector3(0.0,0.0,-0.4f);
						basis = curBody->body->getCenterOfMassTransform().getBasis();
						
						
						
						tempBTV = curOrgNode->tbnTrans[1].getBTV();
						myVector4 = Vector4(
							tempBTV.getX(),
							tempBTV.getY(),
							tempBTV.getZ(),
							1.0f
						);
						resVector4 = myMatrix4*myVector4;
						basePos = btVector3(resVector4.x,resVector4.y,resVector4.z);
						basePos += grabber->skelOffset;
						basePos -= centerPoint;
						safeNorm(basePos);
						
						
						
						tanVec = basis.getColumn(0);//basis*curOrgNode->orgVecs[0].getBTV();
						safeNorm(tanVec);
						// bitVec = basis.getColumn(1);//basis*curOrgNode->orgVecs[1].getBTV();
						// norVec = basis.getColumn(2);//basis*curOrgNode->orgVecs[2].getBTV();
						
						//tanVec = basePos[0];//basis*curOrgNode->orgVecs[0].getBTV();
						bitVec = basePos;//basis*curOrgNode->orgVecs[1].getBTV();
						//norVec = basePos[2];//basis*curOrgNode->orgVecs[2].getBTV();
						
						norVec = tanVec.cross(bitVec);
						safeNorm(norVec);
						
						bitVec = norVec.cross(tanVec);
						safeNorm(bitVec);
						
						
						len0 = curOrgNode->orgVecs[E_OV_TBNRAD0].getBTV();
						len1 = curOrgNode->orgVecs[E_OV_TBNRAD1].getBTV();
						
						
						// datVec
						randOff = abs( fSeedRand2((ge->uid*37.19232f),(curOrgNode->orgVecs[E_OV_MATPARAMS].getFX()*17.89923f)) );
						
						singleton->limbTBOData[dataInd] = ge->uid; dataInd++;
						singleton->limbTBOData[dataInd] = curBody->body->limbUID; dataInd++;
						singleton->limbTBOData[dataInd] = curOrgNode->orgVecs[E_OV_MATPARAMS].getFX(); dataInd++;
						singleton->limbTBOData[dataInd] = randOff; dataInd++;
						
						//cenVec
						
						singleton->limbTBOData[dataInd] = centerPoint.getX(); dataInd++;
						singleton->limbTBOData[dataInd] = centerPoint.getY(); dataInd++;
						singleton->limbTBOData[dataInd] = centerPoint.getZ(); dataInd++;
						singleton->limbTBOData[dataInd] = curOrgNode->orgVecs[E_OV_POWVALS].getFX(); dataInd++;
						
						singleton->limbTBOData[dataInd] = tanVec.getX(); dataInd++;
						singleton->limbTBOData[dataInd] = tanVec.getY(); dataInd++;
						singleton->limbTBOData[dataInd] = tanVec.getZ(); dataInd++;
						singleton->limbTBOData[dataInd] = curOrgNode->orgVecs[E_OV_POWVALS].getFY(); dataInd++;
						
						singleton->limbTBOData[dataInd] = bitVec.getX(); dataInd++;
						singleton->limbTBOData[dataInd] = bitVec.getY(); dataInd++;
						singleton->limbTBOData[dataInd] = bitVec.getZ(); dataInd++;
						singleton->limbTBOData[dataInd] = curOrgNode->orgVecs[E_OV_POWVALS].getFZ(); dataInd++;
						
						// if (singleton->doPathReport) {
						// 	cout << curOrgNode->orgVecs[E_OV_MATPARAMS].getFX() << "\n";
						// }
						
						singleton->limbTBOData[dataInd] = norVec.getX(); dataInd++;
						singleton->limbTBOData[dataInd] = norVec.getY(); dataInd++;
						singleton->limbTBOData[dataInd] = norVec.getZ(); dataInd++;
						singleton->limbTBOData[dataInd] = curOrgNode->orgVecs[E_OV_POWVALS].getFW(); dataInd++;
						
						// ln0Vec
						
						singleton->limbTBOData[dataInd] = len0.getX(); dataInd++;
						singleton->limbTBOData[dataInd] = len0.getY(); dataInd++;
						singleton->limbTBOData[dataInd] = len0.getZ(); dataInd++;
						singleton->limbTBOData[dataInd] = ge->entType; dataInd++;
						
						// ln1Vec
						
						singleton->limbTBOData[dataInd] = len1.getX(); dataInd++;
						singleton->limbTBOData[dataInd] = len1.getY(); dataInd++;
						singleton->limbTBOData[dataInd] = len1.getZ(); dataInd++;
						singleton->limbTBOData[dataInd] = curOrgNode->orgVecs[E_OV_TBNOFFSET].getFW(); dataInd++;
						
						
					}
				}
				
				singleton->limbTBOData[headerStart+0] = dataInd/4;
				singleton->limbTBOData[headerStart+1] = 0.0f;
				singleton->limbTBOData[headerStart+2] = 0.0f;
				singleton->limbTBOData[headerStart+3] = 0.0f;
				
				
				
			}
		}
		
		// pad end with blank data
		
		singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
		singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
		singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
		singleton->limbTBOData[dataInd] = 0.0f; dataInd++;
		
		singleton->actorCount = actorCount;
		
		singleton->limbTBO.update(singleton->limbTBOData,NULL,dataInd*4);
		
		// if (singleton->doPathReport) {
		// 	cout << "\n\n";
		// }
		// singleton->doPathReport = false;
	}
void GameWorld::drawPrim (bool doSphereMap, bool doTer, bool doPoly)
                                                                 {
		int i;
		
		int ind = 0;
		
		if (doSphereMap) {
			
			//cout << "doSphereMap\n";
			
			ind = 1;
		}
		
		
		bool skipPrim =			
			(singleton->gameFluid[E_FID_BIG]->curGeomCount == 0) &&
			(singleton->placingGeom == false);
		
		
		bool doPrim = !doTer;
		
		int curGeomCount = 0;
		
		
		
		
		
		if (doPrim) {
			ind = 2;
			
			curGeomCount = singleton->gameFluid[E_FID_BIG]->curGeomCount;
			
			if (skipPrim) {
				singleton->copyFBO2("terTargFBO","solidBaseTargFBO", 0, 1);
				singleton->copyFBO2("terTargFBO","waterTargFBO", 2, 3);
				singleton->copyFBO2("terTargFBO","prmDepthFBO", 4, 5);
				return;
			}
			
		}
		else {
			curGeomCount = MAX_PRIM_IDS;
		}
		
		
		
		if (doPoly) {
			singleton->bindShader("PrimShader_330_DOTER_DOPOLY");
			singleton->bindFBO("polyFBO");
		}
		else {
			if (doTer) {
				
				if (USE_SPHERE_MAP) {
					singleton->bindShader("PrimShader_330_DOTER_USESPHEREMAP");
				}
				else {
					singleton->bindShader("PrimShader_330_DOTER");
				}
				
			}
			else {
				singleton->bindShader("PrimShader_330_DOPRIM");
			}
			singleton->bindFBO(curTargFBO[ind]);
		}
		
		
		
		
		
		
		
		
		singleton->setShaderTexture3D(0, singleton->gameFluid[E_FID_BIG]->volIdPrim[0]);
		
		if (doPrim) {
			singleton->setShaderTBO(
				1,
				singleton->gameFluid[E_FID_BIG]->tboWrapper.tbo_tex,
				singleton->gameFluid[E_FID_BIG]->tboWrapper.tbo_buf,
				true
			);
		}
		else {
			singleton->setShaderTBO(
				1,
				singleton->limbTBO.tbo_tex,
				singleton->limbTBO.tbo_buf,
				true
			);
		}
		
		
		
		singleton->sampleFBO("hmFBOLinearBig",2);
		singleton->sampleFBO("terDepthFBO",3);
		
		//if (USE_SPHERE_MAP) {
		//	singleton->sampleFBO("sphDepthFBO",5);
		//}
		
		singleton->sampleFBO("geomTargFBO",5);
		
		// sample opposite pass
		if (doPrim) {
			singleton->sampleFBO("terTargFBO",7, -1, 0, 6);
		}
		else {
			singleton->sampleFBO("prmTargFBO",7, -1, 0, 6);
		}
		
		singleton->setShaderTexture3D(13, singleton->volumeWrappers[E_VW_VORO]->volId);
		singleton->setShaderTexture3D(14, singleton->volumeWrappers[E_VW_WORLD]->volId);
		singleton->sampleFBO("noiseFBOLinear", 15);
		
		// if (!doPoly) {
		// 	singleton->sampleFBO(polyFBOStrings[NUM_POLY_STRINGS],14);
		// }
		
		
		
		
		if ((singleton->gem->getCurActor() == NULL)||singleton->gem->firstPerson) {
			singleton->setShaderFloat("thirdPerson", 0.0f);
			//singleton->setShaderFloat("CAM_BOX_SIZE", 0.5f);
		}
		else {
			singleton->setShaderFloat("thirdPerson", 1.0f);
			//singleton->setShaderFloat("CAM_BOX_SIZE", 0.5f);
			singleton->setShaderfVec3("entPos", singleton->gem->getCurActor()->getCenterPointFIV(0));
		}
		
		
		singleton->setShaderFloat("isUnderWater", -(singleton->getUnderWater()-0.5f)*2.0f );
		
		
		singleton->setShaderMatrix4x4("modelview",singleton->viewMatrix.get(),1);
		singleton->setShaderMatrix4x4("proj",singleton->projMatrix.get(),1);
		singleton->setShaderMatrix4x4("modelviewInverse",singleton->viewMatrixDI,1);
		//singleton->setShaderInt("readPoly", (int)(readPoly));
		singleton->setShaderInt("depthInvalidMove", (int)(singleton->depthInvalidMove));
		singleton->setShaderInt("depthInvalidRotate", (int)(singleton->depthInvalidRotate));
		
		singleton->setShaderFloat("voroSize",singleton->volumeWrappers[E_VW_VORO]->terGenDim.getFZ());
		
		singleton->setShaderInt("actorCount",singleton->actorCount);
		singleton->setShaderInt("MAX_PRIM_IDS", min(curGeomCount,MAX_PRIM_IDS));
		singleton->setShaderInt("MAX_PRIMTEST", min(curGeomCount,MAX_PRIMTEST));
		
		
		singleton->setShaderFloat("invalidCount", invalidCount/invalidCountMax);
		singleton->setShaderInt("doSphereMap",
			// (int)(doSphereMap)
			(int)(singleton->sphereMapOn)
		);
		singleton->setShaderInt("testOn", (int)(singleton->testOn));
		singleton->setShaderInt("skipPrim", (int)(skipPrim));
		singleton->setShaderInt("placingGeom", (int)(singleton->placingGeom));
		
		
		
		singleton->setShaderfVec3("waterMin", &(singleton->gameFluid[E_FID_BIG]->curWaterMin) );
		singleton->setShaderfVec3("waterMax", &(singleton->gameFluid[E_FID_BIG]->curWaterMax) );
		
		
		singleton->setShaderfVec3("volMinReadyInPixels", &(singleton->gameFluid[E_FID_BIG]->volMinReadyInPixels) );
		singleton->setShaderfVec3("volMaxReadyInPixels", &(singleton->gameFluid[E_FID_BIG]->volMaxReadyInPixels) );
		
		
		singleton->setShaderFloat("mapPitch", singleton->mapPitch);
		singleton->setShaderFloat("seaLevel", singleton->getSLNormalized() );
		singleton->setShaderFloat("heightMapMaxInCells", singleton->heightMapMaxInCells);
		singleton->setShaderfVec4("mapFreqs", &(singleton->mapFreqs) );
		singleton->setShaderfVec4("mapAmps", &(singleton->mapAmps) );
		
		singleton->setShaderFloat("SPHEREMAP_SCALE_FACTOR", SPHEREMAP_SCALE_FACTOR);
		singleton->setShaderFloat("UNIT_MAX", FLUID_UNIT_MAX + 1);
		singleton->setShaderFloat("waterLerp", singleton->gameFluid[E_FID_BIG]->waterLerp); //todo: E_FID_SML?
		singleton->setShaderFloat("volSizePrim", singleton->gameFluid[E_FID_BIG]->volSizePrim);
		singleton->setShaderFloat("curTime", singleton->pauseTime/1000.0f);
		singleton->setShaderfVec2("bufferDim", &(singleton->bufferRenderDim) );
		singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		singleton->setShaderfVec3("lookAtVec", &(singleton->lookAtVec) );
		singleton->setShaderfVec3("lightVec", &(singleton->lightVec) );
		singleton->setShaderFloat("cellsPerWorld", cellsPerWorld );
		
		// singleton->setShaderFloat("volSizePrimSmall", singleton->gameFluid[E_FID_SML]->volSizePrim);
		// singleton->setShaderfVec3("volMinReadyInPixelsSmall", &(singleton->gameFluid[E_FID_SML]->volMinReadyInPixels) );
		// singleton->setShaderfVec3("volMaxReadyInPixelsSmall", &(singleton->gameFluid[E_FID_SML]->volMaxReadyInPixels) );
		
		singleton->setShaderVec2("clipDist",singleton->clipDist[0],singleton->clipDist[1]);
		singleton->setShaderFloat("FOV", singleton->FOV*M_PI/180.0f);
		
		
		//paramFetch1: x,y,z: position; w: template number
		//paramFetch2: x:diagMask, y:uid, z:?, w:?
		
		
		
		tempVec1.copyFrom(&(singleton->geomPoints[0]));
		tempVec1.addXYZRef(&(singleton->geomOrigOffset));
		
		tempVec2.setFXYZW(0.0f,-99.0f,0.0f,0.0f);
		
		singleton->setShaderfVec4("paramFetch1", &tempVec1 );
		singleton->setShaderfVec4("paramFetch2", &tempVec2 );
		singleton->setShaderArrayfVec4("paramArrGeom", singleton->paramArrGeom, E_PRIMTEMP_LENGTH);
		
		
		if (singleton->gem->getCurActor() != NULL) {
			
			singleton->splashArr[0] = singleton->gem->getCurActor()->getCenterPointFIV(0)->getFX();
			singleton->splashArr[1] = singleton->gem->getCurActor()->getCenterPointFIV(0)->getFX();
			singleton->splashArr[2] = singleton->gem->getCurActor()->getCenterPointFIV(0)->getFX();
			singleton->splashArr[3] = singleton->gem->getCurActor()->getVel(0)->length();
			
			singleton->setShaderInt("numSplashes", 1);
			singleton->setShaderArrayfVec4("splashArr", singleton->splashArr, MAX_SPLASHES);
		}
		else {
			singleton->setShaderInt("numSplashes", 0);
		}
		
		
		
		if (singleton->waterBulletOn) {
			singleton->setShaderInt("numExplodes", 0);
		}
		else {
			singleton->setShaderInt("numExplodes", singleton->sphereStack.size());
			
			if ( singleton->sphereStack.size() > 0) {
				for (i = 0; i < singleton->sphereStack.size();i++) {
					singleton->explodeArr[i*4+0] = singleton->sphereStack[i].position[0];
					singleton->explodeArr[i*4+1] = singleton->sphereStack[i].position[1];
					singleton->explodeArr[i*4+2] = singleton->sphereStack[i].position[2];
					singleton->explodeArr[i*4+3] = singleton->sphereStack[i].curRad;
				}
				singleton->setShaderArrayfVec4("explodeArr", singleton->explodeArr, MAX_EXPLODES);
			}
		}
		
		
		if (doPoly) {
			rasterPolys(0,5);
		}
		else {
			singleton->fsQuad.draw();
		}
		
		// if (!doPoly) {
		// 	singleton->unsampleFBO(polyFBOStrings[NUM_POLY_STRINGS],14);
		// }
		
		
		singleton->unsampleFBO("noiseFBOLinear", 15);
		singleton->setShaderTexture3D(14, 0);
		singleton->setShaderTexture3D(13, 0);
		
		
		if (doPrim) {
			singleton->unsampleFBO("terTargFBO",7, -1, 0, 6);
		}
		else {
			singleton->unsampleFBO("prmTargFBO",7, -1, 0, 6);
		}
		
		// if (USE_SPHERE_MAP) {
		// 	singleton->unsampleFBO("sphDepthFBO",5);
		// }
		singleton->unsampleFBO("geomTargFBO",5);
		
		singleton->unsampleFBO("terDepthFBO",3);
		singleton->unsampleFBO("hmFBOLinearBig",2);
		
		singleton->setShaderTBO(1,0,0,true);
		singleton->setShaderTexture3D(1, 0);
		
		singleton->unbindFBO();
		singleton->unbindShader();
		
		if (doPoly) {
			return;
		}
		
		if (doTer) {
			singleton->copyFBO("terTargFBO", "limbFBO", 6);
		}
		
		
		singleton->copyFBO2(curTargFBO[ind],curDepthFBO[ind], 4, 5);
		
		if (doPrim) {
			singleton->copyFBO2("prmTargFBO","waterTargFBO", 2, 3);
			singleton->copyFBO2("prmTargFBO","solidBaseTargFBO", 0, 1);
		}
		
		
		
		
	}
void GameWorld::drawOrg (GameOrg * curOrg, bool drawAll)
                                                    {
		
		if (curOrg == NULL) {
			return;
		}
		
		float scale = 1.0f;
		
		
		
		
		
		// tangents
		singleton->setShaderVec3("matVal", 255, 0, 0 );
		drawNodeEnt((curOrg->baseNode),&(curOrg->basePosition), scale, 0, drawAll);
		
		// bitangents
		singleton->setShaderVec3("matVal", 0, 255, 0);
		drawNodeEnt((curOrg->baseNode),&(curOrg->basePosition), scale, 1, drawAll);
		
		// normals
		singleton->setShaderVec3("matVal", 0, 0, 255);
		drawNodeEnt((curOrg->baseNode),&(curOrg->basePosition), scale, 2, drawAll);
		
		if (drawAll) {
			// nodes
			singleton->setShaderVec3("matVal", 254, 254, 254);
			drawNodeEnt((curOrg->baseNode),&(curOrg->basePosition), scale, 3, drawAll);
		}
		
		
		
	}
void GameWorld::drawNodeEnt (GameOrgNode * curNode, FIVector4 * basePosition, float scale, int drawMode, bool drawAll)
          {
		
		
		BaseObj* grabber;
		
		
		bool doProc = false;
		
		if (drawAll) {
			doProc = true;
		}
		else {
			if (curNode == singleton->gem->selectedNode) {
				doProc = true;
			}
		}
		
		int i;
		
		
		if (doProc) {
			lineSeg[0].setFXYZRef(&(curNode->orgTrans[0]));
			lineSeg[0].multXYZ(  scale  );
			
			// if (drawAll) {
			// 	lineSeg[1].setFXYZRef(&(curNode->tbnTrans[drawMode%3]));
			// 	lineSeg[1].multXYZ(  scale  );
			// }
			// else {
				lineSeg[1].setFXYZRef(&(curNode->tbnRotC[drawMode%3]));
				lineSeg[1].multXYZ( 1.0f );//(curNode->orgVecs[E_OV_TBNRAD0][drawMode%3]*scale)  ); //*16.0f
				//lineSeg[1].multXYZ(&(curNode->tbnRadScale0));
				lineSeg[1].addXYZRef(&(lineSeg[0]));
			//}
			
			if (singleton->gem->getCurActor() != NULL) {
				
				
				if (singleton->gem->getCurActor()->isGrabbedById > -1) {
					grabber = &(singleton->gem->gameObjects[singleton->gem->getCurActor()->isGrabbedById]);
				}
				else {
					grabber = singleton->gem->getCurActor();
				}
				
				
				lineSeg[0].addXYZ(0.0f,0.0f,grabber->skelOffset.getZ());
				lineSeg[1].addXYZ(0.0f,0.0f,grabber->skelOffset.getZ());
			}
			
			
			
			
			switch(drawMode) {
				case 0: // tangents
				case 1: // bitangents
				case 2: // normals
					singleton->drawLine(&(lineSeg[0]),&(lineSeg[1]));
				break;
				case 3: // nodes
					singleton->drawCubeCentered(&(lineSeg[1]),0.0125f*scale);
				break;
				
			}
		}
		
		
		for (i = 0; i < curNode->children.size(); i++) {
			drawNodeEnt(curNode->children[i], basePosition, scale, drawMode, drawAll);
		}
		
	}
void GameWorld::polyCombine ()
                           {
		int q;
		
		singleton->bindShader("PolyCombineShader");
		singleton->bindFBO(polyFBOStrings[NUM_POLY_STRINGS]);
		
		for (q = 0; q < NUM_POLY_STRINGS; q++) {
			singleton->sampleFBO(polyFBOStrings[q], q);
		}
		
		singleton->fsQuad.draw();
		
		for (q = NUM_POLY_STRINGS-1; q >= 0; q--) {
			singleton->unsampleFBO(polyFBOStrings[q], q);
		}
		
		singleton->unbindFBO();
		singleton->unbindShader();
	}
void GameWorld::drawPolys (string fboName, int minPeel, int maxPeel, bool isBlockHolder)
                                                                                     {
		
		//VolumeWrapper* curVW = (singleton->volumeWrappers[E_VW_VORO]);
		
		singleton->bindShader("PolyShader");
		singleton->bindFBO(fboName);
		
		//glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		
		//singleton->sampleFBO("polyFBO",0,fboNum);
		
		///singleton->setShaderTexture3D(0, singleton->gameFluid[E_FID_BIG]->volIdPrim[0]);
		//singleton->sampleFBO("hmFBOLinearBig",2);
		//singleton->setShaderTexture3D(13, curVW->volId);
		
		if (polyFBOStrings[0].compare(fboName) == 0) {
			singleton->setShaderVec4("maskVals", 1.0f, 0.0f, 0.0f, 0.0f);
		}
		else {
			singleton->setShaderVec4("maskVals", 0.0f, 1.0f, 0.0f, 0.0f);
		}
		
		
		singleton->setShaderFloat("volSizePrim", singleton->gameFluid[E_FID_BIG]->volSizePrim);
		singleton->setShaderFloat("FOV", singleton->FOV*M_PI/180.0f);
		singleton->setShaderVec2("clipDist",singleton->clipDist[0],singleton->clipDist[1]);
		singleton->setShaderfVec2("bufferDim", &(singleton->bufferRenderDim) );
		singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		singleton->setShaderfVec3("volMinReadyInPixels", &(singleton->gameFluid[E_FID_BIG]->volMinReadyInPixels) );
		singleton->setShaderfVec3("lookAtVec", &(singleton->lookAtVec) );
		
		singleton->setShaderMatrix4x4("modelviewInverse",singleton->viewMatrixDI,1);
		singleton->setShaderMatrix4x4("modelview",singleton->viewMatrix.get(),1);
		singleton->setShaderMatrix4x4("proj",singleton->projMatrix.get(),1);
		
		if (isBlockHolder) {
			rasterPolysWorld();
		}
		else {
			rasterPolys(minPeel,maxPeel*4, 6);
		}
		
		
		
		// singleton->setShaderTexture3D(13, 0);
		// singleton->unsampleFBO("hmFBOLinearBig",2);
		// singleton->setShaderTexture3D(0,0);
		
		//singleton->unsampleFBO("polyFBO",0,fboNum);
		singleton->unbindFBO();
		singleton->unbindShader();
	}
void GameWorld::rasterPolysWorld ()
                                {
		
		
		GamePageHolder* curHolder = blockHolder;
		
		if (curHolder == NULL) {
			return;
		}
		
		if (
			(curHolder->listGenerated) &&
			(!(curHolder->listEmpty))
		) {
			curHolder->vboWrapper.draw();
		}
		
		
		
	}
void GameWorld::rasterPolys (int minPeel, int maxPeel, int extraRad)
                                                                     {
		
		int q;
		
		int ii;
		int jj;
		int kk;
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		
		
		GamePageHolder* curHolder;
		
		minv.copyIntDiv(&(singleton->gameFluid[E_FID_BIG]->volMinReadyInPixels),cellsPerHolder);
		maxv.copyIntDiv(&(singleton->gameFluid[E_FID_BIG]->volMaxReadyInPixels),cellsPerHolder);
		
		
		
		bool idealDis = false;
		
		int pCount = 0;
		
		
		int bi = singleton->lastHolderPos.getIX();
		int bj = singleton->lastHolderPos.getIY();
		int bk = singleton->lastHolderPos.getIZ();
		
		int curRad = 0;
		
		
		int minK = minv.getIZ() - extraRad;
		int maxK = maxv.getIZ() + extraRad;
		int minJ = minv.getIY() - extraRad;
		int maxJ = maxv.getIY() + extraRad;
		int minI = minv.getIX() - extraRad;
		int maxI = maxv.getIX() + extraRad;
		
		int qmod;
		
		if (minPeel < maxPeel) {
			qmod = 1;
		}
		else {
			qmod = -1;
		}
		
		for (q = minPeel; q != maxPeel; q += qmod) {
			
			// if (q <= 1) {
			// 	doClear = 1;
			// }
			// else {
			// 	doClear = 0;
			// }
			
			
			// switch(q) {
			// 	case 0:
			// 		singleton->setShaderVec4("maskVals", 1.0f, 0.0f, 0.0f, 0.0f);
			// 	break;
			// 	case 1:
			// 		singleton->setShaderVec4("maskVals", 0.0f, 1.0f, 0.0f, 0.0f);
			// 	break;
			// 	case 2:
			// 		singleton->setShaderVec4("maskVals", 0.0f, 0.0f, 1.0f, 0.0f);
			// 	break;
			// 	case 3:
			// 		singleton->setShaderVec4("maskVals", 0.0f, 0.0f, 0.0f, 1.0f);
			// 	break;
			// 	case 4:
			// 		singleton->setShaderVec4("maskVals", 1.0f, 0.0f, 0.0f, 0.0f);
			// 	break;
			// }
			
			
			// singleton->bindFBO("polyFBO");//,swapFlag);
			// //singleton->sampleFBO("polyFBO", 0, swapFlag);
			
			for (kk = minK; kk < maxK; kk++) {
				for (jj = minJ; jj < maxJ; jj++) {
					for (ii = minI; ii < maxI; ii++) {
						curHolder = getHolderAtCoords(ii,jj,kk,true);
						
						curRad = max(max(abs(bi-ii),abs(bj-jj)),abs(bk-kk));
						
						
						// if (q == 4) {
						// 	idealDis = true;
						// }
						// else {
						// 	if (q == 3) {
						// 		idealDis = (q>=curRad);
						// 	}
						// 	else {
						// 		idealDis = (q==curRad);
						// 	}
						// }
						
						
						if (
							(curHolder->listGenerated) &&
							(!(curHolder->listEmpty)) &&
							(q==curRad) || (q == -1)
						) {
							
							pCount++;
							
							// singleton->setShaderFloat("volSizePrim", singleton->cellsPerHolder);
							// singleton->setShaderfVec3("volMinReadyInPixels", &(curHolder->gphMinInPixels) );
							// singleton->setShaderfVec3("volMaxReadyInPixels", &(curHolder->gphMaxInPixels) );
							// singleton->setShaderTexture3D(0, curHolder->terVW->volId);
							
							curHolder->vboWrapper.draw();
							
						}
					}
				}
			}
			
			//singleton->unsampleFBO("polyFBO", 0);//, swapFlag);
			//singleton->unbindFBO();
			
			//swapFlag = 1 - swapFlag;
			
		}
		
		
		// singleton->setShaderTexture3D(13, 0);
		// singleton->unsampleFBO("hmFBOLinearBig",2);
		// singleton->setShaderTexture3D(0,0);
		
		// singleton->unbindShader();
		
		singleton->polyCount = pCount;
		
		
	}
void GameWorld::renderGeom ()
        {

		int i;
		int j;
		int k;
		int n;
		int q;
		
		int ii;
		int jj;
		int kk;
		int ii2;
		int jj2;
		int kk2;
		
		FIVector4 p0;
		FIVector4 p1;
		FIVector4 p2;
		FIVector4 p3;
		FIVector4 rotVec;
		
		int ind;
		int lastId;
		int curId;
		int curInd;
		int cameFromInd;
		
		int cellsPerHolder = singleton->cellsPerHolder;
		
		
		float frameMod;
		int objCount = 0;
		
		int curOr;
		bool doProc;
		int cellVal;
		int xmax,ymax,zmax;
		int xmin,ymin,zmin;
		
		CharStruct* tempCS;
		
		BaseObj* curObj;
		BaseObj* eqObj;
		
		bool showHit = false;
		float dirVecLength = 4.0f;
		
		float x1 = 0.0f;
		float x2 = 0.0f;
		float y1 = 0.0f;
		float y2 = 0.0f;
		float iw = singleton->fontWrappers[EFW_ICONS]->fontImage->width;
		float ih = singleton->fontWrappers[EFW_ICONS]->fontImage->height;



		// singleton->bindShader("GeomShader");
		// singleton->bindFBO("geomBaseTargFBO");
		// singleton->setShaderFloat("objectId",0.0);
		// singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		// singleton->setShaderfVec3("lookAtVec", &(singleton->lookAtVec));
		// singleton->setShaderFloat("isWire", 0.0);
		// singleton->setShaderFloat("clipDist",singleton->clipDist[1]);
		// singleton->setShaderfVec3("offsetPos",&(singleton->origin));
		// singleton->setShaderMatrix4x4("modelview",singleton->viewMatrix.get(),1);
		// singleton->setShaderMatrix4x4("proj",singleton->projMatrix.get(),1);
		
		
		
		
		// singleton->setShaderVec3("matVal", 30, 30, 30);
		
		
		// //singleton->gamePhysics->example->renderScene();
		
		
		
		
		// for(i = 0; i < singleton->gem->visObjects.size(); i++) {
			
		// 	curObj = &(singleton->gem->gameObjects[visObjects[i]]);
			
		// 	objCount++;
			
		// 	if (curObj->isHidden) {
				
		// 	}
		// 	else {
								
				
				
				
		// 		// tempVec1.copyFrom( &(curObj->boundsMinTransInPixels) );
		// 		// tempVec2.copyFrom( &(curObj->boundsMaxTransInPixels) );
				
				
				
		// 		// tempVec3.copyFrom(curObj->getCenterPointFIV(0));
		// 		// tempVec3.setFW(curObj->ang);
				
		// 		// singleton->setShaderfVec4("rotationZ",&tempVec3);
				
		// 		doProc = false;
				
		// 		if (visObjects[i] == singleton->actObjInd) {
					
		// 			if (!singleton->gem->firstPerson) {
						
		// 				// singleton->drawBox(
		// 				// 	&tempVec1,
		// 				// 	&tempVec2
		// 				// );
						
		// 				doProc = true;
						
						
						
						
		// 				// singleton->setShaderFloat("objectId",0);
						
		// 				// tempVec1.copyFrom( curObj->getCenterPointFIV(0) );
						
						
		// 				// curOr = curObj->orientationXYZ.getIX();
		// 				// tempVec2.setFXYZRef( &(singleton->dirVecs[curOr]) );
		// 				// tempVec2.multXYZ(2.0f);
		// 				// tempVec2.addXYZRef(&tempVec1);
		// 				// singleton->setShaderVec3("matVal", 255, 0, 0);
		// 				// singleton->drawLine(&tempVec1,&tempVec2);
						
		// 				// curOr = curObj->orientationXYZ.getIY();
		// 				// tempVec2.setFXYZRef( &(singleton->dirVecs[curOr]) );
		// 				// tempVec2.multXYZ(2.0f);
		// 				// tempVec2.addXYZRef(&tempVec1);
		// 				// singleton->setShaderVec3("matVal", 0, 255, 0);
		// 				// singleton->drawLine(&tempVec1,&tempVec2);
						
		// 				// curOr = curObj->orientationXYZ.getIZ();
		// 				// tempVec2.setFXYZRef( &(singleton->dirVecs[curOr]) );
		// 				// tempVec2.multXYZ(2.0f);
		// 				// tempVec2.addXYZRef(&tempVec1);
		// 				// singleton->setShaderVec3("matVal", 0, 0, 255);
		// 				// singleton->drawLine(&tempVec1,&tempVec2);
						
						
		// 				// singleton->setShaderVec3("matVal", 30, 30, 30);
		// 			}
					
					
					
		// 		}
		// 		else {
					
		// 			if (
		// 				(curObj->entType == E_ENTTYPE_BULLET) ||
		// 				(curObj->entType == E_ENTTYPE_TRACE) ||
		// 				(
		// 					(singleton->gem->firstPerson) &&
		// 					(curObj->uid == singleton->gem->getCurActorUID())
		// 				)
		// 			) {
						
		// 			}
		// 			else {
		// 				// singleton->drawBox(
		// 				// 	&tempVec1,
		// 				// 	&tempVec2
		// 				// );
						
		// 				doProc = true;
		// 			}
					
					
		// 		}
				
		// 		if (doProc) {
					
		// 			singleton->setShaderFloat("objectId",visObjects[i]);
					
		// 			// if (curObj->body != NULL) {
		// 			// 	glBegin( GL_TRIANGLES );
		// 			// 	//curObj->body->Render(&q3Rend);
		// 			// 	glEnd( );
		// 			// }
		// 		}
				
		// 	}
								
						
			
			
			
			
		// }
		
		
		
		// tempVec3.setFXYZW(0.0f,0.0f,0.0f,0.0f);
		// singleton->setShaderfVec4("rotationZ",&tempVec3);
		// singleton->setShaderFloat("objectId",0.0);
		




		
		// // singleton->setShaderFloat("isWire", 1.0);
		// // singleton->setShaderVec3("matVal", 255, 0, 0);
		// // minv.setFXYZRef(&(singleton->gameFluid[E_FID_BIG]->curDirtyMin));
		// // maxv.setFXYZRef(&(singleton->gameFluid[E_FID_BIG]->curDirtyMax));
		// // minv.addXYZRef(&(singleton->gameFluid[E_FID_BIG]->volMinReadyInPixels));
		// // maxv.addXYZRef(&(singleton->gameFluid[E_FID_BIG]->volMinReadyInPixels));
		// // minv.addXYZ(-4.0f,-4.0f,0.0f);
		// // maxv.addXYZ(4.0f,4.0f,0.0f);
		// // singleton->drawBox(&minv, &maxv);
		
		
		// // singleton->setShaderFloat("isWire", 1.0);
		// // singleton->setShaderVec3("matVal", 255, 0, 0);
		// // minv.setFXYZRef(&(singleton->gameFluid[E_FID_BIG]->curWaterMin));
		// // maxv.setFXYZRef(&(singleton->gameFluid[E_FID_BIG]->curWaterMax));
		// // minv.addXYZ(-4.0f,-4.0f,0.0f);
		// // maxv.addXYZ(4.0f,4.0f,0.0f);
		// // singleton->drawBox(&minv, &maxv);
		
		
		

		// switch (singleton->mouseState)
		// {

		// case E_MOUSE_STATE_MOVE:
			
			
		
		// 	// if (singleton->placingGeom) {
				
				
		// 	// 	singleton->setShaderVec3("matVal", 255, 0, 0);
		// 	// 	singleton->setShaderFloat("isWire", 0.0);
				
		// 	// 	for (i = 0; i <= singleton->geomStep; i++) {
					
		// 	// 		singleton->drawCubeCentered(
		// 	// 			&singleton->geomPoints[i],
		// 	// 			0.25f	
		// 	// 		);
		// 	// 	}
		// 	// }
		
		// 	break;
		
		// case E_MOUSE_STATE_BRUSH:
			
			
		// 	if (singleton->earthMod == E_PTT_TER) {
		// 		singleton->setShaderVec3("matVal", 255, 0, 0);
		// 	}
		// 	else {
		// 		singleton->setShaderVec3("matVal", 0, 0, 255);
		// 	}
			
			
		// 	singleton->setShaderFloat("isWire", 1.0);
		// 	singleton->drawCubeCentered(
		// 		&lastUnitPos,
		// 		((int)singleton->curBrushRad)
		// 	);
			
			
		// 	//glClear(GL_DEPTH_BUFFER_BIT);
		// break;
		// case E_MOUSE_STATE_PICKING:

			
			

		// 	if (singleton->highlightedEnt == NULL)
		// 	{

		// 	}
		// 	else
		// 	{
		// 		singleton->setShaderVec3("matVal", 254, 254, 254);
		// 		singleton->setShaderFloat("isWire", 1.0);

		// 		minv.setFXYZRef(singleton->highlightedEnt->getVisMinInPixelsT());
		// 		maxv.setFXYZRef(singleton->highlightedEnt->getVisMaxInPixelsT());

		// 		minv.addXYZ(-0.25);
		// 		maxv.addXYZ(0.25);


		// 		singleton->drawBox(&minv, &maxv);
		// 	}

		// 	if (singleton->selectedEnts.getSelectedEnt() == NULL)
		// 	{

		// 	}
		// 	else
		// 	{
		// 		singleton->setShaderVec3("matVal", 255, 255, 0);
		// 		singleton->setShaderFloat("isWire", 1.0);

		// 		minv.setFXYZRef(singleton->selectedEnts.getSelectedEnt()->getVisMinInPixelsT());
		// 		maxv.setFXYZRef(singleton->selectedEnts.getSelectedEnt()->getVisMaxInPixelsT());

		// 		singleton->drawBox(&minv, &maxv);
		// 	}


		// 	break;

		// }
		
		// if (singleton->pathfindingOn) {
		// 	singleton->gameLogic->update();
		// }
		
		
		
		// if (
		// 	(singleton->bCtrl) &&
		// 	(singleton->mouseState != E_MOUSE_STATE_BRUSH) &&
		// 	(!(singleton->anyMenuVisible()))	
		// ) {
		// 	for (i = 1; i < singleton->dynObjects.size(); i++) {
		// 		if (singleton->dynObjects[i]->doRender)
		// 		{

		// 			doProc = false;

		// 			if (i >= E_OBJ_LIGHT0)
		// 			{
		// 				if (i - E_OBJ_LIGHT0 < singleton->numDynLights)
		// 				{
		// 					doProc = true;
		// 				}
		// 			}
		// 			else
		// 			{
		// 				doProc = true;
		// 			}

		// 			if (doProc)
		// 			{
		// 				singleton->setShaderFloat("objectId",i);
		// 				singleton->setShaderfVec3("matVal", &(singleton->dynObjects[i]->color) );
		// 				curBoxPos = &(singleton->dynObjects[i]->pos);
		// 				singleton->drawCubeCentered(curBoxPos, singleton->dynObjects[i]->radius);


		// 				if (i == singleton->activeObject)
		// 				{
		// 					//singleton->drawCrossHairs(singleton->dynObjects[i]->pos,4.0f);
		// 				}
		// 			}


		// 		}
		// 	}
		// }
		
		
		// // singleton->setShaderVec3("matVal", 254, 0, 0);
		// // singleton->setShaderFloat("isWire", 1.0);
		// // for (i = 0; i < singleton->nearestLights.selEntList.size(); i++) {
			

		// // 	minv.setFXYZRef(singleton->nearestLights.selEntList[i]->getVisMinInPixelsT());
		// // 	maxv.setFXYZRef(singleton->nearestLights.selEntList[i]->getVisMaxInPixelsT());


		// // 	singleton->drawBox(&minv, &maxv);
		// // }



		
		
		// singleton->unbindFBO();
		// singleton->unbindShader();



		float yval;



		
		
		//~~~~~~~~~~~~~~
		
		singleton->bindShader("BoxShader");
		singleton->bindFBO("geomBaseTargFBO");//, -1, 0); //solidTargFBO
		singleton->setShaderfVec3("lightVec", &(singleton->lightVec) );
		singleton->setShaderFloat("objectId",0.0);
		singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		singleton->setShaderfVec3("lookAtVec", &(singleton->lookAtVec));
		singleton->setShaderFloat("isWire", 0.0);
		singleton->setShaderFloat("clipDist",singleton->clipDist[1]);
		singleton->setShaderMatrix4x4("modelview",singleton->viewMatrix.get(),1);
		singleton->setShaderMatrix4x4("proj",singleton->projMatrix.get(),1);
		singleton->setShaderVec3("matVal", 1, 1, 1);
					
		// glBegin( GL_TRIANGLES );
		// //m_data->m_gl2ShapeDrawer->drawScene(rbWorld,true);
		// singleton->gamePhysics->myShapeDrawer->drawScene(
		// 	singleton->gamePhysics->example->getDynamicsWorld(), true); //drawAll();
		// glEnd( );
		
		//glMatrixMode(GL_MODELVIEW);		
		// singleton->gamePhysics->myShapeDrawer->drawScene(
		// 	singleton->gamePhysics->example->getDynamicsWorld(),
		// 	false
		// );
		
		
		
		if (singleton->gamePhysics != NULL) {
			singleton->drawOrient = false;
			singleton->gamePhysics->example->renderScene();
		}
		
		
		singleton->unbindFBO();
		singleton->unbindShader();
		
		
		singleton->copyFBO2("geomBaseTargFBO","geomTargFBO", 0, 1);
		
		
		//~~~~~~~~~~~~~~
		
		
		
		
		

		//////////////////////////////
		
		
		// singleton->bindShader("CylBBShader");
		// singleton->bindFBO("geomBaseTargFBO", -1, 0);
		// singleton->setShaderfVec2("bufferDim", &(singleton->bufferModDim) );
		// singleton->setShaderFloat("clipDist",singleton->clipDist[1]);
		// singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		// singleton->setShaderFloat("curTime", singleton->pauseTime/1000.0f);
		// singleton->setShaderTexture(0,singleton->fontWrappers[EFW_ICONS]->fontImage->tid);
		
		// for(i = 0; i < singleton->gem->visObjects.size(); i++) {
			
		// 	curObj = &(singleton->gem->gameObjects[visObjects[i]]);
			
		// 	eqObj = singleton->getEquipped(curObj);
			
		// 	if (
		// 		curObj->isHidden ||
		// 		(eqObj == NULL) ||
		// 		(
		// 			(singleton->gem->firstPerson) &&
		// 			(curObj->uid == singleton->gem->getCurActorUID())
		// 		)
		// 	) {
				
		// 	}
		// 	else {
				
				
				
		// 		/////
		// 		tempVec1.copyFrom( curObj->getCenterPointFIV(0) );
		// 		curOr = curObj->orientationXYZ.getIY();
		// 		tempVec2.setFXYZRef( &(singleton->dirVecs[curOr]) );
		// 		//tempVec2.multXYZ(1.0f);
		// 		tempVec2.addXYZRef(&tempVec1);
		// 		//tempVec3.averageXYZ(&tempVec1,&tempVec2);
				
				
		// 		rotVec.copyFrom(curObj->getCenterPointFIV(0));
		// 		//rotVec.addXYZ(0.0,2.0,0.0);
		// 		rotVec.setFW( curObj->ang + curObj->angRelative );
		// 		singleton->setShaderfVec4("rotZ",&rotVec);
		// 		singleton->setShaderfVec4("rotZ2",&tempVec2);
				
		// 		p0.copyFrom(&tempVec2);
		// 		p1.copyFrom(&tempVec2);
		// 		p2.copyFrom(&tempVec2);
		// 		p3.copyFrom(&tempVec2);
				
		// 		p0.addXYZ(-0.5f, -0.5f,  0.0f);
		// 		p1.addXYZ( 0.5f, -0.5f,  0.0f);
		// 		p2.addXYZ( 0.5f,  0.5f,  0.0f);
		// 		p3.addXYZ(-0.5f,  0.5f,  0.0f);
				
		// 		/////
				
				
				
		// 		tempCS = &(singleton->fontWrappers[EFW_ICONS]->charVals[
		// 			singleton->gem->entIdToIcon[eqObj->objectType] 
		// 		]);
		// 		frameMod = 0;
		// 		if (eqObj->maxFrames != 0) {
		// 			frameMod = ((singleton->currentTick/(20))%(eqObj->maxFrames))*16.0f;
		// 		}
				
				
		// 		x1 = (tempCS->sampX + frameMod )/iw;
		// 		x2 = (tempCS->sampX + tempCS->sampW + frameMod)/iw;
		// 		y1 = 1.0f-(tempCS->sampY)/ih;
		// 		y2 = 1.0f-(tempCS->sampY+tempCS->sampH)/ih;
				
		// 		if (
		// 			(eqObj->entType == E_ENTTYPE_BULLET) ||
		// 			(eqObj->entType == E_ENTTYPE_TRACE)	
		// 		) {
		// 			yval = 1.0f;
		// 		}
		// 		else {
		// 			yval = -1.0f;
		// 		}
				
		// 		// glMultiTexCoord4f(GL_TEXTURE0, visObjects[i], yval, 1.0f, 1.0f);
		// 		// glMultiTexCoord4f(GL_TEXTURE1, x1,y1,x2,y2);
				
				
				
		// 		singleton->drawQuadWithCoords(
		// 				&p0,
		// 				&p1,
		// 				&p2,
		// 				&p3,
						
		// 				x1, y1, x2, y2
		// 		);
				
		// 	}
			
			
			
		// }
		// singleton->setShaderTexture(0,0);
		// singleton->unbindFBO();
		// singleton->unbindShader();
		
		
		
		
		
		
		
		
		
		
		
		
		// singleton->copyFBO2("geomBaseTargFBO","geomTargFBO");
		
		
		// singleton->bindShader("BillboardShader");
		// singleton->setShaderfVec2("bufferDim", &(singleton->bufferModDim) );
		// singleton->setShaderFloat("cellsPerHolder",cellsPerHolder);
		// singleton->setShaderFloat("heightOfNearPlane",singleton->heightOfNearPlane);
		// singleton->setShaderFloat("clipDist",singleton->clipDist[1]);
		// singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		// singleton->setShaderTexture(0,singleton->fontWrappers[EFW_ICONS]->fontImage->tid);
		// singleton->sampleFBO("geomBaseTargFBO",1);
		// singleton->bindFBO("geomTargFBO", -1, 0);
		
		
		// glBegin(GL_POINTS);
		
		// for(i = 0; i < singleton->gem->visObjects.size(); i++) {
			
		// 	curObj = &(singleton->gem->gameObjects[visObjects[i]]);
			
		// 	if (
		// 		curObj->isHidden ||
		// 		(curObj->objectType <= 0) ||
		// 		(
		// 			(singleton->gem->firstPerson) &&
		// 			(curObj->uid == singleton->gem->getCurActorUID())
		// 		)
		// 	) {
				
		// 	}
		// 	else {
		// 		tempCS = &(singleton->fontWrappers[EFW_ICONS]->charVals[
		// 			singleton->gem->entIdToIcon[curObj->objectType] 
		// 		]);
		// 		frameMod = 0;
		// 		if (curObj->maxFrames != 0) {
		// 			frameMod = ((singleton->currentTick/(20))%(curObj->maxFrames))*16.0f;
		// 		}
				
				
		// 		x1 = (tempCS->sampX + frameMod )/iw;
		// 		x2 = (tempCS->sampX + tempCS->sampW + frameMod)/iw;
		// 		y1 = 1.0f-(tempCS->sampY)/ih;
		// 		y2 = 1.0f-(tempCS->sampY+tempCS->sampH)/ih;
				
		// 		if (
		// 			(curObj->entType == E_ENTTYPE_BULLET) ||
		// 			(curObj->entType == E_ENTTYPE_TRACE)	
		// 		) {
		// 			yval = 1.0f;
		// 		}
		// 		else {
		// 			yval = -1.0f;
		// 		}
				
		// 		glMultiTexCoord4f(GL_TEXTURE0, visObjects[i], yval, 1.0f, 1.0f);
		// 		glMultiTexCoord4f(GL_TEXTURE1, x1,y1,x2,y2);
		// 		glVertex3f(
		// 			curObj->getCenterPointFIV(0)->getFX(),
		// 			curObj->getCenterPointFIV(0)->getFY(),
		// 			curObj->getCenterPointFIV(0)->getFZ()
		// 		);
		// 	}
			
			
			
		// }
		// glEnd();
		
		
		
		// singleton->unsampleFBO("geomBaseTargFBO",1);
		// singleton->setShaderTexture(0,0);
		// singleton->unbindFBO();
		// singleton->unbindShader();
		
		//////////////////////////////
		
		

	}
void GameWorld::updateMouseCoords (FIVector4 * fPixelWorldCoordsBase)
                                                                 {

		FIVector4 fPixelWorldCoords;
		fPixelWorldCoords.copyFrom(fPixelWorldCoordsBase);


		lastUnitPos.copyFrom(&fPixelWorldCoords);
		lastUnitPos.setFW(1.0);
		

	}
float GameWorld::weighPath (float x1, float y1, float x2, float y2, float rad, bool doSet, bool isOcean)
        {

		int i;
		int iMax = (int)min(64.0f, rad * 4.0f);

		float fi;
		float fMax = (float)(iMax - 1);
		float lerp;

		float curX;
		float curY;


		float startVal = curFBO->getPixelAtWrapped((int)x1, (int)y1, hmChannel);
		float lastRes = startVal;
		float curRes;
		float curRes2;
		float tempRes;
		float tot = 0.0f;

		bool startsInWater = startVal <= seaLevel;

		for (i = 1; i < iMax; i++)
		{
			fi = (float)i;
			lerp = fi / fMax;
			curX = (1.0f - lerp) * x1 + (lerp) * x2;
			curY = (1.0f - lerp) * y1 + (lerp) * y2;
			curRes = curFBO->getPixelAtWrapped((int)curX, (int)curY, hmChannel);

			if (isOcean)
			{
				if (doSet)
				{

					if (curRes > seaLevel)
					{

						tempRes = abs(curRes - lastRes);
						tempRes = tempRes * tempRes * tempRes;
						//tempRes = 255-curRes;
					}
					else
					{
						tempRes = curRes;
					}


					//tempRes = abs(curRes-lastRes);
					//tempRes = tempRes*tempRes*tempRes;
					if ((curRes > seaLevel) != (lastRes > seaLevel))
					{
						tempRes += 100000.0f;
					}

					// if (startsInWater) {
					//  if (curRes > seaLevel) {
					//      tempRes += 1000000.0f;
					//  }
					// }

				}
				else
				{
					tempRes = 0.0;
					if (curRes > seaLevel)
					{
						tempRes = 1.0f;
					}
					else
					{
						tempRes = -1.0f;
					}
				}
			}
			else
			{
				tempRes = abs(curRes - lastRes) * 10.0 + curRes;
				//tempRes = tempRes;
				if (curRes <= seaLevel - 20.0f)
				{
					tempRes += 100000.0f;
				}
				if ((curRes > seaLevel) != (lastRes > seaLevel))
				{
					tempRes += 100000.0f;
				}
			}


			tot += tempRes;
			lastRes = curRes;

		}

		return tot;
	}
float GameWorld::findBestPath (float x1, float y1, float x2, float y2, int generation, int roadIndex, bool doSet, bool isOcean)
        {
		int i;
		int j;

		coordAndIndex baseCoord;
		coordAndIndex bestCoord;
		coordAndIndex testCoord;

		float mpx = (x1 + x2) / 2.0;
		float mpy = (y1 + y2) / 2.0;
		float dis = quickDis(x1, y1, x2, y2);
		float rad = dis / 2.0;
		float mpxTemp;
		float mpyTemp;
		float delta;
		float bestDis;
		float curDis;
		float bestDelta = FLT_MAX;
		float bestX;
		float bestY;
		float genMod;

		int q;
		int p;

		int ibx;
		int iby;
		int ix2;
		int iy2;
		int tot1 = 0;
		int tot2 = 0;
		int iRad;
		int numTries = max((int)(rad), 20);

		if ( (rad < 2.0f) || (generation > 1024) )
		{
			// do manhattan distance

			if (doSet)
			{
				ibx = x1;
				iby = y1;
				ix2 = x2;
				iy2 = y2;


				while (ibx != ix2)
				{
					curFBO2->setPixelAtWrapped(ibx, iby, pathChannel, 255);
					if (ibx < ix2)
					{
						ibx++;
					}
					else
					{
						ibx--;
					}
				}
				while (iby != iy2)
				{
					curFBO2->setPixelAtWrapped(ibx, iby, pathChannel, 255);
					if (iby < iy2)
					{
						iby++;
					}
					else
					{
						iby--;
					}
				}

				curFBO2->setPixelAtWrapped(ibx, iby, pathChannel, 255);
			}
			else
			{

			}

			return 0.0f;

		}



		genMod = 2.0f;

		// if (generation > 32) {
		//  return 0.0f;
		// }




		for (i = 0; i < numTries; i++)
		{
			mpxTemp = mpx + (fGenRand() * dis - rad) / genMod;
			mpyTemp = mpy + (fGenRand() * dis - rad) / genMod;

			delta = weighPath(x1, y1, mpxTemp, mpyTemp, rad / 2.0f, doSet, isOcean);
			delta += weighPath(mpxTemp, mpyTemp, x2, y2, rad / 2.0f, doSet, isOcean);

			if (delta < bestDelta)
			{
				bestDelta = delta;
				bestX = mpxTemp;
				bestY = mpyTemp;
			}

		}



		if (doSet)
		{



			if (generation < 8)
			{

				baseCoord.x = bestX;
				baseCoord.y = bestY;
				baseCoord.index = roadIndex;
				//roadCoords.push_back(baseCoord);

				bestDis = FLT_MAX;
				for (i = 0; i < roadCoords.size(); i++)
				{
					testCoord = roadCoords[i];


					if (baseCoord.index == testCoord.index)
					{

					}
					else
					{
						curDis = coordDis(&baseCoord, &testCoord);

						if (curDis < bestDis)
						{
							bestDis = curDis;
							bestCoord = roadCoords[i];
						}
					}


				}

				if (bestDis != FLT_MAX)
				{
					curDis = coordDis(&bestCoord, &baseCoord);

					if (curDis < min(400.0f, rad) )   //
					{
						baseCoord = bestCoord;
						baseCoord.index = roadIndex;
					}

					bestX = baseCoord.x;
					bestY = baseCoord.y;
				}

				roadCoords.push_back(baseCoord);
			}


			//curFBO2->setPixelAtWrapped((int)bestX, (int)bestY, pathChannel, 255);
			//curFBO2->setPixelAtWrapped((int)bestX, (int)bestY, breadCrumbChannel, 255);
			findBestPath(x1, y1, bestX, bestY, generation + 1, roadIndex, doSet, isOcean);
			findBestPath(bestX, bestY, x2, y2, generation + 1, roadIndex, doSet, isOcean);
		}

		return bestDelta;

	}
void GameWorld::initMap ()
        {
		mapLockOn = true;

		mapSwapFlag = 0;

		mapStep = 0.0f;



		FBOWrapper *fbow = singleton->getFBOWrapper("hmFBO", 0);
		FBOWrapper *fbow2 = singleton->getFBOWrapper("cityFBO", 0);

		curFBO = fbow;
		curFBO2 = fbow2;

		

		FIVector4 startVec;
		FIVector4 endVec;
		FIVector4 midPointVec;

		int w = fbow2->width;
		int h = fbow2->height;


		//0:r
		//1:g
		//2:b
		//3:a




		int i;
		int j;
		int k;
		int m;
		int q;
		
		int totSize = w * h;
		int *btStack = new int[totSize];
		int btStackInd = 0;
		int curInd;
		int curX;
		int curY;
		int destX;
		int destY;
		int lastDir;
		int curXRight;
		int curXLeft;
		int curYUp;
		int curYDown;
		int testX;
		int testY;
		int testInd;
		int basePix;
		int basePix2;
		int testPix;
		int testPix1;
		int testPix2;
		int testPix3;
		int testPix4;
		int count;
		int p1;
		int p2;



		// int alleyFlag = 32;
		// int streetFlag = 64;
		// int highwayFlag = 128;

		int startDir;
		int curDir;
		blockMip = intLogB2(singleton->holdersPerBlock);

		int cx1;
		int cy1;
		int cx2;
		int cy2;

		int histogram[256];

		float delta;
		float bestDelta;
		float nextBestDelta;

		int nextBestInd;
		int bestDir;
		int nextBestDir;

		int bestInd;
		int tempVal;

		int xind;
		int yind;
		int curHeight;

		bool isValid;
		bool notFound;
		bool touchesWater;
		bool doBreak;

		float mult;
		float tempDis;

		int minSL = 0;
		int maxSL = 0;
		int curSL = 0;
		int avgSL = 0;
		//int totFilled = 0;



		for (i = 0; i < 16; i++)
		{
			singleton->paramArrMap[i * 3 + 0] = fGenRand();
			singleton->paramArrMap[i * 3 + 1] = fGenRand();
			singleton->paramArrMap[i * 3 + 2] = fGenRand();
		}

		for (i = 0; i < 6; i++)
		{
			singleton->paramArrMap[i * 3 + 0] = i;
		}

		for (i = 0; i < 30; i++)
		{
			p1 = iGenRand(0, 5);
			p2 = iGenRand(0, 5);

			if (p1 != p2)
			{
				tempVal = singleton->paramArrMap[p1];
				singleton->paramArrMap[p1] = singleton->paramArrMap[p2];
				singleton->paramArrMap[p2] = tempVal;
			}
		}



		for (q = 0; q < 2; q++) {
			
			
			singleton->bindShader("Simplex2D");
			singleton->bindFBO("simplexFBO");
			singleton->setShaderFloat("curTime", fGenRand() * 100.0f);
			singleton->drawFSQuad();
			singleton->unbindFBO();
			singleton->unbindShader();

			singleton->bindShader("TerrainMix");
			singleton->bindFBO("hmFBOLinear");
			singleton->sampleFBO("simplexFBO", 0);
			singleton->setShaderTexture(1, singleton->imageHM0->tid);
			singleton->setShaderTexture(2, singleton->imageHM1->tid);
			singleton->setShaderInt("passNum",q);
			singleton->setShaderVec2("minAndMax",((float)minSL)/255.0f,((float)maxSL)/255.0f);
			singleton->setShaderArrayfVec3("paramArrMap", singleton->paramArrMap, 16 );
			singleton->setShaderFloat("mapSampScale", 1.0f); //singleton->mapSampScale
			singleton->drawFSQuad();
			singleton->setShaderTexture(2, 0);
			singleton->setShaderTexture(1, 0);
			singleton->unsampleFBO("simplexFBO", 0);
			singleton->unbindFBO();
			singleton->unbindShader();

			singleton->copyFBO("hmFBOLinear", "hmFBO");
			
			glFlush();
			glFinish();

			fbow->getPixels(true);
			fbow->setAllPixels(densityChannel, 255);
			fbow->setAllPixels(idChannel, 0);
			fbow->setAllPixels(blockChannel, 0);


			// determine sea level

			for (i = 0; i < 256; i++)
			{
				histogram[i] = 0;
			}
			
			minSL = 255;
			maxSL = 0;
			curSL = 0;
			avgSL = 0;
			//totFilled = 0;
			
			for (i = 0; i < totSize; i++)
			{
				curSL = fbow->getPixelAtIndex(i, hmChannel);
				
				if (curSL < minSL) {
					minSL = curSL;
				}
				if (curSL > maxSL) {
					maxSL = curSL;
				}
				
				histogram[curSL]++;
			}

			avgSL = (minSL+maxSL)/2;
		}

		seaLevel = 100;

		
		singleton->copyFBO("hmFBOLinear", "hmFBOLinearBig");
		
		
		seaSlack = seaLevel - 1;
		cout << "Sea Level: " << seaLevel << "\n";

		mapWidth = fbow->width;
		mapHeight = fbow->height;

		goto DONE_WITH_MAP;

		
		cout << "start place cities\n";

		for (i = 1; i < numProvinces; i++)
		{

			isValid = false;

			do
			{

				xind = (int)(fGenRand() * fbow->width);
				yind = (int)(fGenRand() * fbow->height);

				tempVec1.setFXYZ(xind, yind, 0.0f);

				notFound = false;
				for (j = 1; j < i; j++)
				{
					tempVec2.setFXYZ(provinceX[j], provinceY[j], 0.0f);
					tempDis = tempVec2.wrapDistance(&tempVec1, w, false);

					if (tempDis < 10.0f)
					{
						notFound = true;
					}

				}

				if (notFound)
				{

				}
				else
				{
					if (fbow->getPixelAtC(xind, yind, idChannel) == 0)
					{
						curHeight = fbow->getPixelAtC(xind, yind, hmChannel);

						if (
							(curHeight > seaLevel)
						)
						{

							provinceX[i] = xind;
							provinceY[i] = yind;
							fbow->setPixelAtC(xind, yind, idChannel, i);
							fbow->setPixelAtC(xind, yind, densityChannel, 0);
							isValid = true;

						}
					}
				}



			}
			while (!isValid);

		}

		cout << "end place cities\n";


		cout << "start grow provinces\n";

		fbow->cpuToGPU();

		singleton->copyFBO("hmFBO", "swapFBO0");
		singleton->bindShader("MapBorderShader");
		mapStep = 0.0f;
		for (i = 0; i < 1024; i++)
		{

			singleton->bindFBO("swapFBO", mapSwapFlag);
			singleton->sampleFBO("swapFBO", 0, mapSwapFlag);
			singleton->setShaderFloat("seaSlack", ((float)seaSlack) / 255.0 );
			singleton->setShaderFloat("mapStep", mapStep);
			singleton->setShaderFloat("texPitch", w);
			singleton->drawFSQuad();
			singleton->unsampleFBO("swapFBO", 0, mapSwapFlag);
			singleton->unbindFBO();


			mapSwapFlag = 1 - mapSwapFlag;
			mapStep += 1.0f;
		}
		singleton->unbindShader();


		singleton->bindShader("MapBorderShader");
		mapStep = 1.0f;
		for (i = 0; i < 256; i++)
		{

			singleton->bindFBO("swapFBO", mapSwapFlag);
			singleton->sampleFBO("swapFBO", 0, mapSwapFlag);
			singleton->setShaderFloat("seaSlack", ((float)seaSlack) / 255.0 );
			singleton->setShaderFloat("mapStep", -mapStep);
			singleton->setShaderFloat("texPitch", w);
			singleton->drawFSQuad();
			singleton->unsampleFBO("swapFBO", 0, mapSwapFlag);
			singleton->unbindFBO();


			mapSwapFlag = 1 - mapSwapFlag;
			mapStep += 1.0f;
		}
		singleton->unbindShader();


		singleton->copyFBO("swapFBO0", "hmFBO");


		fbow->getPixels();
		fbow->updateMips();

		cout << "end grow provinces\n";


		cout << "start find neighboring cities\n";

		for (i = 0; i < numProvinces * numProvinces; i++)
		{
			provinceGrid[i] = 0;
		}

		for (k = 0; k < totSize; k++)
		{
			curInd = k;
			curY = curInd / w;
			curX = curInd - curY * w;

			basePix = fbow->getPixelAtIndex(curInd, idChannel);

			testPix = fbow->getPixelAtIndex(fbow->getIndex(curX + 1, curY), idChannel);
			testPix2 = fbow->getPixelAtIndex(fbow->getIndex(curX, curY + 1), idChannel);


			if (basePix != 0)
			{
				if (testPix != 0)
				{
					if (basePix != testPix)
					{

						provinceGrid[basePix * numProvinces + testPix] = 1;
						provinceGrid[basePix + testPix * numProvinces] = 1;

					}
				}
				if (testPix2 != 0)
				{
					if (basePix != testPix2)
					{
						provinceGrid[basePix * numProvinces + testPix2] = 1;
						provinceGrid[basePix + testPix2 * numProvinces] = 1;
					}
				}
			}


		}

		cout << "end find neighboring cities\n";




		// 1 - x+
		// 2 - x-
		// 4 - y+
		// 8 - y-


		cout << "start find city blocks\n";


		fbow2->getPixels(true);
		fbow2->setAllPixels(btChannel, 15);
		fbow2->setAllPixels(stChannel, 0);
		fbow2->setAllPixels(pathChannel, 0);
		fbow2->setAllPixels(houseChannel, 0);


		int blockMod = singleton->holdersPerBlock;
		for (k = 0; k < totSize; k++)
		{
			curInd = k;
			curY = curInd / w;
			curX = curInd - curY * w;

			basePix = fbow->getMipVal(curX, curY, blockMip, idChannel, MAX_MIP);
			testPix = fbow->getMipVal(curX, curY, blockMip, densityChannel, AVG_MIP);

			testPix1 = fbow->getMipVal(curX, curY, blockMip, idChannel, MAX_MIP, -1, -1, 0);
			testPix2 = fbow->getMipVal(curX, curY, blockMip, idChannel, MAX_MIP, -1, 1, 0);
			testPix3 = fbow->getMipVal(curX, curY, blockMip, idChannel, MAX_MIP, -1, 0, -1);
			testPix4 = fbow->getMipVal(curX, curY, blockMip, idChannel, MAX_MIP, -1, 0, 1);


			// TODO: EDIT CITY

			//testPix > xxx <- (xxx = 0: no city, xxx = 255: all city, def: 220)
			if ( testPix1 != testPix2 || testPix3 != testPix4 || testPix > 0 )
			{
				fbow->setPixelAtIndex(curInd, blockChannel, 0);
			}
			else
			{
				fbow->setPixelAtIndex(curInd, blockChannel, basePix);
			}

		}

		fbow->cpuToGPU();
		singleton->copyFBO("hmFBO", "hmFBOLinear");

		cout << "end find city blocks\n";


		cout << "start add in city roads\n";
		//add in city roads

		for (i = 0; i < numProvinces; i++)
		{
			// recursive backtrack
			btStack[0] = fbow2->getIndex(provinceX[i], provinceY[i]);
			btStackInd = 0;

			while (btStackInd > -1)
			{

				curInd = btStack[btStackInd];
				curY = curInd / w;
				curX = curInd - curY * w;

				fbow2->orPixelAtIndex(curInd, btChannel, visFlag);

				startDir = 0;
				count = 0;
				notFound = true;
				bestDelta = FLT_MAX;


				testPix2 = fbow->getPixelAtIndex(curInd, blockChannel);

				//testPix2 = fbow->getMipVal(curX,curY,blockMip,densityChannel,AVG_MIP);
				//testPix3 = fbow->getMipVal(curX,curY,blockMip,idChannel,MIN_MIP);
				//testPix4 = fbow->getMipVal(curX,curY,blockMip,idChannel,MAX_MIP);


				if ( testPix2 != 0 )
				{
					do
					{
						curDir = (startDir + count) % 4;

						testX = curX + dirModX[curDir];
						testY = curY + dirModY[curDir];
						testInd = fbow2->getIndex(testX, testY);
						testPix = fbow2->getPixelAtIndex(testInd, btChannel);
						testPix3 = fbow->getPixelAtIndex(testInd, blockChannel);

						if ( (testPix & visFlag) == 0 && (testPix3 != 0))
						{
							//not visited, proceed
							notFound = false;


							delta = abs(
												fbow->getPixelAtIndex(curInd, hmChannel) -
												fbow->getPixelAtIndex(testInd, hmChannel)
											);

							if (delta < bestDelta)
							{
								bestDelta = delta;
								bestDir = curDir;
								bestInd = testInd;
							}

						}

						count++;
					}
					while (count < 4); //notFound &&
				}

				if (notFound)
				{
					btStackInd--;
				}
				else
				{

					// join the two and remove walls
					fbow2->andPixelAtIndex(curInd, btChannel, dirFlags[bestDir]);
					fbow2->andPixelAtIndex(bestInd, btChannel, dirFlagsOp[bestDir]);

					btStackInd++;
					btStack[btStackInd] = bestInd;
				}

			}
		}

		cout << "end add in city roads\n";



		// clear visited
		for (k = 0; k < totSize; k++)
		{
			testPix = fbow2->getPixelAtIndex(k, btChannel);
			if ( (testPix & visFlag) == 0)
			{
				//not visited
				for (i = 0; i < 4; i++)
				{
					fbow2->andPixelAtIndex(k, btChannel, dirFlags[i]);
				}
			}
			else
			{
				//visited
			}

			fbow2->andPixelAtIndex(k, btChannel, visFlagO );
		}



		cout << "start link close cities\n";

		// link close cities

		for (i = 1; i < numProvinces - 1; i++)
		{
			for (j = i + 1; j < numProvinces; j++)
			{

				curInd = i + j * numProvinces;

				if (provinceGrid[curInd] == 1)
				{
					p1 = i;
					p2 = j;



					tempVec1.setIXYZ(provinceX[p1], provinceY[p1], 0);
					tempVec2.setIXYZ(provinceX[p2], provinceY[p2], 0);

					tempVec2.wrapDistance(&tempVec1, w);
					tempVec3.copyFrom(&tempVec1);

					findBestPath(
						tempVec2.getFX(),
						tempVec2.getFY(),
						tempVec3.getFX(),
						tempVec3.getFY(),
						0,
						curInd,
						true,
						false
					);

				}

			}
		}



		cout << "end link close cities\n";



		floatAndIndex *oceanRes = new floatAndIndex[numProvinces * numProvinces];

		for (i = 0; i < numProvinces * numProvinces; i++)
		{
			oceanRes[i].value = FLT_MAX;
			oceanRes[i].index1 = 0;
			oceanRes[i].index2 = 0;
		}

		cout << "start find biggest ocean gaps\n";


		for (k = 0; k < 2; k++)
		{

			cout << "iteration: " << k << "\n";

			count = 0;

			if (k == 0)
			{
				for (i = 1; i < numProvinces - 1; i++)
				{
					for (j = i + 1; j < numProvinces; j++)
					{
						curInd = i + j * numProvinces;
						if (provinceGrid[curInd] != 1)
						{
							p1 = i;
							p2 = j;



							tempVec1.setIXYZ(provinceX[p1], provinceY[p1], 0);
							tempVec2.setIXYZ(provinceX[p2], provinceY[p2], 0);

							tempVec2.wrapDistance(&tempVec1, w);
							tempVec3.copyFrom(&tempVec1);


							oceanRes[count].value = findBestPath(
																				tempVec2.getFX(),
																				tempVec2.getFY(),
																				tempVec3.getFX(),
																				tempVec3.getFY(),
																				0,
																				curInd,
																				false,
																				true
																			);
							oceanRes[count].index1 = i;
							oceanRes[count].index2 = j;

							count++;

						}

					}
				}
			}
			else
			{
				bubbleSortF(oceanRes, numProvinces * numProvinces);


				for (i = 0; i < 30; i++)
				{

					p1 = oceanRes[i].index1;
					p2 = oceanRes[i].index2;

					curInd = p1 + p2 * numProvinces;

					tempVec1.setIXYZ(provinceX[p1], provinceY[p1], 0);
					tempVec2.setIXYZ(provinceX[p2], provinceY[p2], 0);

					tempVec2.wrapDistance(&tempVec1, w);
					tempVec3.copyFrom(&tempVec1);

					findBestPath(
						tempVec2.getFX(),
						tempVec2.getFY(),
						tempVec3.getFX(),
						tempVec3.getFY(),
						0,
						curInd,
						true,
						true
					);
				}

			}


		}



		cout << "end find biggest ocean gaps\n";








		mapSwapFlag = 0;
		mapStep = 0.0f;

		fbow2->cpuToGPU();
		singleton->copyFBO("cityFBO", "swapFBO0");
		singleton->bindShader("DilateShader");
		for (i = 0; i < 2; i++)
		{

			singleton->bindFBO("swapFBO", mapSwapFlag);
			singleton->sampleFBO("swapFBO", 0, mapSwapFlag);
			singleton->sampleFBO("hmFBO", 1);
			singleton->setShaderFloat("seaLevel", singleton->getSLNormalized() );
			singleton->setShaderFloat("mapStep", 1.0);
			singleton->setShaderFloat("doDilate", 1.0);
			singleton->setShaderFloat("texPitch", w);
			singleton->drawFSQuad();
			singleton->unsampleFBO("hmFBO", 1);
			singleton->unsampleFBO("swapFBO", 0, mapSwapFlag);
			singleton->unbindFBO();

			mapSwapFlag = 1 - mapSwapFlag;
			mapStep += 1.0f;
		}
		singleton->unbindShader();
		singleton->copyFBO("swapFBO0", "cityFBO");
		fbow2->getPixels();
		//fbow2->updateMips();






		//bool notCovered = true;
		int id = 1;
		int totCount;
		int fillColor;
		bool incId;

		cout << "start road regions\n";

		for (i = 0; i < totSize; i++)
		{

			if (fbow2->getPixelAtIndex(i, pathChannel) == 0)
			{

				for (j = 0; j < 2; j++)
				{
					btStack[0] = i;
					btStackInd = 0;
					totCount = 0;

					if (j == 0)
					{
						fillColor = id;
					}
					else
					{
						fillColor = 255;
					}


					while (btStackInd > -1)
					{

						curInd = btStack[btStackInd];
						curY = curInd / w;
						curX = curInd - curY * w;

						if (j == 0)
						{
							fbow2->orPixelAtIndex(curInd, btChannel, visFlag);
						}
						else
						{
							fbow2->andPixelAtIndex(curInd, btChannel, visFlagO );
						}


						fbow2->setPixelAtIndex(curInd, pathChannel, fillColor );


						count = 0;
						notFound = true;



						do
						{
							curDir = count;

							testX = curX + dirModX[curDir];
							testY = curY + dirModY[curDir];
							testInd = fbow2->getIndex(testX, testY);
							testPix = fbow2->getPixelAtIndex(testInd, btChannel);
							testPix2 = fbow2->getPixelAtIndex(testInd, pathChannel);


							if (j == 0)
							{
								if ( ( (testPix & visFlag) == 0 ) && (testPix2 == 0))
								{
									notFound = false;
									totCount++;

								}
							}
							else
							{
								if ( ( (testPix & visFlag) > 0) && (testPix2 == id))
								{
									notFound = false;
									totCount++;
								}
							}




							count++;
						}
						while (notFound && count < 4);

						if (notFound)
						{
							btStackInd--;
						}
						else
						{

							// join the two and remove walls
							//fbow2->andPixelAtIndex(curInd, btChannel, dirFlags[bestDir]);
							//fbow2->andPixelAtIndex(bestInd, btChannel, dirFlagsOp[bestDir]);


							btStackInd++;
							btStack[btStackInd] = testInd;
						}

					}

					incId = false;

					if (j == 0)
					{
						if (totCount < 1000)
						{
							//cout << "Too Small\n";
						}
						else
						{
							incId = true;
							j++;
						}
					}
					else
					{
						incId = true;
					}

					if (incId)
					{
						//cout << "Id: " << id << "\n";
						id++;
						if (id > 254)
						{
							id = 1;
						}
					}
				}




			}

		}


		cout << "end road regions\n";

		// clear visited
		for (k = 0; k < totSize; k++)
		{
			fbow2->andPixelAtIndex(k, btChannel, visFlagO );
		}

		fbow2->cpuToGPU();


		mapSwapFlag = 0;
		mapStep = 0.0f;
		singleton->copyFBO("cityFBO", "swapFBO0");



		singleton->bindShader("SkeletonShader");
		for (k = 0; k < 19; k++)
		{

			singleton->bindFBO("swapFBO", mapSwapFlag);
			singleton->sampleFBO("swapFBO", 0, mapSwapFlag);
			//singleton->sampleFBO("hmFBO",1);
			singleton->setShaderFloat("seaLevel", singleton->getSLNormalized() );
			singleton->setShaderFloat("mapStep", 0.0);
			singleton->setShaderFloat("texPitch", w);
			singleton->drawFSQuad();
			//singleton->unsampleFBO("hmFBO",1);
			singleton->unsampleFBO("swapFBO", 0, mapSwapFlag);
			singleton->unbindFBO();
			mapSwapFlag = 1 - mapSwapFlag;
			mapStep += 1.0f;

		}
		singleton->unbindShader();


		singleton->bindShader("RoadShader");
		for (k = 0; k < 1; k++)
		{

			singleton->bindFBO("swapFBO", mapSwapFlag);
			singleton->sampleFBO("swapFBO", 0, mapSwapFlag);
			//singleton->sampleFBO("hmFBO",1);
			singleton->setShaderFloat("seaLevel", singleton->getSLNormalized() );
			singleton->setShaderFloat("mapStep", 0.0);
			singleton->setShaderFloat("texPitch", w);
			singleton->drawFSQuad();
			//singleton->unsampleFBO("hmFBO",1);
			singleton->unsampleFBO("swapFBO", 0, mapSwapFlag);
			singleton->unbindFBO();
			mapSwapFlag = 1 - mapSwapFlag;
			mapStep += 1.0f;

		}
		singleton->unbindShader();


		singleton->copyFBO("swapFBO0", "cityFBO");
		fbow2->getPixels();







		// generate streets

		int *streetFlagsV = new int[w]; //runs vertical
		int *streetFlagsH = new int[h]; //runs horizontal

		for (i = 0; i < w; i++)
		{
			streetFlagsV[i] = 0;
		}
		for (i = 0; i < h; i++)
		{
			streetFlagsH[i] = 0;
		}

		// 1 - x+
		// 2 - x-
		// 4 - y+
		// 8 - y-

		for (i = 0; i < w; i += singleton->holdersPerBlock )
		{

			curInd = i - 1;

			while (curInd < 0)
			{
				curInd += w;
			}

			streetFlagsV[curInd] |= 1;
			streetFlagsV[i] |= 2;
		}
		for (i = 0; i < h; i += singleton->holdersPerBlock )
		{

			curInd = i - 1;

			while (curInd < 0)
			{
				curInd += h;
			}

			streetFlagsH[curInd] |= 4;
			streetFlagsH[i] |= 8;
		}












		//add in main streets
		for (k = 0; k < totSize; k++)
		{
			curInd = k;
			curY = curInd / w;
			curX = curInd - curY * w;

			testPix = fbow->getPixelAtIndex(curInd, blockChannel);

			if (testPix != 0)
			{
				fbow2->orPixelAtIndex(curInd, btChannel, streetFlagsH[curY] | streetFlagsV[curX]);
				fbow2->orPixelAtIndex(curInd, stChannel, streetFlagsH[curY] | streetFlagsV[curX]); //stChannel
			}


		}


		// for (k = 0; k < totSize; k++) {

		//  // int stChannel;
		//  // int btChannel;
		//  // int pathChannel;
		//  // int houseChannel;

		//  testPix = fbow2->getPixelAtIndex(k, stChannel);
		//  fbow2->orPixelAtIndex(k, btChannel, testPix );

		//  testPix = fbow2->getPixelAtIndex(k, pathChannel);
		//  fbow2->orPixelAtIndex(k, btChannel, testPix );
		// }


		/*
		for (i = 0; i < numProvinces-1; i++) {
		    for (j = i + 1; j < numProvinces; j++) {
		        if (provinceGrid[i + j*numProvinces] == 1) {

		            k = fbow->numMips-1;

		            cx1 = provinceX[i];
		            cy1 = provinceY[i];
		            cx2 = provinceX[j];
		            cy2 = provinceY[j];

		            while (getMipInd(cx1,cy1,k) == getMipInd(cx2,cy2,k)) {
		                k--;
		            }

		        }
		    }
		}



		// remove any road that touches water or is out of town

		int cityLevel = 0;
		for (k = 0; k < totSize; k++) {
		    curInd = k;
		    curY = curInd/w;
		    curX = curInd-curY*w;

		    touchesWater = false;

		    for (j = -1; j <= 1; j++) {
		        for (i = -1; i <= 1; i++) {
		            testX = curX + i;
		            testY = curY + j;
		            testInd = fbow->getIndex(testX,testY);
		            testPix = fbow->getPixelAtIndex(testInd, hmChannel);


		            if (testPix < seaLevel + 10) {
		                touchesWater = true;
		                break;
		            }

		        }
		        if (touchesWater) {
		            break;
		        }
		    }

		    testPix2 = fbow->getPixelAtIndex(curInd, densityChannel);


		    if (touchesWater) { // || (testPix2 > 120)
		        fbow2->andPixelAtIndex(curInd, btChannel, dirFlagClear);
		        fbow2->andPixelAtIndex(curInd, stChannel, dirFlagClear);

		        //TODO: repair all broken (half) edges
		    }
		    // if (testPix2 > 80) {
		    //  fbow2->andPixelAtIndex(curInd, stChannel, dirFlagClear);
		    // }


		}



		// fix half streets

		for (k = 0; k < totSize; k++) {
		    curInd = k;
		    curY = curInd/w;
		    curX = curInd-curY*w;

		    basePix = fbow2->getPixelAtIndex(curInd, btChannel);
		    basePix2 = fbow2->getPixelAtIndex(curInd, stChannel);

		    for (i = 0; i < 4; i++) {



		        curDir = i;

		        testX = curX + dirModX[curDir];
		        testY = curY + dirModY[curDir];
		        testInd = fbow2->getIndex(testX,testY);
		        testPix = fbow2->getPixelAtIndex(testInd, btChannel);
		        testPix2 = fbow2->getPixelAtIndex(testInd, stChannel);


		        if ( (basePix & dirFlagsO[curDir]) != (testPix & dirFlagsOpO[curDir]) ) {
		            fbow2->orPixelAtIndex(curInd, btChannel, dirFlagsO[curDir]);
		            fbow2->orPixelAtIndex(testInd, btChannel, dirFlagsOpO[curDir]);
		        }

		        if ( (basePix2 & dirFlagsO[curDir]) != (testPix2 & dirFlagsOpO[curDir]) ) {
		            fbow2->orPixelAtIndex(curInd, stChannel, dirFlagsO[curDir]);
		            fbow2->orPixelAtIndex(testInd, stChannel, dirFlagsOpO[curDir]);
		        }

		    }

		}

		*/


















		// ?????




		cout << "start filling houses\n";

		// clear visited
		for (k = 0; k < totSize; k++)
		{
			fbow2->andPixelAtIndex(k, btChannel, visFlagO );
		}

		fbow->updateMips();




		int wb = blocksPerWorld;
		int hb = blocksPerWorld;
		int blockInd;

		for (i = 0; i < wb; i++)
		{
			for (j = 0; j < hb; j++)
			{
				blockInd = i + j * wb;

				testPix = fbow->getMipAtIndex(blockInd, blockMip, blockChannel, MIN_MIP);

				if (testPix != 0)
				{



					id = 1;

					for (k = i * blockMod; k < (i + 1)*blockMod; k++)
					{
						for (m = j * blockMod; m < (j + 1)*blockMod; m++)
						{
							curInd = k + m * w;
							curX = k;
							curY = m;


							testPix = fbow2->getPixelAtIndex(curInd, btChannel);

							if (testPix & visFlag)
							{

							}
							else
							{
								btStack[0] = curInd;
								btStackInd = 0;
								totCount = 0;


								while ( (btStackInd > -1) && (totCount < 3) )
								{

									curInd = btStack[btStackInd];
									curY = curInd / w;
									curX = curInd - curY * w;

									fbow2->orPixelAtIndex(curInd, btChannel, visFlag);
									fbow2->setPixelAtIndex(curInd, houseChannel, id );


									count = 0;
									notFound = true;

									testPix2 = fbow2->getPixelAtIndex(curInd, btChannel);
									//testPix3 = fbow2->getPixelAtIndex(curInd, stChannel);
									testPix4 = fbow2->getPixelAtIndex(curInd, pathChannel);

									do
									{
										curDir = count;

										testX = curX + dirModX[curDir];
										testY = curY + dirModY[curDir];

										testInd = fbow2->getIndex(testX, testY);

										testPix = fbow2->getPixelAtIndex(testInd, btChannel);

										if (
											( (testPix & visFlag) == 0 ) &&
											( (testPix2 & dirFlagsO[curDir]) == 0) &&
											//( (testPix3 & dirFlagsO[curDir]) == 0) &&
											( (testPix4 & dirFlagsO[curDir]) == 0)
										)
										{
											notFound = false;
											totCount++;

										}


										count++;
									}
									while (notFound && count < 4);

									if (notFound)
									{
										btStackInd--;
									}
									else
									{

										// join the two and remove walls
										//fbow2->andPixelAtIndex(curInd, btChannel, dirFlags[bestDir]);
										//fbow2->andPixelAtIndex(bestInd, btChannel, dirFlagsOp[bestDir]);


										btStackInd++;
										btStack[btStackInd] = testInd;
									}

								}

								id++;
								if (id > 254)
								{
									id = 1;
								}




							}


						}
					}

				}

			}
		}


		cout << "end filling houses\n";

		// clear visited
		for (k = 0; k < totSize; k++)
		{
			fbow2->andPixelAtIndex(k, btChannel, visFlagO );
		}



		// ?????










		fbow2->cpuToGPU();

		delete[] btStack;
		delete[] streetFlagsH;
		delete[] streetFlagsV;
		delete[] oceanRes;

		//////////

DONE_WITH_MAP:

		singleton->mapInvalid = false;

		

		cout << "DONE WITH MAP\n";

		mapLockOn = false;

	}
void GameWorld::drawMap ()
        {

		if (singleton->menuList[E_FM_MAINMENU] == NULL) {
			return;
		}
		if (singleton->menuList[E_FM_MAINMENU]->visible){
			
		}
		else {
			return;
		}
		if (singleton->mapComp == NULL) {
			return;
		}
		if (singleton->mapComp->visible) {
			
		}
		else {
			return;
		}


		FBOWrapper *fbow = singleton->getFBOWrapper("hmFBOLinear", 0);

		


		singleton->bindShader("TopoShader");
		
		//singleton->bindFBO("resultFBO0");
		
		//singleton->sampleFBO("palFBO", 0);
		singleton->setShaderTexture3D(0,singleton->volIdMat);
		singleton->sampleFBO("hmFBO", 1); //Linear
		singleton->sampleFBO("cityFBO", 2);
		singleton->sampleFBO("hmFBOLinear",3);
		//singleton->sampleFBO("frontFaceMapFBO",4);

		
		singleton->setShaderFloat("timeOfDay", singleton->timeOfDay);
		singleton->setShaderfVec4("mapFreqs", &(singleton->mapFreqs) );
		singleton->setShaderfVec4("mapAmps", &(singleton->mapAmps) );
		singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		singleton->setShaderfVec3("lookAtVec", &(singleton->lookAtVec));
		
		singleton->setShaderFloat("cameraZoom", singleton->cameraZoom);
		//singleton->setShaderFloat("mapTrans", mapTrans);
		singleton->setShaderFloat("seaLevel", singleton->getSLNormalized() );
		singleton->setShaderFloat("curTime", singleton->curTime);
		singleton->setShaderVec2("mapDimInPixels", fbow->width, fbow->height);

		singleton->setShaderFloat("mapPitch", singleton->mapPitch);
		singleton->setShaderFloat("heightMapMaxInCells", singleton->heightMapMaxInCells);
		singleton->setShaderFloat("cellsPerWorld", cellsPerWorld );
		
		
		singleton->mainGUI->renderQuadDirect(singleton->mapComp);
		

		//singleton->drawQuadBounds

		//singleton->drawFSQuadOffset(0.75f,0.75f,0.5f,1.0f/singleton->aspectRatio);
		//singleton->drawFSQuad();

		
		//singleton->unsampleFBO("frontFaceMapFBO",4);
		singleton->unsampleFBO("hmFBOLinear",3);
		singleton->unsampleFBO("cityFBO", 2);
		singleton->unsampleFBO("hmFBO", 1);
		//singleton->unsampleFBO("palFBO", 0);
		singleton->setShaderTexture3D(0,0);
		
		//singleton->unbindFBO();
		
		singleton->unbindShader();

		
		
		//glEnable(GL_BLEND);
		//singleton->drawFBO("resultFBO0",0,1.0f);
		//glDisable(GL_BLEND);


	}
void GameWorld::doBlur (string fboName, int _baseFBO)
        {
		int i;
		int baseFBO = _baseFBO;
		
		singleton->bindShader("BlurShader");
		singleton->setShaderFloat("numBlurPixelsPerSide", 4.0); // value of 4 is a 9x9 kernel (4*2+1)
		singleton->setShaderFloat("sigma", 4.0);
		
		for (i = 0; i < 2; i++)
		{
			
			singleton->bindFBO(fboName, baseFBO);
			singleton->sampleFBO(fboName, 0, baseFBO);
			
			if (i == 0) { // horizontal
				singleton->setShaderFloat("blurSize", 1.0f/(singleton->currentFBOResolutionX));
				singleton->setShaderVec2("blurMultiplyVec", 1.0f, 0.0f);
			}
			else { // vertical
				singleton->setShaderFloat("blurSize", 1.0f/(singleton->currentFBOResolutionY));
				singleton->setShaderVec2("blurMultiplyVec", 0.0f, 1.0f);
			}

			
			singleton->drawFSQuad();
			
			singleton->unsampleFBO(fboName, 0, baseFBO);
			singleton->unbindFBO();
			

			baseFBO = 1 - baseFBO;

		}
		
		
		singleton->unbindShader();
		
	}
void GameWorld::updateLights ()
        {
		
		
		int i;
		int j;
		int k;
		bool flag = true;
		GameEnt *tempLight;
		GameEnt *curLight;
		
		
		lightCount = singleton->numDynLights;

		if (singleton->targetTimeOfDay <= 0.5)
		{
			
			
			findNearestEnt(&(singleton->nearestLights),E_ET_LIGHT,4,2,singleton->cameraGetPosNoShake(),false,true);
			
			
			for (i = 0; i < singleton->nearestLights.selEntList.size(); i++) {
				
				
				curLight = singleton->nearestLights.selEntList[i];//&(curBlock->gameEnts[E_ET_LIGHT].data[k]);
				curLight->camDistance = singleton->cameraGetPosNoShake()->distance(&(curLight->geomParams[E_LP_POSITION]));

				if (curLight->toggled) {
					activeLights[lightCount] = singleton->nearestLights.selEntList[i];//&(curBlock->gameEnts[E_ET_LIGHT].data[k]);
					lightCount++;
				}

				if (lightCount >= MAX_EVAL_LIGHTS)
				{
					goto UPDATE_LIGHTS_END;
				}
				
				
			}
			
			

UPDATE_LIGHTS_END:

			for (i = singleton->numDynLights + 1; (i <= lightCount) && flag; i++)
			{
				flag = false;
				for (j = singleton->numDynLights; j < (lightCount - 1); j++)
				{
					if (activeLights[j + 1]->camDistance < activeLights[j]->camDistance) // ascending order simply changes to <
					{
						tempLight = activeLights[j];
						activeLights[j] = activeLights[j + 1];
						activeLights[j + 1] = tempLight;
						flag = true;
					}
				}
			}

			lightCount = min(lightCount, MAX_LIGHTS);
		}



	}
void GameWorld::renderOct (GameOctree * gameOct)
                                            {
		
		// get view matrix
		singleton->perspectiveOn = true;
		singleton->bindShader("OctShader");
		singleton->bindFBO("resultFBO0");
		singleton->unbindFBO();
		singleton->unbindShader();
		singleton->perspectiveOn = false;
		// 
		

		singleton->bindShader("OctShader");
		singleton->bindFBO("resultFBO0");

		singleton->setShaderTBO(
			0,
			gameOct->octTBO.tbo_tex,
			gameOct->octTBO.tbo_buf,
			false
		);

		singleton->setShaderFloat("dimInVoxels", gameOct->dimInVoxels);
		singleton->setShaderInt("renderLevel", gameOct->renderLevel);
		singleton->setShaderInt("maxSize", gameOct->maxSize);
		singleton->setShaderInt("rootPtr", gameOct->rootPtr);
		singleton->setShaderInt("nodeSize", gameOct->nodeSize);
		singleton->setShaderFloat("FOV", singleton->FOV*M_PI/180.0f);
		singleton->setShaderVec2("clipDist",singleton->clipDist[0],singleton->clipDist[1]);
		singleton->setShaderfVec2("bufferDim", &(singleton->bufferDim));
		singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		singleton->setShaderMatrix4x4("modelviewInverse",singleton->viewMatrixDI,1);

		singleton->fsQuad.draw();


		singleton->setShaderTBO(0,0,0,false);
		singleton->unbindFBO();
		singleton->unbindShader();

		singleton->drawFBO("resultFBO0", 0, 1.0f);
		
		glutSwapBuffers();
		
	}
void GameWorld::renderDebug ()
                           {
		
		BaseObj* ge = singleton->gem->getCurActor();
		
		int i;
		
		float identMat[16];
		
		for (i = 0; i < 16; i++) {
			identMat[i] = 0.0f;
		}
		
		identMat[0] = 1.0f;
		identMat[5] = 1.0f;
		identMat[10] = 1.0f;
		identMat[15] = 1.0f;
		
		float myMat[16];
		Matrix4 myMatrix4;
		Vector4 myVector0;
		Vector4 myVector1;
		Vector4 resVector0;
		Vector4 resVector1;
		btVector3 basePos;
		float rad0 = 1.0f;
		float rad1 = 3.0f;
		
		btVector3 boxCenter;
		btVector3 boxRadius;
		BaseObj* grabber;
		
		
		float xrotrad = singleton->getCamRot(0);
		
		singleton->bindShader("GeomShader");
		singleton->bindFBO("debugTargFBO");
		
		
		singleton->setShaderVec4(
			"rotationZ",0.0f,0.0f,0.0f,0.0f
		);
		singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		singleton->setShaderfVec3("lookAtVec", &(singleton->lookAtVec));
		singleton->setShaderFloat("isWire", 0.0);
		singleton->setShaderFloat("clipDist",singleton->clipDist[1]);
		singleton->setShaderMatrix4x4("modelview",singleton->viewMatrix.get(),1);
		singleton->setShaderMatrix4x4("proj",singleton->projMatrix.get(),1);
		singleton->setShaderFloat("objectId",0.0);
		singleton->setShaderVec3("matVal", 255, 0, 0);
		
		
		
		// if (singleton->gamePhysics != NULL) {
		// 	singleton->drawOrient = true;
		// 	singleton->gamePhysics->example->renderScene();
		// }
		
		
		
		glLineWidth(1.0f);
		
		singleton->setShaderFloat("objectId",0.0);
		
		
		
		// skeleton outline		
		if (singleton->gem->getCurActor() != NULL) {
			if (singleton->gem->getCurActor()->orgId > -1) {
				
				if (singleton->gem->getCurActor()->isGrabbedById > -1) {
					grabber = &(singleton->gem->gameObjects[singleton->gem->getCurActor()->isGrabbedById]);
				}
				else {
					grabber = singleton->gem->getCurActor();
				}
				
				
				grabber->bodies[E_BDG_CENTER].body->getWorldTransform().getOpenGLMatrix(myMat);
				
				singleton->setShaderMatrix4x4("objmat",myMat,1);
				
				
				drawOrg(singleton->gem->gameOrgs[singleton->gem->getCurActor()->orgId], false);
			}
		}
		
		glLineWidth(4.0f);
		
		
		singleton->setShaderMatrix4x4("objmat",identMat,1);
		
		float healthMeterScale = 0.5f;
		
		if (singleton->gem->showHealth) {
			for (i = 0; i < singleton->gem->visObjects.size(); i++) {
				ge = &(singleton->gem->gameObjects[singleton->gem->visObjects[i]]);
				if (ge->entType == E_ENTTYPE_NPC) {
					
					//ge->bodies[E_BDG_CENTER].body->getWorldTransform().getOpenGLMatrix(myMat);
					
					if (ge->isAlive()) {
						singleton->setShaderVec3("matVal", 1, 1, 1);
						boxCenter = ge->getCenterPoint(E_BDG_CENTER);
						boxCenter += btVector3(0.0f,0.0f,5.0f);
						boxRadius = btVector3(1.95f,0.2f,0.2f)*healthMeterScale;
						
						singleton->setShaderVec4(
							"rotationZ",
							boxCenter.getX(),
							boxCenter.getY(),
							boxCenter.getZ(),
							xrotrad	
						);
						
						singleton->drawBoxRad(boxCenter,boxRadius);
						
						singleton->setShaderVec3("matVal", 255, 0, 0);
						boxCenter = ge->getCenterPoint(E_BDG_CENTER);
						boxCenter += btVector3(-2.0f*(1.0f-ge->healthPerc())*healthMeterScale,0.0f,5.0f);
						boxRadius = btVector3(2.0f*ge->healthPerc(),0.25f,0.25f)*healthMeterScale;
						singleton->drawBoxRad(boxCenter,boxRadius);
					}
					
					if (singleton->gem->turnBased) {
						boxCenter = (ge->tbPos + btVector3(0.5f,0.5f,0.5f));
						singleton->setShaderVec4(
							"rotationZ",
							boxCenter.getX(),
							boxCenter.getY(),
							boxCenter.getZ(),
							0.0f	
						);
						singleton->setShaderVec3("matVal", 255, 0, 0);
						singleton->drawBoxMinMax(ge->tbPos, ge->tbPos + btVector3(1.0f,1.0f,1.0f));
					}
					
					
					
				}
			}
		}
		
		
		
		singleton->setShaderVec4(
			"rotationZ",0.0f,0.0f,0.0f,0.0f
		);
		singleton->setShaderMatrix4x4("objmat",identMat,1);
		
		
		if (singleton->pathfindingOn) {
			singleton->gameLogic->update();
		}
		
		if (singleton->renderingOctBounds) {
			singleton->setShaderFloat("isWire", 1.0);
			singleton->setShaderVec3("matVal", 255, 0, 0);
			singleton->gameOct->startRender();
		}
		
		
		
		// btVector3 begPos = btVector3(0.0f,0.0f,0.0f);
		// btVector3 endPos = btVector3(0.0f,0.0f,0.0f);
		// btVector3 rayDir = btVector3(0.0f,0.0f,0.0f);
		
		// singleton->getRay(
		// 	singleton->lastMouseX,
		// 	singleton->lastMouseY,
		// 	begPos,
		// 	endPos,
		// 	rayDir
		// );
		//lastBodyPick = example->bodyPick(begPos,endPos);
		
		// tempVec1.setBTV(rayDir);
		// tempVec2.setBTV(rayDir);
		
		
		
		
		
		// tempVec1.setBTV(rayFrom*0.99 + rayTo*0.01);
		// tempVec2.setBTV(rayTo);
		
		// singleton->setShaderFloat("objectId",0.0);
		// singleton->setShaderVec3("matVal", 255, 0, 0);
		// singleton->drawBox(&tempVec1,&tempVec2);
		
		
		
		
		// tempVec1.copyFrom(singleton->cameraGetPosNoShake());
		// tempVec2.copyFrom(singleton->cameraGetPosNoShake());
		
		// tempVec1.addXYZ(
		// 	20.0f,
		// 	20.0f,
		// 	20.0f	
		// );
		
		// tempVec2.addXYZ(
		// 	200.0f,
		// 	200.0f,
		// 	singleton->smoothTime*200.0f	
		// );
		
		// singleton->drawLine(&tempVec1,&tempVec2);
		
		
		
		
		
		
		
		// btVector3 rayFrom = singleton->cameraGetPosNoShake()->getBTV();
		// btVector3 rayTo = singleton->getRayTo(
		// 	singleton->origWinW - singleton->lastMouseOrigX,
		// 	singleton->origWinH - singleton->lastMouseOrigY
		// );
		
		// tempVec1.setBTV(rayFrom*(0.995+singleton->smoothTime*0.005) + rayTo*(0.005-(1.0-singleton->smoothTime)*0.005));
		// tempVec2.copyFrom(&tempVec1);
		// //tempVec3.setBTV(rayDir);
		
		
		// tempVec1.addXYZ(-1.0f);
		// tempVec2.addXYZ( 1.0f);
		
		// singleton->setShaderFloat("objectId",0.0);
		// singleton->setShaderVec3("matVal", 255, 0, 0);
		// singleton->drawBox(&tempVec1,&tempVec2);
		
		
		
		
		
		singleton->unbindFBO();
		singleton->unbindShader();
		
	}
void GameWorld::postProcess ()
        {

		

		int i;
		int k;
		int curCount;
		int baseInd;

		bool doProc = false;

		GameEnt *curLight;



		for (i = 0; i < singleton->numDynLights; i++)
		{
			activeLights[i] = singleton->dynObjects[E_OBJ_LIGHT0 + i]->getLight();
		}

		curCount = 0;
		for (k = 0; k < lightCount; k++)
		{
			baseInd = curCount * FLOATS_PER_LIGHT;
			curLight = activeLights[k];
			lightPos = &(curLight->geomParams[E_LP_POSITION]);

			// if (curLight->toggled) {
			// 	singleton->worldToScreenBase(&lScreenCoords, lightPos);

			// 	singleton->lightArr[baseInd + 0] = lightPos->getFX();
			// 	singleton->lightArr[baseInd + 1] = lightPos->getFY();
			// 	singleton->lightArr[baseInd + 2] = lightPos->getFZ();
			// 	singleton->lightArr[baseInd + 3] = lScreenCoords.getFZ();


			// 	singleton->lightArr[baseInd + 4] = lScreenCoords.getFX();
			// 	singleton->lightArr[baseInd + 5] = lScreenCoords.getFY();
			// 	singleton->lightArr[baseInd + 6] = lScreenCoords.getFZ();
			// 	singleton->lightArr[baseInd + 7] = curLight->geomParams[E_LP_RADIUS].getFX();


			// 	// light color

			// 	singleton->lightArr[baseInd + 8] = curLight->geomParams[E_LP_COLOR].getFX(); // light red
			// 	singleton->lightArr[baseInd + 9] = curLight->geomParams[E_LP_COLOR].getFY(); // light green
			// 	singleton->lightArr[baseInd + 10] = curLight->geomParams[E_LP_COLOR].getFZ(); // light blue

			// 	// switch (k)
			// 	// {
			// 	// case 0:
			// 	// 	singleton->lightArr[baseInd + 11] = 1.0f; // light intensity (unused?)
			// 	// 	singleton->lightArr[baseInd + 12] = 0.0f; // light colorization (0-1)
			// 	// 	singleton->lightArr[baseInd + 13] = 0.0f; // light flooding (colorizes regardless of shadows) (0-1)
			// 	// 	break;
			// 	// default:
			// 	// 	singleton->lightArr[baseInd + 11] = 1.0f;
			// 	// 	singleton->lightArr[baseInd + 12] = 1.0f;
			// 	// 	singleton->lightArr[baseInd + 13] = 0.0f;
			// 	// 	break;

			// 	// }

			// 	curCount++;
			// }

			
		}

		

		activeFBO = 0;

		//renderWaveHeight();

		if (singleton->waterOn)	{


			


			singleton->bindShader("WaterShaderCombine");
			singleton->bindFBO("combineWithWaterTargFBO");
			singleton->sampleFBO("solidTargFBO",0);
			singleton->sampleFBO("waterTargFBO",2);
			//singleton->sampleFBO("geomTargFBO", 4);
			//singleton->sampleFBO("waveFBO", 6);
			
			// singleton->setShaderFloat("clipDist",singleton->clipDist[1]);
			// singleton->setShaderVec2("resolution", singleton->currentFBOResolutionX, singleton->currentFBOResolutionY);
			// singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
			// singleton->setShaderfVec2("bufferDim", &(singleton->bufferModDim));
			// singleton->setShaderFloat("curTime", singleton->curTime);
			singleton->drawFSQuad();
			
			//singleton->unsampleFBO("waveFBO", 6);
			//singleton->unsampleFBO("geomTargFBO", 4);
			singleton->unsampleFBO("waterTargFBO",2);
			singleton->unsampleFBO("solidTargFBO",0);
			singleton->unbindFBO();
			singleton->unbindShader();
			
			
			
		}
		else
		{
			// TODO: copy over any necessary buffers when water is off
			
			singleton->copyFBO2("solidTargFBO","combineWithWaterTargFBO");
			
		}
		
		
		//singleton->projMatrix*

		singleton->curMVP = singleton->projMatrix*singleton->viewMatrix;
		
		singleton->curObjMatrix3.set4(singleton->curMVP.get());
		singleton->curObjMatrix3.invert();
		singleton->curObjMatrix3.transpose();

		

		singleton->bindShader("PreLightingShader");
		singleton->bindFBO("prelightFBO");
		singleton->sampleFBO("solidTargFBO",0);
		singleton->sampleFBO("combineWithWaterTargFBO",2);
		singleton->sampleFBO("geomTargFBO",4);
		singleton->sampleFBO("prmDepthFBO",6);
		singleton->setShaderMatrix3x3("rotMat",singleton->curObjMatrix3.get(),1);
		singleton->setShaderMatrix4x4("modelview",singleton->viewMatrix.get(),1);
		singleton->setShaderMatrix4x4("proj",singleton->projMatrix.get(),1);
		singleton->setShaderVec2("clipDist",singleton->clipDist[0],singleton->clipDist[1]);
		singleton->setShaderfVec3("lookAtVec", &(singleton->lookAtVec));
		singleton->setShaderVec2("bufferDim", singleton->currentFBOResolutionX, singleton->currentFBOResolutionY); //MUST BE CALLED AFTER FBO IS BOUND
		singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		singleton->setShaderInt("testOn", (int)(singleton->testOn));
		singleton->setShaderInt("iNumSteps", singleton->iNumSteps);
		singleton->setShaderArrayfVec4("lightArr", singleton->lightArr, (FLOATS_PER_LIGHT * lightCount) / 4);
		singleton->setShaderInt("vecsPerLight", FLOATS_PER_LIGHT / 4);
		singleton->setShaderFloat("lightCount", lightCount);
		singleton->setShaderFloat("timeOfDay", singleton->timeOfDay);
		singleton->setShaderfVec3("baseLightVec", &(singleton->lightVec) );
		
		singleton->drawFSQuad();
		
		singleton->unsampleFBO("prmDepthFBO",6);
		singleton->unsampleFBO("geomTargFBO",4);
		singleton->unsampleFBO("combineWithWaterTargFBO",2);
		singleton->unsampleFBO("solidTargFBO",0);
		singleton->unbindFBO();
		singleton->unbindShader();
		
			
		
		
		
		singleton->bindShader("PostLightingShader");
		singleton->bindFBO("resultFBO", activeFBO);
		
		singleton->sampleFBO("solidTargFBO",0);
		singleton->sampleFBO("prelightFBO", 2);
		// singleton->sampleFBO("geomTargFBO", 6);
		// singleton->sampleFBO("debugTargFBO", 8);
		singleton->setShaderTexture3D(10,singleton->volIdMat);
		
		singleton->setShaderfVec4("worldMarker",&(singleton->worldMarker));
		singleton->setShaderInt("markerFound", (int)(singleton->markerFound));
		
		
		singleton->setShaderMatrix4x4("modelviewInverse",singleton->viewMatrixDI,1);
		singleton->setShaderFloat("FOV", singleton->FOV*M_PI/180.0f);
		singleton->setShaderVec2("clipDist",singleton->clipDist[0],singleton->clipDist[1]);
		singleton->setShaderfVec3("lightVec", &(singleton->lightVec) );
		singleton->setShaderfVec3("lightVecOrig", &(singleton->lightVecOrig) );
		
		
		singleton->setShaderfVec3("lookAtVec", &(singleton->lookAtVec));
		singleton->setShaderVec2("bufferDim", singleton->currentFBOResolutionX, singleton->currentFBOResolutionY); //MUST BE CALLED AFTER FBO IS BOUND
		singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
		singleton->setShaderInt("testOn", (int)(singleton->testOn));
		singleton->setShaderInt("testOn2", (int)(singleton->testOn2));
		singleton->setShaderFloat("curTime", singleton->curTime);
		singleton->setShaderFloat("cellsPerBlock", singleton->cellsPerBlock);
		singleton->setShaderFloat("timeOfDay", singleton->timeOfDay);
		singleton->drawFSQuad();
		
		singleton->setShaderTexture3D(10,0);
		// singleton->unsampleFBO("debugTargFBO", 8);
		// singleton->unsampleFBO("geomTargFBO", 6);
		singleton->unsampleFBO("prelightFBO", 2);
		singleton->unsampleFBO("solidTargFBO",0);
		
		singleton->unbindFBO();
		singleton->unbindShader();
		
		activeFBO = 1 - activeFBO;
		
		

		if (singleton->waterOn)
		{
			singleton->copyFBO("resultFBO1", "swapFBOLinHalf0");
			doBlur("swapFBOLinHalf");
			
			singleton->bindShader("WaterShader");
			singleton->bindFBO("resultFBO", activeFBO);
			singleton->sampleFBO("solidTargFBO",0);
			singleton->sampleFBO("combineWithWaterTargFBO",2);
			singleton->sampleFBO("resultFBO", 4, activeFBO);
			singleton->sampleFBO("swapFBOLinHalf0", 5);
			singleton->sampleFBO("noiseFBO", 6);
			//singleton->sampleFBO("waveFBO", 7);
			singleton->setShaderTexture3D(7,singleton->volIdMat);
			singleton->sampleFBO("prelightFBO", 9);
			//singleton->sampleFBO("geomTargFBO", 13);
			
			
			singleton->setShaderMatrix4x4("modelviewInverse",singleton->viewMatrixDI,1);
			singleton->setShaderFloat("seaLevel", singleton->getSeaHeightScaled() );
			singleton->setShaderFloat("FOV", singleton->FOV*M_PI/180.0f);
			singleton->setShaderVec2("clipDist",singleton->clipDist[0],singleton->clipDist[1]);
			singleton->setShaderfVec2("bufferDim", &(singleton->bufferModDim));
			
			singleton->setShaderfVec3("lookAtVec", &(singleton->lookAtVec) );
			singleton->setShaderFloat("timeOfDay", singleton->timeOfDay);
			singleton->setShaderVec2("resolution", singleton->currentFBOResolutionX, singleton->currentFBOResolutionY);
			singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
			singleton->setShaderFloat("curTime", singleton->curTime);
			singleton->setShaderFloat("isUnderWater", singleton->getUnderWater() );
			singleton->drawFSQuad();
			
			
			//singleton->unsampleFBO("geomTargFBO", 13);
			singleton->unsampleFBO("prelightFBO", 9);
			singleton->setShaderTexture3D(7,0);
			//singleton->unsampleFBO("waveFBO", 7);
			singleton->unsampleFBO("noiseFBO", 6);
			singleton->unsampleFBO("swapFBOLinHalf0", 5);
			singleton->unsampleFBO("resultFBO", 4, activeFBO);
			singleton->unsampleFBO("waterTargFBO",2);
			singleton->unsampleFBO("solidTargFBO",0);
			singleton->unbindFBO();
			singleton->unbindShader();

			activeFBO = 1 - activeFBO;
		}


		if (singleton->radiosityOn || singleton->fogOn)
		{

			if (activeFBO == 0)
			{
				singleton->copyFBO("resultFBO0", "swapFBOBLin0");
			}
			else
			{
				singleton->copyFBO("resultFBO1", "swapFBOBLin0");
			}


			doBlur("swapFBOBLin");
		}



		if (singleton->radiosityOn)
		{

			singleton->bindShader("RadiosityShader");

			singleton->bindFBO("swapFBOLinHalf0");
			singleton->sampleFBO("combineWithWaterTargFBO",0);
			singleton->sampleFBO("swapFBOBLin0", 2);
			singleton->setShaderVec2("resolution", singleton->currentFBOResolutionX, singleton->currentFBOResolutionY); //MUST BE CALLED AFTER FBO IS BOUND
			singleton->setShaderfVec2("bufferDim", &(singleton->bufferModDim));
			singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
			singleton->setShaderfVec3("lightVec", &(singleton->lightVec) );
			//singleton->setShaderfVec3("lightPosWS", lightPos);
			singleton->setShaderInt("iNumSteps", singleton->iNumSteps);
			singleton->drawFSQuad();
			singleton->unsampleFBO("swapFBOBLin0", 2);
			singleton->unsampleFBO("combineWithWaterTargFBO",0);
			singleton->unbindFBO();
			singleton->unbindShader();


			doBlur("swapFBOLinHalf");

			singleton->bindShader("RadiosityCombineShader");
			singleton->bindFBO("resultFBO", activeFBO);
			singleton->sampleFBO("resultFBO", 0, activeFBO);
			singleton->sampleFBO("swapFBOLinHalf0", 1);
			singleton->sampleFBO("combineWithWaterTargFBO",2);
			//singleton->sampleFBO("geomTargFBO", 4);
			singleton->setShaderInt("testOn", (int)(singleton->testOn));
			singleton->drawFSQuad();
			//singleton->unsampleFBO("geomTargFBO", 4);
			singleton->unsampleFBO("combineWithWaterTargFBO",2);
			singleton->unsampleFBO("swapFBOLinHalf0", 1);
			singleton->unsampleFBO("resultFBO", 0, activeFBO);
			singleton->unbindFBO();
			singleton->unbindShader();

			activeFBO = 1 - activeFBO;


		}

		if (singleton->fogOn == 1.0f)
		{

			

			singleton->bindShader("FogShader");
			singleton->bindFBO("resultFBO", activeFBO);

			singleton->sampleFBO("combineWithWaterTargFBO",0);
			singleton->sampleFBO("resultFBO", 2, activeFBO);
			singleton->sampleFBO("swapFBOBLin0", 3);
			
			singleton->sampleFBO("limbFBO", 4);//, -1, 4, 7);
			//singleton->sampleFBO("geomBaseTargFBO", 4);
			
			singleton->setShaderTexture3D(7,singleton->volIdMat);
			singleton->sampleFBO("noiseFBOLinear", 8);
			singleton->sampleFBO("debugTargFBO", 9);
			
			
			if ((singleton->gem->getCurActor() == NULL)||singleton->gem->firstPerson) {
				singleton->setShaderFloat("thirdPerson", 0.0f);
				singleton->setShaderVec3("entPos", 0.0f, 0.0f, 0.0f);
			}
			else {
				singleton->setShaderFloat("thirdPerson", 1.0f);
				singleton->setShaderfVec3("entPos", singleton->gem->getCurActor()->getCenterPointFIV(0));
				singleton->setShaderFloat("volSizePrim", singleton->gameFluid[E_FID_BIG]->volSizePrim);
			}
			
			if (singleton->placingPattern) {
				singleton->setShaderArray(
					"patternCells",
					singleton->patterns[
						singleton->curPattern*4 + singleton->curPatternRot
					].patternVals,
					PATTERN_SIZE*PATTERN_SIZE
				);
				singleton->setShaderfVec3("patternTarg", &(singleton->mouseMovePD));
				
			}
			singleton->setShaderInt("placingPattern", singleton->placingPattern);
			
			
			
			singleton->setShaderInt("gridOn", singleton->gridOn);
			
			if (singleton->gem->getCurActor() == NULL) {
				singleton->setShaderInt("isFalling",false);
				singleton->setShaderInt("isJumping",false);
			}
			else {
				singleton->setShaderInt("isFalling",singleton->gem->getCurActor()->allFalling());
				singleton->setShaderInt("isJumping",singleton->gem->getCurActor()->getActionState(E_ACT_ISJUMPING,RLBN_NEIT));
			}
			
			
			singleton->setShaderFloat("seaLevel", singleton->getSeaHeightScaled() );
			singleton->setShaderMatrix4x4("modelviewInverse",singleton->viewMatrixDI,1);
			singleton->setShaderFloat("FOV", singleton->FOV*M_PI/180.0f);
			singleton->setShaderVec2("clipDist",singleton->clipDist[0],singleton->clipDist[1]);
			singleton->setShaderfVec3("lightVec", &(singleton->lightVec) );
			singleton->setShaderfVec3("lightVecOrig", &(singleton->lightVecOrig) );
			singleton->setShaderInt("iNumSteps", singleton->iNumSteps);
			singleton->setShaderFloat("curTime", singleton->curTime);
			singleton->setShaderFloat("selLimbInd",singleton->gem->highlightedLimb);
			singleton->setShaderFloat("selObjInd",singleton->gem->selObjInd);
			singleton->setShaderFloat("actObjInd",singleton->gem->actObjInd);
			singleton->setShaderFloat("isUnderWater", singleton->getUnderWater() );
			singleton->setShaderFloat("timeOfDay", singleton->timeOfDay);
			singleton->setShaderVec2("resolution", singleton->currentFBOResolutionX, singleton->currentFBOResolutionY); //MUST BE CALLED AFTER FBO IS BOUND
			singleton->setShaderfVec2("bufferDim", &(singleton->bufferModDim));
			singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
			singleton->setShaderfVec3("lookAtVec", &(singleton->lookAtVec));
			//singleton->setShaderfVec4("fogPos", fogPos);

			singleton->drawFSQuad();

			
			singleton->unsampleFBO("debugTargFBO", 9);
			singleton->unsampleFBO("noiseFBOLinear", 8);
			singleton->setShaderTexture3D(7,0);
			
			singleton->unsampleFBO("limbFBO", 4);//, -1, 4, 7);
			//singleton->unsampleFBO("geomBaseTargFBO", 4);
			
			singleton->unsampleFBO("swapFBOBLin0", 3);
			singleton->unsampleFBO("resultFBO", 2, activeFBO);
			singleton->unsampleFBO("combineWithWaterTargFBO",0);

			singleton->unbindFBO();
			singleton->unbindShader();


			activeFBO = 1 - activeFBO;

		}
		
		
		for (i = 0; i < singleton->medianCount; i++) {
			singleton->bindShader("MedianShader");
			singleton->bindFBO("resultFBO",activeFBO);
			singleton->sampleFBO("resultFBO", 0, activeFBO);
			singleton->sampleFBO("solidTargFBO", 1);
			singleton->setShaderfVec3("cameraPos", singleton->cameraGetPos());
			singleton->setShaderfVec2("bufferDim", &(singleton->bufferModDim) );
			
			singleton->drawFSQuad();
			
			singleton->unsampleFBO("solidTargFBO", 1);
			singleton->unsampleFBO("resultFBO", 0, activeFBO);
			singleton->unbindFBO();
			singleton->unbindShader();
			
			activeFBO = 1-activeFBO;
		}
		
		
		if (singleton->testOn) {			
			
			
			
			
			//terGenFBO
			//solidTargFBO
			
			
			
			//solidBaseTargFBO
			//"solidTargFBO" //"polyFBO"
			singleton->drawFBO("terTargFBO", 0, 1.0f);//solidTargFBO //waterTargFBO //solidTargFBO
			
			// leave this here to catch errors
			//cout << "Getting Errors: \n";
			
			
			
			
			//glError();
			
		}
		else {
			
			// if (singleton->frameCount > 1) {
			// 	singleton->bindShader("MergeShader");
			// 	singleton->bindFBO("resultFBO",activeFBO);
			// 	singleton->sampleFBO("resultFBO", 0, activeFBO);
			// 	singleton->sampleFBO("lastFBO", 1);
			// 	singleton->drawFSQuad();
			// 	singleton->unsampleFBO("lastFBO", 1);
			// 	singleton->unsampleFBO("resultFBO", 0, activeFBO);
			// 	singleton->unbindFBO();
			// 	singleton->unbindShader();
				
			// 	activeFBO = 1-activeFBO;
			// }
			// if (activeFBO == 0) {
			// 	singleton->copyFBO("resultFBO0", "lastFBO");
			// }
			// else {
			// 	singleton->copyFBO("resultFBO1", "lastFBO");
			// }
			
			
			if (singleton->fxaaOn) {
				singleton->bindShader("FXAAShader");
				singleton->bindFBO("resultFBO",activeFBO);
				singleton->sampleFBO("resultFBO", 0, activeFBO);
				singleton->setShaderfVec2("resolution",&(singleton->bufferDim));
				singleton->drawFSQuad();
				singleton->unsampleFBO("resultFBO", 0, activeFBO);
				singleton->unbindFBO();
				singleton->unbindShader();
				
				activeFBO = 1 - activeFBO;
			}
			
			
			
			
			
			singleton->drawFBO("resultFBO", 0, 1.0f, 1 - activeFBO);
			
			
			
			
		}

		


		if (singleton->anyMenuVisible()) {
			glEnable (GL_BLEND);

			singleton->bindShader("GUIShader");
			singleton->setShaderTexture(0,singleton->fontWrappers[EFW_TEXT]->fontImage->tid);
			singleton->setShaderTexture(1,singleton->fontWrappers[EFW_ICONS]->fontImage->tid);
			singleton->sampleFBO("swapFBOBLin0", 2);
			singleton->setShaderTexture3D(3,singleton->volIdMat);
			
			singleton->mainGUI->renderGUI();
			
			
			singleton->setShaderTexture3D(3,0);
			singleton->unsampleFBO("swapFBOBLin0", 2);
			singleton->setShaderTexture(1,0);
			singleton->setShaderTexture(0,0);
			singleton->unbindShader();
			
			glDisable(GL_BLEND);
		}
		
		
		

	}
GameWorld::~ GameWorld ()
        {

		//threadpool.stopAll();

		int i;
		int j;

	}
#undef LZZ_INLINE
 



Singleton* singleton;


void processSpecialKeys(int key, int x, int y) {
    singleton->processSpecialKeys(key,x,y);
}
// void processKey(unsigned char key, int x, int y, bool isPressed) {
//     singleton->processKey(key,x,y,isPressed);
// }
void keyboardUp(unsigned char key, int x, int y) {
    singleton->keyboardUp(key,x,y);
}
void keyboardDown(unsigned char key, int x, int y) {
    singleton->keyboardDown(key,x,y);
}
void mouseMovementWithButton(int x, int y) {
    singleton->mouseMove(x,y);
}
void mouseMovementWithoutButton(int x, int y) {
    singleton->mouseMove(x,y);
}
void mouseClick(int button, int state, int x, int y) {
    singleton->mouseClick(button,state,x,y);
}

void display(void) {
    singleton->display(true);
}

void reshape (int w, int h) {
    singleton->reshape(w,h);
}
void idleFunc(void) {
    singleton->display(false);
}

int MAX_CONSOLE_LINES = 500;

void RedirectIOToConsole() {

    int hConHandle;

    long lStdHandle;

    CONSOLE_SCREEN_BUFFER_INFO coninfo;

    FILE *fp;

    // allocate a console for this app

    AllocConsole();

    // set the screen buffer to be big enough to let us scroll text

    GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE),

                               &coninfo);

    coninfo.dwSize.Y = MAX_CONSOLE_LINES;

    SetConsoleScreenBufferSize(GetStdHandle(STD_OUTPUT_HANDLE),

                               coninfo.dwSize);

    // redirect unbuffered STDOUT to the console

    lStdHandle = (long)GetStdHandle(STD_OUTPUT_HANDLE);

    hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);

    fp = _fdopen( hConHandle, "w" );

    *stdout = *fp;

    setvbuf( stdout, NULL, _IONBF, 0 );

    // redirect unbuffered STDIN to the console

    lStdHandle = (long)GetStdHandle(STD_INPUT_HANDLE);

    hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);

    fp = _fdopen( hConHandle, "r" );

    *stdin = *fp;

    setvbuf( stdin, NULL, _IONBF, 0 );

    // redirect unbuffered STDERR to the console

    lStdHandle = (long)GetStdHandle(STD_ERROR_HANDLE);

    hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);

    fp = _fdopen( hConHandle, "w" );

    *stderr = *fp;

    setvbuf( stderr, NULL, _IONBF, 0 );

    std::ios::sync_with_stdio();

}



// #ifdef USE_POCO
// WebSocketServer myWebsocketServer;
// #endif

int main(int argc, char* argv[])
{

    int winWidth;
    int winHeight;
    int scaleFactor;
    
    winWidth = DEF_WIN_W;
    winHeight = DEF_WIN_H;
    scaleFactor = DEF_SCALE_FACTOR;

    RedirectIOToConsole();

    glutInit(&argc, argv);


    glutInitDisplayMode (GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);  //GLUT_SINGLE

    //glutInitDisplayMode(GLUT_DOUBLE|GLUT_RGB); //|GLUT_MULTISAMPLE
    glutInitWindowSize(winWidth, winHeight);
    glutInitWindowPosition(400, 50);
    glutCreateWindow("VoxelQuest");

    GLenum err = glewInit();
    if (err != GLEW_OK) {
        doTrace("There was an error with GLEW");
    }
    else {
        doTrace("GLEW_OK");
    }


    
    ////////////
    singleton = new Singleton();
    singleton->init(
        winWidth,
        winHeight,
        scaleFactor
        
        // #ifdef USE_POCO
        //     ,&myWebsocketServer
        // #endif
        
        
    );
    

    glutDisplayFunc(display);
    glutIdleFunc(idleFunc);
    glutReshapeFunc(reshape);
    glutPassiveMotionFunc(mouseMovementWithoutButton);
    glutMotionFunc(mouseMovementWithButton);
    glutMouseFunc(mouseClick);
    glutKeyboardFunc(keyboardDown);
    glutKeyboardUpFunc(keyboardUp);
    glutSpecialFunc(processSpecialKeys);
    
    // #ifdef USE_POCO
    //     myWebsocketServer.run(argc, argv);
    // #else
        glutMainLoop();
    //#endif
    




    

    return 0;
}
 
